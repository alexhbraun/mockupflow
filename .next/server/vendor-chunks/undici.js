"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/undici";
exports.ids = ["vendor-chunks/undici"];
exports.modules = {

/***/ "(ssr)/./node_modules/undici/index.js":
/*!**************************************!*\
  !*** ./node_modules/undici/index.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst Client = __webpack_require__(/*! ./lib/dispatcher/client */ \"(ssr)/./node_modules/undici/lib/dispatcher/client.js\");\nconst Dispatcher = __webpack_require__(/*! ./lib/dispatcher/dispatcher */ \"(ssr)/./node_modules/undici/lib/dispatcher/dispatcher.js\");\nconst Pool = __webpack_require__(/*! ./lib/dispatcher/pool */ \"(ssr)/./node_modules/undici/lib/dispatcher/pool.js\");\nconst BalancedPool = __webpack_require__(/*! ./lib/dispatcher/balanced-pool */ \"(ssr)/./node_modules/undici/lib/dispatcher/balanced-pool.js\");\nconst Agent = __webpack_require__(/*! ./lib/dispatcher/agent */ \"(ssr)/./node_modules/undici/lib/dispatcher/agent.js\");\nconst ProxyAgent = __webpack_require__(/*! ./lib/dispatcher/proxy-agent */ \"(ssr)/./node_modules/undici/lib/dispatcher/proxy-agent.js\");\nconst EnvHttpProxyAgent = __webpack_require__(/*! ./lib/dispatcher/env-http-proxy-agent */ \"(ssr)/./node_modules/undici/lib/dispatcher/env-http-proxy-agent.js\");\nconst RetryAgent = __webpack_require__(/*! ./lib/dispatcher/retry-agent */ \"(ssr)/./node_modules/undici/lib/dispatcher/retry-agent.js\");\nconst errors = __webpack_require__(/*! ./lib/core/errors */ \"(ssr)/./node_modules/undici/lib/core/errors.js\");\nconst util = __webpack_require__(/*! ./lib/core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\");\nconst { InvalidArgumentError } = errors;\nconst api = __webpack_require__(/*! ./lib/api */ \"(ssr)/./node_modules/undici/lib/api/index.js\");\nconst buildConnector = __webpack_require__(/*! ./lib/core/connect */ \"(ssr)/./node_modules/undici/lib/core/connect.js\");\nconst MockClient = __webpack_require__(/*! ./lib/mock/mock-client */ \"(ssr)/./node_modules/undici/lib/mock/mock-client.js\");\nconst MockAgent = __webpack_require__(/*! ./lib/mock/mock-agent */ \"(ssr)/./node_modules/undici/lib/mock/mock-agent.js\");\nconst MockPool = __webpack_require__(/*! ./lib/mock/mock-pool */ \"(ssr)/./node_modules/undici/lib/mock/mock-pool.js\");\nconst mockErrors = __webpack_require__(/*! ./lib/mock/mock-errors */ \"(ssr)/./node_modules/undici/lib/mock/mock-errors.js\");\nconst RetryHandler = __webpack_require__(/*! ./lib/handler/retry-handler */ \"(ssr)/./node_modules/undici/lib/handler/retry-handler.js\");\nconst { getGlobalDispatcher, setGlobalDispatcher } = __webpack_require__(/*! ./lib/global */ \"(ssr)/./node_modules/undici/lib/global.js\");\nconst DecoratorHandler = __webpack_require__(/*! ./lib/handler/decorator-handler */ \"(ssr)/./node_modules/undici/lib/handler/decorator-handler.js\");\nconst RedirectHandler = __webpack_require__(/*! ./lib/handler/redirect-handler */ \"(ssr)/./node_modules/undici/lib/handler/redirect-handler.js\");\nconst createRedirectInterceptor = __webpack_require__(/*! ./lib/interceptor/redirect-interceptor */ \"(ssr)/./node_modules/undici/lib/interceptor/redirect-interceptor.js\");\nObject.assign(Dispatcher.prototype, api);\nmodule.exports.Dispatcher = Dispatcher;\nmodule.exports.Client = Client;\nmodule.exports.Pool = Pool;\nmodule.exports.BalancedPool = BalancedPool;\nmodule.exports.Agent = Agent;\nmodule.exports.ProxyAgent = ProxyAgent;\nmodule.exports.EnvHttpProxyAgent = EnvHttpProxyAgent;\nmodule.exports.RetryAgent = RetryAgent;\nmodule.exports.RetryHandler = RetryHandler;\nmodule.exports.DecoratorHandler = DecoratorHandler;\nmodule.exports.RedirectHandler = RedirectHandler;\nmodule.exports.createRedirectInterceptor = createRedirectInterceptor;\nmodule.exports.interceptors = {\n    redirect: __webpack_require__(/*! ./lib/interceptor/redirect */ \"(ssr)/./node_modules/undici/lib/interceptor/redirect.js\"),\n    retry: __webpack_require__(/*! ./lib/interceptor/retry */ \"(ssr)/./node_modules/undici/lib/interceptor/retry.js\"),\n    dump: __webpack_require__(/*! ./lib/interceptor/dump */ \"(ssr)/./node_modules/undici/lib/interceptor/dump.js\")\n};\nmodule.exports.buildConnector = buildConnector;\nmodule.exports.errors = errors;\nmodule.exports.util = {\n    parseHeaders: util.parseHeaders,\n    headerNameToString: util.headerNameToString\n};\nfunction makeDispatcher(fn) {\n    return (url, opts, handler)=>{\n        if (typeof opts === \"function\") {\n            handler = opts;\n            opts = null;\n        }\n        if (!url || typeof url !== \"string\" && typeof url !== \"object\" && !(url instanceof URL)) {\n            throw new InvalidArgumentError(\"invalid url\");\n        }\n        if (opts != null && typeof opts !== \"object\") {\n            throw new InvalidArgumentError(\"invalid opts\");\n        }\n        if (opts && opts.path != null) {\n            if (typeof opts.path !== \"string\") {\n                throw new InvalidArgumentError(\"invalid opts.path\");\n            }\n            let path = opts.path;\n            if (!opts.path.startsWith(\"/\")) {\n                path = `/${path}`;\n            }\n            url = new URL(util.parseOrigin(url).origin + path);\n        } else {\n            if (!opts) {\n                opts = typeof url === \"object\" ? url : {};\n            }\n            url = util.parseURL(url);\n        }\n        const { agent, dispatcher = getGlobalDispatcher() } = opts;\n        if (agent) {\n            throw new InvalidArgumentError(\"unsupported opts.agent. Did you mean opts.client?\");\n        }\n        return fn.call(dispatcher, {\n            ...opts,\n            origin: url.origin,\n            path: url.search ? `${url.pathname}${url.search}` : url.pathname,\n            method: opts.method || (opts.body ? \"PUT\" : \"GET\")\n        }, handler);\n    };\n}\nmodule.exports.setGlobalDispatcher = setGlobalDispatcher;\nmodule.exports.getGlobalDispatcher = getGlobalDispatcher;\nconst fetchImpl = (__webpack_require__(/*! ./lib/web/fetch */ \"(ssr)/./node_modules/undici/lib/web/fetch/index.js\").fetch);\nmodule.exports.fetch = async function fetch(init, options = undefined) {\n    try {\n        return await fetchImpl(init, options);\n    } catch (err) {\n        if (err && typeof err === \"object\") {\n            Error.captureStackTrace(err);\n        }\n        throw err;\n    }\n};\nmodule.exports.Headers = __webpack_require__(/*! ./lib/web/fetch/headers */ \"(ssr)/./node_modules/undici/lib/web/fetch/headers.js\").Headers;\nmodule.exports.Response = __webpack_require__(/*! ./lib/web/fetch/response */ \"(ssr)/./node_modules/undici/lib/web/fetch/response.js\").Response;\nmodule.exports.Request = __webpack_require__(/*! ./lib/web/fetch/request */ \"(ssr)/./node_modules/undici/lib/web/fetch/request.js\").Request;\nmodule.exports.FormData = __webpack_require__(/*! ./lib/web/fetch/formdata */ \"(ssr)/./node_modules/undici/lib/web/fetch/formdata.js\").FormData;\nmodule.exports.File = globalThis.File ?? (__webpack_require__(/*! node:buffer */ \"node:buffer\").File);\nmodule.exports.FileReader = __webpack_require__(/*! ./lib/web/fileapi/filereader */ \"(ssr)/./node_modules/undici/lib/web/fileapi/filereader.js\").FileReader;\nconst { setGlobalOrigin, getGlobalOrigin } = __webpack_require__(/*! ./lib/web/fetch/global */ \"(ssr)/./node_modules/undici/lib/web/fetch/global.js\");\nmodule.exports.setGlobalOrigin = setGlobalOrigin;\nmodule.exports.getGlobalOrigin = getGlobalOrigin;\nconst { CacheStorage } = __webpack_require__(/*! ./lib/web/cache/cachestorage */ \"(ssr)/./node_modules/undici/lib/web/cache/cachestorage.js\");\nconst { kConstruct } = __webpack_require__(/*! ./lib/web/cache/symbols */ \"(ssr)/./node_modules/undici/lib/web/cache/symbols.js\");\n// Cache & CacheStorage are tightly coupled with fetch. Even if it may run\n// in an older version of Node, it doesn't have any use without fetch.\nmodule.exports.caches = new CacheStorage(kConstruct);\nconst { deleteCookie, getCookies, getSetCookies, setCookie } = __webpack_require__(/*! ./lib/web/cookies */ \"(ssr)/./node_modules/undici/lib/web/cookies/index.js\");\nmodule.exports.deleteCookie = deleteCookie;\nmodule.exports.getCookies = getCookies;\nmodule.exports.getSetCookies = getSetCookies;\nmodule.exports.setCookie = setCookie;\nconst { parseMIMEType, serializeAMimeType } = __webpack_require__(/*! ./lib/web/fetch/data-url */ \"(ssr)/./node_modules/undici/lib/web/fetch/data-url.js\");\nmodule.exports.parseMIMEType = parseMIMEType;\nmodule.exports.serializeAMimeType = serializeAMimeType;\nconst { CloseEvent, ErrorEvent, MessageEvent } = __webpack_require__(/*! ./lib/web/websocket/events */ \"(ssr)/./node_modules/undici/lib/web/websocket/events.js\");\nmodule.exports.WebSocket = __webpack_require__(/*! ./lib/web/websocket/websocket */ \"(ssr)/./node_modules/undici/lib/web/websocket/websocket.js\").WebSocket;\nmodule.exports.CloseEvent = CloseEvent;\nmodule.exports.ErrorEvent = ErrorEvent;\nmodule.exports.MessageEvent = MessageEvent;\nmodule.exports.request = makeDispatcher(api.request);\nmodule.exports.stream = makeDispatcher(api.stream);\nmodule.exports.pipeline = makeDispatcher(api.pipeline);\nmodule.exports.connect = makeDispatcher(api.connect);\nmodule.exports.upgrade = makeDispatcher(api.upgrade);\nmodule.exports.MockClient = MockClient;\nmodule.exports.MockPool = MockPool;\nmodule.exports.MockAgent = MockAgent;\nmodule.exports.mockErrors = mockErrors;\nconst { EventSource } = __webpack_require__(/*! ./lib/web/eventsource/eventsource */ \"(ssr)/./node_modules/undici/lib/web/eventsource/eventsource.js\");\nmodule.exports.EventSource = EventSource;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QkFBeUIsR0FBR2I7QUFDNUJhLHVCQUF1QixHQUFHWDtBQUMxQlcsd0JBQXdCLEdBQUdaO0FBQzNCWSx5QkFBeUIsR0FBR1Y7QUFFNUIsTUFBTSxFQUFFdUUsV0FBQUEsRUFBYSxHQUFHdkYsbUJBQU9BLENBQUM7QUFFaEMwQiwwQkFBMEIsR0FBRzZEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbW9ja3VwZmxvdy8uL25vZGVfbW9kdWxlcy91bmRpY2kvaW5kZXguanM/MTI0YSIsIndlYnBhY2s6Ly9tb2NrdXBmbG93Ly4vbm9kZV9tb2R1bGVzL3VuZGljaS9pbmRleC5qcz8xMjRhKiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgQ2xpZW50ID0gcmVxdWlyZSgnLi9saWIvZGlzcGF0Y2hlci9jbGllbnQnKVxuY29uc3QgRGlzcGF0Y2hlciA9IHJlcXVpcmUoJy4vbGliL2Rpc3BhdGNoZXIvZGlzcGF0Y2hlcicpXG5jb25zdCBQb29sID0gcmVxdWlyZSgnLi9saWIvZGlzcGF0Y2hlci9wb29sJylcbmNvbnN0IEJhbGFuY2VkUG9vbCA9IHJlcXVpcmUoJy4vbGliL2Rpc3BhdGNoZXIvYmFsYW5jZWQtcG9vbCcpXG5jb25zdCBBZ2VudCA9IHJlcXVpcmUoJy4vbGliL2Rpc3BhdGNoZXIvYWdlbnQnKVxuY29uc3QgUHJveHlBZ2VudCA9IHJlcXVpcmUoJy4vbGliL2Rpc3BhdGNoZXIvcHJveHktYWdlbnQnKVxuY29uc3QgRW52SHR0cFByb3h5QWdlbnQgPSByZXF1aXJlKCcuL2xpYi9kaXNwYXRjaGVyL2Vudi1odHRwLXByb3h5LWFnZW50JylcbmNvbnN0IFJldHJ5QWdlbnQgPSByZXF1aXJlKCcuL2xpYi9kaXNwYXRjaGVyL3JldHJ5LWFnZW50JylcbmNvbnN0IGVycm9ycyA9IHJlcXVpcmUoJy4vbGliL2NvcmUvZXJyb3JzJylcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCcuL2xpYi9jb3JlL3V0aWwnKVxuY29uc3QgeyBJbnZhbGlkQXJndW1lbnRFcnJvciB9ID0gZXJyb3JzXG5jb25zdCBhcGkgPSByZXF1aXJlKCcuL2xpYi9hcGknKVxuY29uc3QgYnVpbGRDb25uZWN0b3IgPSByZXF1aXJlKCcuL2xpYi9jb3JlL2Nvbm5lY3QnKVxuY29uc3QgTW9ja0NsaWVudCA9IHJlcXVpcmUoJy4vbGliL21vY2svbW9jay1jbGllbnQnKVxuY29uc3QgTW9ja0FnZW50ID0gcmVxdWlyZSgnLi9saWIvbW9jay9tb2NrLWFnZW50JylcbmNvbnN0IE1vY2tQb29sID0gcmVxdWlyZSgnLi9saWIvbW9jay9tb2NrLXBvb2wnKVxuY29uc3QgbW9ja0Vycm9ycyA9IHJlcXVpcmUoJy4vbGliL21vY2svbW9jay1lcnJvcnMnKVxuY29uc3QgUmV0cnlIYW5kbGVyID0gcmVxdWlyZSgnLi9saWIvaGFuZGxlci9yZXRyeS1oYW5kbGVyJylcbmNvbnN0IHsgZ2V0R2xvYmFsRGlzcGF0Y2hlciwgc2V0R2xvYmFsRGlzcGF0Y2hlciB9ID0gcmVxdWlyZSgnLi9saWIvZ2xvYmFsJylcbmNvbnN0IERlY29yYXRvckhhbmRsZXIgPSByZXF1aXJlKCcuL2xpYi9oYW5kbGVyL2RlY29yYXRvci1oYW5kbGVyJylcbmNvbnN0IFJlZGlyZWN0SGFuZGxlciA9IHJlcXVpcmUoJy4vbGliL2hhbmRsZXIvcmVkaXJlY3QtaGFuZGxlcicpXG5jb25zdCBjcmVhdGVSZWRpcmVjdEludGVyY2VwdG9yID0gcmVxdWlyZSgnLi9saWIvaW50ZXJjZXB0b3IvcmVkaXJlY3QtaW50ZXJjZXB0b3InKVxuXG5PYmplY3QuYXNzaWduKERpc3BhdGNoZXIucHJvdG90eXBlLCBhcGkpXG5cbm1vZHVsZS5leHBvcnRzLkRpc3BhdGNoZXIgPSBEaXNwYXRjaGVyXG5tb2R1bGUuZXhwb3J0cy5DbGllbnQgPSBDbGllbnRcbm1vZHVsZS5leHBvcnRzLlBvb2wgPSBQb29sXG5tb2R1bGUuZXhwb3J0cy5CYWxhbmNlZFBvb2wgPSBCYWxhbmNlZFBvb2xcbm1vZHVsZS5leHBvcnRzLkFnZW50ID0gQWdlbnRcbm1vZHVsZS5leHBvcnRzLlByb3h5QWdlbnQgPSBQcm94eUFnZW50XG5tb2R1bGUuZXhwb3J0cy5FbnZIdHRwUHJveHlBZ2VudCA9IEVudkh0dHBQcm94eUFnZW50XG5tb2R1bGUuZXhwb3J0cy5SZXRyeUFnZW50ID0gUmV0cnlBZ2VudFxubW9kdWxlLmV4cG9ydHMuUmV0cnlIYW5kbGVyID0gUmV0cnlIYW5kbGVyXG5cbm1vZHVsZS5leHBvcnRzLkRlY29yYXRvckhhbmRsZXIgPSBEZWNvcmF0b3JIYW5kbGVyXG5tb2R1bGUuZXhwb3J0cy5SZWRpcmVjdEhhbmRsZXIgPSBSZWRpcmVjdEhhbmRsZXJcbm1vZHVsZS5leHBvcnRzLmNyZWF0ZVJlZGlyZWN0SW50ZXJjZXB0b3IgPSBjcmVhdGVSZWRpcmVjdEludGVyY2VwdG9yXG5tb2R1bGUuZXhwb3J0cy5pbnRlcmNlcHRvcnMgPSB7XG4gIHJlZGlyZWN0OiByZXF1aXJlKCcuL2xpYi9pbnRlcmNlcHRvci9yZWRpcmVjdCcpLFxuICByZXRyeTogcmVxdWlyZSgnLi9saWIvaW50ZXJjZXB0b3IvcmV0cnknKSxcbiAgZHVtcDogcmVxdWlyZSgnLi9saWIvaW50ZXJjZXB0b3IvZHVtcCcpXG59XG5cbm1vZHVsZS5leHBvcnRzLmJ1aWxkQ29ubmVjdG9yID0gYnVpbGRDb25uZWN0b3Jcbm1vZHVsZS5leHBvcnRzLmVycm9ycyA9IGVycm9yc1xubW9kdWxlLmV4cG9ydHMudXRpbCA9IHtcbiAgcGFyc2VIZWFkZXJzOiB1dGlsLnBhcnNlSGVhZGVycyxcbiAgaGVhZGVyTmFtZVRvU3RyaW5nOiB1dGlsLmhlYWRlck5hbWVUb1N0cmluZ1xufVxuXG5mdW5jdGlvbiBtYWtlRGlzcGF0Y2hlciAoZm4pIHtcbiAgcmV0dXJuICh1cmwsIG9wdHMsIGhhbmRsZXIpID0+IHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGhhbmRsZXIgPSBvcHRzXG4gICAgICBvcHRzID0gbnVsbFxuICAgIH1cblxuICAgIGlmICghdXJsIHx8ICh0eXBlb2YgdXJsICE9PSAnc3RyaW5nJyAmJiB0eXBlb2YgdXJsICE9PSAnb2JqZWN0JyAmJiAhKHVybCBpbnN0YW5jZW9mIFVSTCkpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgdXJsJylcbiAgICB9XG5cbiAgICBpZiAob3B0cyAhPSBudWxsICYmIHR5cGVvZiBvcHRzICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIG9wdHMnKVxuICAgIH1cblxuICAgIGlmIChvcHRzICYmIG9wdHMucGF0aCAhPSBudWxsKSB7XG4gICAgICBpZiAodHlwZW9mIG9wdHMucGF0aCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIG9wdHMucGF0aCcpXG4gICAgICB9XG5cbiAgICAgIGxldCBwYXRoID0gb3B0cy5wYXRoXG4gICAgICBpZiAoIW9wdHMucGF0aC5zdGFydHNXaXRoKCcvJykpIHtcbiAgICAgICAgcGF0aCA9IGAvJHtwYXRofWBcbiAgICAgIH1cblxuICAgICAgdXJsID0gbmV3IFVSTCh1dGlsLnBhcnNlT3JpZ2luKHVybCkub3JpZ2luICsgcGF0aClcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFvcHRzKSB7XG4gICAgICAgIG9wdHMgPSB0eXBlb2YgdXJsID09PSAnb2JqZWN0JyA/IHVybCA6IHt9XG4gICAgICB9XG5cbiAgICAgIHVybCA9IHV0aWwucGFyc2VVUkwodXJsKVxuICAgIH1cblxuICAgIGNvbnN0IHsgYWdlbnQsIGRpc3BhdGNoZXIgPSBnZXRHbG9iYWxEaXNwYXRjaGVyKCkgfSA9IG9wdHNcblxuICAgIGlmIChhZ2VudCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCd1bnN1cHBvcnRlZCBvcHRzLmFnZW50LiBEaWQgeW91IG1lYW4gb3B0cy5jbGllbnQ/JylcbiAgICB9XG5cbiAgICByZXR1cm4gZm4uY2FsbChkaXNwYXRjaGVyLCB7XG4gICAgICAuLi5vcHRzLFxuICAgICAgb3JpZ2luOiB1cmwub3JpZ2luLFxuICAgICAgcGF0aDogdXJsLnNlYXJjaCA/IGAke3VybC5wYXRobmFtZX0ke3VybC5zZWFyY2h9YCA6IHVybC5wYXRobmFtZSxcbiAgICAgIG1ldGhvZDogb3B0cy5tZXRob2QgfHwgKG9wdHMuYm9keSA/ICdQVVQnIDogJ0dFVCcpXG4gICAgfSwgaGFuZGxlcilcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cy5zZXRHbG9iYWxEaXNwYXRjaGVyID0gc2V0R2xvYmFsRGlzcGF0Y2hlclxubW9kdWxlLmV4cG9ydHMuZ2V0R2xvYmFsRGlzcGF0Y2hlciA9IGdldEdsb2JhbERpc3BhdGNoZXJcblxuY29uc3QgZmV0Y2hJbXBsID0gcmVxdWlyZSgnLi9saWIvd2ViL2ZldGNoJykuZmV0Y2hcbm1vZHVsZS5leHBvcnRzLmZldGNoID0gYXN5bmMgZnVuY3Rpb24gZmV0Y2ggKGluaXQsIG9wdGlvbnMgPSB1bmRlZmluZWQpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gYXdhaXQgZmV0Y2hJbXBsKGluaXQsIG9wdGlvbnMpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmIChlcnIgJiYgdHlwZW9mIGVyciA9PT0gJ29iamVjdCcpIHtcbiAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKGVycilcbiAgICB9XG5cbiAgICB0aHJvdyBlcnJcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMuSGVhZGVycyA9IHJlcXVpcmUoJy4vbGliL3dlYi9mZXRjaC9oZWFkZXJzJykuSGVhZGVyc1xubW9kdWxlLmV4cG9ydHMuUmVzcG9uc2UgPSByZXF1aXJlKCcuL2xpYi93ZWIvZmV0Y2gvcmVzcG9uc2UnKS5SZXNwb25zZVxubW9kdWxlLmV4cG9ydHMuUmVxdWVzdCA9IHJlcXVpcmUoJy4vbGliL3dlYi9mZXRjaC9yZXF1ZXN0JykuUmVxdWVzdFxubW9kdWxlLmV4cG9ydHMuRm9ybURhdGEgPSByZXF1aXJlKCcuL2xpYi93ZWIvZmV0Y2gvZm9ybWRhdGEnKS5Gb3JtRGF0YVxubW9kdWxlLmV4cG9ydHMuRmlsZSA9IGdsb2JhbFRoaXMuRmlsZSA/PyByZXF1aXJlKCdub2RlOmJ1ZmZlcicpLkZpbGVcbm1vZHVsZS5leHBvcnRzLkZpbGVSZWFkZXIgPSByZXF1aXJlKCcuL2xpYi93ZWIvZmlsZWFwaS9maWxlcmVhZGVyJykuRmlsZVJlYWRlclxuXG5jb25zdCB7IHNldEdsb2JhbE9yaWdpbiwgZ2V0R2xvYmFsT3JpZ2luIH0gPSByZXF1aXJlKCcuL2xpYi93ZWIvZmV0Y2gvZ2xvYmFsJylcblxubW9kdWxlLmV4cG9ydHMuc2V0R2xvYmFsT3JpZ2luID0gc2V0R2xvYmFsT3JpZ2luXG5tb2R1bGUuZXhwb3J0cy5nZXRHbG9iYWxPcmlnaW4gPSBnZXRHbG9iYWxPcmlnaW5cblxuY29uc3QgeyBDYWNoZVN0b3JhZ2UgfSA9IHJlcXVpcmUoJy4vbGliL3dlYi9jYWNoZS9jYWNoZXN0b3JhZ2UnKVxuY29uc3QgeyBrQ29uc3RydWN0IH0gPSByZXF1aXJlKCcuL2xpYi93ZWIvY2FjaGUvc3ltYm9scycpXG5cbi8vIENhY2hlICYgQ2FjaGVTdG9yYWdlIGFyZSB0aWdodGx5IGNvdXBsZWQgd2l0aCBmZXRjaC4gRXZlbiBpZiBpdCBtYXkgcnVuXG4vLyBpbiBhbiBvbGRlciB2ZXJzaW9uIG9mIE5vZGUsIGl0IGRvZXNuJ3QgaGF2ZSBhbnkgdXNlIHdpdGhvdXQgZmV0Y2guXG5tb2R1bGUuZXhwb3J0cy5jYWNoZXMgPSBuZXcgQ2FjaGVTdG9yYWdlKGtDb25zdHJ1Y3QpXG5cbmNvbnN0IHsgZGVsZXRlQ29va2llLCBnZXRDb29raWVzLCBnZXRTZXRDb29raWVzLCBzZXRDb29raWUgfSA9IHJlcXVpcmUoJy4vbGliL3dlYi9jb29raWVzJylcblxubW9kdWxlLmV4cG9ydHMuZGVsZXRlQ29va2llID0gZGVsZXRlQ29va2llXG5tb2R1bGUuZXhwb3J0cy5nZXRDb29raWVzID0gZ2V0Q29va2llc1xubW9kdWxlLmV4cG9ydHMuZ2V0U2V0Q29va2llcyA9IGdldFNldENvb2tpZXNcbm1vZHVsZS5leHBvcnRzLnNldENvb2tpZSA9IHNldENvb2tpZVxuXG5jb25zdCB7IHBhcnNlTUlNRVR5cGUsIHNlcmlhbGl6ZUFNaW1lVHlwZSB9ID0gcmVxdWlyZSgnLi9saWIvd2ViL2ZldGNoL2RhdGEtdXJsJylcblxubW9kdWxlLmV4cG9ydHMucGFyc2VNSU1FVHlwZSA9IHBhcnNlTUlNRVR5cGVcbm1vZHVsZS5leHBvcnRzLnNlcmlhbGl6ZUFNaW1lVHlwZSA9IHNlcmlhbGl6ZUFNaW1lVHlwZVxuXG5jb25zdCB7IENsb3NlRXZlbnQsIEVycm9yRXZlbnQsIE1lc3NhZ2VFdmVudCB9ID0gcmVxdWlyZSgnLi9saWIvd2ViL3dlYnNvY2tldC9ldmVudHMnKVxubW9kdWxlLmV4cG9ydHMuV2ViU29ja2V0ID0gcmVxdWlyZSgnLi9saWIvd2ViL3dlYnNvY2tldC93ZWJzb2NrZXQnKS5XZWJTb2NrZXRcbm1vZHVsZS5leHBvcnRzLkNsb3NlRXZlbnQgPSBDbG9zZUV2ZW50XG5tb2R1bGUuZXhwb3J0cy5FcnJvckV2ZW50ID0gRXJyb3JFdmVudFxubW9kdWxlLmV4cG9ydHMuTWVzc2FnZUV2ZW50ID0gTWVzc2FnZUV2ZW50XG5cbm1vZHVsZS5leHBvcnRzLnJlcXVlc3QgPSBtYWtlRGlzcGF0Y2hlcihhcGkucmVxdWVzdClcbm1vZHVsZS5leHBvcnRzLnN0cmVhbSA9IG1ha2VEaXNwYXRjaGVyKGFwaS5zdHJlYW0pXG5tb2R1bGUuZXhwb3J0cy5waXBlbGluZSA9IG1ha2VEaXNwYXRjaGVyKGFwaS5waXBlbGluZSlcbm1vZHVsZS5leHBvcnRzLmNvbm5lY3QgPSBtYWtlRGlzcGF0Y2hlcihhcGkuY29ubmVjdClcbm1vZHVsZS5leHBvcnRzLnVwZ3JhZGUgPSBtYWtlRGlzcGF0Y2hlcihhcGkudXBncmFkZSlcblxubW9kdWxlLmV4cG9ydHMuTW9ja0NsaWVudCA9IE1vY2tDbGllbnRcbm1vZHVsZS5leHBvcnRzLk1vY2tQb29sID0gTW9ja1Bvb2xcbm1vZHVsZS5leHBvcnRzLk1vY2tBZ2VudCA9IE1vY2tBZ2VudFxubW9kdWxlLmV4cG9ydHMubW9ja0Vycm9ycyA9IG1vY2tFcnJvcnNcblxuY29uc3QgeyBFdmVudFNvdXJjZSB9ID0gcmVxdWlyZSgnLi9saWIvd2ViL2V2ZW50c291cmNlL2V2ZW50c291cmNlJylcblxubW9kdWxlLmV4cG9ydHMuRXZlbnRTb3VyY2UgPSBFdmVudFNvdXJjZVxuIl0sIm5hbWVzIjpbIkNsaWVudCIsInJlcXVpcmUiLCJEaXNwYXRjaGVyIiwiUG9vbCIsIkJhbGFuY2VkUG9vbCIsIkFnZW50IiwiUHJveHlBZ2VudCIsIkVudkh0dHBQcm94eUFnZW50IiwiUmV0cnlBZ2VudCIsImVycm9ycyIsInV0aWwiLCJJbnZhbGlkQXJndW1lbnRFcnJvciIsImFwaSIsImJ1aWxkQ29ubmVjdG9yIiwiTW9ja0NsaWVudCIsIk1vY2tBZ2VudCIsIk1vY2tQb29sIiwibW9ja0Vycm9ycyIsIlJldHJ5SGFuZGxlciIsImdldEdsb2JhbERpc3BhdGNoZXIiLCJzZXRHbG9iYWxEaXNwYXRjaGVyIiwiRGVjb3JhdG9ySGFuZGxlciIsIlJlZGlyZWN0SGFuZGxlciIsImNyZWF0ZVJlZGlyZWN0SW50ZXJjZXB0b3IiLCJPYmplY3QiLCJhc3NpZ24iLCJwcm90b3R5cGUiLCJtb2R1bGUiLCJleHBvcnRzIiwiaW50ZXJjZXB0b3JzIiwicmVkaXJlY3QiLCJyZXRyeSIsImR1bXAiLCJwYXJzZUhlYWRlcnMiLCJoZWFkZXJOYW1lVG9TdHJpbmciLCJtYWtlRGlzcGF0Y2hlciIsImZuIiwidXJsIiwib3B0cyIsImhhbmRsZXIiLCJVUkwiLCJwYXRoIiwic3RhcnRzV2l0aCIsInBhcnNlT3JpZ2luIiwib3JpZ2luIiwicGFyc2VVUkwiLCJhZ2VudCIsImRpc3BhdGNoZXIiLCJjYWxsIiwic2VhcmNoIiwicGF0aG5hbWUiLCJtZXRob2QiLCJib2R5IiwiZmV0Y2hJbXBsIiwiZmV0Y2giLCJpbml0Iiwib3B0aW9ucyIsInVuZGVmaW5lZCIsImVyciIsIkVycm9yIiwiY2FwdHVyZVN0YWNrVHJhY2UiLCJIZWFkZXJzIiwiUmVzcG9uc2UiLCJSZXF1ZXN0IiwiRm9ybURhdGEiLCJGaWxlIiwiZ2xvYmFsVGhpcyIsIkZpbGVSZWFkZXIiLCJzZXRHbG9iYWxPcmlnaW4iLCJnZXRHbG9iYWxPcmlnaW4iLCJDYWNoZVN0b3JhZ2UiLCJrQ29uc3RydWN0IiwiY2FjaGVzIiwiZGVsZXRlQ29va2llIiwiZ2V0Q29va2llcyIsImdldFNldENvb2tpZXMiLCJzZXRDb29raWUiLCJwYXJzZU1JTUVUeXBlIiwic2VyaWFsaXplQU1pbWVUeXBlIiwiQ2xvc2VFdmVudCIsIkVycm9yRXZlbnQiLCJNZXNzYWdlRXZlbnQiLCJXZWJTb2NrZXQiLCJyZXF1ZXN0Iiwic3RyZWFtIiwicGlwZWxpbmUiLCJjb25uZWN0IiwidXBncmFkZSIsIkV2ZW50U291cmNlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/api/abort-signal.js":
/*!*****************************************************!*\
  !*** ./node_modules/undici/lib/api/abort-signal.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { addAbortListener } = __webpack_require__(/*! ../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\");\nconst { RequestAbortedError } = __webpack_require__(/*! ../core/errors */ \"(ssr)/./node_modules/undici/lib/core/errors.js\");\nconst kListener = Symbol(\"kListener\");\nconst kSignal = Symbol(\"kSignal\");\nfunction abort(self) {\n    if (self.abort) {\n        self.abort(self[kSignal]?.reason);\n    } else {\n        self.reason = self[kSignal]?.reason ?? new RequestAbortedError();\n    }\n    removeSignal(self);\n}\nfunction addSignal(self, signal) {\n    self.reason = null;\n    self[kSignal] = null;\n    self[kListener] = null;\n    if (!signal) {\n        return;\n    }\n    if (signal.aborted) {\n        abort(self);\n        return;\n    }\n    self[kSignal] = signal;\n    self[kListener] = ()=>{\n        abort(self);\n    };\n    addAbortListener(self[kSignal], self[kListener]);\n}\nfunction removeSignal(self) {\n    if (!self[kSignal]) {\n        return;\n    }\n    if (\"removeEventListener\" in self[kSignal]) {\n        self[kSignal].removeEventListener(\"abort\", self[kListener]);\n    } else {\n        self[kSignal].removeListener(\"abort\", self[kListener]);\n    }\n    self[kSignal] = null;\n    self[kListener] = null;\n}\nmodule.exports = {\n    addSignal,\n    removeSignal\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9hcGkvYWJvcnQtc2lnbmFsLmpzIiwibWFwcGluZ3MiOiI7QUFBQSxNQUFNLEVBQUVBLGdCQUFBQSxFQUFrQixHQUFHQyxtQkFBT0EsQ0FBQztBQUNyQyxNQUFNLEVBQUVDLG1CQUFBQSxFQUFxQixHQUFHRCxtQkFBT0EsQ0FBQztBQUV4QyxNQUFNRSxZQUFZQyxPQUFPO0FBQ3pCLE1BQU1DLFVBQVVELE9BQU87QUFFdkIsU0FBU0UsTUFBT0MsSUFBSTtJQUNsQixJQUFJQSxLQUFLRCxLQUFLLEVBQUU7UUFDZEMsS0FBS0QsS0FBSyxDQUFDQyxJQUFJLENBQUNGLFFBQVEsRUFBRUc7SUFDNUIsT0FBTztRQUNMRCxLQUFLQyxNQUFNLEdBQUdELElBQUksQ0FBQ0YsUUFBUSxFQUFFRyxVQUFVLElBQUlOO0lBQzdDO0lBQ0FPLGFBQWFGO0FBQ2Y7QUFFQSxTQUFTRyxVQUFXSCxJQUFJLEVBQUVJLE1BQU07SUFDOUJKLEtBQUtDLE1BQU0sR0FBRztJQUVkRCxJQUFJLENBQUNGLFFBQVEsR0FBRztJQUNoQkUsSUFBSSxDQUFDSixVQUFVLEdBQUc7SUFFbEIsSUFBSSxDQUFDUSxRQUFRO1FBQ1g7SUFDRjtJQUVBLElBQUlBLE9BQU9DLE9BQU8sRUFBRTtRQUNsQk4sTUFBTUM7UUFDTjtJQUNGO0lBRUFBLElBQUksQ0FBQ0YsUUFBUSxHQUFHTTtJQUNoQkosSUFBSSxDQUFDSixVQUFVLEdBQUc7UUFDaEJHLE1BQU1DO0lBQ1I7SUFFQVAsaUJBQWlCTyxJQUFJLENBQUNGLFFBQVEsRUFBRUUsSUFBSSxDQUFDSixVQUFVO0FBQ2pEO0FBRUEsU0FBU00sYUFBY0YsSUFBSTtJQUN6QixJQUFJLENBQUNBLElBQUksQ0FBQ0YsUUFBUSxFQUFFO1FBQ2xCO0lBQ0Y7SUFFQSxJQUFJLHlCQUF5QkUsSUFBSSxDQUFDRixRQUFRLEVBQUU7UUFDMUNFLElBQUksQ0FBQ0YsUUFBUSxDQUFDUSxtQkFBbUIsQ0FBQyxTQUFTTixJQUFJLENBQUNKLFVBQVU7SUFDNUQsT0FBTztRQUNMSSxJQUFJLENBQUNGLFFBQVEsQ0FBQ1MsY0FBYyxDQUFDLFNBQVNQLElBQUksQ0FBQ0osVUFBVTtJQUN2RDtJQUVBSSxJQUFJLENBQUNGLFFBQVEsR0FBRztJQUNoQkUsSUFBSSxDQUFDSixVQUFVLEdBQUc7QUFDcEI7QUFFQVksT0FBT0MsT0FBTyxHQUFHO0lBQ2ZOO0lBQ0FEO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tb2NrdXBmbG93Ly4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvYXBpL2Fib3J0LXNpZ25hbC5qcz82M2I0Iiwid2VicGFjazovL21vY2t1cGZsb3cvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9hcGkvYWJvcnQtc2lnbmFsLmpzPzYzYjQqIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHsgYWRkQWJvcnRMaXN0ZW5lciB9ID0gcmVxdWlyZSgnLi4vY29yZS91dGlsJylcbmNvbnN0IHsgUmVxdWVzdEFib3J0ZWRFcnJvciB9ID0gcmVxdWlyZSgnLi4vY29yZS9lcnJvcnMnKVxuXG5jb25zdCBrTGlzdGVuZXIgPSBTeW1ib2woJ2tMaXN0ZW5lcicpXG5jb25zdCBrU2lnbmFsID0gU3ltYm9sKCdrU2lnbmFsJylcblxuZnVuY3Rpb24gYWJvcnQgKHNlbGYpIHtcbiAgaWYgKHNlbGYuYWJvcnQpIHtcbiAgICBzZWxmLmFib3J0KHNlbGZba1NpZ25hbF0/LnJlYXNvbilcbiAgfSBlbHNlIHtcbiAgICBzZWxmLnJlYXNvbiA9IHNlbGZba1NpZ25hbF0/LnJlYXNvbiA/PyBuZXcgUmVxdWVzdEFib3J0ZWRFcnJvcigpXG4gIH1cbiAgcmVtb3ZlU2lnbmFsKHNlbGYpXG59XG5cbmZ1bmN0aW9uIGFkZFNpZ25hbCAoc2VsZiwgc2lnbmFsKSB7XG4gIHNlbGYucmVhc29uID0gbnVsbFxuXG4gIHNlbGZba1NpZ25hbF0gPSBudWxsXG4gIHNlbGZba0xpc3RlbmVyXSA9IG51bGxcblxuICBpZiAoIXNpZ25hbCkge1xuICAgIHJldHVyblxuICB9XG5cbiAgaWYgKHNpZ25hbC5hYm9ydGVkKSB7XG4gICAgYWJvcnQoc2VsZilcbiAgICByZXR1cm5cbiAgfVxuXG4gIHNlbGZba1NpZ25hbF0gPSBzaWduYWxcbiAgc2VsZltrTGlzdGVuZXJdID0gKCkgPT4ge1xuICAgIGFib3J0KHNlbGYpXG4gIH1cblxuICBhZGRBYm9ydExpc3RlbmVyKHNlbGZba1NpZ25hbF0sIHNlbGZba0xpc3RlbmVyXSlcbn1cblxuZnVuY3Rpb24gcmVtb3ZlU2lnbmFsIChzZWxmKSB7XG4gIGlmICghc2VsZltrU2lnbmFsXSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgaWYgKCdyZW1vdmVFdmVudExpc3RlbmVyJyBpbiBzZWxmW2tTaWduYWxdKSB7XG4gICAgc2VsZltrU2lnbmFsXS5yZW1vdmVFdmVudExpc3RlbmVyKCdhYm9ydCcsIHNlbGZba0xpc3RlbmVyXSlcbiAgfSBlbHNlIHtcbiAgICBzZWxmW2tTaWduYWxdLnJlbW92ZUxpc3RlbmVyKCdhYm9ydCcsIHNlbGZba0xpc3RlbmVyXSlcbiAgfVxuXG4gIHNlbGZba1NpZ25hbF0gPSBudWxsXG4gIHNlbGZba0xpc3RlbmVyXSA9IG51bGxcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGFkZFNpZ25hbCxcbiAgcmVtb3ZlU2lnbmFsXG59XG4iXSwibmFtZXMiOlsiYWRkQWJvcnRMaXN0ZW5lciIsInJlcXVpcmUiLCJSZXF1ZXN0QWJvcnRlZEVycm9yIiwia0xpc3RlbmVyIiwiU3ltYm9sIiwia1NpZ25hbCIsImFib3J0Iiwic2VsZiIsInJlYXNvbiIsInJlbW92ZVNpZ25hbCIsImFkZFNpZ25hbCIsInNpZ25hbCIsImFib3J0ZWQiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwicmVtb3ZlTGlzdGVuZXIiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/api/abort-signal.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/api/api-connect.js":
/*!****************************************************!*\
  !*** ./node_modules/undici/lib/api/api-connect.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\");\nconst { AsyncResource } = __webpack_require__(/*! node:async_hooks */ \"node:async_hooks\");\nconst { InvalidArgumentError, SocketError } = __webpack_require__(/*! ../core/errors */ \"(ssr)/./node_modules/undici/lib/core/errors.js\");\nconst util = __webpack_require__(/*! ../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\");\nconst { addSignal, removeSignal } = __webpack_require__(/*! ./abort-signal */ \"(ssr)/./node_modules/undici/lib/api/abort-signal.js\");\nclass ConnectHandler extends AsyncResource {\n    constructor(opts, callback){\n        if (!opts || typeof opts !== \"object\") {\n            throw new InvalidArgumentError(\"invalid opts\");\n        }\n        if (typeof callback !== \"function\") {\n            throw new InvalidArgumentError(\"invalid callback\");\n        }\n        const { signal, opaque, responseHeaders } = opts;\n        if (signal && typeof signal.on !== \"function\" && typeof signal.addEventListener !== \"function\") {\n            throw new InvalidArgumentError(\"signal must be an EventEmitter or EventTarget\");\n        }\n        super(\"UNDICI_CONNECT\");\n        this.opaque = opaque || null;\n        this.responseHeaders = responseHeaders || null;\n        this.callback = callback;\n        this.abort = null;\n        addSignal(this, signal);\n    }\n    onConnect(abort, context) {\n        if (this.reason) {\n            abort(this.reason);\n            return;\n        }\n        assert(this.callback);\n        this.abort = abort;\n        this.context = context;\n    }\n    onHeaders() {\n        throw new SocketError(\"bad connect\", null);\n    }\n    onUpgrade(statusCode, rawHeaders, socket) {\n        const { callback, opaque, context } = this;\n        removeSignal(this);\n        this.callback = null;\n        let headers = rawHeaders;\n        // Indicates is an HTTP2Session\n        if (headers != null) {\n            headers = this.responseHeaders === \"raw\" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);\n        }\n        this.runInAsyncScope(callback, null, null, {\n            statusCode,\n            headers,\n            socket,\n            opaque,\n            context\n        });\n    }\n    onError(err) {\n        const { callback, opaque } = this;\n        removeSignal(this);\n        if (callback) {\n            this.callback = null;\n            queueMicrotask(()=>{\n                this.runInAsyncScope(callback, null, err, {\n                    opaque\n                });\n            });\n        }\n    }\n}\nfunction connect(opts, callback) {\n    if (callback === undefined) {\n        return new Promise((resolve, reject)=>{\n            connect.call(this, opts, (err, data)=>{\n                return err ? reject(err) : resolve(data);\n            });\n        });\n    }\n    try {\n        const connectHandler = new ConnectHandler(opts, callback);\n        this.dispatch({\n            ...opts,\n            method: \"CONNECT\"\n        }, connectHandler);\n    } catch (err) {\n        if (typeof callback !== \"function\") {\n            throw err;\n        }\n        const opaque = opts?.opaque;\n        queueMicrotask(()=>callback(err, {\n                opaque\n            }));\n    }\n}\nmodule.exports = connect;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9hcGkvYXBpLWNvbm5lY3QuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNQSxTQUFTQyxtQkFBT0EsQ0FBQztBQUN2QixNQUFNLEVBQUVDLGFBQUFBLEVBQWUsR0FBR0QsbUJBQU9BLENBQUM7QUFDbEMsTUFBTSxFQUFFRSxvQkFBb0IsRUFBRUMsV0FBQUEsRUFBYSxHQUFHSCxtQkFBT0EsQ0FBQztBQUN0RCxNQUFNSSxPQUFPSixtQkFBT0EsQ0FBQztBQUNyQixNQUFNLEVBQUVLLFNBQVMsRUFBRUMsWUFBQUEsRUFBYyxHQUFHTixtQkFBT0EsQ0FBQztBQUU1QyxNQUFNTyx1QkFBdUJOO0lBQzNCTyxZQUFhQyxJQUFJLEVBQUVDLFFBQVEsQ0FBRTtRQUMzQixJQUFJLENBQUNELFFBQVEsT0FBT0EsU0FBUyxVQUFVO1lBQ3JDLE1BQU0sSUFBSVAscUJBQXFCO1FBQ2pDO1FBRUEsSUFBSSxPQUFPUSxhQUFhLFlBQVk7WUFDbEMsTUFBTSxJQUFJUixxQkFBcUI7UUFDakM7UUFFQSxNQUFNLEVBQUVTLE1BQU0sRUFBRUMsTUFBTSxFQUFFQyxlQUFBQSxFQUFpQixHQUFHSjtRQUU1QyxJQUFJRSxVQUFVLE9BQU9BLE9BQU9HLEVBQUUsS0FBSyxjQUFjLE9BQU9ILE9BQU9JLGdCQUFnQixLQUFLLFlBQVk7WUFDOUYsTUFBTSxJQUFJYixxQkFBcUI7UUFDakM7UUFFQSxLQUFLLENBQUM7UUFFTixJQUFJLENBQUNVLE1BQU0sR0FBR0EsVUFBVTtRQUN4QixJQUFJLENBQUNDLGVBQWUsR0FBR0EsbUJBQW1CO1FBQzFDLElBQUksQ0FBQ0gsUUFBUSxHQUFHQTtRQUNoQixJQUFJLENBQUNNLEtBQUssR0FBRztRQUViWCxVQUFVLElBQUksRUFBRU07SUFDbEI7SUFFQU0sVUFBV0QsS0FBSyxFQUFFRSxPQUFPLEVBQUU7UUFDekIsSUFBSSxJQUFJLENBQUNDLE1BQU0sRUFBRTtZQUNmSCxNQUFNLElBQUksQ0FBQ0csTUFBTTtZQUNqQjtRQUNGO1FBRUFwQixPQUFPLElBQUksQ0FBQ1csUUFBUTtRQUVwQixJQUFJLENBQUNNLEtBQUssR0FBR0E7UUFDYixJQUFJLENBQUNFLE9BQU8sR0FBR0E7SUFDakI7SUFFQUUsWUFBYTtRQUNYLE1BQU0sSUFBSWpCLFlBQVksZUFBZTtJQUN2QztJQUVBa0IsVUFBV0MsVUFBVSxFQUFFQyxVQUFVLEVBQUVDLE1BQU0sRUFBRTtRQUN6QyxNQUFNLEVBQUVkLFFBQVEsRUFBRUUsTUFBTSxFQUFFTSxPQUFBQSxFQUFTLEdBQUcsSUFBSTtRQUUxQ1osYUFBYSxJQUFJO1FBRWpCLElBQUksQ0FBQ0ksUUFBUSxHQUFHO1FBRWhCLElBQUllLFVBQVVGO1FBQ2Q7UUFDQSxJQUFJRSxXQUFXLE1BQU07WUFDbkJBLFVBQVUsSUFBSSxDQUFDWixlQUFlLEtBQUssUUFBUVQsS0FBS3NCLGVBQWUsQ0FBQ0gsY0FBY25CLEtBQUt1QixZQUFZLENBQUNKO1FBQ2xHO1FBRUEsSUFBSSxDQUFDSyxlQUFlLENBQUNsQixVQUFVLE1BQU0sTUFBTTtZQUN6Q1k7WUFDQUc7WUFDQUQ7WUFDQVo7WUFDQU07UUFDRjtJQUNGO0lBRUFXLFFBQVNDLEdBQUcsRUFBRTtRQUNaLE1BQU0sRUFBRXBCLFFBQVEsRUFBRUUsTUFBQUEsRUFBUSxHQUFHLElBQUk7UUFFakNOLGFBQWEsSUFBSTtRQUVqQixJQUFJSSxVQUFVO1lBQ1osSUFBSSxDQUFDQSxRQUFRLEdBQUc7WUFDaEJxQixlQUFlO2dCQUNiLElBQUksQ0FBQ0gsZUFBZSxDQUFDbEIsVUFBVSxNQUFNb0IsS0FBSztvQkFBRWxCO2dCQUFPO1lBQ3JEO1FBQ0Y7SUFDRjtBQUNGO0FBRUEsU0FBU29CLFFBQVN2QixJQUFJLEVBQUVDLFFBQVE7SUFDOUIsSUFBSUEsYUFBYXVCLFdBQVc7UUFDMUIsT0FBTyxJQUFJQyxRQUFRLENBQUNDLFNBQVNDO1lBQzNCSixRQUFRSyxJQUFJLENBQUMsSUFBSSxFQUFFNUIsTUFBTSxDQUFDcUIsS0FBS1E7Z0JBQzdCLE9BQU9SLE1BQU1NLE9BQU9OLE9BQU9LLFFBQVFHO1lBQ3JDO1FBQ0Y7SUFDRjtJQUVBLElBQUk7UUFDRixNQUFNQyxpQkFBaUIsSUFBSWhDLGVBQWVFLE1BQU1DO1FBQ2hELElBQUksQ0FBQzhCLFFBQVEsQ0FBQztZQUFFLEdBQUcvQixJQUFJO1lBQUVnQyxRQUFRO1FBQVUsR0FBR0Y7SUFDaEQsRUFBRSxPQUFPVCxLQUFLO1FBQ1osSUFBSSxPQUFPcEIsYUFBYSxZQUFZO1lBQ2xDLE1BQU1vQjtRQUNSO1FBQ0EsTUFBTWxCLFNBQVNILE1BQU1HO1FBQ3JCbUIsZUFBZSxJQUFNckIsU0FBU29CLEtBQUs7Z0JBQUVsQjtZQUFPO0lBQzlDO0FBQ0Y7QUFFQThCLE9BQU9DLE9BQU8sR0FBR1giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tb2NrdXBmbG93Ly4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvYXBpL2FwaS1jb25uZWN0LmpzP2VlMmQiLCJ3ZWJwYWNrOi8vbW9ja3VwZmxvdy8uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2FwaS9hcGktY29ubmVjdC5qcz9lZTJkKiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZSgnbm9kZTphc3NlcnQnKVxuY29uc3QgeyBBc3luY1Jlc291cmNlIH0gPSByZXF1aXJlKCdub2RlOmFzeW5jX2hvb2tzJylcbmNvbnN0IHsgSW52YWxpZEFyZ3VtZW50RXJyb3IsIFNvY2tldEVycm9yIH0gPSByZXF1aXJlKCcuLi9jb3JlL2Vycm9ycycpXG5jb25zdCB1dGlsID0gcmVxdWlyZSgnLi4vY29yZS91dGlsJylcbmNvbnN0IHsgYWRkU2lnbmFsLCByZW1vdmVTaWduYWwgfSA9IHJlcXVpcmUoJy4vYWJvcnQtc2lnbmFsJylcblxuY2xhc3MgQ29ubmVjdEhhbmRsZXIgZXh0ZW5kcyBBc3luY1Jlc291cmNlIHtcbiAgY29uc3RydWN0b3IgKG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCFvcHRzIHx8IHR5cGVvZiBvcHRzICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIG9wdHMnKVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBjYWxsYmFjaycpXG4gICAgfVxuXG4gICAgY29uc3QgeyBzaWduYWwsIG9wYXF1ZSwgcmVzcG9uc2VIZWFkZXJzIH0gPSBvcHRzXG5cbiAgICBpZiAoc2lnbmFsICYmIHR5cGVvZiBzaWduYWwub24gIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ3NpZ25hbCBtdXN0IGJlIGFuIEV2ZW50RW1pdHRlciBvciBFdmVudFRhcmdldCcpXG4gICAgfVxuXG4gICAgc3VwZXIoJ1VORElDSV9DT05ORUNUJylcblxuICAgIHRoaXMub3BhcXVlID0gb3BhcXVlIHx8IG51bGxcbiAgICB0aGlzLnJlc3BvbnNlSGVhZGVycyA9IHJlc3BvbnNlSGVhZGVycyB8fCBudWxsXG4gICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrXG4gICAgdGhpcy5hYm9ydCA9IG51bGxcblxuICAgIGFkZFNpZ25hbCh0aGlzLCBzaWduYWwpXG4gIH1cblxuICBvbkNvbm5lY3QgKGFib3J0LCBjb250ZXh0KSB7XG4gICAgaWYgKHRoaXMucmVhc29uKSB7XG4gICAgICBhYm9ydCh0aGlzLnJlYXNvbilcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGFzc2VydCh0aGlzLmNhbGxiYWNrKVxuXG4gICAgdGhpcy5hYm9ydCA9IGFib3J0XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dFxuICB9XG5cbiAgb25IZWFkZXJzICgpIHtcbiAgICB0aHJvdyBuZXcgU29ja2V0RXJyb3IoJ2JhZCBjb25uZWN0JywgbnVsbClcbiAgfVxuXG4gIG9uVXBncmFkZSAoc3RhdHVzQ29kZSwgcmF3SGVhZGVycywgc29ja2V0KSB7XG4gICAgY29uc3QgeyBjYWxsYmFjaywgb3BhcXVlLCBjb250ZXh0IH0gPSB0aGlzXG5cbiAgICByZW1vdmVTaWduYWwodGhpcylcblxuICAgIHRoaXMuY2FsbGJhY2sgPSBudWxsXG5cbiAgICBsZXQgaGVhZGVycyA9IHJhd0hlYWRlcnNcbiAgICAvLyBJbmRpY2F0ZXMgaXMgYW4gSFRUUDJTZXNzaW9uXG4gICAgaWYgKGhlYWRlcnMgIT0gbnVsbCkge1xuICAgICAgaGVhZGVycyA9IHRoaXMucmVzcG9uc2VIZWFkZXJzID09PSAncmF3JyA/IHV0aWwucGFyc2VSYXdIZWFkZXJzKHJhd0hlYWRlcnMpIDogdXRpbC5wYXJzZUhlYWRlcnMocmF3SGVhZGVycylcbiAgICB9XG5cbiAgICB0aGlzLnJ1bkluQXN5bmNTY29wZShjYWxsYmFjaywgbnVsbCwgbnVsbCwge1xuICAgICAgc3RhdHVzQ29kZSxcbiAgICAgIGhlYWRlcnMsXG4gICAgICBzb2NrZXQsXG4gICAgICBvcGFxdWUsXG4gICAgICBjb250ZXh0XG4gICAgfSlcbiAgfVxuXG4gIG9uRXJyb3IgKGVycikge1xuICAgIGNvbnN0IHsgY2FsbGJhY2ssIG9wYXF1ZSB9ID0gdGhpc1xuXG4gICAgcmVtb3ZlU2lnbmFsKHRoaXMpXG5cbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIHRoaXMuY2FsbGJhY2sgPSBudWxsXG4gICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICAgIHRoaXMucnVuSW5Bc3luY1Njb3BlKGNhbGxiYWNrLCBudWxsLCBlcnIsIHsgb3BhcXVlIH0pXG4gICAgICB9KVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb25uZWN0IChvcHRzLCBjYWxsYmFjaykge1xuICBpZiAoY2FsbGJhY2sgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25uZWN0LmNhbGwodGhpcywgb3B0cywgKGVyciwgZGF0YSkgPT4ge1xuICAgICAgICByZXR1cm4gZXJyID8gcmVqZWN0KGVycikgOiByZXNvbHZlKGRhdGEpXG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICB0cnkge1xuICAgIGNvbnN0IGNvbm5lY3RIYW5kbGVyID0gbmV3IENvbm5lY3RIYW5kbGVyKG9wdHMsIGNhbGxiYWNrKVxuICAgIHRoaXMuZGlzcGF0Y2goeyAuLi5vcHRzLCBtZXRob2Q6ICdDT05ORUNUJyB9LCBjb25uZWN0SGFuZGxlcilcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuICAgIGNvbnN0IG9wYXF1ZSA9IG9wdHM/Lm9wYXF1ZVxuICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IGNhbGxiYWNrKGVyciwgeyBvcGFxdWUgfSkpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb25uZWN0XG4iXSwibmFtZXMiOlsiYXNzZXJ0IiwicmVxdWlyZSIsIkFzeW5jUmVzb3VyY2UiLCJJbnZhbGlkQXJndW1lbnRFcnJvciIsIlNvY2tldEVycm9yIiwidXRpbCIsImFkZFNpZ25hbCIsInJlbW92ZVNpZ25hbCIsIkNvbm5lY3RIYW5kbGVyIiwiY29uc3RydWN0b3IiLCJvcHRzIiwiY2FsbGJhY2siLCJzaWduYWwiLCJvcGFxdWUiLCJyZXNwb25zZUhlYWRlcnMiLCJvbiIsImFkZEV2ZW50TGlzdGVuZXIiLCJhYm9ydCIsIm9uQ29ubmVjdCIsImNvbnRleHQiLCJyZWFzb24iLCJvbkhlYWRlcnMiLCJvblVwZ3JhZGUiLCJzdGF0dXNDb2RlIiwicmF3SGVhZGVycyIsInNvY2tldCIsImhlYWRlcnMiLCJwYXJzZVJhd0hlYWRlcnMiLCJwYXJzZUhlYWRlcnMiLCJydW5JbkFzeW5jU2NvcGUiLCJvbkVycm9yIiwiZXJyIiwicXVldWVNaWNyb3Rhc2siLCJjb25uZWN0IiwidW5kZWZpbmVkIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJjYWxsIiwiZGF0YSIsImNvbm5lY3RIYW5kbGVyIiwiZGlzcGF0Y2giLCJtZXRob2QiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/api/api-connect.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/api/api-pipeline.js":
/*!*****************************************************!*\
  !*** ./node_modules/undici/lib/api/api-pipeline.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { Readable, Duplex, PassThrough } = __webpack_require__(/*! node:stream */ \"node:stream\");\nconst { InvalidArgumentError, InvalidReturnValueError, RequestAbortedError } = __webpack_require__(/*! ../core/errors */ \"(ssr)/./node_modules/undici/lib/core/errors.js\");\nconst util = __webpack_require__(/*! ../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\");\nconst { AsyncResource } = __webpack_require__(/*! node:async_hooks */ \"node:async_hooks\");\nconst { addSignal, removeSignal } = __webpack_require__(/*! ./abort-signal */ \"(ssr)/./node_modules/undici/lib/api/abort-signal.js\");\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\");\nconst kResume = Symbol(\"resume\");\nclass PipelineRequest extends Readable {\n    constructor(){\n        super({\n            autoDestroy: true\n        });\n        this[kResume] = null;\n    }\n    _read() {\n        const { [kResume]: resume } = this;\n        if (resume) {\n            this[kResume] = null;\n            resume();\n        }\n    }\n    _destroy(err, callback) {\n        this._read();\n        callback(err);\n    }\n}\nclass PipelineResponse extends Readable {\n    constructor(resume){\n        super({\n            autoDestroy: true\n        });\n        this[kResume] = resume;\n    }\n    _read() {\n        this[kResume]();\n    }\n    _destroy(err, callback) {\n        if (!err && !this._readableState.endEmitted) {\n            err = new RequestAbortedError();\n        }\n        callback(err);\n    }\n}\nclass PipelineHandler extends AsyncResource {\n    constructor(opts, handler){\n        if (!opts || typeof opts !== \"object\") {\n            throw new InvalidArgumentError(\"invalid opts\");\n        }\n        if (typeof handler !== \"function\") {\n            throw new InvalidArgumentError(\"invalid handler\");\n        }\n        const { signal, method, opaque, onInfo, responseHeaders } = opts;\n        if (signal && typeof signal.on !== \"function\" && typeof signal.addEventListener !== \"function\") {\n            throw new InvalidArgumentError(\"signal must be an EventEmitter or EventTarget\");\n        }\n        if (method === \"CONNECT\") {\n            throw new InvalidArgumentError(\"invalid method\");\n        }\n        if (onInfo && typeof onInfo !== \"function\") {\n            throw new InvalidArgumentError(\"invalid onInfo callback\");\n        }\n        super(\"UNDICI_PIPELINE\");\n        this.opaque = opaque || null;\n        this.responseHeaders = responseHeaders || null;\n        this.handler = handler;\n        this.abort = null;\n        this.context = null;\n        this.onInfo = onInfo || null;\n        this.req = new PipelineRequest().on(\"error\", util.nop);\n        this.ret = new Duplex({\n            readableObjectMode: opts.objectMode,\n            autoDestroy: true,\n            read: ()=>{\n                const { body } = this;\n                if (body?.resume) {\n                    body.resume();\n                }\n            },\n            write: (chunk, encoding, callback)=>{\n                const { req } = this;\n                if (req.push(chunk, encoding) || req._readableState.destroyed) {\n                    callback();\n                } else {\n                    req[kResume] = callback;\n                }\n            },\n            destroy: (err, callback)=>{\n                const { body, req, res, ret, abort } = this;\n                if (!err && !ret._readableState.endEmitted) {\n                    err = new RequestAbortedError();\n                }\n                if (abort && err) {\n                    abort();\n                }\n                util.destroy(body, err);\n                util.destroy(req, err);\n                util.destroy(res, err);\n                removeSignal(this);\n                callback(err);\n            }\n        }).on(\"prefinish\", ()=>{\n            const { req } = this;\n            // Node < 15 does not call _final in same tick.\n            req.push(null);\n        });\n        this.res = null;\n        addSignal(this, signal);\n    }\n    onConnect(abort, context) {\n        const { ret, res } = this;\n        if (this.reason) {\n            abort(this.reason);\n            return;\n        }\n        assert(!res, \"pipeline cannot be retried\");\n        assert(!ret.destroyed);\n        this.abort = abort;\n        this.context = context;\n    }\n    onHeaders(statusCode, rawHeaders, resume) {\n        const { opaque, handler, context } = this;\n        if (statusCode < 200) {\n            if (this.onInfo) {\n                const headers = this.responseHeaders === \"raw\" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);\n                this.onInfo({\n                    statusCode,\n                    headers\n                });\n            }\n            return;\n        }\n        this.res = new PipelineResponse(resume);\n        let body;\n        try {\n            this.handler = null;\n            const headers = this.responseHeaders === \"raw\" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);\n            body = this.runInAsyncScope(handler, null, {\n                statusCode,\n                headers,\n                opaque,\n                body: this.res,\n                context\n            });\n        } catch (err) {\n            this.res.on(\"error\", util.nop);\n            throw err;\n        }\n        if (!body || typeof body.on !== \"function\") {\n            throw new InvalidReturnValueError(\"expected Readable\");\n        }\n        body.on(\"data\", (chunk)=>{\n            const { ret, body } = this;\n            if (!ret.push(chunk) && body.pause) {\n                body.pause();\n            }\n        }).on(\"error\", (err)=>{\n            const { ret } = this;\n            util.destroy(ret, err);\n        }).on(\"end\", ()=>{\n            const { ret } = this;\n            ret.push(null);\n        }).on(\"close\", ()=>{\n            const { ret } = this;\n            if (!ret._readableState.ended) {\n                util.destroy(ret, new RequestAbortedError());\n            }\n        });\n        this.body = body;\n    }\n    onData(chunk) {\n        const { res } = this;\n        return res.push(chunk);\n    }\n    onComplete(trailers) {\n        const { res } = this;\n        res.push(null);\n    }\n    onError(err) {\n        const { ret } = this;\n        this.handler = null;\n        util.destroy(ret, err);\n    }\n}\nfunction pipeline(opts, handler) {\n    try {\n        const pipelineHandler = new PipelineHandler(opts, handler);\n        this.dispatch({\n            ...opts,\n            body: pipelineHandler.req\n        }, pipelineHandler);\n        return pipelineHandler.ret;\n    } catch (err) {\n        return new PassThrough().destroy(err);\n    }\n}\nmodule.exports = pipeline;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9hcGkvYXBpLXBpcGVsaW5lLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTSxFQUNKQSxRQUFRLEVBQ1JDLE1BQU0sRUFDTkMsV0FBQUEsRUFDRCxHQUFHQyxtQkFBT0EsQ0FBQztBQUNaLE1BQU0sRUFDSkMsb0JBQW9CLEVBQ3BCQyx1QkFBdUIsRUFDdkJDLG1CQUFBQSxFQUNELEdBQUdILG1CQUFPQSxDQUFDO0FBQ1osTUFBTUksT0FBT0osbUJBQU9BLENBQUM7QUFDckIsTUFBTSxFQUFFSyxhQUFBQSxFQUFlLEdBQUdMLG1CQUFPQSxDQUFDO0FBQ2xDLE1BQU0sRUFBRU0sU0FBUyxFQUFFQyxZQUFBQSxFQUFjLEdBQUdQLG1CQUFPQSxDQUFDO0FBQzVDLE1BQU1RLFNBQVNSLG1CQUFPQSxDQUFDO0FBRXZCLE1BQU1TLFVBQVVDLE9BQU87QUFFdkIsTUFBTUMsd0JBQXdCZDtJQUM1QmUsYUFBZTtRQUNiLEtBQUssQ0FBQztZQUFFQyxhQUFhO1FBQUs7UUFFMUIsSUFBSSxDQUFDSixRQUFRLEdBQUc7SUFDbEI7SUFFQUssUUFBUztRQUNQLE1BQU0sRUFBRSxDQUFDTCxRQUFPLEVBQUdNLE1BQUFBLEVBQVEsR0FBRyxJQUFJO1FBRWxDLElBQUlBLFFBQVE7WUFDVixJQUFJLENBQUNOLFFBQVEsR0FBRztZQUNoQk07UUFDRjtJQUNGO0lBRUFDLFNBQVVDLEdBQUcsRUFBRUMsUUFBUSxFQUFFO1FBQ3ZCLElBQUksQ0FBQ0osS0FBSztRQUVWSSxTQUFTRDtJQUNYO0FBQ0Y7QUFFQSxNQUFNRSx5QkFBeUJ0QjtJQUM3QmUsWUFBYUcsTUFBTSxDQUFFO1FBQ25CLEtBQUssQ0FBQztZQUFFRixhQUFhO1FBQUs7UUFDMUIsSUFBSSxDQUFDSixRQUFRLEdBQUdNO0lBQ2xCO0lBRUFELFFBQVM7UUFDUCxJQUFJLENBQUNMLFFBQVE7SUFDZjtJQUVBTyxTQUFVQyxHQUFHLEVBQUVDLFFBQVEsRUFBRTtRQUN2QixJ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R0FBRyxJQUFJO1FBQ3BCLElBQUksQ0FBQ1osT0FBTyxHQUFHO1FBQ2ZwQixLQUFLMEMsT0FBTyxDQUFDVixLQUFLbkI7SUFDcEI7QUFDRjtBQUVBLFNBQVM4QyxTQUFVeEMsSUFBSSxFQUFFQyxPQUFPO0lBQzlCLElBQUk7UUFDRixNQUFNd0Msa0JBQWtCLElBQUkxQyxnQkFBZ0JDLE1BQU1DO1FBQ2xELElBQUksQ0FBQ3lDLFFBQVEsQ0FBQztZQUFFLEdBQUcxQyxJQUFJO1lBQUVpQixNQUFNd0IsZ0JBQWdCOUIsR0FBQUE7UUFBSSxHQUFHOEI7UUFDdEQsT0FBT0EsZ0JBQWdCNUIsR0FBRztJQUM1QixFQUFFLE9BQU9uQixLQUFLO1FBQ1osT0FBTyxJQUFJbEIsY0FBYytDLE9BQU8sQ0FBQzdCO0lBQ25DO0FBQ0Y7QUFFQWlELE9BQU9DLE9BQU8sR0FBR0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tb2NrdXBmbG93Ly4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvYXBpL2FwaS1waXBlbGluZS5qcz8yMzQzIiwid2VicGFjazovL21vY2t1cGZsb3cvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9hcGkvYXBpLXBpcGVsaW5lLmpzPzIzNDMqIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7XG4gIFJlYWRhYmxlLFxuICBEdXBsZXgsXG4gIFBhc3NUaHJvdWdoXG59ID0gcmVxdWlyZSgnbm9kZTpzdHJlYW0nKVxuY29uc3Qge1xuICBJbnZhbGlkQXJndW1lbnRFcnJvcixcbiAgSW52YWxpZFJldHVyblZhbHVlRXJyb3IsXG4gIFJlcXVlc3RBYm9ydGVkRXJyb3Jcbn0gPSByZXF1aXJlKCcuLi9jb3JlL2Vycm9ycycpXG5jb25zdCB1dGlsID0gcmVxdWlyZSgnLi4vY29yZS91dGlsJylcbmNvbnN0IHsgQXN5bmNSZXNvdXJjZSB9ID0gcmVxdWlyZSgnbm9kZTphc3luY19ob29rcycpXG5jb25zdCB7IGFkZFNpZ25hbCwgcmVtb3ZlU2lnbmFsIH0gPSByZXF1aXJlKCcuL2Fib3J0LXNpZ25hbCcpXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdub2RlOmFzc2VydCcpXG5cbmNvbnN0IGtSZXN1bWUgPSBTeW1ib2woJ3Jlc3VtZScpXG5cbmNsYXNzIFBpcGVsaW5lUmVxdWVzdCBleHRlbmRzIFJlYWRhYmxlIHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHN1cGVyKHsgYXV0b0Rlc3Ryb3k6IHRydWUgfSlcblxuICAgIHRoaXNba1Jlc3VtZV0gPSBudWxsXG4gIH1cblxuICBfcmVhZCAoKSB7XG4gICAgY29uc3QgeyBba1Jlc3VtZV06IHJlc3VtZSB9ID0gdGhpc1xuXG4gICAgaWYgKHJlc3VtZSkge1xuICAgICAgdGhpc1trUmVzdW1lXSA9IG51bGxcbiAgICAgIHJlc3VtZSgpXG4gICAgfVxuICB9XG5cbiAgX2Rlc3Ryb3kgKGVyciwgY2FsbGJhY2spIHtcbiAgICB0aGlzLl9yZWFkKClcblxuICAgIGNhbGxiYWNrKGVycilcbiAgfVxufVxuXG5jbGFzcyBQaXBlbGluZVJlc3BvbnNlIGV4dGVuZHMgUmVhZGFibGUge1xuICBjb25zdHJ1Y3RvciAocmVzdW1lKSB7XG4gICAgc3VwZXIoeyBhdXRvRGVzdHJveTogdHJ1ZSB9KVxuICAgIHRoaXNba1Jlc3VtZV0gPSByZXN1bWVcbiAgfVxuXG4gIF9yZWFkICgpIHtcbiAgICB0aGlzW2tSZXN1bWVdKClcbiAgfVxuXG4gIF9kZXN0cm95IChlcnIsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCFlcnIgJiYgIXRoaXMuX3JlYWRhYmxlU3RhdGUuZW5kRW1pdHRlZCkge1xuICAgICAgZXJyID0gbmV3IFJlcXVlc3RBYm9ydGVkRXJyb3IoKVxuICAgIH1cblxuICAgIGNhbGxiYWNrKGVycilcbiAgfVxufVxuXG5jbGFzcyBQaXBlbGluZUhhbmRsZXIgZXh0ZW5kcyBBc3luY1Jlc291cmNlIHtcbiAgY29uc3RydWN0b3IgKG9wdHMsIGhhbmRsZXIpIHtcbiAgICBpZiAoIW9wdHMgfHwgdHlwZW9mIG9wdHMgIT09ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgb3B0cycpXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBoYW5kbGVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgaGFuZGxlcicpXG4gICAgfVxuXG4gICAgY29uc3QgeyBzaWduYWwsIG1ldGhvZCwgb3BhcXVlLCBvbkluZm8sIHJlc3BvbnNlSGVhZGVycyB9ID0gb3B0c1xuXG4gICAgaWYgKHNpZ25hbCAmJiB0eXBlb2Ygc2lnbmFsLm9uICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdzaWduYWwgbXVzdCBiZSBhbiBFdmVudEVtaXR0ZXIgb3IgRXZlbnRUYXJnZXQnKVxuICAgIH1cblxuICAgIGlmIChtZXRob2QgPT09ICdDT05ORUNUJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIG1ldGhvZCcpXG4gICAgfVxuXG4gICAgaWYgKG9uSW5mbyAmJiB0eXBlb2Ygb25JbmZvICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgb25JbmZvIGNhbGxiYWNrJylcbiAgICB9XG5cbiAgICBzdXBlcignVU5ESUNJX1BJUEVMSU5FJylcblxuICAgIHRoaXMub3BhcXVlID0gb3BhcXVlIHx8IG51bGxcbiAgICB0aGlzLnJlc3BvbnNlSGVhZGVycyA9IHJlc3BvbnNlSGVhZGVycyB8fCBudWxsXG4gICAgdGhpcy5oYW5kbGVyID0gaGFuZGxlclxuICAgIHRoaXMuYWJvcnQgPSBudWxsXG4gICAgdGhpcy5jb250ZXh0ID0gbnVsbFxuICAgIHRoaXMub25JbmZvID0gb25JbmZvIHx8IG51bGxcblxuICAgIHRoaXMucmVxID0gbmV3IFBpcGVsaW5lUmVxdWVzdCgpLm9uKCdlcnJvcicsIHV0aWwubm9wKVxuXG4gICAgdGhpcy5yZXQgPSBuZXcgRHVwbGV4KHtcbiAgICAgIHJlYWRhYmxlT2JqZWN0TW9kZTogb3B0cy5vYmplY3RNb2RlLFxuICAgICAgYXV0b0Rlc3Ryb3k6IHRydWUsXG4gICAgICByZWFkOiAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgYm9keSB9ID0gdGhpc1xuXG4gICAgICAgIGlmIChib2R5Py5yZXN1bWUpIHtcbiAgICAgICAgICBib2R5LnJlc3VtZSgpXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB3cml0ZTogKGNodW5rLCBlbmNvZGluZywgY2FsbGJhY2spID0+IHtcbiAgICAgICAgY29uc3QgeyByZXEgfSA9IHRoaXNcblxuICAgICAgICBpZiAocmVxLnB1c2goY2h1bmssIGVuY29kaW5nKSB8fCByZXEuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkKSB7XG4gICAgICAgICAgY2FsbGJhY2soKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlcVtrUmVzdW1lXSA9IGNhbGxiYWNrXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBkZXN0cm95OiAoZXJyLCBjYWxsYmFjaykgPT4ge1xuICAgICAgICBjb25zdCB7IGJvZHksIHJlcSwgcmVzLCByZXQsIGFib3J0IH0gPSB0aGlzXG5cbiAgICAgICAgaWYgKCFlcnIgJiYgIXJldC5fcmVhZGFibGVTdGF0ZS5lbmRFbWl0dGVkKSB7XG4gICAgICAgICAgZXJyID0gbmV3IFJlcXVlc3RBYm9ydGVkRXJyb3IoKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFib3J0ICYmIGVycikge1xuICAgICAgICAgIGFib3J0KClcbiAgICAgICAgfVxuXG4gICAgICAgIHV0aWwuZGVzdHJveShib2R5LCBlcnIpXG4gICAgICAgIHV0aWwuZGVzdHJveShyZXEsIGVycilcbiAgICAgICAgdXRpbC5kZXN0cm95KHJlcywgZXJyKVxuXG4gICAgICAgIHJlbW92ZVNpZ25hbCh0aGlzKVxuXG4gICAgICAgIGNhbGxiYWNrKGVycilcbiAgICAgIH1cbiAgICB9KS5vbigncHJlZmluaXNoJywgKCkgPT4ge1xuICAgICAgY29uc3QgeyByZXEgfSA9IHRoaXNcblxuICAgICAgLy8gTm9kZSA8IDE1IGRvZXMgbm90IGNhbGwgX2ZpbmFsIGluIHNhbWUgdGljay5cbiAgICAgIHJlcS5wdXNoKG51bGwpXG4gICAgfSlcblxuICAgIHRoaXMucmVzID0gbnVsbFxuXG4gICAgYWRkU2lnbmFsKHRoaXMsIHNpZ25hbClcbiAgfVxuXG4gIG9uQ29ubmVjdCAoYWJvcnQsIGNvbnRleHQpIHtcbiAgICBjb25zdCB7IHJldCwgcmVzIH0gPSB0aGlzXG5cbiAgICBpZiAodGhpcy5yZWFzb24pIHtcbiAgICAgIGFib3J0KHRoaXMucmVhc29uKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgYXNzZXJ0KCFyZXMsICdwaXBlbGluZSBjYW5ub3QgYmUgcmV0cmllZCcpXG4gICAgYXNzZXJ0KCFyZXQuZGVzdHJveWVkKVxuXG4gICAgdGhpcy5hYm9ydCA9IGFib3J0XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dFxuICB9XG5cbiAgb25IZWFkZXJzIChzdGF0dXNDb2RlLCByYXdIZWFkZXJzLCByZXN1bWUpIHtcbiAgICBjb25zdCB7IG9wYXF1ZSwgaGFuZGxlciwgY29udGV4dCB9ID0gdGhpc1xuXG4gICAgaWYgKHN0YXR1c0NvZGUgPCAyMDApIHtcbiAgICAgIGlmICh0aGlzLm9uSW5mbykge1xuICAgICAgICBjb25zdCBoZWFkZXJzID0gdGhpcy5yZXNwb25zZUhlYWRlcnMgPT09ICdyYXcnID8gdXRpbC5wYXJzZVJhd0hlYWRlcnMocmF3SGVhZGVycykgOiB1dGlsLnBhcnNlSGVhZGVycyhyYXdIZWFkZXJzKVxuICAgICAgICB0aGlzLm9uSW5mbyh7IHN0YXR1c0NvZGUsIGhlYWRlcnMgfSlcbiAgICAgIH1cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMucmVzID0gbmV3IFBpcGVsaW5lUmVzcG9uc2UocmVzdW1lKVxuXG4gICAgbGV0IGJvZHlcbiAgICB0cnkge1xuICAgICAgdGhpcy5oYW5kbGVyID0gbnVsbFxuICAgICAgY29uc3QgaGVhZGVycyA9IHRoaXMucmVzcG9uc2VIZWFkZXJzID09PSAncmF3JyA/IHV0aWwucGFyc2VSYXdIZWFkZXJzKHJhd0hlYWRlcnMpIDogdXRpbC5wYXJzZUhlYWRlcnMocmF3SGVhZGVycylcbiAgICAgIGJvZHkgPSB0aGlzLnJ1bkluQXN5bmNTY29wZShoYW5kbGVyLCBudWxsLCB7XG4gICAgICAgIHN0YXR1c0NvZGUsXG4gICAgICAgIGhlYWRlcnMsXG4gICAgICAgIG9wYXF1ZSxcbiAgICAgICAgYm9keTogdGhpcy5yZXMsXG4gICAgICAgIGNvbnRleHRcbiAgICAgIH0pXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aGlzLnJlcy5vbignZXJyb3InLCB1dGlsLm5vcClcbiAgICAgIHRocm93IGVyclxuICAgIH1cblxuICAgIGlmICghYm9keSB8fCB0eXBlb2YgYm9keS5vbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRSZXR1cm5WYWx1ZUVycm9yKCdleHBlY3RlZCBSZWFkYWJsZScpXG4gICAgfVxuXG4gICAgYm9keVxuICAgICAgLm9uKCdkYXRhJywgKGNodW5rKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgcmV0LCBib2R5IH0gPSB0aGlzXG5cbiAgICAgICAgaWYgKCFyZXQucHVzaChjaHVuaykgJiYgYm9keS5wYXVzZSkge1xuICAgICAgICAgIGJvZHkucGF1c2UoKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgLm9uKCdlcnJvcicsIChlcnIpID0+IHtcbiAgICAgICAgY29uc3QgeyByZXQgfSA9IHRoaXNcblxuICAgICAgICB1dGlsLmRlc3Ryb3kocmV0LCBlcnIpXG4gICAgICB9KVxuICAgICAgLm9uKCdlbmQnLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgcmV0IH0gPSB0aGlzXG5cbiAgICAgICAgcmV0LnB1c2gobnVsbClcbiAgICAgIH0pXG4gICAgICAub24oJ2Nsb3NlJywgKCkgPT4ge1xuICAgICAgICBjb25zdCB7IHJldCB9ID0gdGhpc1xuXG4gICAgICAgIGlmICghcmV0Ll9yZWFkYWJsZVN0YXRlLmVuZGVkKSB7XG4gICAgICAgICAgdXRpbC5kZXN0cm95KHJldCwgbmV3IFJlcXVlc3RBYm9ydGVkRXJyb3IoKSlcbiAgICAgICAgfVxuICAgICAgfSlcblxuICAgIHRoaXMuYm9keSA9IGJvZHlcbiAgfVxuXG4gIG9uRGF0YSAoY2h1bmspIHtcbiAgICBjb25zdCB7IHJlcyB9ID0gdGhpc1xuICAgIHJldHVybiByZXMucHVzaChjaHVuaylcbiAgfVxuXG4gIG9uQ29tcGxldGUgKHRyYWlsZXJzKSB7XG4gICAgY29uc3QgeyByZXMgfSA9IHRoaXNcbiAgICByZXMucHVzaChudWxsKVxuICB9XG5cbiAgb25FcnJvciAoZXJyKSB7XG4gICAgY29uc3QgeyByZXQgfSA9IHRoaXNcbiAgICB0aGlzLmhhbmRsZXIgPSBudWxsXG4gICAgdXRpbC5kZXN0cm95KHJldCwgZXJyKVxuICB9XG59XG5cbmZ1bmN0aW9uIHBpcGVsaW5lIChvcHRzLCBoYW5kbGVyKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgcGlwZWxpbmVIYW5kbGVyID0gbmV3IFBpcGVsaW5lSGFuZGxlcihvcHRzLCBoYW5kbGVyKVxuICAgIHRoaXMuZGlzcGF0Y2goeyAuLi5vcHRzLCBib2R5OiBwaXBlbGluZUhhbmRsZXIucmVxIH0sIHBpcGVsaW5lSGFuZGxlcilcbiAgICByZXR1cm4gcGlwZWxpbmVIYW5kbGVyLnJldFxuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gbmV3IFBhc3NUaHJvdWdoKCkuZGVzdHJveShlcnIpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwaXBlbGluZVxuIl0sIm5hbWVzIjpbIlJlYWRhYmxlIiwiRHVwbGV4IiwiUGFzc1Rocm91Z2giLCJyZXF1aXJlIiwiSW52YWxpZEFyZ3VtZW50RXJyb3IiLCJJbnZhbGlkUmV0dXJuVmFsdWVFcnJvciIsIlJlcXVlc3RBYm9ydGVkRXJyb3IiLCJ1dGlsIiwiQXN5bmNSZXNvdXJjZSIsImFkZFNpZ25hbCIsInJlbW92ZVNpZ25hbCIsImFzc2VydCIsImtSZXN1bWUiLCJTeW1ib2wiLCJQaXBlbGluZVJlcXVlc3QiLCJjb25zdHJ1Y3RvciIsImF1dG9EZXN0cm95IiwiX3JlYWQiLCJyZXN1bWUiLCJfZGVzdHJveSIsImVyciIsImNhbGxiYWNrIiwiUGlwZWxpbmVSZXNwb25zZSIsIl9yZWFkYWJsZVN0YXRlIiwiZW5kRW1pdHRlZCIsIlBpcGVsaW5lSGFuZGxlciIsIm9wdHMiLCJoYW5kbGVyIiwic2lnbmFsIiwibWV0aG9kIiwib3BhcXVlIiwib25JbmZvIiwicmVzcG9uc2VIZWFkZXJzIiwib24iLCJhZGRFdmVudExpc3RlbmVyIiwiYWJvcnQiLCJjb250ZXh0IiwicmVxIiwibm9wIiwicmV0IiwicmVhZGFibGVPYmplY3RNb2RlIiwib2JqZWN0TW9kZSIsInJlYWQiLCJib2R5Iiwid3JpdGUiLCJjaHVuayIsImVuY29kaW5nIiwicHVzaCIsImRlc3Ryb3llZCIsImRlc3Ryb3kiLCJyZXMiLCJvbkNvbm5lY3QiLCJyZWFzb24iLCJvbkhlYWRlcnMiLCJzdGF0dXNDb2RlIiwicmF3SGVhZGVycyIsImhlYWRlcnMiLCJwYXJzZVJhd0hlYWRlcnMiLCJwYXJzZUhlYWRlcnMiLCJydW5JbkFzeW5jU2NvcGUiLCJwYXVzZSIsImVuZGVkIiwib25EYXRhIiwib25Db21wbGV0ZSIsInRyYWlsZXJzIiwib25FcnJvciIsInBpcGVsaW5lIiwicGlwZWxpbmVIYW5kbGVyIiwiZGlzcGF0Y2giLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/api/api-pipeline.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/api/api-request.js":
/*!****************************************************!*\
  !*** ./node_modules/undici/lib/api/api-request.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\");\nconst { Readable } = __webpack_require__(/*! ./readable */ \"(ssr)/./node_modules/undici/lib/api/readable.js\");\nconst { InvalidArgumentError, RequestAbortedError } = __webpack_require__(/*! ../core/errors */ \"(ssr)/./node_modules/undici/lib/core/errors.js\");\nconst util = __webpack_require__(/*! ../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\");\nconst { getResolveErrorBodyCallback } = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/undici/lib/api/util.js\");\nconst { AsyncResource } = __webpack_require__(/*! node:async_hooks */ \"node:async_hooks\");\nclass RequestHandler extends AsyncResource {\n    constructor(opts, callback){\n        if (!opts || typeof opts !== \"object\") {\n            throw new InvalidArgumentError(\"invalid opts\");\n        }\n        const { signal, method, opaque, body, onInfo, responseHeaders, throwOnError, highWaterMark } = opts;\n        try {\n            if (typeof callback !== \"function\") {\n                throw new InvalidArgumentError(\"invalid callback\");\n            }\n            if (highWaterMark && (typeof highWaterMark !== \"number\" || highWaterMark < 0)) {\n                throw new InvalidArgumentError(\"invalid highWaterMark\");\n            }\n            if (signal && typeof signal.on !== \"function\" && typeof signal.addEventListener !== \"function\") {\n                throw new InvalidArgumentError(\"signal must be an EventEmitter or EventTarget\");\n            }\n            if (method === \"CONNECT\") {\n                throw new InvalidArgumentError(\"invalid method\");\n            }\n            if (onInfo && typeof onInfo !== \"function\") {\n                throw new InvalidArgumentError(\"invalid onInfo callback\");\n            }\n            super(\"UNDICI_REQUEST\");\n        } catch (err) {\n            if (util.isStream(body)) {\n                util.destroy(body.on(\"error\", util.nop), err);\n            }\n            throw err;\n        }\n        this.method = method;\n        this.responseHeaders = responseHeaders || null;\n        this.opaque = opaque || null;\n        this.callback = callback;\n        this.res = null;\n        this.abort = null;\n        this.body = body;\n        this.trailers = {};\n        this.context = null;\n        this.onInfo = onInfo || null;\n        this.throwOnError = throwOnError;\n        this.highWaterMark = highWaterMark;\n        this.signal = signal;\n        this.reason = null;\n        this.removeAbortListener = null;\n        if (util.isStream(body)) {\n            body.on(\"error\", (err)=>{\n                this.onError(err);\n            });\n        }\n        if (this.signal) {\n            if (this.signal.aborted) {\n                this.reason = this.signal.reason ?? new RequestAbortedError();\n            } else {\n                this.removeAbortListener = util.addAbortListener(this.signal, ()=>{\n                    this.reason = this.signal.reason ?? new RequestAbortedError();\n                    if (this.res) {\n                        util.destroy(this.res, this.reason);\n                    } else if (this.abort) {\n                        this.abort(this.reason);\n                    }\n                    if (this.removeAbortListener) {\n                        this.res?.off(\"close\", this.removeAbortListener);\n                        this.removeAbortListener();\n                        this.removeAbortListener = null;\n                    }\n                });\n            }\n        }\n    }\n    onConnect(abort, context) {\n        if (this.reason) {\n            abort(this.reason);\n            return;\n        }\n        assert(this.callback);\n        this.abort = abort;\n        this.context = context;\n    }\n    onHeaders(statusCode, rawHeaders, resume, statusMessage) {\n        const { callback, opaque, abort, context, responseHeaders, highWaterMark } = this;\n        const headers = responseHeaders === \"raw\" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);\n        if (statusCode < 200) {\n            if (this.onInfo) {\n                this.onInfo({\n                    statusCode,\n                    headers\n                });\n            }\n            return;\n        }\n        const parsedHeaders = responseHeaders === \"raw\" ? util.parseHeaders(rawHeaders) : headers;\n        const contentType = parsedHeaders[\"content-type\"];\n        const contentLength = parsedHeaders[\"content-length\"];\n        const res = new Readable({\n            resume,\n            abort,\n            contentType,\n            contentLength: this.method !== \"HEAD\" && contentLength ? Number(contentLength) : null,\n            highWaterMark\n        });\n        if (this.removeAbortListener) {\n            res.on(\"close\", this.removeAbortListener);\n        }\n        this.callback = null;\n        this.res = res;\n        if (callback !== null) {\n            if (this.throwOnError && statusCode >= 400) {\n                this.runInAsyncScope(getResolveErrorBodyCallback, null, {\n                    callback,\n                    body: res,\n                    contentType,\n                    statusCode,\n                    statusMessage,\n                    headers\n                });\n            } else {\n                this.runInAsyncScope(callback, null, null, {\n                    statusCode,\n                    headers,\n                    trailers: this.trailers,\n                    opaque,\n                    body: res,\n                    context\n                });\n            }\n        }\n    }\n    onData(chunk) {\n        return this.res.push(chunk);\n    }\n    onComplete(trailers) {\n        util.parseHeaders(trailers, this.trailers);\n        this.res.push(null);\n    }\n    onError(err) {\n        const { res, callback, body, opaque } = this;\n        if (callback) {\n            // TODO: Does this need queueMicrotask?\n            this.callback = null;\n            queueMicrotask(()=>{\n                this.runInAsyncScope(callback, null, err, {\n                    opaque\n                });\n            });\n        }\n        if (res) {\n            this.res = null;\n            // Ensure all queued handlers are invoked before destroying res.\n            queueMicrotask(()=>{\n                util.destroy(res, err);\n            });\n        }\n        if (body) {\n            this.body = null;\n            util.destroy(body, err);\n        }\n        if (this.removeAbortListener) {\n            res?.off(\"close\", this.removeAbortListener);\n            this.removeAbortListener();\n            this.removeAbortListener = null;\n        }\n    }\n}\nfunction request(opts, callback) {\n    if (callback === undefined) {\n        return new Promise((resolve, reject)=>{\n            request.call(this, opts, (err, data)=>{\n                return err ? reject(err) : resolve(data);\n            });\n        });\n    }\n    try {\n        this.dispatch(opts, new RequestHandler(opts, callback));\n    } catch (err) {\n        if (typeof callback !== \"function\") {\n            throw err;\n        }\n        const opaque = opts?.opaque;\n        queueMicrotask(()=>callback(err, {\n                opaque\n            }));\n    }\n}\nmodule.exports = request;\nmodule.exports.RequestHandler = RequestHandler;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9hcGkvYXBpLXJlcXVlc3QuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNQSxTQUFTQyxtQkFBT0EsQ0FBQztBQUN2QixNQUFNLEVBQUVDLFFBQUFBLEVBQVUsR0FBR0QsbUJBQU9BLENBQUM7QUFDN0IsTUFBTSxFQUFFRSxvQkFBb0IsRUFBRUMsbUJBQUFBLEVBQXFCLEdBQUdILG1CQUFPQSxDQUFDO0FBQzlELE1BQU1JLE9BQU9KLG1CQUFPQSxDQUFDO0FBQ3JCLE1BQU0sRUFBRUssMkJBQUFBLEVBQTZCLEdBQUdMLG1CQUFPQSxDQUFDO0FBQ2hELE1BQU0sRUFBRU0sYUFBQUEsRUFBZSxHQUFHTixtQkFBT0EsQ0FBQztBQUVsQyxNQUFNTyx1QkFBdUJEO0lBQzNCRSxZQUFhQyxJQUFJLEVBQUVDLFFBQVEsQ0FBRTtRQUMzQixJQUFJLENBQUNELFFBQVEsT0FBT0EsU0FBUyxVQUFVO1lBQ3JDLE1BQU0sSUFBSVAscUJBQXFCO1FBQ2pDO1FBRUEsTUFBTSxFQUFFUyxNQUFNLEVBQUVDLE1BQU0sRUFBRUMsTUFBTSxFQUFFQyxJQUFJLEVBQUVDLE1BQU0sRUFBRUMsZUFBZSxFQUFFQyxZQUFZLEVBQUVDLGFBQUFBLEVBQWUsR0FBR1Q7UUFFL0YsSUFBSTtZQUNGLElBQUksT0FBT0MsYUFBYSxZQUFZO2dCQUNsQyxNQUFNLElBQUlSLHFCQUFxQjtZQUNqQztZQUVBLElBQUlnQixpQkFBa0IsUUFBT0Esa0JBQWtCLFlBQVlBLGdCQUFnQixJQUFJO2dCQUM3RSxNQUFNLElBQUloQixxQkFBcUI7WUFDakM7WUFFQSxJQUFJUyxVQUFVLE9BQU9BLE9BQU9RLEVBQUUsS0FBSyxjQUFjLE9BQU9SLE9BQU9TLGdCQUFnQixLQUFLLFlBQVk7Z0JBQzlGLE1BQU0sSUFBSWxCLHFCQUFxQjtZQUNqQztZQUVBLElBQUlVLFdBQVcsV0FBVztnQkFDeEIsTUFBTSxJQUFJVixxQkFBcUI7WUFDakM7WUFFQSxJQUFJYSxV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SUFBSSxDQUFDQyxRQUFRLENBQUNwRCxNQUFNLElBQUlGLGVBQWVFLE1BQU1DO0lBQy9DLEVBQUUsT0FBT1csS0FBSztRQUNaLElBQUksT0FBT1gsYUFBYSxZQUFZO1lBQ2xDLE1BQU1XO1FBQ1I7UUFDQSxNQUFNUixTQUFTSixNQUFNSTtRQUNyQndDLGVBQWUsSUFBTTNDLFNBQVNXLEtBQUs7Z0JBQUVSO1lBQU87SUFDOUM7QUFDRjtBQUVBaUQsT0FBT0MsT0FBTyxHQUFHVDtBQUNqQlEsNkJBQTZCLEdBQUd2RCIsInNvdXJjZXMiOlsid2VicGFjazovL21vY2t1cGZsb3cvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9hcGkvYXBpLXJlcXVlc3QuanM/OTViNCIsIndlYnBhY2s6Ly9tb2NrdXBmbG93Ly4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvYXBpL2FwaS1yZXF1ZXN0LmpzPzk1YjQqIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdub2RlOmFzc2VydCcpXG5jb25zdCB7IFJlYWRhYmxlIH0gPSByZXF1aXJlKCcuL3JlYWRhYmxlJylcbmNvbnN0IHsgSW52YWxpZEFyZ3VtZW50RXJyb3IsIFJlcXVlc3RBYm9ydGVkRXJyb3IgfSA9IHJlcXVpcmUoJy4uL2NvcmUvZXJyb3JzJylcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCcuLi9jb3JlL3V0aWwnKVxuY29uc3QgeyBnZXRSZXNvbHZlRXJyb3JCb2R5Q2FsbGJhY2sgfSA9IHJlcXVpcmUoJy4vdXRpbCcpXG5jb25zdCB7IEFzeW5jUmVzb3VyY2UgfSA9IHJlcXVpcmUoJ25vZGU6YXN5bmNfaG9va3MnKVxuXG5jbGFzcyBSZXF1ZXN0SGFuZGxlciBleHRlbmRzIEFzeW5jUmVzb3VyY2Uge1xuICBjb25zdHJ1Y3RvciAob3B0cywgY2FsbGJhY2spIHtcbiAgICBpZiAoIW9wdHMgfHwgdHlwZW9mIG9wdHMgIT09ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgb3B0cycpXG4gICAgfVxuXG4gICAgY29uc3QgeyBzaWduYWwsIG1ldGhvZCwgb3BhcXVlLCBib2R5LCBvbkluZm8sIHJlc3BvbnNlSGVhZGVycywgdGhyb3dPbkVycm9yLCBoaWdoV2F0ZXJNYXJrIH0gPSBvcHRzXG5cbiAgICB0cnkge1xuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgY2FsbGJhY2snKVxuICAgICAgfVxuXG4gICAgICBpZiAoaGlnaFdhdGVyTWFyayAmJiAodHlwZW9mIGhpZ2hXYXRlck1hcmsgIT09ICdudW1iZXInIHx8IGhpZ2hXYXRlck1hcmsgPCAwKSkge1xuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgaGlnaFdhdGVyTWFyaycpXG4gICAgICB9XG5cbiAgICAgIGlmIChzaWduYWwgJiYgdHlwZW9mIHNpZ25hbC5vbiAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdzaWduYWwgbXVzdCBiZSBhbiBFdmVudEVtaXR0ZXIgb3IgRXZlbnRUYXJnZXQnKVxuICAgICAgfVxuXG4gICAgICBpZiAobWV0aG9kID09PSAnQ09OTkVDVCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIG1ldGhvZCcpXG4gICAgICB9XG5cbiAgICAgIGlmIChvbkluZm8gJiYgdHlwZW9mIG9uSW5mbyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgb25JbmZvIGNhbGxiYWNrJylcbiAgICAgIH1cblxuICAgICAgc3VwZXIoJ1VORElDSV9SRVFVRVNUJylcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmICh1dGlsLmlzU3RyZWFtKGJvZHkpKSB7XG4gICAgICAgIHV0aWwuZGVzdHJveShib2R5Lm9uKCdlcnJvcicsIHV0aWwubm9wKSwgZXJyKVxuICAgICAgfVxuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuXG4gICAgdGhpcy5tZXRob2QgPSBtZXRob2RcbiAgICB0aGlzLnJlc3BvbnNlSGVhZGVycyA9IHJlc3BvbnNlSGVhZGVycyB8fCBudWxsXG4gICAgdGhpcy5vcGFxdWUgPSBvcGFxdWUgfHwgbnVsbFxuICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFja1xuICAgIHRoaXMucmVzID0gbnVsbFxuICAgIHRoaXMuYWJvcnQgPSBudWxsXG4gICAgdGhpcy5ib2R5ID0gYm9keVxuICAgIHRoaXMudHJhaWxlcnMgPSB7fVxuICAgIHRoaXMuY29udGV4dCA9IG51bGxcbiAgICB0aGlzLm9uSW5mbyA9IG9uSW5mbyB8fCBudWxsXG4gICAgdGhpcy50aHJvd09uRXJyb3IgPSB0aHJvd09uRXJyb3JcbiAgICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBoaWdoV2F0ZXJNYXJrXG4gICAgdGhpcy5zaWduYWwgPSBzaWduYWxcbiAgICB0aGlzLnJlYXNvbiA9IG51bGxcbiAgICB0aGlzLnJlbW92ZUFib3J0TGlzdGVuZXIgPSBudWxsXG5cbiAgICBpZiAodXRpbC5pc1N0cmVhbShib2R5KSkge1xuICAgICAgYm9keS5vbignZXJyb3InLCAoZXJyKSA9PiB7XG4gICAgICAgIHRoaXMub25FcnJvcihlcnIpXG4gICAgICB9KVxuICAgIH1cblxuICAgIGlmICh0aGlzLnNpZ25hbCkge1xuICAgICAgaWYgKHRoaXMuc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgdGhpcy5yZWFzb24gPSB0aGlzLnNpZ25hbC5yZWFzb24gPz8gbmV3IFJlcXVlc3RBYm9ydGVkRXJyb3IoKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5yZW1vdmVBYm9ydExpc3RlbmVyID0gdXRpbC5hZGRBYm9ydExpc3RlbmVyKHRoaXMuc2lnbmFsLCAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5yZWFzb24gPSB0aGlzLnNpZ25hbC5yZWFzb24gPz8gbmV3IFJlcXVlc3RBYm9ydGVkRXJyb3IoKVxuICAgICAgICAgIGlmICh0aGlzLnJlcykge1xuICAgICAgICAgICAgdXRpbC5kZXN0cm95KHRoaXMucmVzLCB0aGlzLnJlYXNvbilcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuYWJvcnQpIHtcbiAgICAgICAgICAgIHRoaXMuYWJvcnQodGhpcy5yZWFzb24pXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHRoaXMucmVtb3ZlQWJvcnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgdGhpcy5yZXM/Lm9mZignY2xvc2UnLCB0aGlzLnJlbW92ZUFib3J0TGlzdGVuZXIpXG4gICAgICAgICAgICB0aGlzLnJlbW92ZUFib3J0TGlzdGVuZXIoKVxuICAgICAgICAgICAgdGhpcy5yZW1vdmVBYm9ydExpc3RlbmVyID0gbnVsbFxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBvbkNvbm5lY3QgKGFib3J0LCBjb250ZXh0KSB7XG4gICAgaWYgKHRoaXMucmVhc29uKSB7XG4gICAgICBhYm9ydCh0aGlzLnJlYXNvbilcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGFzc2VydCh0aGlzLmNhbGxiYWNrKVxuXG4gICAgdGhpcy5hYm9ydCA9IGFib3J0XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dFxuICB9XG5cbiAgb25IZWFkZXJzIChzdGF0dXNDb2RlLCByYXdIZWFkZXJzLCByZXN1bWUsIHN0YXR1c01lc3NhZ2UpIHtcbiAgICBjb25zdCB7IGNhbGxiYWNrLCBvcGFxdWUsIGFib3J0LCBjb250ZXh0LCByZXNwb25zZUhlYWRlcnMsIGhpZ2hXYXRlck1hcmsgfSA9IHRoaXNcblxuICAgIGNvbnN0IGhlYWRlcnMgPSByZXNwb25zZUhlYWRlcnMgPT09ICdyYXcnID8gdXRpbC5wYXJzZVJhd0hlYWRlcnMocmF3SGVhZGVycykgOiB1dGlsLnBhcnNlSGVhZGVycyhyYXdIZWFkZXJzKVxuXG4gICAgaWYgKHN0YXR1c0NvZGUgPCAyMDApIHtcbiAgICAgIGlmICh0aGlzLm9uSW5mbykge1xuICAgICAgICB0aGlzLm9uSW5mbyh7IHN0YXR1c0NvZGUsIGhlYWRlcnMgfSlcbiAgICAgIH1cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IHBhcnNlZEhlYWRlcnMgPSByZXNwb25zZUhlYWRlcnMgPT09ICdyYXcnID8gdXRpbC5wYXJzZUhlYWRlcnMocmF3SGVhZGVycykgOiBoZWFkZXJzXG4gICAgY29uc3QgY29udGVudFR5cGUgPSBwYXJzZWRIZWFkZXJzWydjb250ZW50LXR5cGUnXVxuICAgIGNvbnN0IGNvbnRlbnRMZW5ndGggPSBwYXJzZWRIZWFkZXJzWydjb250ZW50LWxlbmd0aCddXG4gICAgY29uc3QgcmVzID0gbmV3IFJlYWRhYmxlKHtcbiAgICAgIHJlc3VtZSxcbiAgICAgIGFib3J0LFxuICAgICAgY29udGVudFR5cGUsXG4gICAgICBjb250ZW50TGVuZ3RoOiB0aGlzLm1ldGhvZCAhPT0gJ0hFQUQnICYmIGNvbnRlbnRMZW5ndGhcbiAgICAgICAgPyBOdW1iZXIoY29udGVudExlbmd0aClcbiAgICAgICAgOiBudWxsLFxuICAgICAgaGlnaFdhdGVyTWFya1xuICAgIH0pXG5cbiAgICBpZiAodGhpcy5yZW1vdmVBYm9ydExpc3RlbmVyKSB7XG4gICAgICByZXMub24oJ2Nsb3NlJywgdGhpcy5yZW1vdmVBYm9ydExpc3RlbmVyKVxuICAgIH1cblxuICAgIHRoaXMuY2FsbGJhY2sgPSBudWxsXG4gICAgdGhpcy5yZXMgPSByZXNcbiAgICBpZiAoY2FsbGJhY2sgIT09IG51bGwpIHtcbiAgICAgIGlmICh0aGlzLnRocm93T25FcnJvciAmJiBzdGF0dXNDb2RlID49IDQwMCkge1xuICAgICAgICB0aGlzLnJ1bkluQXN5bmNTY29wZShnZXRSZXNvbHZlRXJyb3JCb2R5Q2FsbGJhY2ssIG51bGwsXG4gICAgICAgICAgeyBjYWxsYmFjaywgYm9keTogcmVzLCBjb250ZW50VHlwZSwgc3RhdHVzQ29kZSwgc3RhdHVzTWVzc2FnZSwgaGVhZGVycyB9XG4gICAgICAgIClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucnVuSW5Bc3luY1Njb3BlKGNhbGxiYWNrLCBudWxsLCBudWxsLCB7XG4gICAgICAgICAgc3RhdHVzQ29kZSxcbiAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgIHRyYWlsZXJzOiB0aGlzLnRyYWlsZXJzLFxuICAgICAgICAgIG9wYXF1ZSxcbiAgICAgICAgICBib2R5OiByZXMsXG4gICAgICAgICAgY29udGV4dFxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIG9uRGF0YSAoY2h1bmspIHtcbiAgICByZXR1cm4gdGhpcy5yZXMucHVzaChjaHVuaylcbiAgfVxuXG4gIG9uQ29tcGxldGUgKHRyYWlsZXJzKSB7XG4gICAgdXRpbC5wYXJzZUhlYWRlcnModHJhaWxlcnMsIHRoaXMudHJhaWxlcnMpXG4gICAgdGhpcy5yZXMucHVzaChudWxsKVxuICB9XG5cbiAgb25FcnJvciAoZXJyKSB7XG4gICAgY29uc3QgeyByZXMsIGNhbGxiYWNrLCBib2R5LCBvcGFxdWUgfSA9IHRoaXNcblxuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgLy8gVE9ETzogRG9lcyB0aGlzIG5lZWQgcXVldWVNaWNyb3Rhc2s/XG4gICAgICB0aGlzLmNhbGxiYWNrID0gbnVsbFxuICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgICB0aGlzLnJ1bkluQXN5bmNTY29wZShjYWxsYmFjaywgbnVsbCwgZXJyLCB7IG9wYXF1ZSB9KVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBpZiAocmVzKSB7XG4gICAgICB0aGlzLnJlcyA9IG51bGxcbiAgICAgIC8vIEVuc3VyZSBhbGwgcXVldWVkIGhhbmRsZXJzIGFyZSBpbnZva2VkIGJlZm9yZSBkZXN0cm95aW5nIHJlcy5cbiAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgICAgdXRpbC5kZXN0cm95KHJlcywgZXJyKVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBpZiAoYm9keSkge1xuICAgICAgdGhpcy5ib2R5ID0gbnVsbFxuICAgICAgdXRpbC5kZXN0cm95KGJvZHksIGVycilcbiAgICB9XG5cbiAgICBpZiAodGhpcy5yZW1vdmVBYm9ydExpc3RlbmVyKSB7XG4gICAgICByZXM/Lm9mZignY2xvc2UnLCB0aGlzLnJlbW92ZUFib3J0TGlzdGVuZXIpXG4gICAgICB0aGlzLnJlbW92ZUFib3J0TGlzdGVuZXIoKVxuICAgICAgdGhpcy5yZW1vdmVBYm9ydExpc3RlbmVyID0gbnVsbFxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZXF1ZXN0IChvcHRzLCBjYWxsYmFjaykge1xuICBpZiAoY2FsbGJhY2sgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICByZXF1ZXN0LmNhbGwodGhpcywgb3B0cywgKGVyciwgZGF0YSkgPT4ge1xuICAgICAgICByZXR1cm4gZXJyID8gcmVqZWN0KGVycikgOiByZXNvbHZlKGRhdGEpXG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICB0cnkge1xuICAgIHRoaXMuZGlzcGF0Y2gob3B0cywgbmV3IFJlcXVlc3RIYW5kbGVyKG9wdHMsIGNhbGxiYWNrKSlcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuICAgIGNvbnN0IG9wYXF1ZSA9IG9wdHM/Lm9wYXF1ZVxuICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IGNhbGxiYWNrKGVyciwgeyBvcGFxdWUgfSkpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSByZXF1ZXN0XG5tb2R1bGUuZXhwb3J0cy5SZXF1ZXN0SGFuZGxlciA9IFJlcXVlc3RIYW5kbGVyXG4iXSwibmFtZXMiOlsiYXNzZXJ0IiwicmVxdWlyZSIsIlJlYWRhYmxlIiwiSW52YWxpZEFyZ3VtZW50RXJyb3IiLCJSZXF1ZXN0QWJvcnRlZEVycm9yIiwidXRpbCIsImdldFJlc29sdmVFcnJvckJvZHlDYWxsYmFjayIsIkFzeW5jUmVzb3VyY2UiLCJSZXF1ZXN0SGFuZGxlciIsImNvbnN0cnVjdG9yIiwib3B0cyIsImNhbGxiYWNrIiwic2lnbmFsIiwibWV0aG9kIiwib3BhcXVlIiwiYm9keSIsIm9uSW5mbyIsInJlc3BvbnNlSGVhZGVycyIsInRocm93T25FcnJvciIsImhpZ2hXYXRlck1hcmsiLCJvbiIsImFkZEV2ZW50TGlzdGVuZXIiLCJlcnIiLCJpc1N0cmVhbSIsImRlc3Ryb3kiLCJub3AiLCJyZXMiLCJhYm9ydCIsInRyYWlsZXJzIiwiY29udGV4dCIsInJlYXNvbiIsInJlbW92ZUFib3J0TGlzdGVuZXIiLCJvbkVycm9yIiwiYWJvcnRlZCIsImFkZEFib3J0TGlzdGVuZXIiLCJvZmYiLCJvbkNvbm5lY3QiLCJvbkhlYWRlcnMiLCJzdGF0dXNDb2RlIiwicmF3SGVhZGVycyIsInJlc3VtZSIsInN0YXR1c01lc3NhZ2UiLCJoZWFkZXJzIiwicGFyc2VSYXdIZWFkZXJzIiwicGFyc2VIZWFkZXJzIiwicGFyc2VkSGVhZGVycyIsImNvbnRlbnRUeXBlIiwiY29udGVudExlbmd0aCIsIk51bWJlciIsInJ1bkluQXN5bmNTY29wZSIsIm9uRGF0YSIsImNodW5rIiwicHVzaCIsIm9uQ29tcGxldGUiLCJxdWV1ZU1pY3JvdGFzayIsInJlcXVlc3QiLCJ1bmRlZmluZWQiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsImNhbGwiLCJkYXRhIiwiZGlzcGF0Y2giLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/api/api-request.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/api/api-stream.js":
/*!***************************************************!*\
  !*** ./node_modules/undici/lib/api/api-stream.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\");\nconst { finished, PassThrough } = __webpack_require__(/*! node:stream */ \"node:stream\");\nconst { InvalidArgumentError, InvalidReturnValueError } = __webpack_require__(/*! ../core/errors */ \"(ssr)/./node_modules/undici/lib/core/errors.js\");\nconst util = __webpack_require__(/*! ../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\");\nconst { getResolveErrorBodyCallback } = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/undici/lib/api/util.js\");\nconst { AsyncResource } = __webpack_require__(/*! node:async_hooks */ \"node:async_hooks\");\nconst { addSignal, removeSignal } = __webpack_require__(/*! ./abort-signal */ \"(ssr)/./node_modules/undici/lib/api/abort-signal.js\");\nclass StreamHandler extends AsyncResource {\n    constructor(opts, factory, callback){\n        if (!opts || typeof opts !== \"object\") {\n            throw new InvalidArgumentError(\"invalid opts\");\n        }\n        const { signal, method, opaque, body, onInfo, responseHeaders, throwOnError } = opts;\n        try {\n            if (typeof callback !== \"function\") {\n                throw new InvalidArgumentError(\"invalid callback\");\n            }\n            if (typeof factory !== \"function\") {\n                throw new InvalidArgumentError(\"invalid factory\");\n            }\n            if (signal && typeof signal.on !== \"function\" && typeof signal.addEventListener !== \"function\") {\n                throw new InvalidArgumentError(\"signal must be an EventEmitter or EventTarget\");\n            }\n            if (method === \"CONNECT\") {\n                throw new InvalidArgumentError(\"invalid method\");\n            }\n            if (onInfo && typeof onInfo !== \"function\") {\n                throw new InvalidArgumentError(\"invalid onInfo callback\");\n            }\n            super(\"UNDICI_STREAM\");\n        } catch (err) {\n            if (util.isStream(body)) {\n                util.destroy(body.on(\"error\", util.nop), err);\n            }\n            throw err;\n        }\n        this.responseHeaders = responseHeaders || null;\n        this.opaque = opaque || null;\n        this.factory = factory;\n        this.callback = callback;\n        this.res = null;\n        this.abort = null;\n        this.context = null;\n        this.trailers = null;\n        this.body = body;\n        this.onInfo = onInfo || null;\n        this.throwOnError = throwOnError || false;\n        if (util.isStream(body)) {\n            body.on(\"error\", (err)=>{\n                this.onError(err);\n            });\n        }\n        addSignal(this, signal);\n    }\n    onConnect(abort, context) {\n        if (this.reason) {\n            abort(this.reason);\n            return;\n        }\n        assert(this.callback);\n        this.abort = abort;\n        this.context = context;\n    }\n    onHeaders(statusCode, rawHeaders, resume, statusMessage) {\n        const { factory, opaque, context, callback, responseHeaders } = this;\n        const headers = responseHeaders === \"raw\" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);\n        if (statusCode < 200) {\n            if (this.onInfo) {\n                this.onInfo({\n                    statusCode,\n                    headers\n                });\n            }\n            return;\n        }\n        this.factory = null;\n        let res;\n        if (this.throwOnError && statusCode >= 400) {\n            const parsedHeaders = responseHeaders === \"raw\" ? util.parseHeaders(rawHeaders) : headers;\n            const contentType = parsedHeaders[\"content-type\"];\n            res = new PassThrough();\n            this.callback = null;\n            this.runInAsyncScope(getResolveErrorBodyCallback, null, {\n                callback,\n                body: res,\n                contentType,\n                statusCode,\n                statusMessage,\n                headers\n            });\n        } else {\n            if (factory === null) {\n                return;\n            }\n            res = this.runInAsyncScope(factory, null, {\n                statusCode,\n                headers,\n                opaque,\n                context\n            });\n            if (!res || typeof res.write !== \"function\" || typeof res.end !== \"function\" || typeof res.on !== \"function\") {\n                throw new InvalidReturnValueError(\"expected Writable\");\n            }\n            // TODO: Avoid finished. It registers an unnecessary amount of listeners.\n            finished(res, {\n                readable: false\n            }, (err)=>{\n                const { callback, res, opaque, trailers, abort } = this;\n                this.res = null;\n                if (err || !res.readable) {\n                    util.destroy(res, err);\n                }\n                this.callback = null;\n                this.runInAsyncScope(callback, null, err || null, {\n                    opaque,\n                    trailers\n                });\n                if (err) {\n                    abort();\n                }\n            });\n        }\n        res.on(\"drain\", resume);\n        this.res = res;\n        const needDrain = res.writableNeedDrain !== undefined ? res.writableNeedDrain : res._writableState?.needDrain;\n        return needDrain !== true;\n    }\n    onData(chunk) {\n        const { res } = this;\n        return res ? res.write(chunk) : true;\n    }\n    onComplete(trailers) {\n        const { res } = this;\n        removeSignal(this);\n        if (!res) {\n            return;\n        }\n        this.trailers = util.parseHeaders(trailers);\n        res.end();\n    }\n    onError(err) {\n        const { res, callback, opaque, body } = this;\n        removeSignal(this);\n        this.factory = null;\n        if (res) {\n            this.res = null;\n            util.destroy(res, err);\n        } else if (callback) {\n            this.callback = null;\n            queueMicrotask(()=>{\n                this.runInAsyncScope(callback, null, err, {\n                    opaque\n                });\n            });\n        }\n        if (body) {\n            this.body = null;\n            util.destroy(body, err);\n        }\n    }\n}\nfunction stream(opts, factory, callback) {\n    if (callback === undefined) {\n        return new Promise((resolve, reject)=>{\n            stream.call(this, opts, factory, (err, data)=>{\n                return err ? reject(err) : resolve(data);\n            });\n        });\n    }\n    try {\n        this.dispatch(opts, new StreamHandler(opts, factory, callback));\n    } catch (err) {\n        if (typeof callback !== \"function\") {\n            throw err;\n        }\n        const opaque = opts?.opaque;\n        queueMicrotask(()=>callback(err, {\n                opaque\n            }));\n    }\n}\nmodule.exports = stream;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9hcGkvYXBpLXN0cmVhbS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU1BLFNBQVNDLG1CQUFPQSxDQUFDO0FBQ3ZCLE1BQU0sRUFBRUMsUUFBUSxFQUFFQyxXQUFBQSxFQUFhLEdBQUdGLG1CQUFPQSxDQUFDO0FBQzFDLE1BQU0sRUFBRUcsb0JBQW9CLEVBQUVDLHVCQUFBQSxFQUF5QixHQUFHSixtQkFBT0EsQ0FBQztBQUNsRSxNQUFNSyxPQUFPTCxtQkFBT0EsQ0FBQztBQUNyQixNQUFNLEVBQUVNLDJCQUFBQSxFQUE2QixHQUFHTixtQkFBT0EsQ0FBQztBQUNoRCxNQUFNLEVBQUVPLGFBQUFBLEVBQWUsR0FBR1AsbUJBQU9BLENBQUM7QUFDbEMsTUFBTSxFQUFFUSxTQUFTLEVBQUVDLFlBQUFBLEVBQWMsR0FBR1QsbUJBQU9BLENBQUM7QUFFNUMsTUFBTVUsc0JBQXNCSDtJQUMxQkksWUFBYUMsSUFBSSxFQUFFQyxPQUFPLEVBQUVDLFFBQVEsQ0FBRTtRQUNwQyxJQUFJLENBQUNGLFFBQVEsT0FBT0EsU0FBUyxVQUFVO1lBQ3JDLE1BQU0sSUFBSVQscUJBQXFCO1FBQ2pDO1FBRUEsTUFBTSxFQUFFWSxNQUFNLEVBQUVDLE1BQU0sRUFBRUMsTUFBTSxFQUFFQyxJQUFJLEVBQUVDLE1BQU0sRUFBRUMsZUFBZSxFQUFFQyxZQUFBQSxFQUFjLEdBQUdUO1FBRWhGLElBQUk7WUFDRixJQUFJLE9BQU9FLGFBQWEsWUFBWTtnQkFDbEMsTUFBTSxJQUFJWCxxQkFBcUI7WUFDakM7WUFFQSxJQUFJLE9BQU9VLFlBQVksWUFBWTtnQkFDakMsTUFBTSxJQUFJVixxQkFBcUI7WUFDakM7WUFFQSxJQUFJWSxVQUFVLE9BQU9BLE9BQU9PLEVBQUUsS0FBSyxjQUFjLE9BQU9QLE9BQU9RLGdCQUFnQixLQUFLLFlBQVk7Z0JBQzlGLE1BQU0sSUFBSXBCLHFCQUFxQjtZQUNqQztZQUVBLElBQUlhLFdBQVcsV0FBVztn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aS9saWIvYXBpL2FwaS1zdHJlYW0uanM/M2FjOCIsIndlYnBhY2s6Ly9tb2NrdXBmbG93Ly4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvYXBpL2FwaS1zdHJlYW0uanM/M2FjOCoiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ25vZGU6YXNzZXJ0JylcbmNvbnN0IHsgZmluaXNoZWQsIFBhc3NUaHJvdWdoIH0gPSByZXF1aXJlKCdub2RlOnN0cmVhbScpXG5jb25zdCB7IEludmFsaWRBcmd1bWVudEVycm9yLCBJbnZhbGlkUmV0dXJuVmFsdWVFcnJvciB9ID0gcmVxdWlyZSgnLi4vY29yZS9lcnJvcnMnKVxuY29uc3QgdXRpbCA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpXG5jb25zdCB7IGdldFJlc29sdmVFcnJvckJvZHlDYWxsYmFjayB9ID0gcmVxdWlyZSgnLi91dGlsJylcbmNvbnN0IHsgQXN5bmNSZXNvdXJjZSB9ID0gcmVxdWlyZSgnbm9kZTphc3luY19ob29rcycpXG5jb25zdCB7IGFkZFNpZ25hbCwgcmVtb3ZlU2lnbmFsIH0gPSByZXF1aXJlKCcuL2Fib3J0LXNpZ25hbCcpXG5cbmNsYXNzIFN0cmVhbUhhbmRsZXIgZXh0ZW5kcyBBc3luY1Jlc291cmNlIHtcbiAgY29uc3RydWN0b3IgKG9wdHMsIGZhY3RvcnksIGNhbGxiYWNrKSB7XG4gICAgaWYgKCFvcHRzIHx8IHR5cGVvZiBvcHRzICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIG9wdHMnKVxuICAgIH1cblxuICAgIGNvbnN0IHsgc2lnbmFsLCBtZXRob2QsIG9wYXF1ZSwgYm9keSwgb25JbmZvLCByZXNwb25zZUhlYWRlcnMsIHRocm93T25FcnJvciB9ID0gb3B0c1xuXG4gICAgdHJ5IHtcbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIGNhbGxiYWNrJylcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBmYWN0b3J5ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBmYWN0b3J5JylcbiAgICAgIH1cblxuICAgICAgaWYgKHNpZ25hbCAmJiB0eXBlb2Ygc2lnbmFsLm9uICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ3NpZ25hbCBtdXN0IGJlIGFuIEV2ZW50RW1pdHRlciBvciBFdmVudFRhcmdldCcpXG4gICAgICB9XG5cbiAgICAgIGlmIChtZXRob2QgPT09ICdDT05ORUNUJykge1xuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgbWV0aG9kJylcbiAgICAgIH1cblxuICAgICAgaWYgKG9uSW5mbyAmJiB0eXBlb2Ygb25JbmZvICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBvbkluZm8gY2FsbGJhY2snKVxuICAgICAgfVxuXG4gICAgICBzdXBlcignVU5ESUNJX1NUUkVBTScpXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAodXRpbC5pc1N0cmVhbShib2R5KSkge1xuICAgICAgICB1dGlsLmRlc3Ryb3koYm9keS5vbignZXJyb3InLCB1dGlsLm5vcCksIGVycilcbiAgICAgIH1cbiAgICAgIHRocm93IGVyclxuICAgIH1cblxuICAgIHRoaXMucmVzcG9uc2VIZWFkZXJzID0gcmVzcG9uc2VIZWFkZXJzIHx8IG51bGxcbiAgICB0aGlzLm9wYXF1ZSA9IG9wYXF1ZSB8fCBudWxsXG4gICAgdGhpcy5mYWN0b3J5ID0gZmFjdG9yeVxuICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFja1xuICAgIHRoaXMucmVzID0gbnVsbFxuICAgIHRoaXMuYWJvcnQgPSBudWxsXG4gICAgdGhpcy5jb250ZXh0ID0gbnVsbFxuICAgIHRoaXMudHJhaWxlcnMgPSBudWxsXG4gICAgdGhpcy5ib2R5ID0gYm9keVxuICAgIHRoaXMub25JbmZvID0gb25JbmZvIHx8IG51bGxcbiAgICB0aGlzLnRocm93T25FcnJvciA9IHRocm93T25FcnJvciB8fCBmYWxzZVxuXG4gICAgaWYgKHV0aWwuaXNTdHJlYW0oYm9keSkpIHtcbiAgICAgIGJvZHkub24oJ2Vycm9yJywgKGVycikgPT4ge1xuICAgICAgICB0aGlzLm9uRXJyb3IoZXJyKVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBhZGRTaWduYWwodGhpcywgc2lnbmFsKVxuICB9XG5cbiAgb25Db25uZWN0IChhYm9ydCwgY29udGV4dCkge1xuICAgIGlmICh0aGlzLnJlYXNvbikge1xuICAgICAgYWJvcnQodGhpcy5yZWFzb24pXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBhc3NlcnQodGhpcy5jYWxsYmFjaylcblxuICAgIHRoaXMuYWJvcnQgPSBhYm9ydFxuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHRcbiAgfVxuXG4gIG9uSGVhZGVycyAoc3RhdHVzQ29kZSwgcmF3SGVhZGVycywgcmVzdW1lLCBzdGF0dXNNZXNzYWdlKSB7XG4gICAgY29uc3QgeyBmYWN0b3J5LCBvcGFxdWUsIGNvbnRleHQsIGNhbGxiYWNrLCByZXNwb25zZUhlYWRlcnMgfSA9IHRoaXNcblxuICAgIGNvbnN0IGhlYWRlcnMgPSByZXNwb25zZUhlYWRlcnMgPT09ICdyYXcnID8gdXRpbC5wYXJzZVJhd0hlYWRlcnMocmF3SGVhZGVycykgOiB1dGlsLnBhcnNlSGVhZGVycyhyYXdIZWFkZXJzKVxuXG4gICAgaWYgKHN0YXR1c0NvZGUgPCAyMDApIHtcbiAgICAgIGlmICh0aGlzLm9uSW5mbykge1xuICAgICAgICB0aGlzLm9uSW5mbyh7IHN0YXR1c0NvZGUsIGhlYWRlcnMgfSlcbiAgICAgIH1cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuZmFjdG9yeSA9IG51bGxcblxuICAgIGxldCByZXNcblxuICAgIGlmICh0aGlzLnRocm93T25FcnJvciAmJiBzdGF0dXNDb2RlID49IDQwMCkge1xuICAgICAgY29uc3QgcGFyc2VkSGVhZGVycyA9IHJlc3BvbnNlSGVhZGVycyA9PT0gJ3JhdycgPyB1dGlsLnBhcnNlSGVhZGVycyhyYXdIZWFkZXJzKSA6IGhlYWRlcnNcbiAgICAgIGNvbnN0IGNvbnRlbnRUeXBlID0gcGFyc2VkSGVhZGVyc1snY29udGVudC10eXBlJ11cbiAgICAgIHJlcyA9IG5ldyBQYXNzVGhyb3VnaCgpXG5cbiAgICAgIHRoaXMuY2FsbGJhY2sgPSBudWxsXG4gICAgICB0aGlzLnJ1bkluQXN5bmNTY29wZShnZXRSZXNvbHZlRXJyb3JCb2R5Q2FsbGJhY2ssIG51bGwsXG4gICAgICAgIHsgY2FsbGJhY2ssIGJvZHk6IHJlcywgY29udGVudFR5cGUsIHN0YXR1c0NvZGUsIHN0YXR1c01lc3NhZ2UsIGhlYWRlcnMgfVxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZmFjdG9yeSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgcmVzID0gdGhpcy5ydW5JbkFzeW5jU2NvcGUoZmFjdG9yeSwgbnVsbCwge1xuICAgICAgICBzdGF0dXNDb2RlLFxuICAgICAgICBoZWFkZXJzLFxuICAgICAgICBvcGFxdWUsXG4gICAgICAgIGNvbnRleHRcbiAgICAgIH0pXG5cbiAgICAgIGlmIChcbiAgICAgICAgIXJlcyB8fFxuICAgICAgICB0eXBlb2YgcmVzLndyaXRlICE9PSAnZnVuY3Rpb24nIHx8XG4gICAgICAgIHR5cGVvZiByZXMuZW5kICE9PSAnZnVuY3Rpb24nIHx8XG4gICAgICAgIHR5cGVvZiByZXMub24gIT09ICdmdW5jdGlvbidcbiAgICAgICkge1xuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFJldHVyblZhbHVlRXJyb3IoJ2V4cGVjdGVkIFdyaXRhYmxlJylcbiAgICAgIH1cblxuICAgICAgLy8gVE9ETzogQXZvaWQgZmluaXNoZWQuIEl0IHJlZ2lzdGVycyBhbiB1bm5lY2Vzc2FyeSBhbW91bnQgb2YgbGlzdGVuZXJzLlxuICAgICAgZmluaXNoZWQocmVzLCB7IHJlYWRhYmxlOiBmYWxzZSB9LCAoZXJyKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgY2FsbGJhY2ssIHJlcywgb3BhcXVlLCB0cmFpbGVycywgYWJvcnQgfSA9IHRoaXNcblxuICAgICAgICB0aGlzLnJlcyA9IG51bGxcbiAgICAgICAgaWYgKGVyciB8fCAhcmVzLnJlYWRhYmxlKSB7XG4gICAgICAgICAgdXRpbC5kZXN0cm95KHJlcywgZXJyKVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jYWxsYmFjayA9IG51bGxcbiAgICAgICAgdGhpcy5ydW5JbkFzeW5jU2NvcGUoY2FsbGJhY2ssIG51bGwsIGVyciB8fCBudWxsLCB7IG9wYXF1ZSwgdHJhaWxlcnMgfSlcblxuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgYWJvcnQoKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cblxuICAgIHJlcy5vbignZHJhaW4nLCByZXN1bWUpXG5cbiAgICB0aGlzLnJlcyA9IHJlc1xuXG4gICAgY29uc3QgbmVlZERyYWluID0gcmVzLndyaXRhYmxlTmVlZERyYWluICE9PSB1bmRlZmluZWRcbiAgICAgID8gcmVzLndyaXRhYmxlTmVlZERyYWluXG4gICAgICA6IHJlcy5fd3JpdGFibGVTdGF0ZT8ubmVlZERyYWluXG5cbiAgICByZXR1cm4gbmVlZERyYWluICE9PSB0cnVlXG4gIH1cblxuICBvbkRhdGEgKGNodW5rKSB7XG4gICAgY29uc3QgeyByZXMgfSA9IHRoaXNcblxuICAgIHJldHVybiByZXMgPyByZXMud3JpdGUoY2h1bmspIDogdHJ1ZVxuICB9XG5cbiAgb25Db21wbGV0ZSAodHJhaWxlcnMpIHtcbiAgICBjb25zdCB7IHJlcyB9ID0gdGhpc1xuXG4gICAgcmVtb3ZlU2lnbmFsKHRoaXMpXG5cbiAgICBpZiAoIXJlcykge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpcy50cmFpbGVycyA9IHV0aWwucGFyc2VIZWFkZXJzKHRyYWlsZXJzKVxuXG4gICAgcmVzLmVuZCgpXG4gIH1cblxuICBvbkVycm9yIChlcnIpIHtcbiAgICBjb25zdCB7IHJlcywgY2FsbGJhY2ssIG9wYXF1ZSwgYm9keSB9ID0gdGhpc1xuXG4gICAgcmVtb3ZlU2lnbmFsKHRoaXMpXG5cbiAgICB0aGlzLmZhY3RvcnkgPSBudWxsXG5cbiAgICBpZiAocmVzKSB7XG4gICAgICB0aGlzLnJlcyA9IG51bGxcbiAgICAgIHV0aWwuZGVzdHJveShyZXMsIGVycilcbiAgICB9IGVsc2UgaWYgKGNhbGxiYWNrKSB7XG4gICAgICB0aGlzLmNhbGxiYWNrID0gbnVsbFxuICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgICB0aGlzLnJ1bkluQXN5bmNTY29wZShjYWxsYmFjaywgbnVsbCwgZXJyLCB7IG9wYXF1ZSB9KVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBpZiAoYm9keSkge1xuICAgICAgdGhpcy5ib2R5ID0gbnVsbFxuICAgICAgdXRpbC5kZXN0cm95KGJvZHksIGVycilcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RyZWFtIChvcHRzLCBmYWN0b3J5LCBjYWxsYmFjaykge1xuICBpZiAoY2FsbGJhY2sgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBzdHJlYW0uY2FsbCh0aGlzLCBvcHRzLCBmYWN0b3J5LCAoZXJyLCBkYXRhKSA9PiB7XG4gICAgICAgIHJldHVybiBlcnIgPyByZWplY3QoZXJyKSA6IHJlc29sdmUoZGF0YSlcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIHRyeSB7XG4gICAgdGhpcy5kaXNwYXRjaChvcHRzLCBuZXcgU3RyZWFtSGFuZGxlcihvcHRzLCBmYWN0b3J5LCBjYWxsYmFjaykpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IGVyclxuICAgIH1cbiAgICBjb25zdCBvcGFxdWUgPSBvcHRzPy5vcGFxdWVcbiAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiBjYWxsYmFjayhlcnIsIHsgb3BhcXVlIH0pKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RyZWFtXG4iXSwibmFtZXMiOlsiYXNzZXJ0IiwicmVxdWlyZSIsImZpbmlzaGVkIiwiUGFzc1Rocm91Z2giLCJJbnZhbGlkQXJndW1lbnRFcnJvciIsIkludmFsaWRSZXR1cm5WYWx1ZUVycm9yIiwidXRpbCIsImdldFJlc29sdmVFcnJvckJvZHlDYWxsYmFjayIsIkFzeW5jUmVzb3VyY2UiLCJhZGRTaWduYWwiLCJyZW1vdmVTaWduYWwiLCJTdHJlYW1IYW5kbGVyIiwiY29uc3RydWN0b3IiLCJvcHRzIiwiZmFjdG9yeSIsImNhbGxiYWNrIiwic2lnbmFsIiwibWV0aG9kIiwib3BhcXVlIiwiYm9keSIsIm9uSW5mbyIsInJlc3BvbnNlSGVhZGVycyIsInRocm93T25FcnJvciIsIm9uIiwiYWRkRXZlbnRMaXN0ZW5lciIsImVyciIsImlzU3RyZWFtIiwiZGVzdHJveSIsIm5vcCIsInJlcyIsImFib3J0IiwiY29udGV4dCIsInRyYWlsZXJzIiwib25FcnJvciIsIm9uQ29ubmVjdCIsInJlYXNvbiIsIm9uSGVhZGVycyIsInN0YXR1c0NvZGUiLCJyYXdIZWFkZXJzIiwicmVzdW1lIiwic3RhdHVzTWVzc2FnZSIsImhlYWRlcnMiLCJwYXJzZVJhd0hlYWRlcnMiLCJwYXJzZUhlYWRlcnMiLCJwYXJzZWRIZWFkZXJzIiwiY29udGVudFR5cGUiLCJydW5JbkFzeW5jU2NvcGUiLCJ3cml0ZSIsImVuZCIsInJlYWRhYmxlIiwibmVlZERyYWluIiwid3JpdGFibGVOZWVkRHJhaW4iLCJ1bmRlZmluZWQiLCJfd3JpdGFibGVTdGF0ZSIsIm9uRGF0YSIsImNodW5rIiwib25Db21wbGV0ZSIsInF1ZXVlTWljcm90YXNrIiwic3RyZWFtIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJjYWxsIiwiZGF0YSIsImRpc3BhdGNoIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/api/api-stream.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/api/api-upgrade.js":
/*!****************************************************!*\
  !*** ./node_modules/undici/lib/api/api-upgrade.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { InvalidArgumentError, SocketError } = __webpack_require__(/*! ../core/errors */ \"(ssr)/./node_modules/undici/lib/core/errors.js\");\nconst { AsyncResource } = __webpack_require__(/*! node:async_hooks */ \"node:async_hooks\");\nconst util = __webpack_require__(/*! ../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\");\nconst { addSignal, removeSignal } = __webpack_require__(/*! ./abort-signal */ \"(ssr)/./node_modules/undici/lib/api/abort-signal.js\");\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\");\nclass UpgradeHandler extends AsyncResource {\n    constructor(opts, callback){\n        if (!opts || typeof opts !== \"object\") {\n            throw new InvalidArgumentError(\"invalid opts\");\n        }\n        if (typeof callback !== \"function\") {\n            throw new InvalidArgumentError(\"invalid callback\");\n        }\n        const { signal, opaque, responseHeaders } = opts;\n        if (signal && typeof signal.on !== \"function\" && typeof signal.addEventListener !== \"function\") {\n            throw new InvalidArgumentError(\"signal must be an EventEmitter or EventTarget\");\n        }\n        super(\"UNDICI_UPGRADE\");\n        this.responseHeaders = responseHeaders || null;\n        this.opaque = opaque || null;\n        this.callback = callback;\n        this.abort = null;\n        this.context = null;\n        addSignal(this, signal);\n    }\n    onConnect(abort, context) {\n        if (this.reason) {\n            abort(this.reason);\n            return;\n        }\n        assert(this.callback);\n        this.abort = abort;\n        this.context = null;\n    }\n    onHeaders() {\n        throw new SocketError(\"bad upgrade\", null);\n    }\n    onUpgrade(statusCode, rawHeaders, socket) {\n        const { callback, opaque, context } = this;\n        assert.strictEqual(statusCode, 101);\n        removeSignal(this);\n        this.callback = null;\n        const headers = this.responseHeaders === \"raw\" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);\n        this.runInAsyncScope(callback, null, null, {\n            headers,\n            socket,\n            opaque,\n            context\n        });\n    }\n    onError(err) {\n        const { callback, opaque } = this;\n        removeSignal(this);\n        if (callback) {\n            this.callback = null;\n            queueMicrotask(()=>{\n                this.runInAsyncScope(callback, null, err, {\n                    opaque\n                });\n            });\n        }\n    }\n}\nfunction upgrade(opts, callback) {\n    if (callback === undefined) {\n        return new Promise((resolve, reject)=>{\n            upgrade.call(this, opts, (err, data)=>{\n                return err ? reject(err) : resolve(data);\n            });\n        });\n    }\n    try {\n        const upgradeHandler = new UpgradeHandler(opts, callback);\n        this.dispatch({\n            ...opts,\n            method: opts.method || \"GET\",\n            upgrade: opts.protocol || \"Websocket\"\n        }, upgradeHandler);\n    } catch (err) {\n        if (typeof callback !== \"function\") {\n            throw err;\n        }\n        const opaque = opts?.opaque;\n        queueMicrotask(()=>callback(err, {\n                opaque\n            }));\n    }\n}\nmodule.exports = upgrade;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9hcGkvYXBpLXVwZ3JhZGUuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNLEVBQUVBLG9CQUFvQixFQUFFQyxXQUFBQSxFQUFhLEdBQUdDLG1CQUFPQSxDQUFDO0FBQ3RELE1BQU0sRUFBRUMsYUFBQUEsRUFBZSxHQUFHRCxtQkFBT0EsQ0FBQztBQUNsQyxNQUFNRSxPQUFPRixtQkFBT0EsQ0FBQztBQUNyQixNQUFNLEVBQUVHLFNBQVMsRUFBRUMsWUFBQUEsRUFBYyxHQUFHSixtQkFBT0EsQ0FBQztBQUM1QyxNQUFNSyxTQUFTTCxtQkFBT0EsQ0FBQztBQUV2QixNQUFNTSx1QkFBdUJMO0lBQzNCTSxZQUFhQyxJQUFJLEVBQUVDLFFBQVEsQ0FBRTtRQUMzQixJQUFJLENBQUNELFFBQVEsT0FBT0EsU0FBUyxVQUFVO1lBQ3JDLE1BQU0sSUFBSVYscUJBQXFCO1FBQ2pDO1FBRUEsSUFBSSxPQUFPVyxhQUFhLFlBQVk7WUFDbEMsTUFBTSxJQUFJWCxxQkFBcUI7UUFDakM7UUFFQSxNQUFNLEVBQUVZLE1BQU0sRUFBRUMsTUFBTSxFQUFFQyxlQUFBQSxFQUFpQixHQUFHSjtRQUU1QyxJQUFJRSxVQUFVLE9BQU9BLE9BQU9HLEVBQUUsS0FBSyxjQUFjLE9BQU9ILE9BQU9JLGdCQUFnQixLQUFLLFlBQVk7WUFDOUYsTUFBTSxJQUFJaEIscUJBQXFCO1FBQ2pDO1FBRUEsS0FBSyxDQUFDO1FBRU4sSUFBSSxDQUFDYyxlQUFlLEdBQUdBLG1CQUFtQjtRQUMxQyxJQUFJLENBQUNELE1BQU0sR0FBR0EsVUFBVTtRQUN4QixJQUFJLENBQUNGLFFBQVEsR0FBR0E7UUFDaEIsSUFBSSxDQUFDTSxLQUFLLEdBQUc7UUFDYixJQUFJLENBQUNDLE9BQU8sR0FBRztRQUVmYixVQUFVLElBQUksRUFBRU87SUFDbEI7SUFFQU8sVUFBV0YsS0FBSyxFQUFFQyxPQUFPLEVBQUU7UUFDekIsSUFBSSxJQUFJLENBQUNFLE1BQU0sRUFBRTtZQUNmSCxNQUFNLElBQUksQ0FBQ0csTUFBTTtZQUNqQjtRQUNGO1FBRUFiLE9BQU8sSUFBSSxDQUFDSSxRQUFRO1FBRXBCLElBQUksQ0FBQ00sS0FBSyxHQUFHQTtRQUNiLElBQUksQ0FBQ0MsT0FBTyxHQUFHO0lBQ2pCO0lBRUFHLFlBQWE7UUFDWCxNQUFNLElBQUlwQixZQUFZLGVBQWU7SUFDdkM7SUFFQXFCLFVBQVdDLFVBQVUsRUFBRUMsVUFBVSxFQUFFQyxNQUFNLEVBQUU7UUFDekMsTUFBTSxFQUFFZCxRQUFRLEVBQUVFLE1BQU0sRUFBRUssT0FBQUEsRUFBUyxHQUFHLElBQUk7UUFFMUNYLE9BQU9tQixXQUFXLENBQUNILFlBQVk7UUFFL0JqQixhQUFhLElBQUk7UUFFakIsSUFBSSxDQUFDSyxRQUFRLEdBQUc7UUFDaEIsTUFBTWdCLFVBQVUsSUFBSSxDQUFDYixlQUFlLEtBQUssUUFBUVYsS0FBS3dCLGVBQWUsQ0FBQ0osY0FBY3BCLEtBQUt5QixZQUFZLENBQUNMO1FBQ3RHLElBQUksQ0FBQ00sZUFBZSxDQUFDbkIsVUFBVSxNQUFNLE1BQU07WUFDekNnQjtZQUNBRjtZQUNBWjtZQUNBSztRQUNGO0lBQ0Y7SUFFQWEsUUFBU0MsR0FBRyxFQUFFO1FBQ1osTUFBTSxFQUFFckIsUUFBUSxFQUFFRSxNQUFBQSxFQUFRLEdBQUcsSUFBSTtRQUVqQ1AsYUFBYSxJQUFJO1FBRWpCLElBQUlLLFVBQVU7WUFDWixJQUFJLENBQUNBLFFBQVEsR0FBRztZQUNoQnNCLGVBQWU7Z0JBQ2IsSUFBSSxDQUFDSCxlQUFlLENBQUNuQixVQUFVLE1BQU1xQixLQUFLO29CQUFFbkI7Z0JBQU87WUFDckQ7UUFDRjtJQUNGO0FBQ0Y7QUFFQSxTQUFTcUIsUUFBU3hCLElBQUksRUFBRUMsUUFBUTtJQUM5QixJQUFJQSxhQUFhd0IsV0FBVztRQUMxQixPQUFPLElBQUlDLFFBQVEsQ0FBQ0MsU0FBU0M7WUFDM0JKLFFBQVFLLElBQUksQ0FBQyxJQUFJLEVBQUU3QixNQUFNLENBQUNzQixLQUFLUTtnQkFDN0IsT0FBT1IsTUFBTU0sT0FBT04sT0FBT0ssUUFBUUc7WUFDckM7UUFDRjtJQUNGO0lBRUEsSUFBSTtRQUNGLE1BQU1DLGlCQUFpQixJQUFJakMsZUFBZUUsTUFBTUM7UUFDaEQsSUFBSSxDQUFDK0IsUUFBUSxDQUFDO1lBQ1osR0FBR2hDLElBQUk7WUFDUGlDLFFBQVFqQyxLQUFLaUMsTUFBTSxJQUFJO1lBQ3ZCVCxTQUFTeEIsS0FBS2tDLFFBQVEsSUFBSTtRQUM1QixHQUFHSDtJQUNMLEVBQUUsT0FBT1QsS0FBSztRQUNaLElBQUksT0FBT3JCLGFBQWEsWUFBWTtZQUNsQyxNQUFNcUI7UUFDUjtRQUNBLE1BQU1uQixTQUFTSCxNQUFNRztRQUNyQm9CLGVBQWUsSUFBTXRCLFNBQVNxQixLQUFLO2dCQUFFbkI7WUFBTztJQUM5QztBQUNGO0FBRUFnQyxPQUFPQyxPQUFPLEdBQUdaIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbW9ja3VwZmxvdy8uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2FwaS9hcGktdXBncmFkZS5qcz80NDA2Iiwid2VicGFjazovL21vY2t1cGZsb3cvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9hcGkvYXBpLXVwZ3JhZGUuanM/NDQwNioiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgSW52YWxpZEFyZ3VtZW50RXJyb3IsIFNvY2tldEVycm9yIH0gPSByZXF1aXJlKCcuLi9jb3JlL2Vycm9ycycpXG5jb25zdCB7IEFzeW5jUmVzb3VyY2UgfSA9IHJlcXVpcmUoJ25vZGU6YXN5bmNfaG9va3MnKVxuY29uc3QgdXRpbCA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpXG5jb25zdCB7IGFkZFNpZ25hbCwgcmVtb3ZlU2lnbmFsIH0gPSByZXF1aXJlKCcuL2Fib3J0LXNpZ25hbCcpXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdub2RlOmFzc2VydCcpXG5cbmNsYXNzIFVwZ3JhZGVIYW5kbGVyIGV4dGVuZHMgQXN5bmNSZXNvdXJjZSB7XG4gIGNvbnN0cnVjdG9yIChvcHRzLCBjYWxsYmFjaykge1xuICAgIGlmICghb3B0cyB8fCB0eXBlb2Ygb3B0cyAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBvcHRzJylcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgY2FsbGJhY2snKVxuICAgIH1cblxuICAgIGNvbnN0IHsgc2lnbmFsLCBvcGFxdWUsIHJlc3BvbnNlSGVhZGVycyB9ID0gb3B0c1xuXG4gICAgaWYgKHNpZ25hbCAmJiB0eXBlb2Ygc2lnbmFsLm9uICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdzaWduYWwgbXVzdCBiZSBhbiBFdmVudEVtaXR0ZXIgb3IgRXZlbnRUYXJnZXQnKVxuICAgIH1cblxuICAgIHN1cGVyKCdVTkRJQ0lfVVBHUkFERScpXG5cbiAgICB0aGlzLnJlc3BvbnNlSGVhZGVycyA9IHJlc3BvbnNlSGVhZGVycyB8fCBudWxsXG4gICAgdGhpcy5vcGFxdWUgPSBvcGFxdWUgfHwgbnVsbFxuICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFja1xuICAgIHRoaXMuYWJvcnQgPSBudWxsXG4gICAgdGhpcy5jb250ZXh0ID0gbnVsbFxuXG4gICAgYWRkU2lnbmFsKHRoaXMsIHNpZ25hbClcbiAgfVxuXG4gIG9uQ29ubmVjdCAoYWJvcnQsIGNvbnRleHQpIHtcbiAgICBpZiAodGhpcy5yZWFzb24pIHtcbiAgICAgIGFib3J0KHRoaXMucmVhc29uKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgYXNzZXJ0KHRoaXMuY2FsbGJhY2spXG5cbiAgICB0aGlzLmFib3J0ID0gYWJvcnRcbiAgICB0aGlzLmNvbnRleHQgPSBudWxsXG4gIH1cblxuICBvbkhlYWRlcnMgKCkge1xuICAgIHRocm93IG5ldyBTb2NrZXRFcnJvcignYmFkIHVwZ3JhZGUnLCBudWxsKVxuICB9XG5cbiAgb25VcGdyYWRlIChzdGF0dXNDb2RlLCByYXdIZWFkZXJzLCBzb2NrZXQpIHtcbiAgICBjb25zdCB7IGNhbGxiYWNrLCBvcGFxdWUsIGNvbnRleHQgfSA9IHRoaXNcblxuICAgIGFzc2VydC5zdHJpY3RFcXVhbChzdGF0dXNDb2RlLCAxMDEpXG5cbiAgICByZW1vdmVTaWduYWwodGhpcylcblxuICAgIHRoaXMuY2FsbGJhY2sgPSBudWxsXG4gICAgY29uc3QgaGVhZGVycyA9IHRoaXMucmVzcG9uc2VIZWFkZXJzID09PSAncmF3JyA/IHV0aWwucGFyc2VSYXdIZWFkZXJzKHJhd0hlYWRlcnMpIDogdXRpbC5wYXJzZUhlYWRlcnMocmF3SGVhZGVycylcbiAgICB0aGlzLnJ1bkluQXN5bmNTY29wZShjYWxsYmFjaywgbnVsbCwgbnVsbCwge1xuICAgICAgaGVhZGVycyxcbiAgICAgIHNvY2tldCxcbiAgICAgIG9wYXF1ZSxcbiAgICAgIGNvbnRleHRcbiAgICB9KVxuICB9XG5cbiAgb25FcnJvciAoZXJyKSB7XG4gICAgY29uc3QgeyBjYWxsYmFjaywgb3BhcXVlIH0gPSB0aGlzXG5cbiAgICByZW1vdmVTaWduYWwodGhpcylcblxuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgdGhpcy5jYWxsYmFjayA9IG51bGxcbiAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgICAgdGhpcy5ydW5JbkFzeW5jU2NvcGUoY2FsbGJhY2ssIG51bGwsIGVyciwgeyBvcGFxdWUgfSlcbiAgICAgIH0pXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHVwZ3JhZGUgKG9wdHMsIGNhbGxiYWNrKSB7XG4gIGlmIChjYWxsYmFjayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHVwZ3JhZGUuY2FsbCh0aGlzLCBvcHRzLCAoZXJyLCBkYXRhKSA9PiB7XG4gICAgICAgIHJldHVybiBlcnIgPyByZWplY3QoZXJyKSA6IHJlc29sdmUoZGF0YSlcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIHRyeSB7XG4gICAgY29uc3QgdXBncmFkZUhhbmRsZXIgPSBuZXcgVXBncmFkZUhhbmRsZXIob3B0cywgY2FsbGJhY2spXG4gICAgdGhpcy5kaXNwYXRjaCh7XG4gICAgICAuLi5vcHRzLFxuICAgICAgbWV0aG9kOiBvcHRzLm1ldGhvZCB8fCAnR0VUJyxcbiAgICAgIHVwZ3JhZGU6IG9wdHMucHJvdG9jb2wgfHwgJ1dlYnNvY2tldCdcbiAgICB9LCB1cGdyYWRlSGFuZGxlcilcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuICAgIGNvbnN0IG9wYXF1ZSA9IG9wdHM/Lm9wYXF1ZVxuICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IGNhbGxiYWNrKGVyciwgeyBvcGFxdWUgfSkpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB1cGdyYWRlXG4iXSwibmFtZXMiOlsiSW52YWxpZEFyZ3VtZW50RXJyb3IiLCJTb2NrZXRFcnJvciIsInJlcXVpcmUiLCJBc3luY1Jlc291cmNlIiwidXRpbCIsImFkZFNpZ25hbCIsInJlbW92ZVNpZ25hbCIsImFzc2VydCIsIlVwZ3JhZGVIYW5kbGVyIiwiY29uc3RydWN0b3IiLCJvcHRzIiwiY2FsbGJhY2siLCJzaWduYWwiLCJvcGFxdWUiLCJyZXNwb25zZUhlYWRlcnMiLCJvbiIsImFkZEV2ZW50TGlzdGVuZXIiLCJhYm9ydCIsImNvbnRleHQiLCJvbkNvbm5lY3QiLCJyZWFzb24iLCJvbkhlYWRlcnMiLCJvblVwZ3JhZGUiLCJzdGF0dXNDb2RlIiwicmF3SGVhZGVycyIsInNvY2tldCIsInN0cmljdEVxdWFsIiwiaGVhZGVycyIsInBhcnNlUmF3SGVhZGVycyIsInBhcnNlSGVhZGVycyIsInJ1bkluQXN5bmNTY29wZSIsIm9uRXJyb3IiLCJlcnIiLCJxdWV1ZU1pY3JvdGFzayIsInVwZ3JhZGUiLCJ1bmRlZmluZWQiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsImNhbGwiLCJkYXRhIiwidXBncmFkZUhhbmRsZXIiLCJkaXNwYXRjaCIsIm1ldGhvZCIsInByb3RvY29sIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/api/api-upgrade.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/api/index.js":
/*!**********************************************!*\
  !*** ./node_modules/undici/lib/api/index.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nmodule.exports.request = __webpack_require__(/*! ./api-request */ \"(ssr)/./node_modules/undici/lib/api/api-request.js\");\nmodule.exports.stream = __webpack_require__(/*! ./api-stream */ \"(ssr)/./node_modules/undici/lib/api/api-stream.js\");\nmodule.exports.pipeline = __webpack_require__(/*! ./api-pipeline */ \"(ssr)/./node_modules/undici/lib/api/api-pipeline.js\");\nmodule.exports.upgrade = __webpack_require__(/*! ./api-upgrade */ \"(ssr)/./node_modules/undici/lib/api/api-upgrade.js\");\nmodule.exports.connect = __webpack_require__(/*! ./api-connect */ \"(ssr)/./node_modules/undici/lib/api/api-connect.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9hcGkvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQUEsdUhBQWlDO0FBQ2pDQSxvSEFBZ0M7QUFDaENBLDBIQUFrQztBQUNsQ0EsdUhBQWlDO0FBQ2pDQSx1SEFBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tb2NrdXBmbG93Ly4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvYXBpL2luZGV4LmpzPzllZWUiLCJ3ZWJwYWNrOi8vbW9ja3VwZmxvdy8uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2FwaS9pbmRleC5qcz85ZWVlKiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxubW9kdWxlLmV4cG9ydHMucmVxdWVzdCA9IHJlcXVpcmUoJy4vYXBpLXJlcXVlc3QnKVxubW9kdWxlLmV4cG9ydHMuc3RyZWFtID0gcmVxdWlyZSgnLi9hcGktc3RyZWFtJylcbm1vZHVsZS5leHBvcnRzLnBpcGVsaW5lID0gcmVxdWlyZSgnLi9hcGktcGlwZWxpbmUnKVxubW9kdWxlLmV4cG9ydHMudXBncmFkZSA9IHJlcXVpcmUoJy4vYXBpLXVwZ3JhZGUnKVxubW9kdWxlLmV4cG9ydHMuY29ubmVjdCA9IHJlcXVpcmUoJy4vYXBpLWNvbm5lY3QnKVxuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1ZXN0IiwicmVxdWlyZSIsInN0cmVhbSIsInBpcGVsaW5lIiwidXBncmFkZSIsImNvbm5lY3QiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/api/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/api/readable.js":
/*!*************************************************!*\
  !*** ./node_modules/undici/lib/api/readable.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Ported from https://github.com/nodejs/undici/pull/907\n\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\");\nconst { Readable } = __webpack_require__(/*! node:stream */ \"node:stream\");\nconst { RequestAbortedError, NotSupportedError, InvalidArgumentError, AbortError } = __webpack_require__(/*! ../core/errors */ \"(ssr)/./node_modules/undici/lib/core/errors.js\");\nconst util = __webpack_require__(/*! ../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\");\nconst { ReadableStreamFrom } = __webpack_require__(/*! ../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\");\nconst kConsume = Symbol(\"kConsume\");\nconst kReading = Symbol(\"kReading\");\nconst kBody = Symbol(\"kBody\");\nconst kAbort = Symbol(\"kAbort\");\nconst kContentType = Symbol(\"kContentType\");\nconst kContentLength = Symbol(\"kContentLength\");\nconst noop = ()=>{};\nclass BodyReadable extends Readable {\n    constructor({ resume, abort, contentType = \"\", contentLength, highWaterMark = 64 * 1024 // Same as nodejs fs streams.\n     }){\n        super({\n            autoDestroy: true,\n            read: resume,\n            highWaterMark\n        });\n        this._readableState.dataEmitted = false;\n        this[kAbort] = abort;\n        this[kConsume] = null;\n        this[kBody] = null;\n        this[kContentType] = contentType;\n        this[kContentLength] = contentLength;\n        // Is stream being consumed through Readable API?\n        // This is an optimization so that we avoid checking\n        // for 'data' and 'readable' listeners in the hot path\n        // inside push().\n        this[kReading] = false;\n    }\n    destroy(err) {\n        if (!err && !this._readableState.endEmitted) {\n            err = new RequestAbortedError();\n        }\n        if (err) {\n            this[kAbort]();\n        }\n        return super.destroy(err);\n    }\n    _destroy(err, callback) {\n        // Workaround for Node \"bug\". If the stream is destroyed in same\n        // tick as it is created, then a user who is waiting for a\n        // promise (i.e micro tick) for installing a 'error' listener will\n        // never get a chance and will always encounter an unhandled exception.\n        if (!this[kReading]) {\n            setImmediate(()=>{\n                callback(err);\n            });\n        } else {\n            callback(err);\n        }\n    }\n    on(ev, ...args) {\n        if (ev === \"data\" || ev === \"readable\") {\n            this[kReading] = true;\n        }\n        return super.on(ev, ...args);\n    }\n    addListener(ev, ...args) {\n        return this.on(ev, ...args);\n    }\n    off(ev, ...args) {\n        const ret = super.off(ev, ...args);\n        if (ev === \"data\" || ev === \"readable\") {\n            this[kReading] = this.listenerCount(\"data\") > 0 || this.listenerCount(\"readable\") > 0;\n        }\n        return ret;\n    }\n    removeListener(ev, ...args) {\n        return this.off(ev, ...args);\n    }\n    push(chunk) {\n        if (this[kConsume] && chunk !== null) {\n            consumePush(this[kConsume], chunk);\n            return this[kReading] ? super.push(chunk) : true;\n        }\n        return super.push(chunk);\n    }\n    // https://fetch.spec.whatwg.org/#dom-body-text\n    async text() {\n        return consume(this, \"text\");\n    }\n    // https://fetch.spec.whatwg.org/#dom-body-json\n    async json() {\n        return consume(this, \"json\");\n    }\n    // https://fetch.spec.whatwg.org/#dom-body-blob\n    async blob() {\n        return consume(this, \"blob\");\n    }\n    // https://fetch.spec.whatwg.org/#dom-body-arraybuffer\n    async arrayBuffer() {\n        return consume(this, \"arrayBuffer\");\n    }\n    // https://fetch.spec.whatwg.org/#dom-body-formdata\n    async formData() {\n        // TODO: Implement.\n        throw new NotSupportedError();\n    }\n    // https://fetch.spec.whatwg.org/#dom-body-bodyused\n    get bodyUsed() {\n        return util.isDisturbed(this);\n    }\n    // https://fetch.spec.whatwg.org/#dom-body-body\n    get body() {\n        if (!this[kBody]) {\n            this[kBody] = ReadableStreamFrom(this);\n            if (this[kConsume]) {\n                // TODO: Is this the best way to force a lock?\n                this[kBody].getReader(); // Ensure stream is locked.\n                assert(this[kBody].locked);\n            }\n        }\n        return this[kBody];\n    }\n    async dump(opts) {\n        let limit = Number.isFinite(opts?.limit) ? opts.limit : 128 * 1024;\n        const signal = opts?.signal;\n        if (signal != null && (typeof signal !== \"object\" || !(\"aborted\" in signal))) {\n            throw new InvalidArgumentError(\"signal must be an AbortSignal\");\n        }\n        signal?.throwIfAborted();\n        if (this._readableState.closeEmitted) {\n            return null;\n        }\n        return await new Promise((resolve, reject)=>{\n            if (this[kContentLength] > limit) {\n                this.destroy(new AbortError());\n            }\n            const onAbort = ()=>{\n                this.destroy(signal.reason ?? new AbortError());\n            };\n            signal?.addEventListener(\"abort\", onAbort);\n            this.on(\"close\", function() {\n                signal?.removeEventListener(\"abort\", onAbort);\n                if (signal?.aborted) {\n                    reject(signal.reason ?? new AbortError());\n                } else {\n                    resolve(null);\n                }\n            }).on(\"error\", noop).on(\"data\", function(chunk) {\n                limit -= chunk.length;\n                if (limit <= 0) {\n                    this.destroy();\n                }\n            }).resume();\n        });\n    }\n}\n// https://streams.spec.whatwg.org/#readablestream-locked\nfunction isLocked(self) {\n    // Consume is an implicit lock.\n    return self[kBody] && self[kBody].locked === true || self[kConsume];\n}\n// https://fetch.spec.whatwg.org/#body-unusable\nfunction isUnusable(self) {\n    return util.isDisturbed(self) || isLocked(self);\n}\nasync function consume(stream, type) {\n    assert(!stream[kConsume]);\n    return new Promise((resolve, reject)=>{\n        if (isUnusable(stream)) {\n            const rState = stream._readableState;\n            if (rState.destroyed && rState.closeEmitted === false) {\n                stream.on(\"error\", (err)=>{\n                    reject(err);\n                }).on(\"close\", ()=>{\n                    reject(new TypeError(\"unusable\"));\n                });\n            } else {\n                reject(rState.errored ?? new TypeError(\"unusable\"));\n            }\n        } else {\n            queueMicrotask(()=>{\n                stream[kConsume] = {\n                    type,\n                    stream,\n                    resolve,\n                    reject,\n                    length: 0,\n                    body: []\n                };\n                stream.on(\"error\", function(err) {\n                    consumeFinish(this[kConsume], err);\n                }).on(\"close\", function() {\n                    if (this[kConsume].body !== null) {\n                        consumeFinish(this[kConsume], new RequestAbortedError());\n                    }\n                });\n                consumeStart(stream[kConsume]);\n            });\n        }\n    });\n}\nfunction consumeStart(consume) {\n    if (consume.body === null) {\n        return;\n    }\n    const { _readableState: state } = consume.stream;\n    if (state.bufferIndex) {\n        const start = state.bufferIndex;\n        const end = state.buffer.length;\n        for(let n = start; n < end; n++){\n            consumePush(consume, state.buffer[n]);\n        }\n    } else {\n        for (const chunk of state.buffer){\n            consumePush(consume, chunk);\n        }\n    }\n    if (state.endEmitted) {\n        consumeEnd(this[kConsume]);\n    } else {\n        consume.stream.on(\"end\", function() {\n            consumeEnd(this[kConsume]);\n        });\n    }\n    consume.stream.resume();\n    while(consume.stream.read() != null){\n    // Loop\n    }\n}\n/**\n * @param {Buffer[]} chunks\n * @param {number} length\n */ function chunksDecode(chunks, length) {\n    if (chunks.length === 0 || length === 0) {\n        return \"\";\n    }\n    const buffer = chunks.length === 1 ? chunks[0] : Buffer.concat(chunks, length);\n    const bufferLength = buffer.length;\n    // Skip BOM.\n    const start = bufferLength > 2 && buffer[0] === 0xef && buffer[1] === 0xbb && buffer[2] === 0xbf ? 3 : 0;\n    return buffer.utf8Slice(start, bufferLength);\n}\nfunction consumeEnd(consume) {\n    const { type, body, resolve, stream, length } = consume;\n    try {\n        if (type === \"text\") {\n            resolve(chunksDecode(body, length));\n        } else if (type === \"json\") {\n            resolve(JSON.parse(chunksDecode(body, length)));\n        } else if (type === \"arrayBuffer\") {\n            const dst = new Uint8Array(length);\n            let pos = 0;\n            for (const buf of body){\n                dst.set(buf, pos);\n                pos += buf.byteLength;\n            }\n            resolve(dst.buffer);\n        } else if (type === \"blob\") {\n            resolve(new Blob(body, {\n                type: stream[kContentType]\n            }));\n        }\n        consumeFinish(consume);\n    } catch (err) {\n        stream.destroy(err);\n    }\n}\nfunction consumePush(consume, chunk) {\n    consume.length += chunk.length;\n    consume.body.push(chunk);\n}\nfunction consumeFinish(consume, err) {\n    if (consume.body === null) {\n        return;\n    }\n    if (err) {\n        consume.reject(err);\n    } else {\n        consume.resolve();\n    }\n    consume.type = null;\n    consume.stream = null;\n    consume.resolve = null;\n    consume.reject = null;\n    consume.length = 0;\n    consume.body = null;\n}\nmodule.exports = {\n    Readable: BodyReadable,\n    chunksDecode\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9hcGkvcmVhZGFibGUuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQTtBQUVBLE1BQU1BLFNBQVNDLG1CQUFPQSxDQUFDO0FBQ3ZCLE1BQU0sRUFBRUMsUUFBQUEsRUFBVSxHQUFHRCxtQkFBT0EsQ0FBQztBQUM3QixNQUFNLEVBQUVFLG1CQUFtQixFQUFFQyxpQkFBaUIsRUFBRUMsb0JBQW9CLEVBQUVDLFVBQUFBLEVBQVksR0FBR0wsbUJBQU9BLENBQUM7QUFDN0YsTUFBTU0sT0FBT04sbUJBQU9BLENBQUM7QUFDckIsTUFBTSxFQUFFTyxrQkFBQUEsRUFBb0IsR0FBR1AsbUJBQU9BLENBQUM7QUFFdkMsTUFBTVEsV0FBV0MsT0FBTztBQUN4QixNQUFNQyxXQUFXRCxPQUFPO0FBQ3hCLE1BQU1FLFFBQVFGLE9BQU87QUFDckIsTUFBTUcsU0FBU0gsT0FBTztBQUN0QixNQUFNSSxlQUFlSixPQUFPO0FBQzVCLE1BQU1LLGlCQUFpQkwsT0FBTztBQUU5QixNQUFNTSxPQUFPQSxLQUFPO0FBRXBCLE1BQU1DLHFCQUFxQmY7SUFDekJnQixZQUFhLEVBQ1hDLE1BQU0sRUFDTkMsS0FBSyxFQUNMQyxjQUFjLEVBQUUsRUFDaEJDLGFBQWEsRUFDYkMsZ0JBQWdCLEtBQUssS0FBSztJQUFELEVBQzFCLENBQUU7UUFDRCxLQUFLLENBQUM7WUFDSkMsYUFBYTtZQUNiQyxNQUFNTjtZQUNOSTtRQUNGO1FBRUEsSUFBSSxDQUFDRyxjQUFjLENBQUNDLFdBQVcsR0FBRztRQUVsQyxJQUFJLENBQUNkLE9BQU8sR0FBR087UUFDZixJQUFJLENBQUNYLFNBQVMsR0FBRztRQUNqQixJQUFJLENBQUNHLE1BQU0sR0FBRztRQUNkLElBQUksQ0FBQ0UsYUFBYSxHQUFHTztRQUNyQixJQUFJLENBQUNOLGVBQWUsR0FBR087UUFFdkI7UUFDQTtRQUNBO1FBQ0E7UUFDQSxJQUFJLENBQUNYLFNBQVMsR0FBRztJQUNuQjtJQUVBaUIsUUFBU0MsR0FBRyxFQUFFO1FBQ1osSUFBSSxDQUFDQSxPQUFPLENBQUMsSUFBSSxDQUFDSCxjQUFjLENBQUNJLFVBQVUsRUFBRTtZQUMzQ0QsTUFBTSxJQUFJMUI7UUFDWjtRQUVBLElBQUkwQixLQUFLO1lBQ1AsSUFBSSxDQUFDaEIsT0FBTztRQUNkO1FBRUEsT0FBTyxLQUFLLENBQUNlLFFBQVFDO0lBQ3ZCO0lBRUFFLFNBQVVGLEdBQUcsRUFBRUcsUUFBUSxFQUFFO1FBQ3ZCO1FBQ0E7UUFDQTtRQUNBO1FBQ0EsSUFBSSxDQUFDLElBQUksQ0FBQ3JCLFNBQVMsRUFBRTtZQUNuQnNCLGFBQWE7Z0JBQ1hELFNBQVNIO1lBQ1g7UUFDRixPQUFPO1lBQ0xHLFNBQVNIO1FBQ1g7SUFDRjtJQUVBSyxHQUFJQyxFQUFFLEVBQUUsR0FBR0MsSUFBSSxFQUFFO1FBQ2YsSUFBSUQsT0FBTyxVQUFVQSxPQUFPLFlBQVk7WUFDdEMsSUFBSSxDQUFDeEIsU0FBUyxHQUFHO1FBQ25CO1FBQ0EsT0FBTyxLQUFLLENBQUN1QixHQUFHQyxPQUFPQztJQUN6QjtJQUVBQyxZQUFhRixFQUFFLEVBQUUsR0FBR0MsSUFBSSxFQUFFO1FBQ3hCLE9BQU8sSUFBSSxDQUFDRixFQUFFLENBQUNDLE9BQU9DO0lBQ3hCO0lBRUFFLElBQUtILEVBQUUsRUFBRSxHQUFHQyxJQUFJLEVBQUU7UUFDaEIsTUFBTUcsTUFBTSxLQUFLLENBQUNELElBQUlILE9BQU9DO1FBQzdCLElBQUlELE9BQU8sVUFBVUEsT0FBTyxZQUFZO1lBQ3RDLElBQUksQ0FBQ3hCLFNBQVMsR0FDWixJQUFJLENBQUM2QixhQUFhLENBQUMsVUFBVSxLQUM3QixJQUFJLENBQUNBLGFBQWEsQ0FBQyxjQUFjO1FBRXJDO1FBQ0EsT0FBT0Q7SUFDVDtJQUVBRSxlQUFnQk4sRUFBRSxFQUFFLEdBQUdDLElBQUksRUFBRTtRQUMzQixPQUFPLElBQUksQ0FBQ0UsR0FBRyxDQUFDSCxPQUFPQztJQUN6QjtJQUVBTSxLQUFNQyxLQUFLLEVBQUU7UUFDWCxJQUFJLElBQUksQ0FBQ2xDLFNBQVMsSUFBSWtDLFVBQVUsTUFBTTtZQUNwQ0MsWUFBWSxJQUFJLENBQUNuQyxTQUFTLEVBQUVrQztZQUM1QixPQUFPLElBQUksQ0FBQ2hDLFNBQVMsR0FBRyxLQUFLLENBQUMrQixLQUFLQyxTQUFTO1FBQzlDO1FBQ0EsT0FBTyxLQUFLLENBQUNELEtBQUtDO0lBQ3BCO0lBRUE7SUFDQSxNQUFNRSxPQUFRO1FBQ1osT0FBT0MsUUFBUSxJQUFJLEVBQUU7SUFDdkI7SUFFQTtJQUNBLE1BQU1DLE9BQVE7UUFDWixPQUFPRCxRQUFRLElBQUksRUFBRTtJQUN2QjtJQUVBO0lBQ0EsTUFBTUUsT0FBUTtRQUNaLE9BQU9GLFFBQVEsSUFBSSxFQUFFO0lBQ3ZCO0lBRUE7SUFDQSxNQUFNRyxjQUFlO1FBQ25CLE9BQU9ILFFBQVEsSUFBSSxFQUFFO0lBQ3ZCO0lBRUE7SUFDQSxNQUFNSSxXQUFZO1FBQ2hCO1FBQ0EsTUFBTSxJQUFJOUM7SUFDWjtJQUVBO0lBQ0EsSUFBSStDLFdBQVk7UUFDZCxPQUFPNUMsS0FBSzZDLFdBQVcsQ0FBQyxJQUFJO0lBQzlCO0lBRUE7SUFDQSxJQUFJQyxPQUFRO1FBQ1YsSUFBSSxDQUFDLElBQUksQ0FBQ3pDLE1BQU0sRUFBRTtZQUNoQixJQUFJLENBQUNBLE1BQU0sR0FBR0osbUJBQW1CLElBQUk7WUFDckMsSUFBSSxJQUFJLENBQUNDLFNBQVMsRUFBRTtnQkFDbEI7Z0JBQ0EsSUFBSSxDQUFDRyxNQUFNLENBQUMwQyxTQUFTLElBQUc7Z0JBQ3hCdEQsT0FBTyxJQUFJLENBQUNZLE1BQU0sQ0FBQzJDLE1BQU07WUFDM0I7UUFDRjtRQUNBLE9BQU8sSUFBSSxDQUFDM0MsTUFBTTtJQUNwQjtJQUVBLE1BQU00QyxLQUFNQyxJQUFJLEVBQUU7UUFDaEIsSUFBSUMsUUFBUUMsT0FBT0MsUUFBUSxDQUFDSCxNQUFNQyxTQUFTRCxLQUFLQyxLQUFLLEdBQUcsTUFBTTtRQUM5RCxNQUFNRyxTQUFTSixNQUFNSTtRQUVyQixJQUFJQSxVQUFVLFFBQVMsUUFBT0EsV0FBVyxZQUFZLENBQUUsY0FBYUEsTUFBQUEsQ0FBTSxHQUFJO1lBQzVFLE1BQU0sSUFBSXhELHFCQUFxQjtRQUNqQztRQUVBd0QsUUFBUUM7UUFFUixJQUFJLElBQUksQ0FBQ3BDLGNBQWMsQ0FBQ3FDLFlBQVksRUFBRTtZQUNwQyxPQUFPO1FBQ1Q7UUFFQSxPQUFPLE1BQU0sSUFBSUMsUUFBUSxDQUFDQyxTQUFTQztZQUNqQyxJQUFJLElBQUksQ0FBQ25ELGVBQWUsR0FBRzJDLE9BQU87Z0JBQ2hDLElBQUksQ0FBQzlCLE9BQU8sQ0FBQyxJQUFJdEI7WUFDbkI7WUFFQSxNQUFNNkQsVUFBVUE7Z0JBQ2QsSUFBSSxDQUFDdkMsT0FBTyxDQUFDaUMsT0FBT08sTUFBTSxJQUFJLElBQUk5RDtZQUNwQztZQUNBdUQsUUFBUVEsaUJBQWlCLFNBQVNGO1lBRWxDLElBQUksQ0FDRGpDLEVBQUUsQ0FBQyxTQUFTO2dCQUNYMkIsUUFBUVMsb0JBQW9CLFNBQVNIO2dCQUNyQyxJQUFJTixRQUFRVSxTQUFTO29CQUNuQkwsT0FBT0wsT0FBT08sTUFBTSxJQUFJLElBQUk5RDtnQkFDOUIsT0FBTztvQkFDTDJELFFBQVE7Z0JBQ1Y7WUFDRixHQUNDL0IsRUFBRSxDQUFDLFNBQVNsQixNQUNaa0IsRUFBRSxDQUFDLFFBQVEsU0FBVVMsS0FBSztnQkFDekJlLFNBQVNmLE1BQU02QixNQUFNO2dCQUNyQixJQUFJZCxTQUFTLEdBQUc7b0JBQ2QsSUFBSSxDQUFDOUIsT0FBTztnQkFDZDtZQUNGLEdBQ0NULE1BQU07UUFDWDtJQUNGO0FBQ0Y7QUFFQTtBQUNBLFNBQVNzRCxTQUFVQyxJQUFJO0lBQ3JCO0lBQ0EsT0FBUUEsSUFBSSxDQUFDOUQsTUFBTSxJQUFJOEQsSUFBSSxDQUFDOUQsTUFBTSxDQUFDMkMsTUFBTSxLQUFLLFFBQVNtQixJQUFJLENBQUNqRSxTQUFTO0FBQ3ZFO0FBRUE7QUFDQSxTQUFTa0UsV0FBWUQsSUFBSTtJQUN2QixPQUFPbkUsS0FBSzZDLFdBQVcsQ0FBQ3NCLFNBQVNELFNBQVNDO0FBQzVDO0FBRUEsZUFBZTVCLFFBQVM4QixNQUFNLEVBQUVDLElBQUk7SUFDbEM3RSxPQUFPLENBQUM0RSxNQUFNLENBQUNuRSxTQUFTO0lBRXhCLE9BQU8sSUFBSXVELFFBQVEsQ0FBQ0MsU0FBU0M7UUFDM0IsSUFBSVMsV0FBV0MsU0FBUztZQUN0QixNQUFNRSxTQUFTRixPQUFPbEQsY0FBYztZQUNwQyxJQUFJb0QsT0FBT0MsU0FBUyxJQUFJRCxPQUFPZixZQUFZLEtBQUssT0FBTztnQkFDckRhLE9BQ0cxQyxFQUFFLENBQUMsU0FBU0wsQ0FBQUE7b0JBQ1hxQyxPQUFPckM7Z0JBQ1QsR0FDQ0ssRUFBRSxDQUFDLFNBQVM7b0JBQ1hnQyxPQUFPLElBQUljLFVBQVU7Z0JBQ3ZCO1lBQ0osT0FBTztnQkFDTGQsT0FBT1ksT0FBT0csT0FBTyxJQUFJLElBQUlELFVBQVU7WUFDekM7UUFDRixPQUFPO1lBQ0xFLGVBQWU7Z0JBQ2JOLE1BQU0sQ0FBQ25FLFNBQVMsR0FBRztvQkFDakJvRTtvQkFDQUQ7b0JBQ0FYO29CQUNBQztvQkFDQU0sUUFBUTtvQkFDUm5CLE1BQU07Z0JBQ1I7Z0JBRUF1QixPQUNHMUMsRUFBRSxDQUFDLFNBQVMsU0FBVUwsR0FBRztvQkFDeEJzRCxjQUFjLElBQUksQ0FBQzFFLFNBQVMsRUFBRW9CO2dCQUNoQyxHQUNDSyxFQUFFLENBQUMsU0FBUztvQkFDWCxJQUFJLElBQUksQ0FBQ3pCLFNBQVMsQ0FBQzRDLElBQUksS0FBSyxNQUFNO3dCQUNoQzhCLGNBQWMsSUFBSSxDQUFDMUUsU0FBUyxFQUFFLElBQUlOO29CQUNwQztnQkFDRjtnQkFFRmlGLGFBQWFSLE1BQU0sQ0FBQ25FLFNBQVM7WUFDL0I7UUFDRjtJQUNGO0FBQ0Y7QUFFQSxTQUFTMkUsYUFBY3RDLE9BQU87SUFDNUIsSUFBSUEsUUFBUU8sSUFBSSxLQUFLLE1BQU07UUFDekI7SUFDRjtJQUVBLE1BQU0sRUFBRTNCLGdCQUFnQjJELEtBQUFBLEVBQU8sR0FBR3ZDLFFBQVE4QixNQUFNO0lBRWhELElBQUlTLE1BQU1DLFdBQVcsRUFBRTtRQUNyQixNQUFNQyxRQUFRRixNQUFNQyxXQUFXO1FBQy9CLE1BQU1FLE1BQU1ILE1BQU1JLE1BQU0sQ0FBQ2pCLE1BQU07UUFDL0IsSUFBSyxJQUFJa0IsSUFBSUgsT0FBT0csSUFBSUYsS0FBS0UsSUFBSztZQUNoQzlDLFlBQVlFLFNBQVN1QyxNQUFNSSxNQUFNLENBQUNDLEVBQUU7UUFDdEM7SUFDRixPQUFPO1FBQ0wsS0FBSyxNQUFNL0MsU0FBUzBDLE1BQU1JLE1BQU0sQ0FBRTtZQUNoQzdDLFlBQVlFLFNBQVNIO1FBQ3ZCO0lBQ0Y7SUFFQSxJQUFJMEMsTUFBTXZELFVBQVUsRUFBRTtRQUNwQjZELFdBQVcsSUFBSSxDQUFDbEYsU0FBUztJQUMzQixPQUFPO1FBQ0xxQyxRQUFROEIsTUFBTSxDQUFDMUMsRUFBRSxDQUFDLE9BQU87WUFDdkJ5RCxXQUFXLElBQUksQ0FBQ2xGLFNBQVM7UUFDM0I7SUFDRjtJQUVBcUMsUUFBUThCLE1BQU0sQ0FBQ3pELE1BQU07SUFFckIsTUFBTzJCLFFBQVE4QixNQUFNLENBQUNuRCxJQUFJLE1BQU0sS0FBTTtJQUNwQztJQUFBO0FBRUo7QUFFQTs7O0NBR0EsR0FDQSxTQUFTbUUsYUFBY0MsTUFBTSxFQUFFckIsTUFBTTtJQUNuQyxJQUFJcUIsT0FBT3JCLE1BQU0sS0FBSyxLQUFLQSxXQUFXLEdBQUc7UUFDdkMsT0FBTztJQUNUO0lBQ0EsTUFBTWlCLFNBQVNJLE9BQU9yQixNQUFNLEtBQUssSUFBSXFCLE1BQU0sQ0FBQyxFQUFFLEdBQUdDLE9BQU9DLE1BQU0sQ0FBQ0YsUUFBUXJCO0lBQ3ZFLE1BQU13QixlQUFlUCxPQUFPakIsTUFBTTtJQUVsQztJQUNBLE1BQU1lLFFBQ0pTLGVBQWUsS0FDZlAsTUFBTSxDQUFDLEVBQUUsS0FBSyxRQUNkQSxNQUFNLENBQUMsRUFBRSxLQUFLLFFBQ2RBLE1BQU0sQ0FBQyxFQUFFLEtBQUssT0FDVixJQUNBO0lBQ04sT0FBT0EsT0FBT1EsU0FBUyxDQUFDVixPQUFPUztBQUNqQztBQUVBLFNBQVNMLFdBQVk3QyxPQUFPO0lBQzFCLE1BQU0sRUFBRStCLElBQUksRUFBRXhCLElBQUksRUFBRVksT0FBTyxFQUFFVyxNQUFNLEVBQUVKLE1BQUFBLEVBQVEsR0FBRzFCO0lBRWhELElBQUk7UUFDRixJQUFJK0IsU0FBUyxRQUFRO1lBQ25CWixRQUFRMkIsYUFBYXZDLE1BQU1tQjtRQUM3QixPQUFPLElBQUlLLFNBQVMsUUFBUTtZQUMxQlosUUFBUWlDLEtBQUtDLEtBQUssQ0FBQ1AsYUFBYXZDLE1BQU1tQjtRQUN4QyxPQUFPLElBQUlLLFNBQVMsZUFBZTtZQUNqQyxNQUFNdUIsTUFBTSxJQUFJQyxXQUFXN0I7WUFFM0IsSUFBSThCLE1BQU07WUFDVixLQUFLLE1BQU1DLE9BQU9sRCxLQUFNO2dCQUN0QitDLElBQUlJLEdBQUcsQ0FBQ0QsS0FBS0Q7Z0JBQ2JBLE9BQU9DLElBQUlFLFVBQVU7WUFDdkI7WUFFQXhDLFFBQVFtQyxJQUFJWCxNQUFNO1FBQ3BCLE9BQU8sSUFBSVosU0FBUyxRQUFRO1lBQzFCWixRQUFRLElBQUl5QyxLQUFLckQsTUFBTTtnQkFBRXdCLE1BQU1ELE1BQU0sQ0FBQzlELGFBQVk7WUFBRTtRQUN0RDtRQUVBcUUsY0FBY3JDO0lBQ2hCLEVBQUUsT0FBT2pCLEtBQUs7UUFDWitDLE9BQU9oRCxPQUFPLENBQUNDO0lBQ2pCO0FBQ0Y7QUFFQSxTQUFTZSxZQUFhRSxPQUFPLEVBQUVILEtBQUs7SUFDbENHLFFBQVEwQixNQUFNLElBQUk3QixNQUFNNkIsTUFBTTtJQUM5QjFCLFFBQVFPLElBQUksQ0FBQ1gsSUFBSSxDQUFDQztBQUNwQjtBQUVBLFNBQVN3QyxjQUFlckMsT0FBTyxFQUFFakIsR0FBRztJQUNsQyxJQUFJaUIsUUFBUU8sSUFBSSxLQUFLLE1BQU07UUFDekI7SUFDRjtJQUVBLElBQUl4QixLQUFLO1FBQ1BpQixRQUFRb0IsTUFBTSxDQUFDckM7SUFDakIsT0FBTztRQUNMaUIsUUFBUW1CLE9BQU87SUFDakI7SUFFQW5CLFFBQVErQixJQUFJLEdBQUc7SUFDZi9CLFFBQVE4QixNQUFNLEdBQUc7SUFDakI5QixRQUFRbUIsT0FBTyxHQUFHO0lBQ2xCbkIsUUFBUW9CLE1BQU0sR0FBRztJQUNqQnBCLFFBQVEwQixNQUFNLEdBQUc7SUFDakIxQixRQUFRTyxJQUFJLEdBQUc7QUFDakI7QUFFQXNELE9BQU9DLE9BQU8sR0FBRztJQUFFMUcsVUFBVWU7SUFBYzJFO0FBQWEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tb2NrdXBmbG93Ly4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvYXBpL3JlYWRhYmxlLmpzPzY4NWQiLCJ3ZWJwYWNrOi8vbW9ja3VwZmxvdy8uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2FwaS9yZWFkYWJsZS5qcz82ODVkKiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBQb3J0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL3VuZGljaS9wdWxsLzkwN1xuXG4ndXNlIHN0cmljdCdcblxuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZSgnbm9kZTphc3NlcnQnKVxuY29uc3QgeyBSZWFkYWJsZSB9ID0gcmVxdWlyZSgnbm9kZTpzdHJlYW0nKVxuY29uc3QgeyBSZXF1ZXN0QWJvcnRlZEVycm9yLCBOb3RTdXBwb3J0ZWRFcnJvciwgSW52YWxpZEFyZ3VtZW50RXJyb3IsIEFib3J0RXJyb3IgfSA9IHJlcXVpcmUoJy4uL2NvcmUvZXJyb3JzJylcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCcuLi9jb3JlL3V0aWwnKVxuY29uc3QgeyBSZWFkYWJsZVN0cmVhbUZyb20gfSA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpXG5cbmNvbnN0IGtDb25zdW1lID0gU3ltYm9sKCdrQ29uc3VtZScpXG5jb25zdCBrUmVhZGluZyA9IFN5bWJvbCgna1JlYWRpbmcnKVxuY29uc3Qga0JvZHkgPSBTeW1ib2woJ2tCb2R5JylcbmNvbnN0IGtBYm9ydCA9IFN5bWJvbCgna0Fib3J0JylcbmNvbnN0IGtDb250ZW50VHlwZSA9IFN5bWJvbCgna0NvbnRlbnRUeXBlJylcbmNvbnN0IGtDb250ZW50TGVuZ3RoID0gU3ltYm9sKCdrQ29udGVudExlbmd0aCcpXG5cbmNvbnN0IG5vb3AgPSAoKSA9PiB7fVxuXG5jbGFzcyBCb2R5UmVhZGFibGUgZXh0ZW5kcyBSZWFkYWJsZSB7XG4gIGNvbnN0cnVjdG9yICh7XG4gICAgcmVzdW1lLFxuICAgIGFib3J0LFxuICAgIGNvbnRlbnRUeXBlID0gJycsXG4gICAgY29udGVudExlbmd0aCxcbiAgICBoaWdoV2F0ZXJNYXJrID0gNjQgKiAxMDI0IC8vIFNhbWUgYXMgbm9kZWpzIGZzIHN0cmVhbXMuXG4gIH0pIHtcbiAgICBzdXBlcih7XG4gICAgICBhdXRvRGVzdHJveTogdHJ1ZSxcbiAgICAgIHJlYWQ6IHJlc3VtZSxcbiAgICAgIGhpZ2hXYXRlck1hcmtcbiAgICB9KVxuXG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kYXRhRW1pdHRlZCA9IGZhbHNlXG5cbiAgICB0aGlzW2tBYm9ydF0gPSBhYm9ydFxuICAgIHRoaXNba0NvbnN1bWVdID0gbnVsbFxuICAgIHRoaXNba0JvZHldID0gbnVsbFxuICAgIHRoaXNba0NvbnRlbnRUeXBlXSA9IGNvbnRlbnRUeXBlXG4gICAgdGhpc1trQ29udGVudExlbmd0aF0gPSBjb250ZW50TGVuZ3RoXG5cbiAgICAvLyBJcyBzdHJlYW0gYmVpbmcgY29uc3VtZWQgdGhyb3VnaCBSZWFkYWJsZSBBUEk/XG4gICAgLy8gVGhpcyBpcyBhbiBvcHRpbWl6YXRpb24gc28gdGhhdCB3ZSBhdm9pZCBjaGVja2luZ1xuICAgIC8vIGZvciAnZGF0YScgYW5kICdyZWFkYWJsZScgbGlzdGVuZXJzIGluIHRoZSBob3QgcGF0aFxuICAgIC8vIGluc2lkZSBwdXNoKCkuXG4gICAgdGhpc1trUmVhZGluZ10gPSBmYWxzZVxuICB9XG5cbiAgZGVzdHJveSAoZXJyKSB7XG4gICAgaWYgKCFlcnIgJiYgIXRoaXMuX3JlYWRhYmxlU3RhdGUuZW5kRW1pdHRlZCkge1xuICAgICAgZXJyID0gbmV3IFJlcXVlc3RBYm9ydGVkRXJyb3IoKVxuICAgIH1cblxuICAgIGlmIChlcnIpIHtcbiAgICAgIHRoaXNba0Fib3J0XSgpXG4gICAgfVxuXG4gICAgcmV0dXJuIHN1cGVyLmRlc3Ryb3koZXJyKVxuICB9XG5cbiAgX2Rlc3Ryb3kgKGVyciwgY2FsbGJhY2spIHtcbiAgICAvLyBXb3JrYXJvdW5kIGZvciBOb2RlIFwiYnVnXCIuIElmIHRoZSBzdHJlYW0gaXMgZGVzdHJveWVkIGluIHNhbWVcbiAgICAvLyB0aWNrIGFzIGl0IGlzIGNyZWF0ZWQsIHRoZW4gYSB1c2VyIHdobyBpcyB3YWl0aW5nIGZvciBhXG4gICAgLy8gcHJvbWlzZSAoaS5lIG1pY3JvIHRpY2spIGZvciBpbnN0YWxsaW5nIGEgJ2Vycm9yJyBsaXN0ZW5lciB3aWxsXG4gICAgLy8gbmV2ZXIgZ2V0IGEgY2hhbmNlIGFuZCB3aWxsIGFsd2F5cyBlbmNvdW50ZXIgYW4gdW5oYW5kbGVkIGV4Y2VwdGlvbi5cbiAgICBpZiAoIXRoaXNba1JlYWRpbmddKSB7XG4gICAgICBzZXRJbW1lZGlhdGUoKCkgPT4ge1xuICAgICAgICBjYWxsYmFjayhlcnIpXG4gICAgICB9KVxuICAgIH0gZWxzZSB7XG4gICAgICBjYWxsYmFjayhlcnIpXG4gICAgfVxuICB9XG5cbiAgb24gKGV2LCAuLi5hcmdzKSB7XG4gICAgaWYgKGV2ID09PSAnZGF0YScgfHwgZXYgPT09ICdyZWFkYWJsZScpIHtcbiAgICAgIHRoaXNba1JlYWRpbmddID0gdHJ1ZVxuICAgIH1cbiAgICByZXR1cm4gc3VwZXIub24oZXYsIC4uLmFyZ3MpXG4gIH1cblxuICBhZGRMaXN0ZW5lciAoZXYsIC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5vbihldiwgLi4uYXJncylcbiAgfVxuXG4gIG9mZiAoZXYsIC4uLmFyZ3MpIHtcbiAgICBjb25zdCByZXQgPSBzdXBlci5vZmYoZXYsIC4uLmFyZ3MpXG4gICAgaWYgKGV2ID09PSAnZGF0YScgfHwgZXYgPT09ICdyZWFkYWJsZScpIHtcbiAgICAgIHRoaXNba1JlYWRpbmddID0gKFxuICAgICAgICB0aGlzLmxpc3RlbmVyQ291bnQoJ2RhdGEnKSA+IDAgfHxcbiAgICAgICAgdGhpcy5saXN0ZW5lckNvdW50KCdyZWFkYWJsZScpID4gMFxuICAgICAgKVxuICAgIH1cbiAgICByZXR1cm4gcmV0XG4gIH1cblxuICByZW1vdmVMaXN0ZW5lciAoZXYsIC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5vZmYoZXYsIC4uLmFyZ3MpXG4gIH1cblxuICBwdXNoIChjaHVuaykge1xuICAgIGlmICh0aGlzW2tDb25zdW1lXSAmJiBjaHVuayAhPT0gbnVsbCkge1xuICAgICAgY29uc3VtZVB1c2godGhpc1trQ29uc3VtZV0sIGNodW5rKVxuICAgICAgcmV0dXJuIHRoaXNba1JlYWRpbmddID8gc3VwZXIucHVzaChjaHVuaykgOiB0cnVlXG4gICAgfVxuICAgIHJldHVybiBzdXBlci5wdXNoKGNodW5rKVxuICB9XG5cbiAgLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2RvbS1ib2R5LXRleHRcbiAgYXN5bmMgdGV4dCAoKSB7XG4gICAgcmV0dXJuIGNvbnN1bWUodGhpcywgJ3RleHQnKVxuICB9XG5cbiAgLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2RvbS1ib2R5LWpzb25cbiAgYXN5bmMganNvbiAoKSB7XG4gICAgcmV0dXJuIGNvbnN1bWUodGhpcywgJ2pzb24nKVxuICB9XG5cbiAgLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2RvbS1ib2R5LWJsb2JcbiAgYXN5bmMgYmxvYiAoKSB7XG4gICAgcmV0dXJuIGNvbnN1bWUodGhpcywgJ2Jsb2InKVxuICB9XG5cbiAgLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2RvbS1ib2R5LWFycmF5YnVmZmVyXG4gIGFzeW5jIGFycmF5QnVmZmVyICgpIHtcbiAgICByZXR1cm4gY29uc3VtZSh0aGlzLCAnYXJyYXlCdWZmZXInKVxuICB9XG5cbiAgLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2RvbS1ib2R5LWZvcm1kYXRhXG4gIGFzeW5jIGZvcm1EYXRhICgpIHtcbiAgICAvLyBUT0RPOiBJbXBsZW1lbnQuXG4gICAgdGhyb3cgbmV3IE5vdFN1cHBvcnRlZEVycm9yKClcbiAgfVxuXG4gIC8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNkb20tYm9keS1ib2R5dXNlZFxuICBnZXQgYm9keVVzZWQgKCkge1xuICAgIHJldHVybiB1dGlsLmlzRGlzdHVyYmVkKHRoaXMpXG4gIH1cblxuICAvLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jZG9tLWJvZHktYm9keVxuICBnZXQgYm9keSAoKSB7XG4gICAgaWYgKCF0aGlzW2tCb2R5XSkge1xuICAgICAgdGhpc1trQm9keV0gPSBSZWFkYWJsZVN0cmVhbUZyb20odGhpcylcbiAgICAgIGlmICh0aGlzW2tDb25zdW1lXSkge1xuICAgICAgICAvLyBUT0RPOiBJcyB0aGlzIHRoZSBiZXN0IHdheSB0byBmb3JjZSBhIGxvY2s/XG4gICAgICAgIHRoaXNba0JvZHldLmdldFJlYWRlcigpIC8vIEVuc3VyZSBzdHJlYW0gaXMgbG9ja2VkLlxuICAgICAgICBhc3NlcnQodGhpc1trQm9keV0ubG9ja2VkKVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpc1trQm9keV1cbiAgfVxuXG4gIGFzeW5jIGR1bXAgKG9wdHMpIHtcbiAgICBsZXQgbGltaXQgPSBOdW1iZXIuaXNGaW5pdGUob3B0cz8ubGltaXQpID8gb3B0cy5saW1pdCA6IDEyOCAqIDEwMjRcbiAgICBjb25zdCBzaWduYWwgPSBvcHRzPy5zaWduYWxcblxuICAgIGlmIChzaWduYWwgIT0gbnVsbCAmJiAodHlwZW9mIHNpZ25hbCAhPT0gJ29iamVjdCcgfHwgISgnYWJvcnRlZCcgaW4gc2lnbmFsKSkpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignc2lnbmFsIG11c3QgYmUgYW4gQWJvcnRTaWduYWwnKVxuICAgIH1cblxuICAgIHNpZ25hbD8udGhyb3dJZkFib3J0ZWQoKVxuXG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUuY2xvc2VFbWl0dGVkKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIHJldHVybiBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBpZiAodGhpc1trQ29udGVudExlbmd0aF0gPiBsaW1pdCkge1xuICAgICAgICB0aGlzLmRlc3Ryb3kobmV3IEFib3J0RXJyb3IoKSlcbiAgICAgIH1cblxuICAgICAgY29uc3Qgb25BYm9ydCA9ICgpID0+IHtcbiAgICAgICAgdGhpcy5kZXN0cm95KHNpZ25hbC5yZWFzb24gPz8gbmV3IEFib3J0RXJyb3IoKSlcbiAgICAgIH1cbiAgICAgIHNpZ25hbD8uYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBvbkFib3J0KVxuXG4gICAgICB0aGlzXG4gICAgICAgIC5vbignY2xvc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgc2lnbmFsPy5yZW1vdmVFdmVudExpc3RlbmVyKCdhYm9ydCcsIG9uQWJvcnQpXG4gICAgICAgICAgaWYgKHNpZ25hbD8uYWJvcnRlZCkge1xuICAgICAgICAgICAgcmVqZWN0KHNpZ25hbC5yZWFzb24gPz8gbmV3IEFib3J0RXJyb3IoKSlcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzb2x2ZShudWxsKVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgLm9uKCdlcnJvcicsIG5vb3ApXG4gICAgICAgIC5vbignZGF0YScsIGZ1bmN0aW9uIChjaHVuaykge1xuICAgICAgICAgIGxpbWl0IC09IGNodW5rLmxlbmd0aFxuICAgICAgICAgIGlmIChsaW1pdCA8PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3Ryb3koKVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgLnJlc3VtZSgpXG4gICAgfSlcbiAgfVxufVxuXG4vLyBodHRwczovL3N0cmVhbXMuc3BlYy53aGF0d2cub3JnLyNyZWFkYWJsZXN0cmVhbS1sb2NrZWRcbmZ1bmN0aW9uIGlzTG9ja2VkIChzZWxmKSB7XG4gIC8vIENvbnN1bWUgaXMgYW4gaW1wbGljaXQgbG9jay5cbiAgcmV0dXJuIChzZWxmW2tCb2R5XSAmJiBzZWxmW2tCb2R5XS5sb2NrZWQgPT09IHRydWUpIHx8IHNlbGZba0NvbnN1bWVdXG59XG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNib2R5LXVudXNhYmxlXG5mdW5jdGlvbiBpc1VudXNhYmxlIChzZWxmKSB7XG4gIHJldHVybiB1dGlsLmlzRGlzdHVyYmVkKHNlbGYpIHx8IGlzTG9ja2VkKHNlbGYpXG59XG5cbmFzeW5jIGZ1bmN0aW9uIGNvbnN1bWUgKHN0cmVhbSwgdHlwZSkge1xuICBhc3NlcnQoIXN0cmVhbVtrQ29uc3VtZV0pXG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBpZiAoaXNVbnVzYWJsZShzdHJlYW0pKSB7XG4gICAgICBjb25zdCByU3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGVcbiAgICAgIGlmIChyU3RhdGUuZGVzdHJveWVkICYmIHJTdGF0ZS5jbG9zZUVtaXR0ZWQgPT09IGZhbHNlKSB7XG4gICAgICAgIHN0cmVhbVxuICAgICAgICAgIC5vbignZXJyb3InLCBlcnIgPT4ge1xuICAgICAgICAgICAgcmVqZWN0KGVycilcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5vbignY2xvc2UnLCAoKSA9PiB7XG4gICAgICAgICAgICByZWplY3QobmV3IFR5cGVFcnJvcigndW51c2FibGUnKSlcbiAgICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVqZWN0KHJTdGF0ZS5lcnJvcmVkID8/IG5ldyBUeXBlRXJyb3IoJ3VudXNhYmxlJykpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgICAgc3RyZWFtW2tDb25zdW1lXSA9IHtcbiAgICAgICAgICB0eXBlLFxuICAgICAgICAgIHN0cmVhbSxcbiAgICAgICAgICByZXNvbHZlLFxuICAgICAgICAgIHJlamVjdCxcbiAgICAgICAgICBsZW5ndGg6IDAsXG4gICAgICAgICAgYm9keTogW11cbiAgICAgICAgfVxuXG4gICAgICAgIHN0cmVhbVxuICAgICAgICAgIC5vbignZXJyb3InLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBjb25zdW1lRmluaXNoKHRoaXNba0NvbnN1bWVdLCBlcnIpXG4gICAgICAgICAgfSlcbiAgICAgICAgICAub24oJ2Nsb3NlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXNba0NvbnN1bWVdLmJvZHkgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgY29uc3VtZUZpbmlzaCh0aGlzW2tDb25zdW1lXSwgbmV3IFJlcXVlc3RBYm9ydGVkRXJyb3IoKSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuXG4gICAgICAgIGNvbnN1bWVTdGFydChzdHJlYW1ba0NvbnN1bWVdKVxuICAgICAgfSlcbiAgICB9XG4gIH0pXG59XG5cbmZ1bmN0aW9uIGNvbnN1bWVTdGFydCAoY29uc3VtZSkge1xuICBpZiAoY29uc3VtZS5ib2R5ID09PSBudWxsKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBjb25zdCB7IF9yZWFkYWJsZVN0YXRlOiBzdGF0ZSB9ID0gY29uc3VtZS5zdHJlYW1cblxuICBpZiAoc3RhdGUuYnVmZmVySW5kZXgpIHtcbiAgICBjb25zdCBzdGFydCA9IHN0YXRlLmJ1ZmZlckluZGV4XG4gICAgY29uc3QgZW5kID0gc3RhdGUuYnVmZmVyLmxlbmd0aFxuICAgIGZvciAobGV0IG4gPSBzdGFydDsgbiA8IGVuZDsgbisrKSB7XG4gICAgICBjb25zdW1lUHVzaChjb25zdW1lLCBzdGF0ZS5idWZmZXJbbl0pXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAoY29uc3QgY2h1bmsgb2Ygc3RhdGUuYnVmZmVyKSB7XG4gICAgICBjb25zdW1lUHVzaChjb25zdW1lLCBjaHVuaylcbiAgICB9XG4gIH1cblxuICBpZiAoc3RhdGUuZW5kRW1pdHRlZCkge1xuICAgIGNvbnN1bWVFbmQodGhpc1trQ29uc3VtZV0pXG4gIH0gZWxzZSB7XG4gICAgY29uc3VtZS5zdHJlYW0ub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGNvbnN1bWVFbmQodGhpc1trQ29uc3VtZV0pXG4gICAgfSlcbiAgfVxuXG4gIGNvbnN1bWUuc3RyZWFtLnJlc3VtZSgpXG5cbiAgd2hpbGUgKGNvbnN1bWUuc3RyZWFtLnJlYWQoKSAhPSBudWxsKSB7XG4gICAgLy8gTG9vcFxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtCdWZmZXJbXX0gY2h1bmtzXG4gKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoXG4gKi9cbmZ1bmN0aW9uIGNodW5rc0RlY29kZSAoY2h1bmtzLCBsZW5ndGgpIHtcbiAgaWYgKGNodW5rcy5sZW5ndGggPT09IDAgfHwgbGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cbiAgY29uc3QgYnVmZmVyID0gY2h1bmtzLmxlbmd0aCA9PT0gMSA/IGNodW5rc1swXSA6IEJ1ZmZlci5jb25jYXQoY2h1bmtzLCBsZW5ndGgpXG4gIGNvbnN0IGJ1ZmZlckxlbmd0aCA9IGJ1ZmZlci5sZW5ndGhcblxuICAvLyBTa2lwIEJPTS5cbiAgY29uc3Qgc3RhcnQgPVxuICAgIGJ1ZmZlckxlbmd0aCA+IDIgJiZcbiAgICBidWZmZXJbMF0gPT09IDB4ZWYgJiZcbiAgICBidWZmZXJbMV0gPT09IDB4YmIgJiZcbiAgICBidWZmZXJbMl0gPT09IDB4YmZcbiAgICAgID8gM1xuICAgICAgOiAwXG4gIHJldHVybiBidWZmZXIudXRmOFNsaWNlKHN0YXJ0LCBidWZmZXJMZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGNvbnN1bWVFbmQgKGNvbnN1bWUpIHtcbiAgY29uc3QgeyB0eXBlLCBib2R5LCByZXNvbHZlLCBzdHJlYW0sIGxlbmd0aCB9ID0gY29uc3VtZVxuXG4gIHRyeSB7XG4gICAgaWYgKHR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgcmVzb2x2ZShjaHVua3NEZWNvZGUoYm9keSwgbGVuZ3RoKSlcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdqc29uJykge1xuICAgICAgcmVzb2x2ZShKU09OLnBhcnNlKGNodW5rc0RlY29kZShib2R5LCBsZW5ndGgpKSlcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdhcnJheUJ1ZmZlcicpIHtcbiAgICAgIGNvbnN0IGRzdCA9IG5ldyBVaW50OEFycmF5KGxlbmd0aClcblxuICAgICAgbGV0IHBvcyA9IDBcbiAgICAgIGZvciAoY29uc3QgYnVmIG9mIGJvZHkpIHtcbiAgICAgICAgZHN0LnNldChidWYsIHBvcylcbiAgICAgICAgcG9zICs9IGJ1Zi5ieXRlTGVuZ3RoXG4gICAgICB9XG5cbiAgICAgIHJlc29sdmUoZHN0LmJ1ZmZlcilcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdibG9iJykge1xuICAgICAgcmVzb2x2ZShuZXcgQmxvYihib2R5LCB7IHR5cGU6IHN0cmVhbVtrQ29udGVudFR5cGVdIH0pKVxuICAgIH1cblxuICAgIGNvbnN1bWVGaW5pc2goY29uc3VtZSlcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgc3RyZWFtLmRlc3Ryb3koZXJyKVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbnN1bWVQdXNoIChjb25zdW1lLCBjaHVuaykge1xuICBjb25zdW1lLmxlbmd0aCArPSBjaHVuay5sZW5ndGhcbiAgY29uc3VtZS5ib2R5LnB1c2goY2h1bmspXG59XG5cbmZ1bmN0aW9uIGNvbnN1bWVGaW5pc2ggKGNvbnN1bWUsIGVycikge1xuICBpZiAoY29uc3VtZS5ib2R5ID09PSBudWxsKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBpZiAoZXJyKSB7XG4gICAgY29uc3VtZS5yZWplY3QoZXJyKVxuICB9IGVsc2Uge1xuICAgIGNvbnN1bWUucmVzb2x2ZSgpXG4gIH1cblxuICBjb25zdW1lLnR5cGUgPSBudWxsXG4gIGNvbnN1bWUuc3RyZWFtID0gbnVsbFxuICBjb25zdW1lLnJlc29sdmUgPSBudWxsXG4gIGNvbnN1bWUucmVqZWN0ID0gbnVsbFxuICBjb25zdW1lLmxlbmd0aCA9IDBcbiAgY29uc3VtZS5ib2R5ID0gbnVsbFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHsgUmVhZGFibGU6IEJvZHlSZWFkYWJsZSwgY2h1bmtzRGVjb2RlIH1cbiJdLCJuYW1lcyI6WyJhc3NlcnQiLCJyZXF1aXJlIiwiUmVhZGFibGUiLCJSZXF1ZXN0QWJvcnRlZEVycm9yIiwiTm90U3VwcG9ydGVkRXJyb3IiLCJJbnZhbGlkQXJndW1lbnRFcnJvciIsIkFib3J0RXJyb3IiLCJ1dGlsIiwiUmVhZGFibGVTdHJlYW1Gcm9tIiwia0NvbnN1bWUiLCJTeW1ib2wiLCJrUmVhZGluZyIsImtCb2R5Iiwia0Fib3J0Iiwia0NvbnRlbnRUeXBlIiwia0NvbnRlbnRMZW5ndGgiLCJub29wIiwiQm9keVJlYWRhYmxlIiwiY29uc3RydWN0b3IiLCJyZXN1bWUiLCJhYm9ydCIsImNvbnRlbnRUeXBlIiwiY29udGVudExlbmd0aCIsImhpZ2hXYXRlck1hcmsiLCJhdXRvRGVzdHJveSIsInJlYWQiLCJfcmVhZGFibGVTdGF0ZSIsImRhdGFFbWl0dGVkIiwiZGVzdHJveSIsImVyciIsImVuZEVtaXR0ZWQiLCJfZGVzdHJveSIsImNhbGxiYWNrIiwic2V0SW1tZWRpYXRlIiwib24iLCJldiIsImFyZ3MiLCJhZGRMaXN0ZW5lciIsIm9mZiIsInJldCIsImxpc3RlbmVyQ291bnQiLCJyZW1vdmVMaXN0ZW5lciIsInB1c2giLCJjaHVuayIsImNvbnN1bWVQdXNoIiwidGV4dCIsImNvbnN1bWUiLCJqc29uIiwiYmxvYiIsImFycmF5QnVmZmVyIiwiZm9ybURhdGEiLCJib2R5VXNlZCIsImlzRGlzdHVyYmVkIiwiYm9keSIsImdldFJlYWRlciIsImxvY2tlZCIsImR1bXAiLCJvcHRzIiwibGltaXQiLCJOdW1iZXIiLCJpc0Zpbml0ZSIsInNpZ25hbCIsInRocm93SWZBYm9ydGVkIiwiY2xvc2VFbWl0dGVkIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJvbkFib3J0IiwicmVhc29uIiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJhYm9ydGVkIiwibGVuZ3RoIiwiaXNMb2NrZWQiLCJzZWxmIiwiaXNVbnVzYWJsZSIsInN0cmVhbSIsInR5cGUiLCJyU3RhdGUiLCJkZXN0cm95ZWQiLCJUeXBlRXJyb3IiLCJlcnJvcmVkIiwicXVldWVNaWNyb3Rhc2siLCJjb25zdW1lRmluaXNoIiwiY29uc3VtZVN0YXJ0Iiwic3RhdGUiLCJidWZmZXJJbmRleCIsInN0YXJ0IiwiZW5kIiwiYnVmZmVyIiwibiIsImNvbnN1bWVFbmQiLCJjaHVua3NEZWNvZGUiLCJjaHVua3MiLCJCdWZmZXIiLCJjb25jYXQiLCJidWZmZXJMZW5ndGgiLCJ1dGY4U2xpY2UiLCJKU09OIiwicGFyc2UiLCJkc3QiLCJVaW50OEFycmF5IiwicG9zIiwiYnVmIiwic2V0IiwiYnl0ZUxlbmd0aCIsIkJsb2IiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/api/readable.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/api/util.js":
/*!*********************************************!*\
  !*** ./node_modules/undici/lib/api/util.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\");\nconst { ResponseStatusCodeError } = __webpack_require__(/*! ../core/errors */ \"(ssr)/./node_modules/undici/lib/core/errors.js\");\nconst { chunksDecode } = __webpack_require__(/*! ./readable */ \"(ssr)/./node_modules/undici/lib/api/readable.js\");\nconst CHUNK_LIMIT = 128 * 1024;\nasync function getResolveErrorBodyCallback({ callback, body, contentType, statusCode, statusMessage, headers }) {\n    assert(body);\n    let chunks = [];\n    let length = 0;\n    try {\n        for await (const chunk of body){\n            chunks.push(chunk);\n            length += chunk.length;\n            if (length > CHUNK_LIMIT) {\n                chunks = [];\n                length = 0;\n                break;\n            }\n        }\n    } catch  {\n        chunks = [];\n        length = 0;\n    // Do nothing....\n    }\n    const message = `Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : \"\"}`;\n    if (statusCode === 204 || !contentType || !length) {\n        queueMicrotask(()=>callback(new ResponseStatusCodeError(message, statusCode, headers)));\n        return;\n    }\n    const stackTraceLimit = Error.stackTraceLimit;\n    Error.stackTraceLimit = 0;\n    let payload;\n    try {\n        if (isContentTypeApplicationJson(contentType)) {\n            payload = JSON.parse(chunksDecode(chunks, length));\n        } else if (isContentTypeText(contentType)) {\n            payload = chunksDecode(chunks, length);\n        }\n    } catch  {\n    // process in a callback to avoid throwing in the microtask queue\n    } finally{\n        Error.stackTraceLimit = stackTraceLimit;\n    }\n    queueMicrotask(()=>callback(new ResponseStatusCodeError(message, statusCode, headers, payload)));\n}\nconst isContentTypeApplicationJson = (contentType)=>{\n    return contentType.length > 15 && contentType[11] === \"/\" && contentType[0] === \"a\" && contentType[1] === \"p\" && contentType[2] === \"p\" && contentType[3] === \"l\" && contentType[4] === \"i\" && contentType[5] === \"c\" && contentType[6] === \"a\" && contentType[7] === \"t\" && contentType[8] === \"i\" && contentType[9] === \"o\" && contentType[10] === \"n\" && contentType[12] === \"j\" && contentType[13] === \"s\" && contentType[14] === \"o\" && contentType[15] === \"n\";\n};\nconst isContentTypeText = (contentType)=>{\n    return contentType.length > 4 && contentType[4] === \"/\" && contentType[0] === \"t\" && contentType[1] === \"e\" && contentType[2] === \"x\" && contentType[3] === \"t\";\n};\nmodule.exports = {\n    getResolveErrorBodyCallback,\n    isContentTypeApplicationJson,\n    isContentTypeText\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9hcGkvdXRpbC5qcyIsIm1hcHBpbmdzIjoiO0FBQUEsTUFBTUEsU0FBU0MsbUJBQU9BLENBQUM7QUFDdkIsTUFBTSxFQUNKQyx1QkFBQUEsRUFDRCxHQUFHRCxtQkFBT0EsQ0FBQztBQUVaLE1BQU0sRUFBRUUsWUFBQUEsRUFBYyxHQUFHRixtQkFBT0EsQ0FBQztBQUNqQyxNQUFNRyxjQUFjLE1BQU07QUFFMUIsZUFBZUMsNEJBQTZCLEVBQUVDLFFBQVEsRUFBRUMsSUFBSSxFQUFFQyxXQUFXLEVBQUVDLFVBQVUsRUFBRUMsYUFBYSxFQUFFQyxPQUFBQSxFQUFTO0lBQzdHWCxPQUFPTztJQUVQLElBQUlLLFNBQVMsRUFBRTtJQUNmLElBQUlDLFNBQVM7SUFFYixJQUFJO1FBQ0YsV0FBVyxNQUFNQyxTQUFTUCxLQUFNO1lBQzlCSyxPQUFPRyxJQUFJLENBQUNEO1lBQ1pELFVBQVVDLE1BQU1ELE1BQU07WUFDdEIsSUFBSUEsU0FBU1QsYUFBYTtnQkFDeEJRLFNBQVMsRUFBRTtnQkFDWEMsU0FBUztnQkFDVDtZQUNGO1FBQ0Y7SUFDRixFQUFFLE9BQU07UUFDTkQsU0FBUyxFQUFFO1FBQ1hDLFNBQVM7SUFDVDtJQUNGO0lBRUEsTUFBTUcsVUFBVSx3QkFBd0JQLFdBQVUsRUFBR0MsZ0JBQWdCLEtBQUtBLGNBQWEsQ0FBRSxHQUFHLEdBQUUsQ0FBRTtJQUVoRyxJQUFJRCxlQUFlLE9BQU8sQ0FBQ0QsZUFBZSxDQUFDSyxRQUFRO1FBQ2pESSxlQUFlLElBQU1YLFNBQVMsSUFBSUosd0JBQXdCYyxTQUFTUCxZQUFZRTtRQUMvRTtJQUNGO0lBRUEsTUFBTU8sa0JBQWtCQyxNQUFNRCxlQUFlO0lBQzdDQyxNQUFNRCxlQUFlLEdBQUc7SUFDeEIsSUFBSUU7SUFFSixJQUFJO1FBQ0YsSUFBSUMsNkJBQTZCYixjQUFjO1lBQzdDWSxVQUFVRSxLQUFLQyxLQUFLLENBQUNwQixhQUFhUyxRQUFRQztRQUM1QyxPQUFPLElBQUlXLGtCQUFrQmhCLGNBQWM7WUFDekNZLFVBQVVqQixhQUFhUyxRQUFRQztRQUNqQztJQUNGLEVBQUUsT0FBTTtJQUNOO0lBQUEsU0FDUTtRQUNSTSxNQUFNRCxlQUFlLEdBQUdBO0lBQzFCO0lBQ0FELGVBQWUsSUFBTVgsU0FBUyxJQUFJSix3QkFBd0JjLFNBQVNQLFlBQVlFLFNBQVNTO0FBQzFGO0FBRUEsTUFBTUMsK0JBQWdDYixDQUFBQTtJQUNwQyxPQUNFQSxZQUFZSyxNQUFNLEdBQUcsTUFDckJMLFdBQVcsQ0FBQyxHQUFHLEtBQUssT0FDcEJBLFdBQVcsQ0FBQyxFQUFFLEtBQUssT0FDbkJBLFdBQVcsQ0FBQyxFQUFFLEtBQUssT0FDbkJBLFdBQVcsQ0FBQyxFQUFFLEtBQUssT0FDbkJBLFdBQVcsQ0FBQyxFQUFFLEtBQUssT0FDbkJBLFdBQVcsQ0FBQyxFQUFFLEtBQUssT0FDbkJBLFdBQVcsQ0FBQyxFQUFFLEtBQUssT0FDbkJBLFdBQVcsQ0FBQyxFQUFFLEtBQUssT0FDbkJBLFdBQVcsQ0FBQyxFQUFFLEtBQUssT0FDbkJBLFdBQVcsQ0FBQyxFQUFFLEtBQUssT0FDbkJBLFdBQVcsQ0FBQyxFQUFFLEtBQUssT0FDbkJBLFdBQVcsQ0FBQyxHQUFHLEtBQUssT0FDcEJBLFdBQVcsQ0FBQyxHQUFHLEtBQUssT0FDcEJBLFdBQVcsQ0FBQyxHQUFHLEtBQUssT0FDcEJBLFdBQVcsQ0FBQyxHQUFHLEtBQUssT0FDcEJBLFdBQVcsQ0FBQyxHQUFHLEtBQUs7QUFFeEI7QUFFQSxNQUFNZ0Isb0JBQXFCaEIsQ0FBQUE7SUFDekIsT0FDRUEsWUFBWUssTUFBTSxHQUFHLEtBQ3JCTCxXQUFXLENBQUMsRUFBRSxLQUFLLE9BQ25CQSxXQUFXLENBQUMsRUFBRSxLQUFLLE9BQ25CQSxXQUFXLENBQUMsRUFBRSxLQUFLLE9BQ25CQSxXQUFXLENBQUMsRUFBRSxLQUFLLE9BQ25CQSxXQUFXLENBQUMsRUFBRSxLQUFLO0FBRXZCO0FBRUFpQixPQUFPQyxPQUFPLEdBQUc7SUFDZnJCO0lBQ0FnQjtJQUNBRztBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbW9ja3VwZmxvdy8uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2FwaS91dGlsLmpzPzQyN2MiLCJ3ZWJwYWNrOi8vbW9ja3VwZmxvdy8uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2FwaS91dGlsLmpzPzQyN2MqIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ25vZGU6YXNzZXJ0JylcbmNvbnN0IHtcbiAgUmVzcG9uc2VTdGF0dXNDb2RlRXJyb3Jcbn0gPSByZXF1aXJlKCcuLi9jb3JlL2Vycm9ycycpXG5cbmNvbnN0IHsgY2h1bmtzRGVjb2RlIH0gPSByZXF1aXJlKCcuL3JlYWRhYmxlJylcbmNvbnN0IENIVU5LX0xJTUlUID0gMTI4ICogMTAyNFxuXG5hc3luYyBmdW5jdGlvbiBnZXRSZXNvbHZlRXJyb3JCb2R5Q2FsbGJhY2sgKHsgY2FsbGJhY2ssIGJvZHksIGNvbnRlbnRUeXBlLCBzdGF0dXNDb2RlLCBzdGF0dXNNZXNzYWdlLCBoZWFkZXJzIH0pIHtcbiAgYXNzZXJ0KGJvZHkpXG5cbiAgbGV0IGNodW5rcyA9IFtdXG4gIGxldCBsZW5ndGggPSAwXG5cbiAgdHJ5IHtcbiAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIGJvZHkpIHtcbiAgICAgIGNodW5rcy5wdXNoKGNodW5rKVxuICAgICAgbGVuZ3RoICs9IGNodW5rLmxlbmd0aFxuICAgICAgaWYgKGxlbmd0aCA+IENIVU5LX0xJTUlUKSB7XG4gICAgICAgIGNodW5rcyA9IFtdXG4gICAgICAgIGxlbmd0aCA9IDBcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2gge1xuICAgIGNodW5rcyA9IFtdXG4gICAgbGVuZ3RoID0gMFxuICAgIC8vIERvIG5vdGhpbmcuLi4uXG4gIH1cblxuICBjb25zdCBtZXNzYWdlID0gYFJlc3BvbnNlIHN0YXR1cyBjb2RlICR7c3RhdHVzQ29kZX0ke3N0YXR1c01lc3NhZ2UgPyBgOiAke3N0YXR1c01lc3NhZ2V9YCA6ICcnfWBcblxuICBpZiAoc3RhdHVzQ29kZSA9PT0gMjA0IHx8ICFjb250ZW50VHlwZSB8fCAhbGVuZ3RoKSB7XG4gICAgcXVldWVNaWNyb3Rhc2soKCkgPT4gY2FsbGJhY2sobmV3IFJlc3BvbnNlU3RhdHVzQ29kZUVycm9yKG1lc3NhZ2UsIHN0YXR1c0NvZGUsIGhlYWRlcnMpKSlcbiAgICByZXR1cm5cbiAgfVxuXG4gIGNvbnN0IHN0YWNrVHJhY2VMaW1pdCA9IEVycm9yLnN0YWNrVHJhY2VMaW1pdFxuICBFcnJvci5zdGFja1RyYWNlTGltaXQgPSAwXG4gIGxldCBwYXlsb2FkXG5cbiAgdHJ5IHtcbiAgICBpZiAoaXNDb250ZW50VHlwZUFwcGxpY2F0aW9uSnNvbihjb250ZW50VHlwZSkpIHtcbiAgICAgIHBheWxvYWQgPSBKU09OLnBhcnNlKGNodW5rc0RlY29kZShjaHVua3MsIGxlbmd0aCkpXG4gICAgfSBlbHNlIGlmIChpc0NvbnRlbnRUeXBlVGV4dChjb250ZW50VHlwZSkpIHtcbiAgICAgIHBheWxvYWQgPSBjaHVua3NEZWNvZGUoY2h1bmtzLCBsZW5ndGgpXG4gICAgfVxuICB9IGNhdGNoIHtcbiAgICAvLyBwcm9jZXNzIGluIGEgY2FsbGJhY2sgdG8gYXZvaWQgdGhyb3dpbmcgaW4gdGhlIG1pY3JvdGFzayBxdWV1ZVxuICB9IGZpbmFsbHkge1xuICAgIEVycm9yLnN0YWNrVHJhY2VMaW1pdCA9IHN0YWNrVHJhY2VMaW1pdFxuICB9XG4gIHF1ZXVlTWljcm90YXNrKCgpID0+IGNhbGxiYWNrKG5ldyBSZXNwb25zZVN0YXR1c0NvZGVFcnJvcihtZXNzYWdlLCBzdGF0dXNDb2RlLCBoZWFkZXJzLCBwYXlsb2FkKSkpXG59XG5cbmNvbnN0IGlzQ29udGVudFR5cGVBcHBsaWNhdGlvbkpzb24gPSAoY29udGVudFR5cGUpID0+IHtcbiAgcmV0dXJuIChcbiAgICBjb250ZW50VHlwZS5sZW5ndGggPiAxNSAmJlxuICAgIGNvbnRlbnRUeXBlWzExXSA9PT0gJy8nICYmXG4gICAgY29udGVudFR5cGVbMF0gPT09ICdhJyAmJlxuICAgIGNvbnRlbnRUeXBlWzFdID09PSAncCcgJiZcbiAgICBjb250ZW50VHlwZVsyXSA9PT0gJ3AnICYmXG4gICAgY29udGVudFR5cGVbM10gPT09ICdsJyAmJlxuICAgIGNvbnRlbnRUeXBlWzRdID09PSAnaScgJiZcbiAgICBjb250ZW50VHlwZVs1XSA9PT0gJ2MnICYmXG4gICAgY29udGVudFR5cGVbNl0gPT09ICdhJyAmJlxuICAgIGNvbnRlbnRUeXBlWzddID09PSAndCcgJiZcbiAgICBjb250ZW50VHlwZVs4XSA9PT0gJ2knICYmXG4gICAgY29udGVudFR5cGVbOV0gPT09ICdvJyAmJlxuICAgIGNvbnRlbnRUeXBlWzEwXSA9PT0gJ24nICYmXG4gICAgY29udGVudFR5cGVbMTJdID09PSAnaicgJiZcbiAgICBjb250ZW50VHlwZVsxM10gPT09ICdzJyAmJlxuICAgIGNvbnRlbnRUeXBlWzE0XSA9PT0gJ28nICYmXG4gICAgY29udGVudFR5cGVbMTVdID09PSAnbidcbiAgKVxufVxuXG5jb25zdCBpc0NvbnRlbnRUeXBlVGV4dCA9IChjb250ZW50VHlwZSkgPT4ge1xuICByZXR1cm4gKFxuICAgIGNvbnRlbnRUeXBlLmxlbmd0aCA+IDQgJiZcbiAgICBjb250ZW50VHlwZVs0XSA9PT0gJy8nICYmXG4gICAgY29udGVudFR5cGVbMF0gPT09ICd0JyAmJlxuICAgIGNvbnRlbnRUeXBlWzFdID09PSAnZScgJiZcbiAgICBjb250ZW50VHlwZVsyXSA9PT0gJ3gnICYmXG4gICAgY29udGVudFR5cGVbM10gPT09ICd0J1xuICApXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBnZXRSZXNvbHZlRXJyb3JCb2R5Q2FsbGJhY2ssXG4gIGlzQ29udGVudFR5cGVBcHBsaWNhdGlvbkpzb24sXG4gIGlzQ29udGVudFR5cGVUZXh0XG59XG4iXSwibmFtZXMiOlsiYXNzZXJ0IiwicmVxdWlyZSIsIlJlc3BvbnNlU3RhdHVzQ29kZUVycm9yIiwiY2h1bmtzRGVjb2RlIiwiQ0hVTktfTElNSVQiLCJnZXRSZXNvbHZlRXJyb3JCb2R5Q2FsbGJhY2siLCJjYWxsYmFjayIsImJvZHkiLCJjb250ZW50VHlwZSIsInN0YXR1c0NvZGUiLCJzdGF0dXNNZXNzYWdlIiwiaGVhZGVycyIsImNodW5rcyIsImxlbmd0aCIsImNodW5rIiwicHVzaCIsIm1lc3NhZ2UiLCJxdWV1ZU1pY3JvdGFzayIsInN0YWNrVHJhY2VMaW1pdCIsIkVycm9yIiwicGF5bG9hZCIsImlzQ29udGVudFR5cGVBcHBsaWNhdGlvbkpzb24iLCJKU09OIiwicGFyc2UiLCJpc0NvbnRlbnRUeXBlVGV4dCIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/api/util.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/core/connect.js":
/*!*************************************************!*\
  !*** ./node_modules/undici/lib/core/connect.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst net = __webpack_require__(/*! node:net */ \"node:net\");\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\");\nconst util = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/undici/lib/core/util.js\");\nconst { InvalidArgumentError, ConnectTimeoutError } = __webpack_require__(/*! ./errors */ \"(ssr)/./node_modules/undici/lib/core/errors.js\");\nlet tls; // include tls conditionally since it is not always available\n// TODO: session re-use does not wait for the first\n// connection to resolve the session and might therefore\n// resolve the same servername multiple times even when\n// re-use is enabled.\nlet SessionCache;\n// FIXME: remove workaround when the Node bug is fixed\n// https://github.com/nodejs/node/issues/49344#issuecomment-1741776308\nif (global.FinalizationRegistry && !(process.env.NODE_V8_COVERAGE || process.env.UNDICI_NO_FG)) {\n    SessionCache = class WeakSessionCache {\n        constructor(maxCachedSessions){\n            this._maxCachedSessions = maxCachedSessions;\n            this._sessionCache = new Map();\n            this._sessionRegistry = new global.FinalizationRegistry((key)=>{\n                if (this._sessionCache.size < this._maxCachedSessions) {\n                    return;\n                }\n                const ref = this._sessionCache.get(key);\n                if (ref !== undefined && ref.deref() === undefined) {\n                    this._sessionCache.delete(key);\n                }\n            });\n        }\n        get(sessionKey) {\n            const ref = this._sessionCache.get(sessionKey);\n            return ref ? ref.deref() : null;\n        }\n        set(sessionKey, session) {\n            if (this._maxCachedSessions === 0) {\n                return;\n            }\n            this._sessionCache.set(sessionKey, new WeakRef(session));\n            this._sessionRegistry.register(session, sessionKey);\n        }\n    };\n} else {\n    SessionCache = class SimpleSessionCache {\n        constructor(maxCachedSessions){\n            this._maxCachedSessions = maxCachedSessions;\n            this._sessionCache = new Map();\n        }\n        get(sessionKey) {\n            return this._sessionCache.get(sessionKey);\n        }\n        set(sessionKey, session) {\n            if (this._maxCachedSessions === 0) {\n                return;\n            }\n            if (this._sessionCache.size >= this._maxCachedSessions) {\n                // remove the oldest session\n                const { value: oldestKey } = this._sessionCache.keys().next();\n                this._sessionCache.delete(oldestKey);\n            }\n            this._sessionCache.set(sessionKey, session);\n        }\n    };\n}\nfunction buildConnector({ allowH2, maxCachedSessions, socketPath, timeout, session: customSession, ...opts }) {\n    if (maxCachedSessions != null && (!Number.isInteger(maxCachedSessions) || maxCachedSessions < 0)) {\n        throw new InvalidArgumentError(\"maxCachedSessions must be a positive integer or zero\");\n    }\n    const options = {\n        path: socketPath,\n        ...opts\n    };\n    const sessionCache = new SessionCache(maxCachedSessions == null ? 100 : maxCachedSessions);\n    timeout = timeout == null ? 10e3 : timeout;\n    allowH2 = allowH2 != null ? allowH2 : false;\n    return function connect({ hostname, host, protocol, port, servername, localAddress, httpSocket }, callback) {\n        let socket;\n        if (protocol === \"https:\") {\n            if (!tls) {\n                tls = __webpack_require__(/*! node:tls */ \"node:tls\");\n            }\n            servername = servername || options.servername || util.getServerName(host) || null;\n            const sessionKey = servername || hostname;\n            const session = customSession || sessionCache.get(sessionKey) || null;\n            assert(sessionKey);\n            socket = tls.connect({\n                highWaterMark: 16384,\n                // TLS in node can't have bigger HWM anyway...\n                ...options,\n                servername,\n                session,\n                localAddress,\n                // TODO(HTTP/2): Add support for h2c\n                ALPNProtocols: allowH2 ? [\n                    \"http/1.1\",\n                    \"h2\"\n                ] : [\n                    \"http/1.1\"\n                ],\n                socket: httpSocket,\n                // upgrade socket connection\n                port: port || 443,\n                host: hostname\n            });\n            socket.on(\"session\", function(session) {\n                // TODO (fix): Can a session become invalid once established? Don't think so?\n                sessionCache.set(sessionKey, session);\n            });\n        } else {\n            assert(!httpSocket, \"httpSocket can only be sent on TLS update\");\n            socket = net.connect({\n                highWaterMark: 64 * 1024,\n                // Same as nodejs fs streams.\n                ...options,\n                localAddress,\n                port: port || 80,\n                host: hostname\n            });\n        }\n        // Set TCP keep alive options on the socket here instead of in connect() for the case of assigning the socket\n        if (options.keepAlive == null || options.keepAlive) {\n            const keepAliveInitialDelay = options.keepAliveInitialDelay === undefined ? 60e3 : options.keepAliveInitialDelay;\n            socket.setKeepAlive(true, keepAliveInitialDelay);\n        }\n        const cancelTimeout = setupTimeout(()=>onConnectTimeout(socket), timeout);\n        socket.setNoDelay(true).once(protocol === \"https:\" ? \"secureConnect\" : \"connect\", function() {\n            cancelTimeout();\n            if (callback) {\n                const cb = callback;\n                callback = null;\n                cb(null, this);\n            }\n        }).on(\"error\", function(err) {\n            cancelTimeout();\n            if (callback) {\n                const cb = callback;\n                callback = null;\n                cb(err);\n            }\n        });\n        return socket;\n    };\n}\nfunction setupTimeout(onConnectTimeout, timeout) {\n    if (!timeout) {\n        return ()=>{};\n    }\n    let s1 = null;\n    let s2 = null;\n    const timeoutId = setTimeout(()=>{\n        // setImmediate is added to make sure that we prioritize socket error events over timeouts\n        s1 = setImmediate(()=>{\n            if (process.platform === \"win32\") {\n                // Windows needs an extra setImmediate probably due to implementation differences in the socket logic\n                s2 = setImmediate(()=>onConnectTimeout());\n            } else {\n                onConnectTimeout();\n            }\n        });\n    }, timeout);\n    return ()=>{\n        clearTimeout(timeoutId);\n        clearImmediate(s1);\n        clearImmediate(s2);\n    };\n}\nfunction onConnectTimeout(socket) {\n    let message = \"Connect Timeout Error\";\n    if (Array.isArray(socket.autoSelectFamilyAttemptedAddresses)) {\n        message += ` (attempted addresses: ${socket.autoSelectFamilyAttemptedAddresses.join(\", \")})`;\n    }\n    util.destroy(socket, new ConnectTimeoutError(message));\n}\nmodule.exports = buildConnector;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9jb3JlL2Nvbm5lY3QuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNQSxNQUFNQyxtQkFBT0EsQ0FBQztBQUNwQixNQUFNQyxTQUFTRCxtQkFBT0EsQ0FBQztBQUN2QixNQUFNRSxPQUFPRixtQkFBT0EsQ0FBQztBQUNyQixNQUFNLEVBQUVHLG9CQUFvQixFQUFFQyxtQkFBQUEsRUFBcUIsR0FBR0osbUJBQU9BLENBQUM7QUFFOUQsSUFBSUssS0FBSTtBQUVSO0FBQ0E7QUFDQTtBQUNBO0FBRUEsSUFBSUM7QUFDSjtBQUNBO0FBQ0EsSUFBSUMsT0FBT0Msb0JBQW9CLElBQUksQ0FBRUMsQ0FBQUEsUUFBUUMsR0FBRyxDQUFDQyxnQkFBZ0IsSUFBSUYsUUFBUUMsR0FBRyxDQUFDRSxZQUFZLEdBQUc7SUFDOUZOLGVBQWUsTUFBTU87UUFDbkJDLFlBQWFDLGlCQUFpQixDQUFFO1lBQzlCLElBQUksQ0FBQ0Msa0JBQWtCLEdBQUdEO1lBQzFCLElBQUksQ0FBQ0UsYUFBYSxHQUFHLElBQUlDO1lBQ3pCLElBQUksQ0FBQ0MsZ0JBQWdCLEdBQUcsSUFBSVosT0FBT0Msb0JBQW9CLENBQUVZLENBQUFBO2dCQUN2RCxJQUFJLElBQUksQ0FBQ0gsYUFBYSxDQUFDSSxJQUFJLEdBQUcsSUFBSSxDQUFDTCxrQkFBa0IsRUFBRTtvQkFDckQ7Z0JBQ0Y7Z0JBRUEsTUFBTU0sTUFBTSxJQUFJLENBQUNMLGFBQWEsQ0FBQ00sR0FBRyxDQUFDSDtnQkFDbkMsSUFBSUUsUUFBUUUsYUFBYUYsSUFBSUcsS0FBSyxPQUFPRCxXQUFXO29CQUNsRCxJQUFJLENBQUNQLGFBQWEsQ0FBQ1MsTUFBTSxDQUFDTjtnQkFDNUI7WUFDRjtRQUNGO1FBRUFHLElBQUtJLFVBQVUsRUFBRTtZQUNmLE1BQU1MLE1BQU0sSUFBSSxDQUFDTCxhQUFhLENBQUNNLEdBQUcsQ0FBQ0k7WUFDbkMsT0FBT0wsTUFBTUEsSUFBSUcsS0FBSyxLQUFLO1FB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RjtBQUVBLFNBQVNOLGlCQUFrQlYsTUFBTTtJQUMvQixJQUFJdUIsVUFBVTtJQUNkLElBQUlDLE1BQU1DLE9BQU8sQ0FBQ3pCLE9BQU8wQixrQ0FBa0MsR0FBRztRQUM1REgsV0FBVywwQkFBMEJ2QixPQUFPMEIsa0NBQWtDLENBQUNDLElBQUksQ0FBQyxNQUFLLEVBQUc7SUFDOUY7SUFDQWxGLEtBQUttRixPQUFPLENBQUM1QixRQUFRLElBQUlyRCxvQkFBb0I0RTtBQUMvQztBQUVBTSxPQUFPQyxPQUFPLEdBQUdsRCIsInNvdXJjZXMiOlsid2VicGFjazovL21vY2t1cGZsb3cvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9jb3JlL2Nvbm5lY3QuanM/OWJlYiIsIndlYnBhY2s6Ly9tb2NrdXBmbG93Ly4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvY29yZS9jb25uZWN0LmpzPzliZWIqIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBuZXQgPSByZXF1aXJlKCdub2RlOm5ldCcpXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdub2RlOmFzc2VydCcpXG5jb25zdCB1dGlsID0gcmVxdWlyZSgnLi91dGlsJylcbmNvbnN0IHsgSW52YWxpZEFyZ3VtZW50RXJyb3IsIENvbm5lY3RUaW1lb3V0RXJyb3IgfSA9IHJlcXVpcmUoJy4vZXJyb3JzJylcblxubGV0IHRscyAvLyBpbmNsdWRlIHRscyBjb25kaXRpb25hbGx5IHNpbmNlIGl0IGlzIG5vdCBhbHdheXMgYXZhaWxhYmxlXG5cbi8vIFRPRE86IHNlc3Npb24gcmUtdXNlIGRvZXMgbm90IHdhaXQgZm9yIHRoZSBmaXJzdFxuLy8gY29ubmVjdGlvbiB0byByZXNvbHZlIHRoZSBzZXNzaW9uIGFuZCBtaWdodCB0aGVyZWZvcmVcbi8vIHJlc29sdmUgdGhlIHNhbWUgc2VydmVybmFtZSBtdWx0aXBsZSB0aW1lcyBldmVuIHdoZW5cbi8vIHJlLXVzZSBpcyBlbmFibGVkLlxuXG5sZXQgU2Vzc2lvbkNhY2hlXG4vLyBGSVhNRTogcmVtb3ZlIHdvcmthcm91bmQgd2hlbiB0aGUgTm9kZSBidWcgaXMgZml4ZWRcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9pc3N1ZXMvNDkzNDQjaXNzdWVjb21tZW50LTE3NDE3NzYzMDhcbmlmIChnbG9iYWwuRmluYWxpemF0aW9uUmVnaXN0cnkgJiYgIShwcm9jZXNzLmVudi5OT0RFX1Y4X0NPVkVSQUdFIHx8IHByb2Nlc3MuZW52LlVORElDSV9OT19GRykpIHtcbiAgU2Vzc2lvbkNhY2hlID0gY2xhc3MgV2Vha1Nlc3Npb25DYWNoZSB7XG4gICAgY29uc3RydWN0b3IgKG1heENhY2hlZFNlc3Npb25zKSB7XG4gICAgICB0aGlzLl9tYXhDYWNoZWRTZXNzaW9ucyA9IG1heENhY2hlZFNlc3Npb25zXG4gICAgICB0aGlzLl9zZXNzaW9uQ2FjaGUgPSBuZXcgTWFwKClcbiAgICAgIHRoaXMuX3Nlc3Npb25SZWdpc3RyeSA9IG5ldyBnbG9iYWwuRmluYWxpemF0aW9uUmVnaXN0cnkoKGtleSkgPT4ge1xuICAgICAgICBpZiAodGhpcy5fc2Vzc2lvbkNhY2hlLnNpemUgPCB0aGlzLl9tYXhDYWNoZWRTZXNzaW9ucykge1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVmID0gdGhpcy5fc2Vzc2lvbkNhY2hlLmdldChrZXkpXG4gICAgICAgIGlmIChyZWYgIT09IHVuZGVmaW5lZCAmJiByZWYuZGVyZWYoKSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5fc2Vzc2lvbkNhY2hlLmRlbGV0ZShrZXkpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuXG4gICAgZ2V0IChzZXNzaW9uS2V5KSB7XG4gICAgICBjb25zdCByZWYgPSB0aGlzLl9zZXNzaW9uQ2FjaGUuZ2V0KHNlc3Npb25LZXkpXG4gICAgICByZXR1cm4gcmVmID8gcmVmLmRlcmVmKCkgOiBudWxsXG4gICAgfVxuXG4gICAgc2V0IChzZXNzaW9uS2V5LCBzZXNzaW9uKSB7XG4gICAgICBpZiAodGhpcy5fbWF4Q2FjaGVkU2Vzc2lvbnMgPT09IDApIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3Nlc3Npb25DYWNoZS5zZXQoc2Vzc2lvbktleSwgbmV3IFdlYWtSZWYoc2Vzc2lvbikpXG4gICAgICB0aGlzLl9zZXNzaW9uUmVnaXN0cnkucmVnaXN0ZXIoc2Vzc2lvbiwgc2Vzc2lvbktleSlcbiAgICB9XG4gIH1cbn0gZWxzZSB7XG4gIFNlc3Npb25DYWNoZSA9IGNsYXNzIFNpbXBsZVNlc3Npb25DYWNoZSB7XG4gICAgY29uc3RydWN0b3IgKG1heENhY2hlZFNlc3Npb25zKSB7XG4gICAgICB0aGlzLl9tYXhDYWNoZWRTZXNzaW9ucyA9IG1heENhY2hlZFNlc3Npb25zXG4gICAgICB0aGlzLl9zZXNzaW9uQ2FjaGUgPSBuZXcgTWFwKClcbiAgICB9XG5cbiAgICBnZXQgKHNlc3Npb25LZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zZXNzaW9uQ2FjaGUuZ2V0KHNlc3Npb25LZXkpXG4gICAgfVxuXG4gICAgc2V0IChzZXNzaW9uS2V5LCBzZXNzaW9uKSB7XG4gICAgICBpZiAodGhpcy5fbWF4Q2FjaGVkU2Vzc2lvbnMgPT09IDApIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9zZXNzaW9uQ2FjaGUuc2l6ZSA+PSB0aGlzLl9tYXhDYWNoZWRTZXNzaW9ucykge1xuICAgICAgICAvLyByZW1vdmUgdGhlIG9sZGVzdCBzZXNzaW9uXG4gICAgICAgIGNvbnN0IHsgdmFsdWU6IG9sZGVzdEtleSB9ID0gdGhpcy5fc2Vzc2lvbkNhY2hlLmtleXMoKS5uZXh0KClcbiAgICAgICAgdGhpcy5fc2Vzc2lvbkNhY2hlLmRlbGV0ZShvbGRlc3RLZXkpXG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3Nlc3Npb25DYWNoZS5zZXQoc2Vzc2lvbktleSwgc2Vzc2lvbilcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYnVpbGRDb25uZWN0b3IgKHsgYWxsb3dIMiwgbWF4Q2FjaGVkU2Vzc2lvbnMsIHNvY2tldFBhdGgsIHRpbWVvdXQsIHNlc3Npb246IGN1c3RvbVNlc3Npb24sIC4uLm9wdHMgfSkge1xuICBpZiAobWF4Q2FjaGVkU2Vzc2lvbnMgIT0gbnVsbCAmJiAoIU51bWJlci5pc0ludGVnZXIobWF4Q2FjaGVkU2Vzc2lvbnMpIHx8IG1heENhY2hlZFNlc3Npb25zIDwgMCkpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ21heENhY2hlZFNlc3Npb25zIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyIG9yIHplcm8nKVxuICB9XG5cbiAgY29uc3Qgb3B0aW9ucyA9IHsgcGF0aDogc29ja2V0UGF0aCwgLi4ub3B0cyB9XG4gIGNvbnN0IHNlc3Npb25DYWNoZSA9IG5ldyBTZXNzaW9uQ2FjaGUobWF4Q2FjaGVkU2Vzc2lvbnMgPT0gbnVsbCA/IDEwMCA6IG1heENhY2hlZFNlc3Npb25zKVxuICB0aW1lb3V0ID0gdGltZW91dCA9PSBudWxsID8gMTBlMyA6IHRpbWVvdXRcbiAgYWxsb3dIMiA9IGFsbG93SDIgIT0gbnVsbCA/IGFsbG93SDIgOiBmYWxzZVxuICByZXR1cm4gZnVuY3Rpb24gY29ubmVjdCAoeyBob3N0bmFtZSwgaG9zdCwgcHJvdG9jb2wsIHBvcnQsIHNlcnZlcm5hbWUsIGxvY2FsQWRkcmVzcywgaHR0cFNvY2tldCB9LCBjYWxsYmFjaykge1xuICAgIGxldCBzb2NrZXRcbiAgICBpZiAocHJvdG9jb2wgPT09ICdodHRwczonKSB7XG4gICAgICBpZiAoIXRscykge1xuICAgICAgICB0bHMgPSByZXF1aXJlKCdub2RlOnRscycpXG4gICAgICB9XG4gICAgICBzZXJ2ZXJuYW1lID0gc2VydmVybmFtZSB8fCBvcHRpb25zLnNlcnZlcm5hbWUgfHwgdXRpbC5nZXRTZXJ2ZXJOYW1lKGhvc3QpIHx8IG51bGxcblxuICAgICAgY29uc3Qgc2Vzc2lvbktleSA9IHNlcnZlcm5hbWUgfHwgaG9zdG5hbWVcbiAgICAgIGNvbnN0IHNlc3Npb24gPSBjdXN0b21TZXNzaW9uIHx8IHNlc3Npb25DYWNoZS5nZXQoc2Vzc2lvbktleSkgfHwgbnVsbFxuXG4gICAgICBhc3NlcnQoc2Vzc2lvbktleSlcblxuICAgICAgc29ja2V0ID0gdGxzLmNvbm5lY3Qoe1xuICAgICAgICBoaWdoV2F0ZXJNYXJrOiAxNjM4NCwgLy8gVExTIGluIG5vZGUgY2FuJ3QgaGF2ZSBiaWdnZXIgSFdNIGFueXdheS4uLlxuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICBzZXJ2ZXJuYW1lLFxuICAgICAgICBzZXNzaW9uLFxuICAgICAgICBsb2NhbEFkZHJlc3MsXG4gICAgICAgIC8vIFRPRE8oSFRUUC8yKTogQWRkIHN1cHBvcnQgZm9yIGgyY1xuICAgICAgICBBTFBOUHJvdG9jb2xzOiBhbGxvd0gyID8gWydodHRwLzEuMScsICdoMiddIDogWydodHRwLzEuMSddLFxuICAgICAgICBzb2NrZXQ6IGh0dHBTb2NrZXQsIC8vIHVwZ3JhZGUgc29ja2V0IGNvbm5lY3Rpb25cbiAgICAgICAgcG9ydDogcG9ydCB8fCA0NDMsXG4gICAgICAgIGhvc3Q6IGhvc3RuYW1lXG4gICAgICB9KVxuXG4gICAgICBzb2NrZXRcbiAgICAgICAgLm9uKCdzZXNzaW9uJywgZnVuY3Rpb24gKHNlc3Npb24pIHtcbiAgICAgICAgICAvLyBUT0RPIChmaXgpOiBDYW4gYSBzZXNzaW9uIGJlY29tZSBpbnZhbGlkIG9uY2UgZXN0YWJsaXNoZWQ/IERvbid0IHRoaW5rIHNvP1xuICAgICAgICAgIHNlc3Npb25DYWNoZS5zZXQoc2Vzc2lvbktleSwgc2Vzc2lvbilcbiAgICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzZXJ0KCFodHRwU29ja2V0LCAnaHR0cFNvY2tldCBjYW4gb25seSBiZSBzZW50IG9uIFRMUyB1cGRhdGUnKVxuICAgICAgc29ja2V0ID0gbmV0LmNvbm5lY3Qoe1xuICAgICAgICBoaWdoV2F0ZXJNYXJrOiA2NCAqIDEwMjQsIC8vIFNhbWUgYXMgbm9kZWpzIGZzIHN0cmVhbXMuXG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIGxvY2FsQWRkcmVzcyxcbiAgICAgICAgcG9ydDogcG9ydCB8fCA4MCxcbiAgICAgICAgaG9zdDogaG9zdG5hbWVcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgLy8gU2V0IFRDUCBrZWVwIGFsaXZlIG9wdGlvbnMgb24gdGhlIHNvY2tldCBoZXJlIGluc3RlYWQgb2YgaW4gY29ubmVjdCgpIGZvciB0aGUgY2FzZSBvZiBhc3NpZ25pbmcgdGhlIHNvY2tldFxuICAgIGlmIChvcHRpb25zLmtlZXBBbGl2ZSA9PSBudWxsIHx8IG9wdGlvbnMua2VlcEFsaXZlKSB7XG4gICAgICBjb25zdCBrZWVwQWxpdmVJbml0aWFsRGVsYXkgPSBvcHRpb25zLmtlZXBBbGl2ZUluaXRpYWxEZWxheSA9PT0gdW5kZWZpbmVkID8gNjBlMyA6IG9wdGlvbnMua2VlcEFsaXZlSW5pdGlhbERlbGF5XG4gICAgICBzb2NrZXQuc2V0S2VlcEFsaXZlKHRydWUsIGtlZXBBbGl2ZUluaXRpYWxEZWxheSlcbiAgICB9XG5cbiAgICBjb25zdCBjYW5jZWxUaW1lb3V0ID0gc2V0dXBUaW1lb3V0KCgpID0+IG9uQ29ubmVjdFRpbWVvdXQoc29ja2V0KSwgdGltZW91dClcblxuICAgIHNvY2tldFxuICAgICAgLnNldE5vRGVsYXkodHJ1ZSlcbiAgICAgIC5vbmNlKHByb3RvY29sID09PSAnaHR0cHM6JyA/ICdzZWN1cmVDb25uZWN0JyA6ICdjb25uZWN0JywgZnVuY3Rpb24gKCkge1xuICAgICAgICBjYW5jZWxUaW1lb3V0KClcblxuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICBjb25zdCBjYiA9IGNhbGxiYWNrXG4gICAgICAgICAgY2FsbGJhY2sgPSBudWxsXG4gICAgICAgICAgY2IobnVsbCwgdGhpcylcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIC5vbignZXJyb3InLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGNhbmNlbFRpbWVvdXQoKVxuXG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgIGNvbnN0IGNiID0gY2FsbGJhY2tcbiAgICAgICAgICBjYWxsYmFjayA9IG51bGxcbiAgICAgICAgICBjYihlcnIpXG4gICAgICAgIH1cbiAgICAgIH0pXG5cbiAgICByZXR1cm4gc29ja2V0XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0dXBUaW1lb3V0IChvbkNvbm5lY3RUaW1lb3V0LCB0aW1lb3V0KSB7XG4gIGlmICghdGltZW91dCkge1xuICAgIHJldHVybiAoKSA9PiB7fVxuICB9XG5cbiAgbGV0IHMxID0gbnVsbFxuICBsZXQgczIgPSBudWxsXG4gIGNvbnN0IHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgIC8vIHNldEltbWVkaWF0ZSBpcyBhZGRlZCB0byBtYWtlIHN1cmUgdGhhdCB3ZSBwcmlvcml0aXplIHNvY2tldCBlcnJvciBldmVudHMgb3ZlciB0aW1lb3V0c1xuICAgIHMxID0gc2V0SW1tZWRpYXRlKCgpID0+IHtcbiAgICAgIGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInKSB7XG4gICAgICAgIC8vIFdpbmRvd3MgbmVlZHMgYW4gZXh0cmEgc2V0SW1tZWRpYXRlIHByb2JhYmx5IGR1ZSB0byBpbXBsZW1lbnRhdGlvbiBkaWZmZXJlbmNlcyBpbiB0aGUgc29ja2V0IGxvZ2ljXG4gICAgICAgIHMyID0gc2V0SW1tZWRpYXRlKCgpID0+IG9uQ29ubmVjdFRpbWVvdXQoKSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9uQ29ubmVjdFRpbWVvdXQoKVxuICAgICAgfVxuICAgIH0pXG4gIH0sIHRpbWVvdXQpXG4gIHJldHVybiAoKSA9PiB7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZClcbiAgICBjbGVhckltbWVkaWF0ZShzMSlcbiAgICBjbGVhckltbWVkaWF0ZShzMilcbiAgfVxufVxuXG5mdW5jdGlvbiBvbkNvbm5lY3RUaW1lb3V0IChzb2NrZXQpIHtcbiAgbGV0IG1lc3NhZ2UgPSAnQ29ubmVjdCBUaW1lb3V0IEVycm9yJ1xuICBpZiAoQXJyYXkuaXNBcnJheShzb2NrZXQuYXV0b1NlbGVjdEZhbWlseUF0dGVtcHRlZEFkZHJlc3NlcykpIHtcbiAgICBtZXNzYWdlICs9IGAgKGF0dGVtcHRlZCBhZGRyZXNzZXM6ICR7c29ja2V0LmF1dG9TZWxlY3RGYW1pbHlBdHRlbXB0ZWRBZGRyZXNzZXMuam9pbignLCAnKX0pYFxuICB9XG4gIHV0aWwuZGVzdHJveShzb2NrZXQsIG5ldyBDb25uZWN0VGltZW91dEVycm9yKG1lc3NhZ2UpKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJ1aWxkQ29ubmVjdG9yXG4iXSwibmFtZXMiOlsibmV0IiwicmVxdWlyZSIsImFzc2VydCIsInV0aWwiLCJJbnZhbGlkQXJndW1lbnRFcnJvciIsIkNvbm5lY3RUaW1lb3V0RXJyb3IiLCJ0bHMiLCJTZXNzaW9uQ2FjaGUiLCJnbG9iYWwiLCJGaW5hbGl6YXRpb25SZWdpc3RyeSIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX1Y4X0NPVkVSQUdFIiwiVU5ESUNJX05PX0ZHIiwiV2Vha1Nlc3Npb25DYWNoZSIsImNvbnN0cnVjdG9yIiwibWF4Q2FjaGVkU2Vzc2lvbnMiLCJfbWF4Q2FjaGVkU2Vzc2lvbnMiLCJfc2Vzc2lvbkNhY2hlIiwiTWFwIiwiX3Nlc3Npb25SZWdpc3RyeSIsImtleSIsInNpemUiLCJyZWYiLCJnZXQiLCJ1bmRlZmluZWQiLCJkZXJlZiIsImRlbGV0ZSIsInNlc3Npb25LZXkiLCJzZXQiLCJzZXNzaW9uIiwiV2Vha1JlZiIsInJlZ2lzdGVyIiwiU2ltcGxlU2Vzc2lvbkNhY2hlIiwidmFsdWUiLCJvbGRlc3RLZXkiLCJrZXlzIiwibmV4dCIsImJ1aWxkQ29ubmVjdG9yIiwiYWxsb3dIMiIsInNvY2tldFBhdGgiLCJ0aW1lb3V0IiwiY3VzdG9tU2Vzc2lvbiIsIm9wdHMiLCJOdW1iZXIiLCJpc0ludGVnZXIiLCJvcHRpb25zIiwicGF0aCIsInNlc3Npb25DYWNoZSIsImNvbm5lY3QiLCJob3N0bmFtZSIsImhvc3QiLCJwcm90b2NvbCIsInBvcnQiLCJzZXJ2ZXJuYW1lIiwibG9jYWxBZGRyZXNzIiwiaHR0cFNvY2tldCIsImNhbGxiYWNrIiwic29ja2V0IiwiZ2V0U2VydmVyTmFtZSIsImhpZ2hXYXRlck1hcmsiLCJBTFBOUHJvdG9jb2xzIiwib24iLCJrZWVwQWxpdmUiLCJrZWVwQWxpdmVJbml0aWFsRGVsYXkiLCJzZXRLZWVwQWxpdmUiLCJjYW5jZWxUaW1lb3V0Iiwic2V0dXBUaW1lb3V0Iiwib25Db25uZWN0VGltZW91dCIsInNldE5vRGVsYXkiLCJvbmNlIiwiY2IiLCJlcnIiLCJzMSIsInMyIiwidGltZW91dElkIiwic2V0VGltZW91dCIsInNldEltbWVkaWF0ZSIsInBsYXRmb3JtIiwiY2xlYXJUaW1lb3V0IiwiY2xlYXJJbW1lZGlhdGUiLCJtZXNzYWdlIiwiQXJyYXkiLCJpc0FycmF5IiwiYXV0b1NlbGVjdEZhbWlseUF0dGVtcHRlZEFkZHJlc3NlcyIsImpvaW4iLCJkZXN0cm95IiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/core/connect.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/core/constants.js":
/*!***************************************************!*\
  !*** ./node_modules/undici/lib/core/constants.js ***!
  \***************************************************/
/***/ ((module) => {

eval("\n/** @type {Record<string, string | undefined>} */ const headerNameLowerCasedRecord = {};\n// https://developer.mozilla.org/docs/Web/HTTP/Headers\nconst wellknownHeaderNames = [\n    \"Accept\",\n    \"Accept-Encoding\",\n    \"Accept-Language\",\n    \"Accept-Ranges\",\n    \"Access-Control-Allow-Credentials\",\n    \"Access-Control-Allow-Headers\",\n    \"Access-Control-Allow-Methods\",\n    \"Access-Control-Allow-Origin\",\n    \"Access-Control-Expose-Headers\",\n    \"Access-Control-Max-Age\",\n    \"Access-Control-Request-Headers\",\n    \"Access-Control-Request-Method\",\n    \"Age\",\n    \"Allow\",\n    \"Alt-Svc\",\n    \"Alt-Used\",\n    \"Authorization\",\n    \"Cache-Control\",\n    \"Clear-Site-Data\",\n    \"Connection\",\n    \"Content-Disposition\",\n    \"Content-Encoding\",\n    \"Content-Language\",\n    \"Content-Length\",\n    \"Content-Location\",\n    \"Content-Range\",\n    \"Content-Security-Policy\",\n    \"Content-Security-Policy-Report-Only\",\n    \"Content-Type\",\n    \"Cookie\",\n    \"Cross-Origin-Embedder-Policy\",\n    \"Cross-Origin-Opener-Policy\",\n    \"Cross-Origin-Resource-Policy\",\n    \"Date\",\n    \"Device-Memory\",\n    \"Downlink\",\n    \"ECT\",\n    \"ETag\",\n    \"Expect\",\n    \"Expect-CT\",\n    \"Expires\",\n    \"Forwarded\",\n    \"From\",\n    \"Host\",\n    \"If-Match\",\n    \"If-Modified-Since\",\n    \"If-None-Match\",\n    \"If-Range\",\n    \"If-Unmodified-Since\",\n    \"Keep-Alive\",\n    \"Last-Modified\",\n    \"Link\",\n    \"Location\",\n    \"Max-Forwards\",\n    \"Origin\",\n    \"Permissions-Policy\",\n    \"Pragma\",\n    \"Proxy-Authenticate\",\n    \"Proxy-Authorization\",\n    \"RTT\",\n    \"Range\",\n    \"Referer\",\n    \"Referrer-Policy\",\n    \"Refresh\",\n    \"Retry-After\",\n    \"Sec-WebSocket-Accept\",\n    \"Sec-WebSocket-Extensions\",\n    \"Sec-WebSocket-Key\",\n    \"Sec-WebSocket-Protocol\",\n    \"Sec-WebSocket-Version\",\n    \"Server\",\n    \"Server-Timing\",\n    \"Service-Worker-Allowed\",\n    \"Service-Worker-Navigation-Preload\",\n    \"Set-Cookie\",\n    \"SourceMap\",\n    \"Strict-Transport-Security\",\n    \"Supports-Loading-Mode\",\n    \"TE\",\n    \"Timing-Allow-Origin\",\n    \"Trailer\",\n    \"Transfer-Encoding\",\n    \"Upgrade\",\n    \"Upgrade-Insecure-Requests\",\n    \"User-Agent\",\n    \"Vary\",\n    \"Via\",\n    \"WWW-Authenticate\",\n    \"X-Content-Type-Options\",\n    \"X-DNS-Prefetch-Control\",\n    \"X-Frame-Options\",\n    \"X-Permitted-Cross-Domain-Policies\",\n    \"X-Powered-By\",\n    \"X-Requested-With\",\n    \"X-XSS-Protection\"\n];\nfor(let i = 0; i < wellknownHeaderNames.length; ++i){\n    const key = wellknownHeaderNames[i];\n    const lowerCasedKey = key.toLowerCase();\n    headerNameLowerCasedRecord[key] = headerNameLowerCasedRecord[lowerCasedKey] = lowerCasedKey;\n}\n// Note: object prototypes should not be able to be referenced. e.g. `Object#hasOwnProperty`.\nObject.setPrototypeOf(headerNameLowerCasedRecord, null);\nmodule.exports = {\n    wellknownHeaderNames,\n    headerNameLowerCasedRecord\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9jb3JlL2NvbnN0YW50cy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLGtEQUNBLE1BQU1BLDZCQUE2QixDQUFDO0FBRXBDO0FBQ0EsTUFBTUMsdUJBQXVCO0lBQzNCO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7Q0FDRDtBQUVELElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJRCxxQkFBcUJFLE1BQU0sRUFBRSxFQUFFRCxFQUFHO0lBQ3BELE1BQU1FLE1BQU1ILG9CQUFvQixDQUFDQyxFQUFFO0lBQ25DLE1BQU1HLGdCQUFnQkQsSUFBSUUsV0FBVztJQUNyQ04sMEJBQTBCLENBQUNJLElBQUksR0FBR0osMEJBQTBCLENBQUNLLGNBQWMsR0FDekVBO0FBQ0o7QUFFQTtBQUNBRSxPQUFPQyxjQUFjLENBQUNSLDRCQUE0QjtBQUVsRFMsT0FBT0MsT0FBTyxHQUFHO0lBQ2ZUO0lBQ0FEO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tb2NrdXBmbG93Ly4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvY29yZS9jb25zdGFudHMuanM/YmRmYyIsIndlYnBhY2s6Ly9tb2NrdXBmbG93Ly4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvY29yZS9jb25zdGFudHMuanM/YmRmYyoiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbi8qKiBAdHlwZSB7UmVjb3JkPHN0cmluZywgc3RyaW5nIHwgdW5kZWZpbmVkPn0gKi9cbmNvbnN0IGhlYWRlck5hbWVMb3dlckNhc2VkUmVjb3JkID0ge31cblxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvSFRUUC9IZWFkZXJzXG5jb25zdCB3ZWxsa25vd25IZWFkZXJOYW1lcyA9IFtcbiAgJ0FjY2VwdCcsXG4gICdBY2NlcHQtRW5jb2RpbmcnLFxuICAnQWNjZXB0LUxhbmd1YWdlJyxcbiAgJ0FjY2VwdC1SYW5nZXMnLFxuICAnQWNjZXNzLUNvbnRyb2wtQWxsb3ctQ3JlZGVudGlhbHMnLFxuICAnQWNjZXNzLUNvbnRyb2wtQWxsb3ctSGVhZGVycycsXG4gICdBY2Nlc3MtQ29udHJvbC1BbGxvdy1NZXRob2RzJyxcbiAgJ0FjY2Vzcy1Db250cm9sLUFsbG93LU9yaWdpbicsXG4gICdBY2Nlc3MtQ29udHJvbC1FeHBvc2UtSGVhZGVycycsXG4gICdBY2Nlc3MtQ29udHJvbC1NYXgtQWdlJyxcbiAgJ0FjY2Vzcy1Db250cm9sLVJlcXVlc3QtSGVhZGVycycsXG4gICdBY2Nlc3MtQ29udHJvbC1SZXF1ZXN0LU1ldGhvZCcsXG4gICdBZ2UnLFxuICAnQWxsb3cnLFxuICAnQWx0LVN2YycsXG4gICdBbHQtVXNlZCcsXG4gICdBdXRob3JpemF0aW9uJyxcbiAgJ0NhY2hlLUNvbnRyb2wnLFxuICAnQ2xlYXItU2l0ZS1EYXRhJyxcbiAgJ0Nvbm5lY3Rpb24nLFxuICAnQ29udGVudC1EaXNwb3NpdGlvbicsXG4gICdDb250ZW50LUVuY29kaW5nJyxcbiAgJ0NvbnRlbnQtTGFuZ3VhZ2UnLFxuICAnQ29udGVudC1MZW5ndGgnLFxuICAnQ29udGVudC1Mb2NhdGlvbicsXG4gICdDb250ZW50LVJhbmdlJyxcbiAgJ0NvbnRlbnQtU2VjdXJpdHktUG9saWN5JyxcbiAgJ0NvbnRlbnQtU2VjdXJpdHktUG9saWN5LVJlcG9ydC1Pbmx5JyxcbiAgJ0NvbnRlbnQtVHlwZScsXG4gICdDb29raWUnLFxuICAnQ3Jvc3MtT3JpZ2luLUVtYmVkZGVyLVBvbGljeScsXG4gICdDcm9zcy1PcmlnaW4tT3BlbmVyLVBvbGljeScsXG4gICdDcm9zcy1PcmlnaW4tUmVzb3VyY2UtUG9saWN5JyxcbiAgJ0RhdGUnLFxuICAnRGV2aWNlLU1lbW9yeScsXG4gICdEb3dubGluaycsXG4gICdFQ1QnLFxuICAnRVRhZycsXG4gICdFeHBlY3QnLFxuICAnRXhwZWN0LUNUJyxcbiAgJ0V4cGlyZXMnLFxuICAnRm9yd2FyZGVkJyxcbiAgJ0Zyb20nLFxuICAnSG9zdCcsXG4gICdJZi1NYXRjaCcsXG4gICdJZi1Nb2RpZmllZC1TaW5jZScsXG4gICdJZi1Ob25lLU1hdGNoJyxcbiAgJ0lmLVJhbmdlJyxcbiAgJ0lmLVVubW9kaWZpZWQtU2luY2UnLFxuICAnS2VlcC1BbGl2ZScsXG4gICdMYXN0LU1vZGlmaWVkJyxcbiAgJ0xpbmsnLFxuICAnTG9jYXRpb24nLFxuICAnTWF4LUZvcndhcmRzJyxcbiAgJ09yaWdpbicsXG4gICdQZXJtaXNzaW9ucy1Qb2xpY3knLFxuICAnUHJhZ21hJyxcbiAgJ1Byb3h5LUF1dGhlbnRpY2F0ZScsXG4gICdQcm94eS1BdXRob3JpemF0aW9uJyxcbiAgJ1JUVCcsXG4gICdSYW5nZScsXG4gICdSZWZlcmVyJyxcbiAgJ1JlZmVycmVyLVBvbGljeScsXG4gICdSZWZyZXNoJyxcbiAgJ1JldHJ5LUFmdGVyJyxcbiAgJ1NlYy1XZWJTb2NrZXQtQWNjZXB0JyxcbiAgJ1NlYy1XZWJTb2NrZXQtRXh0ZW5zaW9ucycsXG4gICdTZWMtV2ViU29ja2V0LUtleScsXG4gICdTZWMtV2ViU29ja2V0LVByb3RvY29sJyxcbiAgJ1NlYy1XZWJTb2NrZXQtVmVyc2lvbicsXG4gICdTZXJ2ZXInLFxuICAnU2VydmVyLVRpbWluZycsXG4gICdTZXJ2aWNlLVdvcmtlci1BbGxvd2VkJyxcbiAgJ1NlcnZpY2UtV29ya2VyLU5hdmlnYXRpb24tUHJlbG9hZCcsXG4gICdTZXQtQ29va2llJyxcbiAgJ1NvdXJjZU1hcCcsXG4gICdTdHJpY3QtVHJhbnNwb3J0LVNlY3VyaXR5JyxcbiAgJ1N1cHBvcnRzLUxvYWRpbmctTW9kZScsXG4gICdURScsXG4gICdUaW1pbmctQWxsb3ctT3JpZ2luJyxcbiAgJ1RyYWlsZXInLFxuICAnVHJhbnNmZXItRW5jb2RpbmcnLFxuICAnVXBncmFkZScsXG4gICdVcGdyYWRlLUluc2VjdXJlLVJlcXVlc3RzJyxcbiAgJ1VzZXItQWdlbnQnLFxuICAnVmFyeScsXG4gICdWaWEnLFxuICAnV1dXLUF1dGhlbnRpY2F0ZScsXG4gICdYLUNvbnRlbnQtVHlwZS1PcHRpb25zJyxcbiAgJ1gtRE5TLVByZWZldGNoLUNvbnRyb2wnLFxuICAnWC1GcmFtZS1PcHRpb25zJyxcbiAgJ1gtUGVybWl0dGVkLUNyb3NzLURvbWFpbi1Qb2xpY2llcycsXG4gICdYLVBvd2VyZWQtQnknLFxuICAnWC1SZXF1ZXN0ZWQtV2l0aCcsXG4gICdYLVhTUy1Qcm90ZWN0aW9uJ1xuXVxuXG5mb3IgKGxldCBpID0gMDsgaSA8IHdlbGxrbm93bkhlYWRlck5hbWVzLmxlbmd0aDsgKytpKSB7XG4gIGNvbnN0IGtleSA9IHdlbGxrbm93bkhlYWRlck5hbWVzW2ldXG4gIGNvbnN0IGxvd2VyQ2FzZWRLZXkgPSBrZXkudG9Mb3dlckNhc2UoKVxuICBoZWFkZXJOYW1lTG93ZXJDYXNlZFJlY29yZFtrZXldID0gaGVhZGVyTmFtZUxvd2VyQ2FzZWRSZWNvcmRbbG93ZXJDYXNlZEtleV0gPVxuICAgIGxvd2VyQ2FzZWRLZXlcbn1cblxuLy8gTm90ZTogb2JqZWN0IHByb3RvdHlwZXMgc2hvdWxkIG5vdCBiZSBhYmxlIHRvIGJlIHJlZmVyZW5jZWQuIGUuZy4gYE9iamVjdCNoYXNPd25Qcm9wZXJ0eWAuXG5PYmplY3Quc2V0UHJvdG90eXBlT2YoaGVhZGVyTmFtZUxvd2VyQ2FzZWRSZWNvcmQsIG51bGwpXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICB3ZWxsa25vd25IZWFkZXJOYW1lcyxcbiAgaGVhZGVyTmFtZUxvd2VyQ2FzZWRSZWNvcmRcbn1cbiJdLCJuYW1lcyI6WyJoZWFkZXJOYW1lTG93ZXJDYXNlZFJlY29yZCIsIndlbGxrbm93bkhlYWRlck5hbWVzIiwiaSIsImxlbmd0aCIsImtleSIsImxvd2VyQ2FzZWRLZXkiLCJ0b0xvd2VyQ2FzZSIsIk9iamVjdCIsInNldFByb3RvdHlwZU9mIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/core/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/core/diagnostics.js":
/*!*****************************************************!*\
  !*** ./node_modules/undici/lib/core/diagnostics.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst diagnosticsChannel = __webpack_require__(/*! node:diagnostics_channel */ \"node:diagnostics_channel\");\nconst util = __webpack_require__(/*! node:util */ \"node:util\");\nconst undiciDebugLog = util.debuglog(\"undici\");\nconst fetchDebuglog = util.debuglog(\"fetch\");\nconst websocketDebuglog = util.debuglog(\"websocket\");\nlet isClientSet = false;\nconst channels = {\n    // Client\n    beforeConnect: diagnosticsChannel.channel(\"undici:client:beforeConnect\"),\n    connected: diagnosticsChannel.channel(\"undici:client:connected\"),\n    connectError: diagnosticsChannel.channel(\"undici:client:connectError\"),\n    sendHeaders: diagnosticsChannel.channel(\"undici:client:sendHeaders\"),\n    // Request\n    create: diagnosticsChannel.channel(\"undici:request:create\"),\n    bodySent: diagnosticsChannel.channel(\"undici:request:bodySent\"),\n    headers: diagnosticsChannel.channel(\"undici:request:headers\"),\n    trailers: diagnosticsChannel.channel(\"undici:request:trailers\"),\n    error: diagnosticsChannel.channel(\"undici:request:error\"),\n    // WebSocket\n    open: diagnosticsChannel.channel(\"undici:websocket:open\"),\n    close: diagnosticsChannel.channel(\"undici:websocket:close\"),\n    socketError: diagnosticsChannel.channel(\"undici:websocket:socket_error\"),\n    ping: diagnosticsChannel.channel(\"undici:websocket:ping\"),\n    pong: diagnosticsChannel.channel(\"undici:websocket:pong\")\n};\nif (undiciDebugLog.enabled || fetchDebuglog.enabled) {\n    const debuglog = fetchDebuglog.enabled ? fetchDebuglog : undiciDebugLog;\n    // Track all Client events\n    diagnosticsChannel.channel(\"undici:client:beforeConnect\").subscribe((evt)=>{\n        const { connectParams: { version, protocol, port, host } } = evt;\n        debuglog(\"connecting to %s using %s%s\", `${host}${port ? `:${port}` : \"\"}`, protocol, version);\n    });\n    diagnosticsChannel.channel(\"undici:client:connected\").subscribe((evt)=>{\n        const { connectParams: { version, protocol, port, host } } = evt;\n        debuglog(\"connected to %s using %s%s\", `${host}${port ? `:${port}` : \"\"}`, protocol, version);\n    });\n    diagnosticsChannel.channel(\"undici:client:connectError\").subscribe((evt)=>{\n        const { connectParams: { version, protocol, port, host }, error } = evt;\n        debuglog(\"connection to %s using %s%s errored - %s\", `${host}${port ? `:${port}` : \"\"}`, protocol, version, error.message);\n    });\n    diagnosticsChannel.channel(\"undici:client:sendHeaders\").subscribe((evt)=>{\n        const { request: { method, path, origin } } = evt;\n        debuglog(\"sending request to %s %s/%s\", method, origin, path);\n    });\n    // Track Request events\n    diagnosticsChannel.channel(\"undici:request:headers\").subscribe((evt)=>{\n        const { request: { method, path, origin }, response: { statusCode } } = evt;\n        debuglog(\"received response to %s %s/%s - HTTP %d\", method, origin, path, statusCode);\n    });\n    diagnosticsChannel.channel(\"undici:request:trailers\").subscribe((evt)=>{\n        const { request: { method, path, origin } } = evt;\n        debuglog(\"trailers received from %s %s/%s\", method, origin, path);\n    });\n    diagnosticsChannel.channel(\"undici:request:error\").subscribe((evt)=>{\n        const { request: { method, path, origin }, error } = evt;\n        debuglog(\"request to %s %s/%s errored - %s\", method, origin, path, error.message);\n    });\n    isClientSet = true;\n}\nif (websocketDebuglog.enabled) {\n    if (!isClientSet) {\n        const debuglog = undiciDebugLog.enabled ? undiciDebugLog : websocketDebuglog;\n        diagnosticsChannel.channel(\"undici:client:beforeConnect\").subscribe((evt)=>{\n            const { connectParams: { version, protocol, port, host } } = evt;\n            debuglog(\"connecting to %s%s using %s%s\", host, port ? `:${port}` : \"\", protocol, version);\n        });\n        diagnosticsChannel.channel(\"undici:client:connected\").subscribe((evt)=>{\n            const { connectParams: { version, protocol, port, host } } = evt;\n            debuglog(\"connected to %s%s using %s%s\", host, port ? `:${port}` : \"\", protocol, version);\n        });\n        diagnosticsChannel.channel(\"undici:client:connectError\").subscribe((evt)=>{\n            const { connectParams: { version, protocol, port, host }, error } = evt;\n            debuglog(\"connection to %s%s using %s%s errored - %s\", host, port ? `:${port}` : \"\", protocol, version, error.message);\n        });\n        diagnosticsChannel.channel(\"undici:client:sendHeaders\").subscribe((evt)=>{\n            const { request: { method, path, origin } } = evt;\n            debuglog(\"sending request to %s %s/%s\", method, origin, path);\n        });\n    }\n    // Track all WebSocket events\n    diagnosticsChannel.channel(\"undici:websocket:open\").subscribe((evt)=>{\n        const { address: { address, port } } = evt;\n        websocketDebuglog(\"connection opened %s%s\", address, port ? `:${port}` : \"\");\n    });\n    diagnosticsChannel.channel(\"undici:websocket:close\").subscribe((evt)=>{\n        const { websocket, code, reason } = evt;\n        websocketDebuglog(\"closed connection to %s - %s %s\", websocket.url, code, reason);\n    });\n    diagnosticsChannel.channel(\"undici:websocket:socket_error\").subscribe((err)=>{\n        websocketDebuglog(\"connection errored - %s\", err.message);\n    });\n    diagnosticsChannel.channel(\"undici:websocket:ping\").subscribe((evt)=>{\n        websocketDebuglog(\"ping received\");\n    });\n    diagnosticsChannel.channel(\"undici:websocket:pong\").subscribe((evt)=>{\n        websocketDebuglog(\"pong received\");\n    });\n}\nmodule.exports = {\n    channels\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9jb3JlL2RpYWdub3N0aWNzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsTUFBTUEscUJBQXFCQyxtQkFBT0EsQ0FBQztBQUNuQyxNQUFNQyxPQUFPRCxtQkFBT0EsQ0FBQztBQUVyQixNQUFNRSxpQkFBaUJELEtBQUtFLFFBQVEsQ0FBQztBQUNyQyxNQUFNQyxnQkFBZ0JILEtBQUtFLFFBQVEsQ0FBQztBQUNwQyxNQUFNRSxvQkFBb0JKLEtBQUtFLFFBQVEsQ0FBQztBQUN4QyxJQUFJRyxjQUFjO0FBQ2xCLE1BQU1DLFdBQVc7SUFDZjtJQUNBQyxlQUFlVCxtQkFBbUJVLE9BQU8sQ0FBQztJQUMxQ0MsV0FBV1gsbUJBQW1CVSxPQUFPLENBQUM7SUFDdENFLGNBQWNaLG1CQUFtQlUsT0FBTyxDQUFDO0lBQ3pDRyxhQUFhYixtQkFBbUJVLE9BQU8sQ0FBQztJQUN4QztJQUNBSSxRQUFRZCxtQkFBbUJVLE9BQU8sQ0FBQztJQUNuQ0ssVUFBVWYsbUJBQW1CVSxPQUFPLENBQUM7SUFDckNNLFNBQVNoQixtQkFBbUJVLE9BQU8sQ0FBQztJQUNwQ08sVUFBVWpCLG1CQUFtQlUsT0FBTyxDQUFDO0lBQ3JDUSxPQUFPbEIsbUJBQW1CVSxPQUFPLENBQUM7SUFDbEM7SUFDQVMsTUFBTW5CLG1CQUFtQlUsT0FBTyxDQUFDO0lBQ2pDVSxPQUFPcEIsbUJBQW1CVSxPQUFPLENBQUM7SUFDbENXLGFBQWFyQixtQkFBbUJVLE9BQU8sQ0FBQztJQUN4Q1ksTUFBTXRCLG1CQUFtQlUsT0FBTyxDQUFDO0lBQ2pDYSxNQUFNdkIsbUJBQW1CVSxPQUFPLENBQUM7QUFDbkM7QUFFQSxJQUFJUCxlQUFlcUIsT0FBTyxJQUFJbkIsY0FBY21CLE9BQU8sRUFBRTtJQUNuRCxNQUFNcEIsV0FBV0MsY0FBY21CLE9BQU8sR0FBR25CLGdCQUFnQkY7SUFFekQ7SUFDQUgsbUJBQW1CVSxPQUFPLENBQUMsK0JBQStCZSxTQUFTLENBQUNDLENB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QnNDLElBQUlaLE9BQU87SUFDMUQ7SUFFQWhDLG1CQUFtQlUsT0FBTyxDQUFDLHlCQUF5QmUsU0FBUyxDQUFDQyxDQUFBQTtRQUM1RHBCLGtCQUFrQjtJQUNwQjtJQUVBTixtQkFBbUJVLE9BQU8sQ0FBQyx5QkFBeUJlLFNBQVMsQ0FBQ0MsQ0FBQUE7UUFDNURwQixrQkFBa0I7SUFDcEI7QUFDRjtBQUVBdUMsT0FBT0MsT0FBTyxHQUFHO0lBQ2Z0QztBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbW9ja3VwZmxvdy8uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2NvcmUvZGlhZ25vc3RpY3MuanM/N2U4MiIsIndlYnBhY2s6Ly9tb2NrdXBmbG93Ly4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvY29yZS9kaWFnbm9zdGljcy5qcz83ZTgyKiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcbmNvbnN0IGRpYWdub3N0aWNzQ2hhbm5lbCA9IHJlcXVpcmUoJ25vZGU6ZGlhZ25vc3RpY3NfY2hhbm5lbCcpXG5jb25zdCB1dGlsID0gcmVxdWlyZSgnbm9kZTp1dGlsJylcblxuY29uc3QgdW5kaWNpRGVidWdMb2cgPSB1dGlsLmRlYnVnbG9nKCd1bmRpY2knKVxuY29uc3QgZmV0Y2hEZWJ1Z2xvZyA9IHV0aWwuZGVidWdsb2coJ2ZldGNoJylcbmNvbnN0IHdlYnNvY2tldERlYnVnbG9nID0gdXRpbC5kZWJ1Z2xvZygnd2Vic29ja2V0JylcbmxldCBpc0NsaWVudFNldCA9IGZhbHNlXG5jb25zdCBjaGFubmVscyA9IHtcbiAgLy8gQ2xpZW50XG4gIGJlZm9yZUNvbm5lY3Q6IGRpYWdub3N0aWNzQ2hhbm5lbC5jaGFubmVsKCd1bmRpY2k6Y2xpZW50OmJlZm9yZUNvbm5lY3QnKSxcbiAgY29ubmVjdGVkOiBkaWFnbm9zdGljc0NoYW5uZWwuY2hhbm5lbCgndW5kaWNpOmNsaWVudDpjb25uZWN0ZWQnKSxcbiAgY29ubmVjdEVycm9yOiBkaWFnbm9zdGljc0NoYW5uZWwuY2hhbm5lbCgndW5kaWNpOmNsaWVudDpjb25uZWN0RXJyb3InKSxcbiAgc2VuZEhlYWRlcnM6IGRpYWdub3N0aWNzQ2hhbm5lbC5jaGFubmVsKCd1bmRpY2k6Y2xpZW50OnNlbmRIZWFkZXJzJyksXG4gIC8vIFJlcXVlc3RcbiAgY3JlYXRlOiBkaWFnbm9zdGljc0NoYW5uZWwuY2hhbm5lbCgndW5kaWNpOnJlcXVlc3Q6Y3JlYXRlJyksXG4gIGJvZHlTZW50OiBkaWFnbm9zdGljc0NoYW5uZWwuY2hhbm5lbCgndW5kaWNpOnJlcXVlc3Q6Ym9keVNlbnQnKSxcbiAgaGVhZGVyczogZGlhZ25vc3RpY3NDaGFubmVsLmNoYW5uZWwoJ3VuZGljaTpyZXF1ZXN0OmhlYWRlcnMnKSxcbiAgdHJhaWxlcnM6IGRpYWdub3N0aWNzQ2hhbm5lbC5jaGFubmVsKCd1bmRpY2k6cmVxdWVzdDp0cmFpbGVycycpLFxuICBlcnJvcjogZGlhZ25vc3RpY3NDaGFubmVsLmNoYW5uZWwoJ3VuZGljaTpyZXF1ZXN0OmVycm9yJyksXG4gIC8vIFdlYlNvY2tldFxuICBvcGVuOiBkaWFnbm9zdGljc0NoYW5uZWwuY2hhbm5lbCgndW5kaWNpOndlYnNvY2tldDpvcGVuJyksXG4gIGNsb3NlOiBkaWFnbm9zdGljc0NoYW5uZWwuY2hhbm5lbCgndW5kaWNpOndlYnNvY2tldDpjbG9zZScpLFxuICBzb2NrZXRFcnJvcjogZGlhZ25vc3RpY3NDaGFubmVsLmNoYW5uZWwoJ3VuZGljaTp3ZWJzb2NrZXQ6c29ja2V0X2Vycm9yJyksXG4gIHBpbmc6IGRpYWdub3N0aWNzQ2hhbm5lbC5jaGFubmVsKCd1bmRpY2k6d2Vic29ja2V0OnBpbmcnKSxcbiAgcG9uZzogZGlhZ25vc3RpY3NDaGFubmVsLmNoYW5uZWwoJ3VuZGljaTp3ZWJzb2NrZXQ6cG9uZycpXG59XG5cbmlmICh1bmRpY2lEZWJ1Z0xvZy5lbmFibGVkIHx8IGZldGNoRGVidWdsb2cuZW5hYmxlZCkge1xuICBjb25zdCBkZWJ1Z2xvZyA9IGZldGNoRGVidWdsb2cuZW5hYmxlZCA/IGZldGNoRGVidWdsb2cgOiB1bmRpY2lEZWJ1Z0xvZ1xuXG4gIC8vIFRyYWNrIGFsbCBDbGllbnQgZXZlbnRzXG4gIGRpYWdub3N0aWNzQ2hhbm5lbC5jaGFubmVsKCd1bmRpY2k6Y2xpZW50OmJlZm9yZUNvbm5lY3QnKS5zdWJzY3JpYmUoZXZ0ID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBjb25uZWN0UGFyYW1zOiB7IHZlcnNpb24sIHByb3RvY29sLCBwb3J0LCBob3N0IH1cbiAgICB9ID0gZXZ0XG4gICAgZGVidWdsb2coXG4gICAgICAnY29ubmVjdGluZyB0byAlcyB1c2luZyAlcyVzJyxcbiAgICAgIGAke2hvc3R9JHtwb3J0ID8gYDoke3BvcnR9YCA6ICcnfWAsXG4gICAgICBwcm90b2NvbCxcbiAgICAgIHZlcnNpb25cbiAgICApXG4gIH0pXG5cbiAgZGlhZ25vc3RpY3NDaGFubmVsLmNoYW5uZWwoJ3VuZGljaTpjbGllbnQ6Y29ubmVjdGVkJykuc3Vic2NyaWJlKGV2dCA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgY29ubmVjdFBhcmFtczogeyB2ZXJzaW9uLCBwcm90b2NvbCwgcG9ydCwgaG9zdCB9XG4gICAgfSA9IGV2dFxuICAgIGRlYnVnbG9nKFxuICAgICAgJ2Nvbm5lY3RlZCB0byAlcyB1c2luZyAlcyVzJyxcbiAgICAgIGAke2hvc3R9JHtwb3J0ID8gYDoke3BvcnR9YCA6ICcnfWAsXG4gICAgICBwcm90b2NvbCxcbiAgICAgIHZlcnNpb25cbiAgICApXG4gIH0pXG5cbiAgZGlhZ25vc3RpY3NDaGFubmVsLmNoYW5uZWwoJ3VuZGljaTpjbGllbnQ6Y29ubmVjdEVycm9yJykuc3Vic2NyaWJlKGV2dCA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgY29ubmVjdFBhcmFtczogeyB2ZXJzaW9uLCBwcm90b2NvbCwgcG9ydCwgaG9zdCB9LFxuICAgICAgZXJyb3JcbiAgICB9ID0gZXZ0XG4gICAgZGVidWdsb2coXG4gICAgICAnY29ubmVjdGlvbiB0byAlcyB1c2luZyAlcyVzIGVycm9yZWQgLSAlcycsXG4gICAgICBgJHtob3N0fSR7cG9ydCA/IGA6JHtwb3J0fWAgOiAnJ31gLFxuICAgICAgcHJvdG9jb2wsXG4gICAgICB2ZXJzaW9uLFxuICAgICAgZXJyb3IubWVzc2FnZVxuICAgIClcbiAgfSlcblxuICBkaWFnbm9zdGljc0NoYW5uZWwuY2hhbm5lbCgndW5kaWNpOmNsaWVudDpzZW5kSGVhZGVycycpLnN1YnNjcmliZShldnQgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIHJlcXVlc3Q6IHsgbWV0aG9kLCBwYXRoLCBvcmlnaW4gfVxuICAgIH0gPSBldnRcbiAgICBkZWJ1Z2xvZygnc2VuZGluZyByZXF1ZXN0IHRvICVzICVzLyVzJywgbWV0aG9kLCBvcmlnaW4sIHBhdGgpXG4gIH0pXG5cbiAgLy8gVHJhY2sgUmVxdWVzdCBldmVudHNcbiAgZGlhZ25vc3RpY3NDaGFubmVsLmNoYW5uZWwoJ3VuZGljaTpyZXF1ZXN0OmhlYWRlcnMnKS5zdWJzY3JpYmUoZXZ0ID0+IHtcbiAgICBjb25zdCB7XG4gICAgICByZXF1ZXN0OiB7IG1ldGhvZCwgcGF0aCwgb3JpZ2luIH0sXG4gICAgICByZXNwb25zZTogeyBzdGF0dXNDb2RlIH1cbiAgICB9ID0gZXZ0XG4gICAgZGVidWdsb2coXG4gICAgICAncmVjZWl2ZWQgcmVzcG9uc2UgdG8gJXMgJXMvJXMgLSBIVFRQICVkJyxcbiAgICAgIG1ldGhvZCxcbiAgICAgIG9yaWdpbixcbiAgICAgIHBhdGgsXG4gICAgICBzdGF0dXNDb2RlXG4gICAgKVxuICB9KVxuXG4gIGRpYWdub3N0aWNzQ2hhbm5lbC5jaGFubmVsKCd1bmRpY2k6cmVxdWVzdDp0cmFpbGVycycpLnN1YnNjcmliZShldnQgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIHJlcXVlc3Q6IHsgbWV0aG9kLCBwYXRoLCBvcmlnaW4gfVxuICAgIH0gPSBldnRcbiAgICBkZWJ1Z2xvZygndHJhaWxlcnMgcmVjZWl2ZWQgZnJvbSAlcyAlcy8lcycsIG1ldGhvZCwgb3JpZ2luLCBwYXRoKVxuICB9KVxuXG4gIGRpYWdub3N0aWNzQ2hhbm5lbC5jaGFubmVsKCd1bmRpY2k6cmVxdWVzdDplcnJvcicpLnN1YnNjcmliZShldnQgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIHJlcXVlc3Q6IHsgbWV0aG9kLCBwYXRoLCBvcmlnaW4gfSxcbiAgICAgIGVycm9yXG4gICAgfSA9IGV2dFxuICAgIGRlYnVnbG9nKFxuICAgICAgJ3JlcXVlc3QgdG8gJXMgJXMvJXMgZXJyb3JlZCAtICVzJyxcbiAgICAgIG1ldGhvZCxcbiAgICAgIG9yaWdpbixcbiAgICAgIHBhdGgsXG4gICAgICBlcnJvci5tZXNzYWdlXG4gICAgKVxuICB9KVxuXG4gIGlzQ2xpZW50U2V0ID0gdHJ1ZVxufVxuXG5pZiAod2Vic29ja2V0RGVidWdsb2cuZW5hYmxlZCkge1xuICBpZiAoIWlzQ2xpZW50U2V0KSB7XG4gICAgY29uc3QgZGVidWdsb2cgPSB1bmRpY2lEZWJ1Z0xvZy5lbmFibGVkID8gdW5kaWNpRGVidWdMb2cgOiB3ZWJzb2NrZXREZWJ1Z2xvZ1xuICAgIGRpYWdub3N0aWNzQ2hhbm5lbC5jaGFubmVsKCd1bmRpY2k6Y2xpZW50OmJlZm9yZUNvbm5lY3QnKS5zdWJzY3JpYmUoZXZ0ID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY29ubmVjdFBhcmFtczogeyB2ZXJzaW9uLCBwcm90b2NvbCwgcG9ydCwgaG9zdCB9XG4gICAgICB9ID0gZXZ0XG4gICAgICBkZWJ1Z2xvZyhcbiAgICAgICAgJ2Nvbm5lY3RpbmcgdG8gJXMlcyB1c2luZyAlcyVzJyxcbiAgICAgICAgaG9zdCxcbiAgICAgICAgcG9ydCA/IGA6JHtwb3J0fWAgOiAnJyxcbiAgICAgICAgcHJvdG9jb2wsXG4gICAgICAgIHZlcnNpb25cbiAgICAgIClcbiAgICB9KVxuXG4gICAgZGlhZ25vc3RpY3NDaGFubmVsLmNoYW5uZWwoJ3VuZGljaTpjbGllbnQ6Y29ubmVjdGVkJykuc3Vic2NyaWJlKGV2dCA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNvbm5lY3RQYXJhbXM6IHsgdmVyc2lvbiwgcHJvdG9jb2wsIHBvcnQsIGhvc3QgfVxuICAgICAgfSA9IGV2dFxuICAgICAgZGVidWdsb2coXG4gICAgICAgICdjb25uZWN0ZWQgdG8gJXMlcyB1c2luZyAlcyVzJyxcbiAgICAgICAgaG9zdCxcbiAgICAgICAgcG9ydCA/IGA6JHtwb3J0fWAgOiAnJyxcbiAgICAgICAgcHJvdG9jb2wsXG4gICAgICAgIHZlcnNpb25cbiAgICAgIClcbiAgICB9KVxuXG4gICAgZGlhZ25vc3RpY3NDaGFubmVsLmNoYW5uZWwoJ3VuZGljaTpjbGllbnQ6Y29ubmVjdEVycm9yJykuc3Vic2NyaWJlKGV2dCA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNvbm5lY3RQYXJhbXM6IHsgdmVyc2lvbiwgcHJvdG9jb2wsIHBvcnQsIGhvc3QgfSxcbiAgICAgICAgZXJyb3JcbiAgICAgIH0gPSBldnRcbiAgICAgIGRlYnVnbG9nKFxuICAgICAgICAnY29ubmVjdGlvbiB0byAlcyVzIHVzaW5nICVzJXMgZXJyb3JlZCAtICVzJyxcbiAgICAgICAgaG9zdCxcbiAgICAgICAgcG9ydCA/IGA6JHtwb3J0fWAgOiAnJyxcbiAgICAgICAgcHJvdG9jb2wsXG4gICAgICAgIHZlcnNpb24sXG4gICAgICAgIGVycm9yLm1lc3NhZ2VcbiAgICAgIClcbiAgICB9KVxuXG4gICAgZGlhZ25vc3RpY3NDaGFubmVsLmNoYW5uZWwoJ3VuZGljaTpjbGllbnQ6c2VuZEhlYWRlcnMnKS5zdWJzY3JpYmUoZXZ0ID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcmVxdWVzdDogeyBtZXRob2QsIHBhdGgsIG9yaWdpbiB9XG4gICAgICB9ID0gZXZ0XG4gICAgICBkZWJ1Z2xvZygnc2VuZGluZyByZXF1ZXN0IHRvICVzICVzLyVzJywgbWV0aG9kLCBvcmlnaW4sIHBhdGgpXG4gICAgfSlcbiAgfVxuXG4gIC8vIFRyYWNrIGFsbCBXZWJTb2NrZXQgZXZlbnRzXG4gIGRpYWdub3N0aWNzQ2hhbm5lbC5jaGFubmVsKCd1bmRpY2k6d2Vic29ja2V0Om9wZW4nKS5zdWJzY3JpYmUoZXZ0ID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBhZGRyZXNzOiB7IGFkZHJlc3MsIHBvcnQgfVxuICAgIH0gPSBldnRcbiAgICB3ZWJzb2NrZXREZWJ1Z2xvZygnY29ubmVjdGlvbiBvcGVuZWQgJXMlcycsIGFkZHJlc3MsIHBvcnQgPyBgOiR7cG9ydH1gIDogJycpXG4gIH0pXG5cbiAgZGlhZ25vc3RpY3NDaGFubmVsLmNoYW5uZWwoJ3VuZGljaTp3ZWJzb2NrZXQ6Y2xvc2UnKS5zdWJzY3JpYmUoZXZ0ID0+IHtcbiAgICBjb25zdCB7IHdlYnNvY2tldCwgY29kZSwgcmVhc29uIH0gPSBldnRcbiAgICB3ZWJzb2NrZXREZWJ1Z2xvZyhcbiAgICAgICdjbG9zZWQgY29ubmVjdGlvbiB0byAlcyAtICVzICVzJyxcbiAgICAgIHdlYnNvY2tldC51cmwsXG4gICAgICBjb2RlLFxuICAgICAgcmVhc29uXG4gICAgKVxuICB9KVxuXG4gIGRpYWdub3N0aWNzQ2hhbm5lbC5jaGFubmVsKCd1bmRpY2k6d2Vic29ja2V0OnNvY2tldF9lcnJvcicpLnN1YnNjcmliZShlcnIgPT4ge1xuICAgIHdlYnNvY2tldERlYnVnbG9nKCdjb25uZWN0aW9uIGVycm9yZWQgLSAlcycsIGVyci5tZXNzYWdlKVxuICB9KVxuXG4gIGRpYWdub3N0aWNzQ2hhbm5lbC5jaGFubmVsKCd1bmRpY2k6d2Vic29ja2V0OnBpbmcnKS5zdWJzY3JpYmUoZXZ0ID0+IHtcbiAgICB3ZWJzb2NrZXREZWJ1Z2xvZygncGluZyByZWNlaXZlZCcpXG4gIH0pXG5cbiAgZGlhZ25vc3RpY3NDaGFubmVsLmNoYW5uZWwoJ3VuZGljaTp3ZWJzb2NrZXQ6cG9uZycpLnN1YnNjcmliZShldnQgPT4ge1xuICAgIHdlYnNvY2tldERlYnVnbG9nKCdwb25nIHJlY2VpdmVkJylcbiAgfSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNoYW5uZWxzXG59XG4iXSwibmFtZXMiOlsiZGlhZ25vc3RpY3NDaGFubmVsIiwicmVxdWlyZSIsInV0aWwiLCJ1bmRpY2lEZWJ1Z0xvZyIsImRlYnVnbG9nIiwiZmV0Y2hEZWJ1Z2xvZyIsIndlYnNvY2tldERlYnVnbG9nIiwiaXNDbGllbnRTZXQiLCJjaGFubmVscyIsImJlZm9yZUNvbm5lY3QiLCJjaGFubmVsIiwiY29ubmVjdGVkIiwiY29ubmVjdEVycm9yIiwic2VuZEhlYWRlcnMiLCJjcmVhdGUiLCJib2R5U2VudCIsImhlYWRlcnMiLCJ0cmFpbGVycyIsImVycm9yIiwib3BlbiIsImNsb3NlIiwic29ja2V0RXJyb3IiLCJwaW5nIiwicG9uZyIsImVuYWJsZWQiLCJzdWJzY3JpYmUiLCJldnQiLCJjb25uZWN0UGFyYW1zIiwidmVyc2lvbiIsInByb3RvY29sIiwicG9ydCIsImhvc3QiLCJtZXNzYWdlIiwicmVxdWVzdCIsIm1ldGhvZCIsInBhdGgiLCJvcmlnaW4iLCJyZXNwb25zZSIsInN0YXR1c0NvZGUiLCJhZGRyZXNzIiwid2Vic29ja2V0IiwiY29kZSIsInJlYXNvbiIsInVybCIsImVyciIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/core/diagnostics.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/core/errors.js":
/*!************************************************!*\
  !*** ./node_modules/undici/lib/core/errors.js ***!
  \************************************************/
/***/ ((module) => {

eval("\nclass UndiciError extends Error {\n    constructor(message){\n        super(message);\n        this.name = \"UndiciError\";\n        this.code = \"UND_ERR\";\n    }\n}\nclass ConnectTimeoutError extends UndiciError {\n    constructor(message){\n        super(message);\n        this.name = \"ConnectTimeoutError\";\n        this.message = message || \"Connect Timeout Error\";\n        this.code = \"UND_ERR_CONNECT_TIMEOUT\";\n    }\n}\nclass HeadersTimeoutError extends UndiciError {\n    constructor(message){\n        super(message);\n        this.name = \"HeadersTimeoutError\";\n        this.message = message || \"Headers Timeout Error\";\n        this.code = \"UND_ERR_HEADERS_TIMEOUT\";\n    }\n}\nclass HeadersOverflowError extends UndiciError {\n    constructor(message){\n        super(message);\n        this.name = \"HeadersOverflowError\";\n        this.message = message || \"Headers Overflow Error\";\n        this.code = \"UND_ERR_HEADERS_OVERFLOW\";\n    }\n}\nclass BodyTimeoutError extends UndiciError {\n    constructor(message){\n        super(message);\n        this.name = \"BodyTimeoutError\";\n        this.message = message || \"Body Timeout Error\";\n        this.code = \"UND_ERR_BODY_TIMEOUT\";\n    }\n}\nclass ResponseStatusCodeError extends UndiciError {\n    constructor(message, statusCode, headers, body){\n        super(message);\n        this.name = \"ResponseStatusCodeError\";\n        this.message = message || \"Response Status Code Error\";\n        this.code = \"UND_ERR_RESPONSE_STATUS_CODE\";\n        this.body = body;\n        this.status = statusCode;\n        this.statusCode = statusCode;\n        this.headers = headers;\n    }\n}\nclass InvalidArgumentError extends UndiciError {\n    constructor(message){\n        super(message);\n        this.name = \"InvalidArgumentError\";\n        this.message = message || \"Invalid Argument Error\";\n        this.code = \"UND_ERR_INVALID_ARG\";\n    }\n}\nclass InvalidReturnValueError extends UndiciError {\n    constructor(message){\n        super(message);\n        this.name = \"InvalidReturnValueError\";\n        this.message = message || \"Invalid Return Value Error\";\n        this.code = \"UND_ERR_INVALID_RETURN_VALUE\";\n    }\n}\nclass AbortError extends UndiciError {\n    constructor(message){\n        super(message);\n        this.name = \"AbortError\";\n        this.message = message || \"The operation was aborted\";\n    }\n}\nclass RequestAbortedError extends AbortError {\n    constructor(message){\n        super(message);\n        this.name = \"AbortError\";\n        this.message = message || \"Request aborted\";\n        this.code = \"UND_ERR_ABORTED\";\n    }\n}\nclass InformationalError extends UndiciError {\n    constructor(message){\n        super(message);\n        this.name = \"InformationalError\";\n        this.message = message || \"Request information\";\n        this.code = \"UND_ERR_INFO\";\n    }\n}\nclass RequestContentLengthMismatchError extends UndiciError {\n    constructor(message){\n        super(message);\n        this.name = \"RequestContentLengthMismatchError\";\n        this.message = message || \"Request body length does not match content-length header\";\n        this.code = \"UND_ERR_REQ_CONTENT_LENGTH_MISMATCH\";\n    }\n}\nclass ResponseContentLengthMismatchError extends UndiciError {\n    constructor(message){\n        super(message);\n        this.name = \"ResponseContentLengthMismatchError\";\n        this.message = message || \"Response body length does not match content-length header\";\n        this.code = \"UND_ERR_RES_CONTENT_LENGTH_MISMATCH\";\n    }\n}\nclass ClientDestroyedError extends UndiciError {\n    constructor(message){\n        super(message);\n        this.name = \"ClientDestroyedError\";\n        this.message = message || \"The client is destroyed\";\n        this.code = \"UND_ERR_DESTROYED\";\n    }\n}\nclass ClientClosedError extends UndiciError {\n    constructor(message){\n        super(message);\n        this.name = \"ClientClosedError\";\n        this.message = message || \"The client is closed\";\n        this.code = \"UND_ERR_CLOSED\";\n    }\n}\nclass SocketError extends UndiciError {\n    constructor(message, socket){\n        super(message);\n        this.name = \"SocketError\";\n        this.message = message || \"Socket error\";\n        this.code = \"UND_ERR_SOCKET\";\n        this.socket = socket;\n    }\n}\nclass NotSupportedError extends UndiciError {\n    constructor(message){\n        super(message);\n        this.name = \"NotSupportedError\";\n        this.message = message || \"Not supported error\";\n        this.code = \"UND_ERR_NOT_SUPPORTED\";\n    }\n}\nclass BalancedPoolMissingUpstreamError extends UndiciError {\n    constructor(message){\n        super(message);\n        this.name = \"MissingUpstreamError\";\n        this.message = message || \"No upstream has been added to the BalancedPool\";\n        this.code = \"UND_ERR_BPL_MISSING_UPSTREAM\";\n    }\n}\nclass HTTPParserError extends Error {\n    constructor(message, code, data){\n        super(message);\n        this.name = \"HTTPParserError\";\n        this.code = code ? `HPE_${code}` : undefined;\n        this.data = data ? data.toString() : undefined;\n    }\n}\nclass ResponseExceededMaxSizeError extends UndiciError {\n    constructor(message){\n        super(message);\n        this.name = \"ResponseExceededMaxSizeError\";\n        this.message = message || \"Response content exceeded max size\";\n        this.code = \"UND_ERR_RES_EXCEEDED_MAX_SIZE\";\n    }\n}\nclass RequestRetryError extends UndiciError {\n    constructor(message, code, { headers, data }){\n        super(message);\n        this.name = \"RequestRetryError\";\n        this.message = message || \"Request retry error\";\n        this.code = \"UND_ERR_REQ_RETRY\";\n        this.statusCode = code;\n        this.data = data;\n        this.headers = headers;\n    }\n}\nclass SecureProxyConnectionError extends UndiciError {\n    constructor(cause, message, options){\n        super(message, {\n            cause,\n            ...options ?? {}\n        });\n        this.name = \"SecureProxyConnectionError\";\n        this.message = message || \"Secure Proxy Connection failed\";\n        this.code = \"UND_ERR_PRX_TLS\";\n        this.cause = cause;\n    }\n}\nmodule.exports = {\n    AbortError,\n    HTTPParserError,\n    UndiciError,\n    HeadersTimeoutError,\n    HeadersOverflowError,\n    BodyTimeoutError,\n    RequestContentLengthMismatchError,\n    ConnectTimeoutError,\n    ResponseStatusCodeError,\n    InvalidArgumentError,\n    InvalidReturnValueError,\n    RequestAbortedError,\n    ClientDestroyedError,\n    ClientClosedError,\n    InformationalError,\n    SocketError,\n    NotSupportedError,\n    ResponseContentLengthMismatchError,\n    BalancedPoolMissingUpstreamError,\n    ResponseExceededMaxSizeError,\n    RequestRetryError,\n    SecureProxyConnectionError\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9jb3JlL2Vycm9ycy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU1BLG9CQUFvQkM7SUFDeEJDLFlBQWFDLE9BQU8sQ0FBRTtRQUNwQixLQUFLLENBQUNBO1FBQ04sSUFBSSxDQUFDQyxJQUFJLEdBQUc7UUFDWixJQUFJLENBQUNDLElBQUksR0FBRztJQUNkO0FBQ0Y7QUFFQSxNQUFNQyw0QkFBNEJOO0lBQ2hDRSxZQUFhQyxPQUFPLENBQUU7UUFDcEIsS0FBSyxDQUFDQTtRQUNOLElBQUksQ0FBQ0MsSUFBSSxHQUFHO1FBQ1osSUFBSSxDQUFDRCxPQUFPLEdBQUdBLFdBQVc7UUFDMUIsSUFBSSxDQUFDRSxJQUFJLEdBQUc7SUFDZDtBQUNGO0FBRUEsTUFBTUUsNEJBQTRCUDtJQUNoQ0UsWUFBYUMsT0FBTyxDQUFFO1FBQ3BCLEtBQUssQ0FBQ0E7UUFDTixJQUFJLENBQUNDLElBQUksR0FBRztRQUNaLElBQUksQ0FBQ0QsT0FBTyxHQUFHQSxXQUFXO1FBQzFCLElBQUksQ0FBQ0UsSUFBSSxHQUFHO0lBQ2Q7QUFDRjtBQUVBLE1BQU1HLDZCQUE2QlI7SUFDakNFLFlBQWFDLE9BQU8sQ0FBRTtRQUNwQixLQUFLLENBQUNBO1FBQ04sSUFBSSxDQUFDQyxJQUFJLEdBQUc7UUFDWixJQUFJLENBQUNELE9BQU8sR0FBR0EsV0FBVztRQUMxQixJQUFJLENBQUNFLElBQUksR0FBRztJQUNkO0FBQ0Y7QUFFQSxNQUFNSSx5QkFBeUJUO0lBQzdCRSxZQUFhQyxPQUFPLENBQUU7UUFDcEIsS0FBSyxDQUFDQTtRQUNOLElBQUksQ0FBQ0MsSUFBSSxHQUFHO1FBQ1osSUFBSSxDQUFDRCxPQUFPLEdBQUdBLFdBQVc7UUFDMUIsSUFBSSxDQUFDRSxJQUFJLEdBQUc7SUFDZDtBQUNGO0FBRUEsTUFBTUssZ0NBQWdDVjtJQUNwQ0UsWUFBYUMsT0FBTyxFQUFFUSxVQUFVLEVBQUVDLE9BQU8sRUFBRUMsSUFBSSxDQUFFO1FB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O1FBQ2xCLElBQUksQ0FBQ3dCLElBQUksR0FBR0E7UUFDWixJQUFJLENBQUNqQixPQUFPLEdBQUdBO0lBQ2pCO0FBQ0Y7QUFFQSxNQUFNc0IsbUNBQW1DbEM7SUFDdkNFLFlBQWFpQyxLQUFLLEVBQUVoQyxPQUFPLEVBQUVpQyxPQUFPLENBQUU7UUFDcEMsS0FBSyxDQUFDakMsU0FBUztZQUFFZ0M7WUFBTyxHQUFJQyxXQUFXLENBQUMsQ0FBQztRQUFFO1FBQzNDLElBQUksQ0FBQ2hDLElBQUksR0FBRztRQUNaLElBQUksQ0FBQ0QsT0FBTyxHQUFHQSxXQUFXO1FBQzFCLElBQUksQ0FBQ0UsSUFBSSxHQUFHO1FBQ1osSUFBSSxDQUFDOEIsS0FBSyxHQUFHQTtJQUNmO0FBQ0Y7QUFFQUUsT0FBT0MsT0FBTyxHQUFHO0lBQ2ZyQjtJQUNBVztJQUNBNUI7SUFDQU87SUFDQUM7SUFDQUM7SUFDQVc7SUFDQWQ7SUFDQUk7SUFDQUs7SUFDQUM7SUFDQUU7SUFDQUk7SUFDQUM7SUFDQUo7SUFDQUs7SUFDQUU7SUFDQUw7SUFDQU07SUFDQUs7SUFDQUM7SUFDQUM7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL21vY2t1cGZsb3cvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9jb3JlL2Vycm9ycy5qcz8wMzk2Iiwid2VicGFjazovL21vY2t1cGZsb3cvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9jb3JlL2Vycm9ycy5qcz8wMzk2KiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY2xhc3MgVW5kaWNpRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yIChtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSlcbiAgICB0aGlzLm5hbWUgPSAnVW5kaWNpRXJyb3InXG4gICAgdGhpcy5jb2RlID0gJ1VORF9FUlInXG4gIH1cbn1cblxuY2xhc3MgQ29ubmVjdFRpbWVvdXRFcnJvciBleHRlbmRzIFVuZGljaUVycm9yIHtcbiAgY29uc3RydWN0b3IgKG1lc3NhZ2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKVxuICAgIHRoaXMubmFtZSA9ICdDb25uZWN0VGltZW91dEVycm9yJ1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgJ0Nvbm5lY3QgVGltZW91dCBFcnJvcidcbiAgICB0aGlzLmNvZGUgPSAnVU5EX0VSUl9DT05ORUNUX1RJTUVPVVQnXG4gIH1cbn1cblxuY2xhc3MgSGVhZGVyc1RpbWVvdXRFcnJvciBleHRlbmRzIFVuZGljaUVycm9yIHtcbiAgY29uc3RydWN0b3IgKG1lc3NhZ2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKVxuICAgIHRoaXMubmFtZSA9ICdIZWFkZXJzVGltZW91dEVycm9yJ1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgJ0hlYWRlcnMgVGltZW91dCBFcnJvcidcbiAgICB0aGlzLmNvZGUgPSAnVU5EX0VSUl9IRUFERVJTX1RJTUVPVVQnXG4gIH1cbn1cblxuY2xhc3MgSGVhZGVyc092ZXJmbG93RXJyb3IgZXh0ZW5kcyBVbmRpY2lFcnJvciB7XG4gIGNvbnN0cnVjdG9yIChtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSlcbiAgICB0aGlzLm5hbWUgPSAnSGVhZGVyc092ZXJmbG93RXJyb3InXG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZSB8fCAnSGVhZGVycyBPdmVyZmxvdyBFcnJvcidcbiAgICB0aGlzLmNvZGUgPSAnVU5EX0VSUl9IRUFERVJTX09WRVJGTE9XJ1xuICB9XG59XG5cbmNsYXNzIEJvZHlUaW1lb3V0RXJyb3IgZXh0ZW5kcyBVbmRpY2lFcnJvciB7XG4gIGNvbnN0cnVjdG9yIChtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSlcbiAgICB0aGlzLm5hbWUgPSAnQm9keVRpbWVvdXRFcnJvcidcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlIHx8ICdCb2R5IFRpbWVvdXQgRXJyb3InXG4gICAgdGhpcy5jb2RlID0gJ1VORF9FUlJfQk9EWV9USU1FT1VUJ1xuICB9XG59XG5cbmNsYXNzIFJlc3BvbnNlU3RhdHVzQ29kZUVycm9yIGV4dGVuZHMgVW5kaWNpRXJyb3Ige1xuICBjb25zdHJ1Y3RvciAobWVzc2FnZSwgc3RhdHVzQ29kZSwgaGVhZGVycywgYm9keSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpXG4gICAgdGhpcy5uYW1lID0gJ1Jlc3BvbnNlU3RhdHVzQ29kZUVycm9yJ1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgJ1Jlc3BvbnNlIFN0YXR1cyBDb2RlIEVycm9yJ1xuICAgIHRoaXMuY29kZSA9ICdVTkRfRVJSX1JFU1BPTlNFX1NUQVRVU19DT0RFJ1xuICAgIHRoaXMuYm9keSA9IGJvZHlcbiAgICB0aGlzLnN0YXR1cyA9IHN0YXR1c0NvZGVcbiAgICB0aGlzLnN0YXR1c0NvZGUgPSBzdGF0dXNDb2RlXG4gICAgdGhpcy5oZWFkZXJzID0gaGVhZGVyc1xuICB9XG59XG5cbmNsYXNzIEludmFsaWRBcmd1bWVudEVycm9yIGV4dGVuZHMgVW5kaWNpRXJyb3Ige1xuICBjb25zdHJ1Y3RvciAobWVzc2FnZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpXG4gICAgdGhpcy5uYW1lID0gJ0ludmFsaWRBcmd1bWVudEVycm9yJ1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgJ0ludmFsaWQgQXJndW1lbnQgRXJyb3InXG4gICAgdGhpcy5jb2RlID0gJ1VORF9FUlJfSU5WQUxJRF9BUkcnXG4gIH1cbn1cblxuY2xhc3MgSW52YWxpZFJldHVyblZhbHVlRXJyb3IgZXh0ZW5kcyBVbmRpY2lFcnJvciB7XG4gIGNvbnN0cnVjdG9yIChtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSlcbiAgICB0aGlzLm5hbWUgPSAnSW52YWxpZFJldHVyblZhbHVlRXJyb3InXG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZSB8fCAnSW52YWxpZCBSZXR1cm4gVmFsdWUgRXJyb3InXG4gICAgdGhpcy5jb2RlID0gJ1VORF9FUlJfSU5WQUxJRF9SRVRVUk5fVkFMVUUnXG4gIH1cbn1cblxuY2xhc3MgQWJvcnRFcnJvciBleHRlbmRzIFVuZGljaUVycm9yIHtcbiAgY29uc3RydWN0b3IgKG1lc3NhZ2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKVxuICAgIHRoaXMubmFtZSA9ICdBYm9ydEVycm9yJ1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgJ1RoZSBvcGVyYXRpb24gd2FzIGFib3J0ZWQnXG4gIH1cbn1cblxuY2xhc3MgUmVxdWVzdEFib3J0ZWRFcnJvciBleHRlbmRzIEFib3J0RXJyb3Ige1xuICBjb25zdHJ1Y3RvciAobWVzc2FnZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpXG4gICAgdGhpcy5uYW1lID0gJ0Fib3J0RXJyb3InXG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZSB8fCAnUmVxdWVzdCBhYm9ydGVkJ1xuICAgIHRoaXMuY29kZSA9ICdVTkRfRVJSX0FCT1JURUQnXG4gIH1cbn1cblxuY2xhc3MgSW5mb3JtYXRpb25hbEVycm9yIGV4dGVuZHMgVW5kaWNpRXJyb3Ige1xuICBjb25zdHJ1Y3RvciAobWVzc2FnZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpXG4gICAgdGhpcy5uYW1lID0gJ0luZm9ybWF0aW9uYWxFcnJvcidcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlIHx8ICdSZXF1ZXN0IGluZm9ybWF0aW9uJ1xuICAgIHRoaXMuY29kZSA9ICdVTkRfRVJSX0lORk8nXG4gIH1cbn1cblxuY2xhc3MgUmVxdWVzdENvbnRlbnRMZW5ndGhNaXNtYXRjaEVycm9yIGV4dGVuZHMgVW5kaWNpRXJyb3Ige1xuICBjb25zdHJ1Y3RvciAobWVzc2FnZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpXG4gICAgdGhpcy5uYW1lID0gJ1JlcXVlc3RDb250ZW50TGVuZ3RoTWlzbWF0Y2hFcnJvcidcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlIHx8ICdSZXF1ZXN0IGJvZHkgbGVuZ3RoIGRvZXMgbm90IG1hdGNoIGNvbnRlbnQtbGVuZ3RoIGhlYWRlcidcbiAgICB0aGlzLmNvZGUgPSAnVU5EX0VSUl9SRVFfQ09OVEVOVF9MRU5HVEhfTUlTTUFUQ0gnXG4gIH1cbn1cblxuY2xhc3MgUmVzcG9uc2VDb250ZW50TGVuZ3RoTWlzbWF0Y2hFcnJvciBleHRlbmRzIFVuZGljaUVycm9yIHtcbiAgY29uc3RydWN0b3IgKG1lc3NhZ2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKVxuICAgIHRoaXMubmFtZSA9ICdSZXNwb25zZUNvbnRlbnRMZW5ndGhNaXNtYXRjaEVycm9yJ1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgJ1Jlc3BvbnNlIGJvZHkgbGVuZ3RoIGRvZXMgbm90IG1hdGNoIGNvbnRlbnQtbGVuZ3RoIGhlYWRlcidcbiAgICB0aGlzLmNvZGUgPSAnVU5EX0VSUl9SRVNfQ09OVEVOVF9MRU5HVEhfTUlTTUFUQ0gnXG4gIH1cbn1cblxuY2xhc3MgQ2xpZW50RGVzdHJveWVkRXJyb3IgZXh0ZW5kcyBVbmRpY2lFcnJvciB7XG4gIGNvbnN0cnVjdG9yIChtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSlcbiAgICB0aGlzLm5hbWUgPSAnQ2xpZW50RGVzdHJveWVkRXJyb3InXG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZSB8fCAnVGhlIGNsaWVudCBpcyBkZXN0cm95ZWQnXG4gICAgdGhpcy5jb2RlID0gJ1VORF9FUlJfREVTVFJPWUVEJ1xuICB9XG59XG5cbmNsYXNzIENsaWVudENsb3NlZEVycm9yIGV4dGVuZHMgVW5kaWNpRXJyb3Ige1xuICBjb25zdHJ1Y3RvciAobWVzc2FnZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpXG4gICAgdGhpcy5uYW1lID0gJ0NsaWVudENsb3NlZEVycm9yJ1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgJ1RoZSBjbGllbnQgaXMgY2xvc2VkJ1xuICAgIHRoaXMuY29kZSA9ICdVTkRfRVJSX0NMT1NFRCdcbiAgfVxufVxuXG5jbGFzcyBTb2NrZXRFcnJvciBleHRlbmRzIFVuZGljaUVycm9yIHtcbiAgY29uc3RydWN0b3IgKG1lc3NhZ2UsIHNvY2tldCkge1xuICAgIHN1cGVyKG1lc3NhZ2UpXG4gICAgdGhpcy5uYW1lID0gJ1NvY2tldEVycm9yJ1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgJ1NvY2tldCBlcnJvcidcbiAgICB0aGlzLmNvZGUgPSAnVU5EX0VSUl9TT0NLRVQnXG4gICAgdGhpcy5zb2NrZXQgPSBzb2NrZXRcbiAgfVxufVxuXG5jbGFzcyBOb3RTdXBwb3J0ZWRFcnJvciBleHRlbmRzIFVuZGljaUVycm9yIHtcbiAgY29uc3RydWN0b3IgKG1lc3NhZ2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKVxuICAgIHRoaXMubmFtZSA9ICdOb3RTdXBwb3J0ZWRFcnJvcidcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlIHx8ICdOb3Qgc3VwcG9ydGVkIGVycm9yJ1xuICAgIHRoaXMuY29kZSA9ICdVTkRfRVJSX05PVF9TVVBQT1JURUQnXG4gIH1cbn1cblxuY2xhc3MgQmFsYW5jZWRQb29sTWlzc2luZ1Vwc3RyZWFtRXJyb3IgZXh0ZW5kcyBVbmRpY2lFcnJvciB7XG4gIGNvbnN0cnVjdG9yIChtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSlcbiAgICB0aGlzLm5hbWUgPSAnTWlzc2luZ1Vwc3RyZWFtRXJyb3InXG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZSB8fCAnTm8gdXBzdHJlYW0gaGFzIGJlZW4gYWRkZWQgdG8gdGhlIEJhbGFuY2VkUG9vbCdcbiAgICB0aGlzLmNvZGUgPSAnVU5EX0VSUl9CUExfTUlTU0lOR19VUFNUUkVBTSdcbiAgfVxufVxuXG5jbGFzcyBIVFRQUGFyc2VyRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yIChtZXNzYWdlLCBjb2RlLCBkYXRhKSB7XG4gICAgc3VwZXIobWVzc2FnZSlcbiAgICB0aGlzLm5hbWUgPSAnSFRUUFBhcnNlckVycm9yJ1xuICAgIHRoaXMuY29kZSA9IGNvZGUgPyBgSFBFXyR7Y29kZX1gIDogdW5kZWZpbmVkXG4gICAgdGhpcy5kYXRhID0gZGF0YSA/IGRhdGEudG9TdHJpbmcoKSA6IHVuZGVmaW5lZFxuICB9XG59XG5cbmNsYXNzIFJlc3BvbnNlRXhjZWVkZWRNYXhTaXplRXJyb3IgZXh0ZW5kcyBVbmRpY2lFcnJvciB7XG4gIGNvbnN0cnVjdG9yIChtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSlcbiAgICB0aGlzLm5hbWUgPSAnUmVzcG9uc2VFeGNlZWRlZE1heFNpemVFcnJvcidcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlIHx8ICdSZXNwb25zZSBjb250ZW50IGV4Y2VlZGVkIG1heCBzaXplJ1xuICAgIHRoaXMuY29kZSA9ICdVTkRfRVJSX1JFU19FWENFRURFRF9NQVhfU0laRSdcbiAgfVxufVxuXG5jbGFzcyBSZXF1ZXN0UmV0cnlFcnJvciBleHRlbmRzIFVuZGljaUVycm9yIHtcbiAgY29uc3RydWN0b3IgKG1lc3NhZ2UsIGNvZGUsIHsgaGVhZGVycywgZGF0YSB9KSB7XG4gICAgc3VwZXIobWVzc2FnZSlcbiAgICB0aGlzLm5hbWUgPSAnUmVxdWVzdFJldHJ5RXJyb3InXG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZSB8fCAnUmVxdWVzdCByZXRyeSBlcnJvcidcbiAgICB0aGlzLmNvZGUgPSAnVU5EX0VSUl9SRVFfUkVUUlknXG4gICAgdGhpcy5zdGF0dXNDb2RlID0gY29kZVxuICAgIHRoaXMuZGF0YSA9IGRhdGFcbiAgICB0aGlzLmhlYWRlcnMgPSBoZWFkZXJzXG4gIH1cbn1cblxuY2xhc3MgU2VjdXJlUHJveHlDb25uZWN0aW9uRXJyb3IgZXh0ZW5kcyBVbmRpY2lFcnJvciB7XG4gIGNvbnN0cnVjdG9yIChjYXVzZSwgbWVzc2FnZSwgb3B0aW9ucykge1xuICAgIHN1cGVyKG1lc3NhZ2UsIHsgY2F1c2UsIC4uLihvcHRpb25zID8/IHt9KSB9KVxuICAgIHRoaXMubmFtZSA9ICdTZWN1cmVQcm94eUNvbm5lY3Rpb25FcnJvcidcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlIHx8ICdTZWN1cmUgUHJveHkgQ29ubmVjdGlvbiBmYWlsZWQnXG4gICAgdGhpcy5jb2RlID0gJ1VORF9FUlJfUFJYX1RMUydcbiAgICB0aGlzLmNhdXNlID0gY2F1c2VcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgQWJvcnRFcnJvcixcbiAgSFRUUFBhcnNlckVycm9yLFxuICBVbmRpY2lFcnJvcixcbiAgSGVhZGVyc1RpbWVvdXRFcnJvcixcbiAgSGVhZGVyc092ZXJmbG93RXJyb3IsXG4gIEJvZHlUaW1lb3V0RXJyb3IsXG4gIFJlcXVlc3RDb250ZW50TGVuZ3RoTWlzbWF0Y2hFcnJvcixcbiAgQ29ubmVjdFRpbWVvdXRFcnJvcixcbiAgUmVzcG9uc2VTdGF0dXNDb2RlRXJyb3IsXG4gIEludmFsaWRBcmd1bWVudEVycm9yLFxuICBJbnZhbGlkUmV0dXJuVmFsdWVFcnJvcixcbiAgUmVxdWVzdEFib3J0ZWRFcnJvcixcbiAgQ2xpZW50RGVzdHJveWVkRXJyb3IsXG4gIENsaWVudENsb3NlZEVycm9yLFxuICBJbmZvcm1hdGlvbmFsRXJyb3IsXG4gIFNvY2tldEVycm9yLFxuICBOb3RTdXBwb3J0ZWRFcnJvcixcbiAgUmVzcG9uc2VDb250ZW50TGVuZ3RoTWlzbWF0Y2hFcnJvcixcbiAgQmFsYW5jZWRQb29sTWlzc2luZ1Vwc3RyZWFtRXJyb3IsXG4gIFJlc3BvbnNlRXhjZWVkZWRNYXhTaXplRXJyb3IsXG4gIFJlcXVlc3RSZXRyeUVycm9yLFxuICBTZWN1cmVQcm94eUNvbm5lY3Rpb25FcnJvclxufVxuIl0sIm5hbWVzIjpbIlVuZGljaUVycm9yIiwiRXJyb3IiLCJjb25zdHJ1Y3RvciIsIm1lc3NhZ2UiLCJuYW1lIiwiY29kZSIsIkNvbm5lY3RUaW1lb3V0RXJyb3IiLCJIZWFkZXJzVGltZW91dEVycm9yIiwiSGVhZGVyc092ZXJmbG93RXJyb3IiLCJCb2R5VGltZW91dEVycm9yIiwiUmVzcG9uc2VTdGF0dXNDb2RlRXJyb3IiLCJzdGF0dXNDb2RlIiwiaGVhZGVycyIsImJvZHkiLCJzdGF0dXMiLCJJbnZhbGlkQXJndW1lbnRFcnJvciIsIkludmFsaWRSZXR1cm5WYWx1ZUVycm9yIiwiQWJvcnRFcnJvciIsIlJlcXVlc3RBYm9ydGVkRXJyb3IiLCJJbmZvcm1hdGlvbmFsRXJyb3IiLCJSZXF1ZXN0Q29udGVudExlbmd0aE1pc21hdGNoRXJyb3IiLCJSZXNwb25zZUNvbnRlbnRMZW5ndGhNaXNtYXRjaEVycm9yIiwiQ2xpZW50RGVzdHJveWVkRXJyb3IiLCJDbGllbnRDbG9zZWRFcnJvciIsIlNvY2tldEVycm9yIiwic29ja2V0IiwiTm90U3VwcG9ydGVkRXJyb3IiLCJCYWxhbmNlZFBvb2xNaXNzaW5nVXBzdHJlYW1FcnJvciIsIkhUVFBQYXJzZXJFcnJvciIsImRhdGEiLCJ1bmRlZmluZWQiLCJ0b1N0cmluZyIsIlJlc3BvbnNlRXhjZWVkZWRNYXhTaXplRXJyb3IiLCJSZXF1ZXN0UmV0cnlFcnJvciIsIlNlY3VyZVByb3h5Q29ubmVjdGlvbkVycm9yIiwiY2F1c2UiLCJvcHRpb25zIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/core/errors.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/core/request.js":
/*!*************************************************!*\
  !*** ./node_modules/undici/lib/core/request.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { InvalidArgumentError, NotSupportedError } = __webpack_require__(/*! ./errors */ \"(ssr)/./node_modules/undici/lib/core/errors.js\");\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\");\nconst { isValidHTTPToken, isValidHeaderValue, isStream, destroy, isBuffer, isFormDataLike, isIterable, isBlobLike, buildURL, validateHandler, getServerName, normalizedMethodRecords } = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/undici/lib/core/util.js\");\nconst { channels } = __webpack_require__(/*! ./diagnostics.js */ \"(ssr)/./node_modules/undici/lib/core/diagnostics.js\");\nconst { headerNameLowerCasedRecord } = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/undici/lib/core/constants.js\");\n// Verifies that a given path is valid does not contain control chars \\x00 to \\x20\nconst invalidPathRegex = /[^\\u0021-\\u00ff]/;\nconst kHandler = Symbol(\"handler\");\nclass Request {\n    constructor(origin, { path, method, body, headers, query, idempotent, blocking, upgrade, headersTimeout, bodyTimeout, reset, throwOnError, expectContinue, servername }, handler){\n        if (typeof path !== \"string\") {\n            throw new InvalidArgumentError(\"path must be a string\");\n        } else if (path[0] !== \"/\" && !(path.startsWith(\"http://\") || path.startsWith(\"https://\")) && method !== \"CONNECT\") {\n            throw new InvalidArgumentError(\"path must be an absolute URL or start with a slash\");\n        } else if (invalidPathRegex.test(path)) {\n            throw new InvalidArgumentError(\"invalid request path\");\n        }\n        if (typeof method !== \"string\") {\n            throw new InvalidArgumentError(\"method must be a string\");\n        } else if (normalizedMethodRecords[method] === undefined && !isValidHTTPToken(method)) {\n            throw new InvalidArgumentError(\"invalid request method\");\n        }\n        if (upgrade && typeof upgrade !== \"string\") {\n            throw new InvalidArgumentError(\"upgrade must be a string\");\n        }\n        if (headersTimeout != null && (!Number.isFinite(headersTimeout) || headersTimeout < 0)) {\n            throw new InvalidArgumentError(\"invalid headersTimeout\");\n        }\n        if (bodyTimeout != null && (!Number.isFinite(bodyTimeout) || bodyTimeout < 0)) {\n            throw new InvalidArgumentError(\"invalid bodyTimeout\");\n        }\n        if (reset != null && typeof reset !== \"boolean\") {\n            throw new InvalidArgumentError(\"invalid reset\");\n        }\n        if (expectContinue != null && typeof expectContinue !== \"boolean\") {\n            throw new InvalidArgumentError(\"invalid expectContinue\");\n        }\n        this.headersTimeout = headersTimeout;\n        this.bodyTimeout = bodyTimeout;\n        this.throwOnError = throwOnError === true;\n        this.method = method;\n        this.abort = null;\n        if (body == null) {\n            this.body = null;\n        } else if (isStream(body)) {\n            this.body = body;\n            const rState = this.body._readableState;\n            if (!rState || !rState.autoDestroy) {\n                this.endHandler = function autoDestroy() {\n                    destroy(this);\n                };\n                this.body.on(\"end\", this.endHandler);\n            }\n            this.errorHandler = (err)=>{\n                if (this.abort) {\n                    this.abort(err);\n                } else {\n                    this.error = err;\n                }\n            };\n            this.body.on(\"error\", this.errorHandler);\n        } else if (isBuffer(body)) {\n            this.body = body.byteLength ? body : null;\n        } else if (ArrayBuffer.isView(body)) {\n            this.body = body.buffer.byteLength ? Buffer.from(body.buffer, body.byteOffset, body.byteLength) : null;\n        } else if (body instanceof ArrayBuffer) {\n            this.body = body.byteLength ? Buffer.from(body) : null;\n        } else if (typeof body === \"string\") {\n            this.body = body.length ? Buffer.from(body) : null;\n        } else if (isFormDataLike(body) || isIterable(body) || isBlobLike(body)) {\n            this.body = body;\n        } else {\n            throw new InvalidArgumentError(\"body must be a string, a Buffer, a Readable stream, an iterable, or an async iterable\");\n        }\n        this.completed = false;\n        this.aborted = false;\n        this.upgrade = upgrade || null;\n        this.path = query ? buildURL(path, query) : path;\n        this.origin = origin;\n        this.idempotent = idempotent == null ? method === \"HEAD\" || method === \"GET\" : idempotent;\n        this.blocking = blocking == null ? false : blocking;\n        this.reset = reset == null ? null : reset;\n        this.host = null;\n        this.contentLength = null;\n        this.contentType = null;\n        this.headers = [];\n        // Only for H2\n        this.expectContinue = expectContinue != null ? expectContinue : false;\n        if (Array.isArray(headers)) {\n            if (headers.length % 2 !== 0) {\n                throw new InvalidArgumentError(\"headers array must be even\");\n            }\n            for(let i = 0; i < headers.length; i += 2){\n                processHeader(this, headers[i], headers[i + 1]);\n            }\n        } else if (headers && typeof headers === \"object\") {\n            if (headers[Symbol.iterator]) {\n                for (const header of headers){\n                    if (!Array.isArray(header) || header.length !== 2) {\n                        throw new InvalidArgumentError(\"headers must be in key-value pair format\");\n                    }\n                    processHeader(this, header[0], header[1]);\n                }\n            } else {\n                const keys = Object.keys(headers);\n                for(let i = 0; i < keys.length; ++i){\n                    processHeader(this, keys[i], headers[keys[i]]);\n                }\n            }\n        } else if (headers != null) {\n            throw new InvalidArgumentError(\"headers must be an object or an array\");\n        }\n        validateHandler(handler, method, upgrade);\n        this.servername = servername || getServerName(this.host);\n        this[kHandler] = handler;\n        if (channels.create.hasSubscribers) {\n            channels.create.publish({\n                request: this\n            });\n        }\n    }\n    onBodySent(chunk) {\n        if (this[kHandler].onBodySent) {\n            try {\n                return this[kHandler].onBodySent(chunk);\n            } catch (err) {\n                this.abort(err);\n            }\n        }\n    }\n    onRequestSent() {\n        if (channels.bodySent.hasSubscribers) {\n            channels.bodySent.publish({\n                request: this\n            });\n        }\n        if (this[kHandler].onRequestSent) {\n            try {\n                return this[kHandler].onRequestSent();\n            } catch (err) {\n                this.abort(err);\n            }\n        }\n    }\n    onConnect(abort) {\n        assert(!this.aborted);\n        assert(!this.completed);\n        if (this.error) {\n            abort(this.error);\n        } else {\n            this.abort = abort;\n            return this[kHandler].onConnect(abort);\n        }\n    }\n    onResponseStarted() {\n        return this[kHandler].onResponseStarted?.();\n    }\n    onHeaders(statusCode, headers, resume, statusText) {\n        assert(!this.aborted);\n        assert(!this.completed);\n        if (channels.headers.hasSubscribers) {\n            channels.headers.publish({\n                request: this,\n                response: {\n                    statusCode,\n                    headers,\n                    statusText\n                }\n            });\n        }\n        try {\n            return this[kHandler].onHeaders(statusCode, headers, resume, statusText);\n        } catch (err) {\n            this.abort(err);\n        }\n    }\n    onData(chunk) {\n        assert(!this.aborted);\n        assert(!this.completed);\n        try {\n            return this[kHandler].onData(chunk);\n        } catch (err) {\n            this.abort(err);\n            return false;\n        }\n    }\n    onUpgrade(statusCode, headers, socket) {\n        assert(!this.aborted);\n        assert(!this.completed);\n        return this[kHandler].onUpgrade(statusCode, headers, socket);\n    }\n    onComplete(trailers) {\n        this.onFinally();\n        assert(!this.aborted);\n        this.completed = true;\n        if (channels.trailers.hasSubscribers) {\n            channels.trailers.publish({\n                request: this,\n                trailers\n            });\n        }\n        try {\n            return this[kHandler].onComplete(trailers);\n        } catch (err) {\n            // TODO (fix): This might be a bad idea?\n            this.onError(err);\n        }\n    }\n    onError(error) {\n        this.onFinally();\n        if (channels.error.hasSubscribers) {\n            channels.error.publish({\n                request: this,\n                error\n            });\n        }\n        if (this.aborted) {\n            return;\n        }\n        this.aborted = true;\n        return this[kHandler].onError(error);\n    }\n    onFinally() {\n        if (this.errorHandler) {\n            this.body.off(\"error\", this.errorHandler);\n            this.errorHandler = null;\n        }\n        if (this.endHandler) {\n            this.body.off(\"end\", this.endHandler);\n            this.endHandler = null;\n        }\n    }\n    addHeader(key, value) {\n        processHeader(this, key, value);\n        return this;\n    }\n}\nfunction processHeader(request, key, val) {\n    if (val && typeof val === \"object\" && !Array.isArray(val)) {\n        throw new InvalidArgumentError(`invalid ${key} header`);\n    } else if (val === undefined) {\n        return;\n    }\n    let headerName = headerNameLowerCasedRecord[key];\n    if (headerName === undefined) {\n        headerName = key.toLowerCase();\n        if (headerNameLowerCasedRecord[headerName] === undefined && !isValidHTTPToken(headerName)) {\n            throw new InvalidArgumentError(\"invalid header key\");\n        }\n    }\n    if (Array.isArray(val)) {\n        const arr = [];\n        for(let i = 0; i < val.length; i++){\n            if (typeof val[i] === \"string\") {\n                if (!isValidHeaderValue(val[i])) {\n                    throw new InvalidArgumentError(`invalid ${key} header`);\n                }\n                arr.push(val[i]);\n            } else if (val[i] === null) {\n                arr.push(\"\");\n            } else if (typeof val[i] === \"object\") {\n                throw new InvalidArgumentError(`invalid ${key} header`);\n            } else {\n                arr.push(`${val[i]}`);\n            }\n        }\n        val = arr;\n    } else if (typeof val === \"string\") {\n        if (!isValidHeaderValue(val)) {\n            throw new InvalidArgumentError(`invalid ${key} header`);\n        }\n    } else if (val === null) {\n        val = \"\";\n    } else {\n        val = `${val}`;\n    }\n    if (request.host === null && headerName === \"host\") {\n        if (typeof val !== \"string\") {\n            throw new InvalidArgumentError(\"invalid host header\");\n        }\n        // Consumed by Client\n        request.host = val;\n    } else if (request.contentLength === null && headerName === \"content-length\") {\n        request.contentLength = parseInt(val, 10);\n        if (!Number.isFinite(request.contentLength)) {\n            throw new InvalidArgumentError(\"invalid content-length header\");\n        }\n    } else if (request.contentType === null && headerName === \"content-type\") {\n        request.contentType = val;\n        request.headers.push(key, val);\n    } else if (headerName === \"transfer-encoding\" || headerName === \"keep-alive\" || headerName === \"upgrade\") {\n        throw new InvalidArgumentError(`invalid ${headerName} header`);\n    } else if (headerName === \"connection\") {\n        const value = typeof val === \"string\" ? val.toLowerCase() : null;\n        if (value !== \"close\" && value !== \"keep-alive\") {\n            throw new InvalidArgumentError(\"invalid connection header\");\n        }\n        if (value === \"close\") {\n            request.reset = true;\n        }\n    } else if (headerName === \"expect\") {\n        throw new NotSupportedError(\"expect header not supported\");\n    } else {\n        request.headers.push(key, val);\n    }\n}\nmodule.exports = Request;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9jb3JlL3JlcXVlc3QuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNLEVBQ0pBLG9CQUFvQixFQUNwQkMsaUJBQUFBLEVBQ0QsR0FBR0MsbUJBQU9BLENBQUM7QUFDWixNQUFNQyxTQUFTRCxtQkFBT0EsQ0FBQztBQUN2QixNQUFNLEVBQ0pFLGdCQUFnQixFQUNoQkMsa0JBQWtCLEVBQ2xCQyxRQUFRLEVBQ1JDLE9BQU8sRUFDUEMsUUFBUSxFQUNSQyxjQUFjLEVBQ2RDLFVBQVUsRUFDVkMsVUFBVSxFQUNWQyxRQUFRLEVBQ1JDLGVBQWUsRUFDZkMsYUFBYSxFQUNiQyx1QkFBQUEsRUFDRCxHQUFHYixtQkFBT0EsQ0FBQztBQUNaLE1BQU0sRUFBRWMsUUFBQUEsRUFBVSxHQUFHZCxtQkFBT0EsQ0FBQztBQUM3QixNQUFNLEVBQUVlLDBCQUFBQSxFQUE0QixHQUFHZixtQkFBT0EsQ0FBQztBQUUvQztBQUNBLE1BQU1nQixtQkFBbUI7QUFFekIsTUFBTUMsV0FBV0MsT0FBTztBQUV4QixNQUFNQztJQUNKQyxZQUFhQyxNQUFNLEVBQUUsRUFDbkJDLElBQUksRUFDSkMsTUFBTSxFQUNOQyxJQUFJLEVBQ0pDLE9BQU8sRUFDUEMsS0FBSyxFQUNMQyxVQUFVLEVBQ1ZDLFFBQVEsRUFDUkMsT0FBTyxFQUNQQyxjQUFjLEVBQ2RDLFdBQVcsRUFDWEMsS0FBSyxFQUNMQyxZQUFZLEVBQ1pDLGNBQWMsRUFDZEMsVUFBQUEsRUFDRCxFQUFFQyxPQUFPLENBQUU7UUFDVixJQUFJLE9BQU9kLFNBQVMsVUFBVTtZQUM1QixNQUFNLElBQUl4QixxQkFBcUI7UUFDakMsT0FBTyxJQUNMd0IsSUFBSSxDQUFDLEVBQUUsS0FBSyxPQUNaLENBQUVBLENBQUFBLEtBQUtlLFVBQVUsQ0FBQyxjQUFjZixLQUFLZSxVQUFVLENBQUMsV0FBVSxLQUMxRGQsV0FBVyxXQUNYO1lBQ0EsTUFBTSxJQUFJekIscUJBQXFCO1FBQ2pDLE9B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S0FBSyxRQUFRcUMsZUFBZSxrQkFBa0I7UUFDNUV4QixRQUFRYixhQUFhLEdBQUd5QyxTQUFTTCxLQUFLO1FBQ3RDLElBQUksQ0FBQzFELE9BQU9DLFFBQVEsQ0FBQ2tDLFFBQVFiLGFBQWEsR0FBRztZQUMzQyxNQUFNLElBQUloRSxxQkFBcUI7UUFDakM7SUFDRixPQUFPLElBQUk2RSxRQUFRWixXQUFXLEtBQUssUUFBUW9DLGVBQWUsZ0JBQWdCO1FBQ3hFeEIsUUFBUVosV0FBVyxHQUFHbUM7UUFDdEJ2QixRQUFRbEQsT0FBTyxDQUFDNkUsSUFBSSxDQUFDTixLQUFLRTtJQUM1QixPQUFPLElBQUlDLGVBQWUsdUJBQXVCQSxlQUFlLGdCQUFnQkEsZUFBZSxXQUFXO1FBQ3hHLE1BQU0sSUFBSXJHLHFCQUFxQixXQUFXcUcsV0FBVSxRQUFTO0lBQy9ELE9BQU8sSUFBSUEsZUFBZSxjQUFjO1FBQ3RDLE1BQU1GLFFBQVEsT0FBT0MsUUFBUSxXQUFXQSxJQUFJRSxXQUFXLEtBQUs7UUFDNUQsSUFBSUgsVUFBVSxXQUFXQSxVQUFVLGNBQWM7WUFDL0MsTUFBTSxJQUFJbkcscUJBQXFCO1FBQ2pDO1FBRUEsSUFBSW1HLFVBQVUsU0FBUztZQUNyQnRCLFFBQVEzQyxLQUFLLEdBQUc7UUFDbEI7SUFDRixPQUFPLElBQUltRSxlQUFlLFVBQVU7UUFDbEMsTUFBTSxJQUFJcEcsa0JBQWtCO0lBQzlCLE9BQU87UUFDTDRFLFFBQVFsRCxPQUFPLENBQUM2RSxJQUFJLENBQUNOLEtBQUtFO0lBQzVCO0FBQ0Y7QUFFQU0sT0FBT0MsT0FBTyxHQUFHdEYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tb2NrdXBmbG93Ly4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvY29yZS9yZXF1ZXN0LmpzPzM4YTQiLCJ3ZWJwYWNrOi8vbW9ja3VwZmxvdy8uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2NvcmUvcmVxdWVzdC5qcz8zOGE0KiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3Qge1xuICBJbnZhbGlkQXJndW1lbnRFcnJvcixcbiAgTm90U3VwcG9ydGVkRXJyb3Jcbn0gPSByZXF1aXJlKCcuL2Vycm9ycycpXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdub2RlOmFzc2VydCcpXG5jb25zdCB7XG4gIGlzVmFsaWRIVFRQVG9rZW4sXG4gIGlzVmFsaWRIZWFkZXJWYWx1ZSxcbiAgaXNTdHJlYW0sXG4gIGRlc3Ryb3ksXG4gIGlzQnVmZmVyLFxuICBpc0Zvcm1EYXRhTGlrZSxcbiAgaXNJdGVyYWJsZSxcbiAgaXNCbG9iTGlrZSxcbiAgYnVpbGRVUkwsXG4gIHZhbGlkYXRlSGFuZGxlcixcbiAgZ2V0U2VydmVyTmFtZSxcbiAgbm9ybWFsaXplZE1ldGhvZFJlY29yZHNcbn0gPSByZXF1aXJlKCcuL3V0aWwnKVxuY29uc3QgeyBjaGFubmVscyB9ID0gcmVxdWlyZSgnLi9kaWFnbm9zdGljcy5qcycpXG5jb25zdCB7IGhlYWRlck5hbWVMb3dlckNhc2VkUmVjb3JkIH0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpXG5cbi8vIFZlcmlmaWVzIHRoYXQgYSBnaXZlbiBwYXRoIGlzIHZhbGlkIGRvZXMgbm90IGNvbnRhaW4gY29udHJvbCBjaGFycyBcXHgwMCB0byBcXHgyMFxuY29uc3QgaW52YWxpZFBhdGhSZWdleCA9IC9bXlxcdTAwMjEtXFx1MDBmZl0vXG5cbmNvbnN0IGtIYW5kbGVyID0gU3ltYm9sKCdoYW5kbGVyJylcblxuY2xhc3MgUmVxdWVzdCB7XG4gIGNvbnN0cnVjdG9yIChvcmlnaW4sIHtcbiAgICBwYXRoLFxuICAgIG1ldGhvZCxcbiAgICBib2R5LFxuICAgIGhlYWRlcnMsXG4gICAgcXVlcnksXG4gICAgaWRlbXBvdGVudCxcbiAgICBibG9ja2luZyxcbiAgICB1cGdyYWRlLFxuICAgIGhlYWRlcnNUaW1lb3V0LFxuICAgIGJvZHlUaW1lb3V0LFxuICAgIHJlc2V0LFxuICAgIHRocm93T25FcnJvcixcbiAgICBleHBlY3RDb250aW51ZSxcbiAgICBzZXJ2ZXJuYW1lXG4gIH0sIGhhbmRsZXIpIHtcbiAgICBpZiAodHlwZW9mIHBhdGggIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ3BhdGggbXVzdCBiZSBhIHN0cmluZycpXG4gICAgfSBlbHNlIGlmIChcbiAgICAgIHBhdGhbMF0gIT09ICcvJyAmJlxuICAgICAgIShwYXRoLnN0YXJ0c1dpdGgoJ2h0dHA6Ly8nKSB8fCBwYXRoLnN0YXJ0c1dpdGgoJ2h0dHBzOi8vJykpICYmXG4gICAgICBtZXRob2QgIT09ICdDT05ORUNUJ1xuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdwYXRoIG11c3QgYmUgYW4gYWJzb2x1dGUgVVJMIG9yIHN0YXJ0IHdpdGggYSBzbGFzaCcpXG4gICAgfSBlbHNlIGlmIChpbnZhbGlkUGF0aFJlZ2V4LnRlc3QocGF0aCkpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCByZXF1ZXN0IHBhdGgnKVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbWV0aG9kICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdtZXRob2QgbXVzdCBiZSBhIHN0cmluZycpXG4gICAgfSBlbHNlIGlmIChub3JtYWxpemVkTWV0aG9kUmVjb3Jkc1ttZXRob2RdID09PSB1bmRlZmluZWQgJiYgIWlzVmFsaWRIVFRQVG9rZW4obWV0aG9kKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIHJlcXVlc3QgbWV0aG9kJylcbiAgICB9XG5cbiAgICBpZiAodXBncmFkZSAmJiB0eXBlb2YgdXBncmFkZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcigndXBncmFkZSBtdXN0IGJlIGEgc3RyaW5nJylcbiAgICB9XG5cbiAgICBpZiAoaGVhZGVyc1RpbWVvdXQgIT0gbnVsbCAmJiAoIU51bWJlci5pc0Zpbml0ZShoZWFkZXJzVGltZW91dCkgfHwgaGVhZGVyc1RpbWVvdXQgPCAwKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIGhlYWRlcnNUaW1lb3V0JylcbiAgICB9XG5cbiAgICBpZiAoYm9keVRpbWVvdXQgIT0gbnVsbCAmJiAoIU51bWJlci5pc0Zpbml0ZShib2R5VGltZW91dCkgfHwgYm9keVRpbWVvdXQgPCAwKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIGJvZHlUaW1lb3V0JylcbiAgICB9XG5cbiAgICBpZiAocmVzZXQgIT0gbnVsbCAmJiB0eXBlb2YgcmVzZXQgIT09ICdib29sZWFuJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIHJlc2V0JylcbiAgICB9XG5cbiAgICBpZiAoZXhwZWN0Q29udGludWUgIT0gbnVsbCAmJiB0eXBlb2YgZXhwZWN0Q29udGludWUgIT09ICdib29sZWFuJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIGV4cGVjdENvbnRpbnVlJylcbiAgICB9XG5cbiAgICB0aGlzLmhlYWRlcnNUaW1lb3V0ID0gaGVhZGVyc1RpbWVvdXRcblxuICAgIHRoaXMuYm9keVRpbWVvdXQgPSBib2R5VGltZW91dFxuXG4gICAgdGhpcy50aHJvd09uRXJyb3IgPSB0aHJvd09uRXJyb3IgPT09IHRydWVcblxuICAgIHRoaXMubWV0aG9kID0gbWV0aG9kXG5cbiAgICB0aGlzLmFib3J0ID0gbnVsbFxuXG4gICAgaWYgKGJvZHkgPT0gbnVsbCkge1xuICAgICAgdGhpcy5ib2R5ID0gbnVsbFxuICAgIH0gZWxzZSBpZiAoaXNTdHJlYW0oYm9keSkpIHtcbiAgICAgIHRoaXMuYm9keSA9IGJvZHlcblxuICAgICAgY29uc3QgclN0YXRlID0gdGhpcy5ib2R5Ll9yZWFkYWJsZVN0YXRlXG4gICAgICBpZiAoIXJTdGF0ZSB8fCAhclN0YXRlLmF1dG9EZXN0cm95KSB7XG4gICAgICAgIHRoaXMuZW5kSGFuZGxlciA9IGZ1bmN0aW9uIGF1dG9EZXN0cm95ICgpIHtcbiAgICAgICAgICBkZXN0cm95KHRoaXMpXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ib2R5Lm9uKCdlbmQnLCB0aGlzLmVuZEhhbmRsZXIpXG4gICAgICB9XG5cbiAgICAgIHRoaXMuZXJyb3JIYW5kbGVyID0gZXJyID0+IHtcbiAgICAgICAgaWYgKHRoaXMuYWJvcnQpIHtcbiAgICAgICAgICB0aGlzLmFib3J0KGVycilcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmVycm9yID0gZXJyXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuYm9keS5vbignZXJyb3InLCB0aGlzLmVycm9ySGFuZGxlcilcbiAgICB9IGVsc2UgaWYgKGlzQnVmZmVyKGJvZHkpKSB7XG4gICAgICB0aGlzLmJvZHkgPSBib2R5LmJ5dGVMZW5ndGggPyBib2R5IDogbnVsbFxuICAgIH0gZWxzZSBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KGJvZHkpKSB7XG4gICAgICB0aGlzLmJvZHkgPSBib2R5LmJ1ZmZlci5ieXRlTGVuZ3RoID8gQnVmZmVyLmZyb20oYm9keS5idWZmZXIsIGJvZHkuYnl0ZU9mZnNldCwgYm9keS5ieXRlTGVuZ3RoKSA6IG51bGxcbiAgICB9IGVsc2UgaWYgKGJvZHkgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgdGhpcy5ib2R5ID0gYm9keS5ieXRlTGVuZ3RoID8gQnVmZmVyLmZyb20oYm9keSkgOiBudWxsXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgYm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMuYm9keSA9IGJvZHkubGVuZ3RoID8gQnVmZmVyLmZyb20oYm9keSkgOiBudWxsXG4gICAgfSBlbHNlIGlmIChpc0Zvcm1EYXRhTGlrZShib2R5KSB8fCBpc0l0ZXJhYmxlKGJvZHkpIHx8IGlzQmxvYkxpa2UoYm9keSkpIHtcbiAgICAgIHRoaXMuYm9keSA9IGJvZHlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdib2R5IG11c3QgYmUgYSBzdHJpbmcsIGEgQnVmZmVyLCBhIFJlYWRhYmxlIHN0cmVhbSwgYW4gaXRlcmFibGUsIG9yIGFuIGFzeW5jIGl0ZXJhYmxlJylcbiAgICB9XG5cbiAgICB0aGlzLmNvbXBsZXRlZCA9IGZhbHNlXG5cbiAgICB0aGlzLmFib3J0ZWQgPSBmYWxzZVxuXG4gICAgdGhpcy51cGdyYWRlID0gdXBncmFkZSB8fCBudWxsXG5cbiAgICB0aGlzLnBhdGggPSBxdWVyeSA/IGJ1aWxkVVJMKHBhdGgsIHF1ZXJ5KSA6IHBhdGhcblxuICAgIHRoaXMub3JpZ2luID0gb3JpZ2luXG5cbiAgICB0aGlzLmlkZW1wb3RlbnQgPSBpZGVtcG90ZW50ID09IG51bGxcbiAgICAgID8gbWV0aG9kID09PSAnSEVBRCcgfHwgbWV0aG9kID09PSAnR0VUJ1xuICAgICAgOiBpZGVtcG90ZW50XG5cbiAgICB0aGlzLmJsb2NraW5nID0gYmxvY2tpbmcgPT0gbnVsbCA/IGZhbHNlIDogYmxvY2tpbmdcblxuICAgIHRoaXMucmVzZXQgPSByZXNldCA9PSBudWxsID8gbnVsbCA6IHJlc2V0XG5cbiAgICB0aGlzLmhvc3QgPSBudWxsXG5cbiAgICB0aGlzLmNvbnRlbnRMZW5ndGggPSBudWxsXG5cbiAgICB0aGlzLmNvbnRlbnRUeXBlID0gbnVsbFxuXG4gICAgdGhpcy5oZWFkZXJzID0gW11cblxuICAgIC8vIE9ubHkgZm9yIEgyXG4gICAgdGhpcy5leHBlY3RDb250aW51ZSA9IGV4cGVjdENvbnRpbnVlICE9IG51bGwgPyBleHBlY3RDb250aW51ZSA6IGZhbHNlXG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShoZWFkZXJzKSkge1xuICAgICAgaWYgKGhlYWRlcnMubGVuZ3RoICUgMiAhPT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2hlYWRlcnMgYXJyYXkgbXVzdCBiZSBldmVuJylcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaGVhZGVycy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICBwcm9jZXNzSGVhZGVyKHRoaXMsIGhlYWRlcnNbaV0sIGhlYWRlcnNbaSArIDFdKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaGVhZGVycyAmJiB0eXBlb2YgaGVhZGVycyA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGlmIChoZWFkZXJzW1N5bWJvbC5pdGVyYXRvcl0pIHtcbiAgICAgICAgZm9yIChjb25zdCBoZWFkZXIgb2YgaGVhZGVycykge1xuICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShoZWFkZXIpIHx8IGhlYWRlci5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaGVhZGVycyBtdXN0IGJlIGluIGtleS12YWx1ZSBwYWlyIGZvcm1hdCcpXG4gICAgICAgICAgfVxuICAgICAgICAgIHByb2Nlc3NIZWFkZXIodGhpcywgaGVhZGVyWzBdLCBoZWFkZXJbMV0pXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhoZWFkZXJzKVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBwcm9jZXNzSGVhZGVyKHRoaXMsIGtleXNbaV0sIGhlYWRlcnNba2V5c1tpXV0pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGhlYWRlcnMgIT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdoZWFkZXJzIG11c3QgYmUgYW4gb2JqZWN0IG9yIGFuIGFycmF5JylcbiAgICB9XG5cbiAgICB2YWxpZGF0ZUhhbmRsZXIoaGFuZGxlciwgbWV0aG9kLCB1cGdyYWRlKVxuXG4gICAgdGhpcy5zZXJ2ZXJuYW1lID0gc2VydmVybmFtZSB8fCBnZXRTZXJ2ZXJOYW1lKHRoaXMuaG9zdClcblxuICAgIHRoaXNba0hhbmRsZXJdID0gaGFuZGxlclxuXG4gICAgaWYgKGNoYW5uZWxzLmNyZWF0ZS5oYXNTdWJzY3JpYmVycykge1xuICAgICAgY2hhbm5lbHMuY3JlYXRlLnB1Ymxpc2goeyByZXF1ZXN0OiB0aGlzIH0pXG4gICAgfVxuICB9XG5cbiAgb25Cb2R5U2VudCAoY2h1bmspIHtcbiAgICBpZiAodGhpc1trSGFuZGxlcl0ub25Cb2R5U2VudCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHRoaXNba0hhbmRsZXJdLm9uQm9keVNlbnQoY2h1bmspXG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgdGhpcy5hYm9ydChlcnIpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgb25SZXF1ZXN0U2VudCAoKSB7XG4gICAgaWYgKGNoYW5uZWxzLmJvZHlTZW50Lmhhc1N1YnNjcmliZXJzKSB7XG4gICAgICBjaGFubmVscy5ib2R5U2VudC5wdWJsaXNoKHsgcmVxdWVzdDogdGhpcyB9KVxuICAgIH1cblxuICAgIGlmICh0aGlzW2tIYW5kbGVyXS5vblJlcXVlc3RTZW50KSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gdGhpc1trSGFuZGxlcl0ub25SZXF1ZXN0U2VudCgpXG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgdGhpcy5hYm9ydChlcnIpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgb25Db25uZWN0IChhYm9ydCkge1xuICAgIGFzc2VydCghdGhpcy5hYm9ydGVkKVxuICAgIGFzc2VydCghdGhpcy5jb21wbGV0ZWQpXG5cbiAgICBpZiAodGhpcy5lcnJvcikge1xuICAgICAgYWJvcnQodGhpcy5lcnJvcilcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hYm9ydCA9IGFib3J0XG4gICAgICByZXR1cm4gdGhpc1trSGFuZGxlcl0ub25Db25uZWN0KGFib3J0KVxuICAgIH1cbiAgfVxuXG4gIG9uUmVzcG9uc2VTdGFydGVkICgpIHtcbiAgICByZXR1cm4gdGhpc1trSGFuZGxlcl0ub25SZXNwb25zZVN0YXJ0ZWQ/LigpXG4gIH1cblxuICBvbkhlYWRlcnMgKHN0YXR1c0NvZGUsIGhlYWRlcnMsIHJlc3VtZSwgc3RhdHVzVGV4dCkge1xuICAgIGFzc2VydCghdGhpcy5hYm9ydGVkKVxuICAgIGFzc2VydCghdGhpcy5jb21wbGV0ZWQpXG5cbiAgICBpZiAoY2hhbm5lbHMuaGVhZGVycy5oYXNTdWJzY3JpYmVycykge1xuICAgICAgY2hhbm5lbHMuaGVhZGVycy5wdWJsaXNoKHsgcmVxdWVzdDogdGhpcywgcmVzcG9uc2U6IHsgc3RhdHVzQ29kZSwgaGVhZGVycywgc3RhdHVzVGV4dCB9IH0pXG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB0aGlzW2tIYW5kbGVyXS5vbkhlYWRlcnMoc3RhdHVzQ29kZSwgaGVhZGVycywgcmVzdW1lLCBzdGF0dXNUZXh0KVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhpcy5hYm9ydChlcnIpXG4gICAgfVxuICB9XG5cbiAgb25EYXRhIChjaHVuaykge1xuICAgIGFzc2VydCghdGhpcy5hYm9ydGVkKVxuICAgIGFzc2VydCghdGhpcy5jb21wbGV0ZWQpXG5cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHRoaXNba0hhbmRsZXJdLm9uRGF0YShjaHVuaylcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRoaXMuYWJvcnQoZXJyKVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG5cbiAgb25VcGdyYWRlIChzdGF0dXNDb2RlLCBoZWFkZXJzLCBzb2NrZXQpIHtcbiAgICBhc3NlcnQoIXRoaXMuYWJvcnRlZClcbiAgICBhc3NlcnQoIXRoaXMuY29tcGxldGVkKVxuXG4gICAgcmV0dXJuIHRoaXNba0hhbmRsZXJdLm9uVXBncmFkZShzdGF0dXNDb2RlLCBoZWFkZXJzLCBzb2NrZXQpXG4gIH1cblxuICBvbkNvbXBsZXRlICh0cmFpbGVycykge1xuICAgIHRoaXMub25GaW5hbGx5KClcblxuICAgIGFzc2VydCghdGhpcy5hYm9ydGVkKVxuXG4gICAgdGhpcy5jb21wbGV0ZWQgPSB0cnVlXG4gICAgaWYgKGNoYW5uZWxzLnRyYWlsZXJzLmhhc1N1YnNjcmliZXJzKSB7XG4gICAgICBjaGFubmVscy50cmFpbGVycy5wdWJsaXNoKHsgcmVxdWVzdDogdGhpcywgdHJhaWxlcnMgfSlcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHRoaXNba0hhbmRsZXJdLm9uQ29tcGxldGUodHJhaWxlcnMpXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAvLyBUT0RPIChmaXgpOiBUaGlzIG1pZ2h0IGJlIGEgYmFkIGlkZWE/XG4gICAgICB0aGlzLm9uRXJyb3IoZXJyKVxuICAgIH1cbiAgfVxuXG4gIG9uRXJyb3IgKGVycm9yKSB7XG4gICAgdGhpcy5vbkZpbmFsbHkoKVxuXG4gICAgaWYgKGNoYW5uZWxzLmVycm9yLmhhc1N1YnNjcmliZXJzKSB7XG4gICAgICBjaGFubmVscy5lcnJvci5wdWJsaXNoKHsgcmVxdWVzdDogdGhpcywgZXJyb3IgfSlcbiAgICB9XG5cbiAgICBpZiAodGhpcy5hYm9ydGVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgdGhpcy5hYm9ydGVkID0gdHJ1ZVxuXG4gICAgcmV0dXJuIHRoaXNba0hhbmRsZXJdLm9uRXJyb3IoZXJyb3IpXG4gIH1cblxuICBvbkZpbmFsbHkgKCkge1xuICAgIGlmICh0aGlzLmVycm9ySGFuZGxlcikge1xuICAgICAgdGhpcy5ib2R5Lm9mZignZXJyb3InLCB0aGlzLmVycm9ySGFuZGxlcilcbiAgICAgIHRoaXMuZXJyb3JIYW5kbGVyID0gbnVsbFxuICAgIH1cblxuICAgIGlmICh0aGlzLmVuZEhhbmRsZXIpIHtcbiAgICAgIHRoaXMuYm9keS5vZmYoJ2VuZCcsIHRoaXMuZW5kSGFuZGxlcilcbiAgICAgIHRoaXMuZW5kSGFuZGxlciA9IG51bGxcbiAgICB9XG4gIH1cblxuICBhZGRIZWFkZXIgKGtleSwgdmFsdWUpIHtcbiAgICBwcm9jZXNzSGVhZGVyKHRoaXMsIGtleSwgdmFsdWUpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzSGVhZGVyIChyZXF1ZXN0LCBrZXksIHZhbCkge1xuICBpZiAodmFsICYmICh0eXBlb2YgdmFsID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheSh2YWwpKSkge1xuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihgaW52YWxpZCAke2tleX0gaGVhZGVyYClcbiAgfSBlbHNlIGlmICh2YWwgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVyblxuICB9XG5cbiAgbGV0IGhlYWRlck5hbWUgPSBoZWFkZXJOYW1lTG93ZXJDYXNlZFJlY29yZFtrZXldXG5cbiAgaWYgKGhlYWRlck5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgIGhlYWRlck5hbWUgPSBrZXkudG9Mb3dlckNhc2UoKVxuICAgIGlmIChoZWFkZXJOYW1lTG93ZXJDYXNlZFJlY29yZFtoZWFkZXJOYW1lXSA9PT0gdW5kZWZpbmVkICYmICFpc1ZhbGlkSFRUUFRva2VuKGhlYWRlck5hbWUpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgaGVhZGVyIGtleScpXG4gICAgfVxuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgIGNvbnN0IGFyciA9IFtdXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWwubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsW2ldID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAoIWlzVmFsaWRIZWFkZXJWYWx1ZSh2YWxbaV0pKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKGBpbnZhbGlkICR7a2V5fSBoZWFkZXJgKVxuICAgICAgICB9XG4gICAgICAgIGFyci5wdXNoKHZhbFtpXSlcbiAgICAgIH0gZWxzZSBpZiAodmFsW2ldID09PSBudWxsKSB7XG4gICAgICAgIGFyci5wdXNoKCcnKVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsW2ldID09PSAnb2JqZWN0Jykge1xuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoYGludmFsaWQgJHtrZXl9IGhlYWRlcmApXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhcnIucHVzaChgJHt2YWxbaV19YClcbiAgICAgIH1cbiAgICB9XG4gICAgdmFsID0gYXJyXG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAoIWlzVmFsaWRIZWFkZXJWYWx1ZSh2YWwpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoYGludmFsaWQgJHtrZXl9IGhlYWRlcmApXG4gICAgfVxuICB9IGVsc2UgaWYgKHZhbCA9PT0gbnVsbCkge1xuICAgIHZhbCA9ICcnXG4gIH0gZWxzZSB7XG4gICAgdmFsID0gYCR7dmFsfWBcbiAgfVxuXG4gIGlmIChyZXF1ZXN0Lmhvc3QgPT09IG51bGwgJiYgaGVhZGVyTmFtZSA9PT0gJ2hvc3QnKSB7XG4gICAgaWYgKHR5cGVvZiB2YWwgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgaG9zdCBoZWFkZXInKVxuICAgIH1cbiAgICAvLyBDb25zdW1lZCBieSBDbGllbnRcbiAgICByZXF1ZXN0Lmhvc3QgPSB2YWxcbiAgfSBlbHNlIGlmIChyZXF1ZXN0LmNvbnRlbnRMZW5ndGggPT09IG51bGwgJiYgaGVhZGVyTmFtZSA9PT0gJ2NvbnRlbnQtbGVuZ3RoJykge1xuICAgIHJlcXVlc3QuY29udGVudExlbmd0aCA9IHBhcnNlSW50KHZhbCwgMTApXG4gICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUocmVxdWVzdC5jb250ZW50TGVuZ3RoKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIGNvbnRlbnQtbGVuZ3RoIGhlYWRlcicpXG4gICAgfVxuICB9IGVsc2UgaWYgKHJlcXVlc3QuY29udGVudFR5cGUgPT09IG51bGwgJiYgaGVhZGVyTmFtZSA9PT0gJ2NvbnRlbnQtdHlwZScpIHtcbiAgICByZXF1ZXN0LmNvbnRlbnRUeXBlID0gdmFsXG4gICAgcmVxdWVzdC5oZWFkZXJzLnB1c2goa2V5LCB2YWwpXG4gIH0gZWxzZSBpZiAoaGVhZGVyTmFtZSA9PT0gJ3RyYW5zZmVyLWVuY29kaW5nJyB8fCBoZWFkZXJOYW1lID09PSAna2VlcC1hbGl2ZScgfHwgaGVhZGVyTmFtZSA9PT0gJ3VwZ3JhZGUnKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKGBpbnZhbGlkICR7aGVhZGVyTmFtZX0gaGVhZGVyYClcbiAgfSBlbHNlIGlmIChoZWFkZXJOYW1lID09PSAnY29ubmVjdGlvbicpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnID8gdmFsLnRvTG93ZXJDYXNlKCkgOiBudWxsXG4gICAgaWYgKHZhbHVlICE9PSAnY2xvc2UnICYmIHZhbHVlICE9PSAna2VlcC1hbGl2ZScpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBjb25uZWN0aW9uIGhlYWRlcicpXG4gICAgfVxuXG4gICAgaWYgKHZhbHVlID09PSAnY2xvc2UnKSB7XG4gICAgICByZXF1ZXN0LnJlc2V0ID0gdHJ1ZVxuICAgIH1cbiAgfSBlbHNlIGlmIChoZWFkZXJOYW1lID09PSAnZXhwZWN0Jykge1xuICAgIHRocm93IG5ldyBOb3RTdXBwb3J0ZWRFcnJvcignZXhwZWN0IGhlYWRlciBub3Qgc3VwcG9ydGVkJylcbiAgfSBlbHNlIHtcbiAgICByZXF1ZXN0LmhlYWRlcnMucHVzaChrZXksIHZhbClcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlcXVlc3RcbiJdLCJuYW1lcyI6WyJJbnZhbGlkQXJndW1lbnRFcnJvciIsIk5vdFN1cHBvcnRlZEVycm9yIiwicmVxdWlyZSIsImFzc2VydCIsImlzVmFsaWRIVFRQVG9rZW4iLCJpc1ZhbGlkSGVhZGVyVmFsdWUiLCJpc1N0cmVhbSIsImRlc3Ryb3kiLCJpc0J1ZmZlciIsImlzRm9ybURhdGFMaWtlIiwiaXNJdGVyYWJsZSIsImlzQmxvYkxpa2UiLCJidWlsZFVSTCIsInZhbGlkYXRlSGFuZGxlciIsImdldFNlcnZlck5hbWUiLCJub3JtYWxpemVkTWV0aG9kUmVjb3JkcyIsImNoYW5uZWxzIiwiaGVhZGVyTmFtZUxvd2VyQ2FzZWRSZWNvcmQiLCJpbnZhbGlkUGF0aFJlZ2V4Iiwia0hhbmRsZXIiLCJTeW1ib2wiLCJSZXF1ZXN0IiwiY29uc3RydWN0b3IiLCJvcmlnaW4iLCJwYXRoIiwibWV0aG9kIiwiYm9keSIsImhlYWRlcnMiLCJxdWVyeSIsImlkZW1wb3RlbnQiLCJibG9ja2luZyIsInVwZ3JhZGUiLCJoZWFkZXJzVGltZW91dCIsImJvZHlUaW1lb3V0IiwicmVzZXQiLCJ0aHJvd09uRXJyb3IiLCJleHBlY3RDb250aW51ZSIsInNlcnZlcm5hbWUiLCJoYW5kbGVyIiwic3RhcnRzV2l0aCIsInRlc3QiLCJ1bmRlZmluZWQiLCJOdW1iZXIiLCJpc0Zpbml0ZSIsImFib3J0IiwiclN0YXRlIiwiX3JlYWRhYmxlU3RhdGUiLCJhdXRvRGVzdHJveSIsImVuZEhhbmRsZXIiLCJvbiIsImVycm9ySGFuZGxlciIsImVyciIsImVycm9yIiwiYnl0ZUxlbmd0aCIsIkFycmF5QnVmZmVyIiwiaXNWaWV3IiwiYnVmZmVyIiwiQnVmZmVyIiwiZnJvbSIsImJ5dGVPZmZzZXQiLCJsZW5ndGgiLCJjb21wbGV0ZWQiLCJhYm9ydGVkIiwiaG9zdCIsImNvbnRlbnRMZW5ndGgiLCJjb250ZW50VHlwZSIsIkFycmF5IiwiaXNBcnJheSIsImkiLCJwcm9jZXNzSGVhZGVyIiwiaXRlcmF0b3IiLCJoZWFkZXIiLCJrZXlzIiwiT2JqZWN0IiwiY3JlYXRlIiwiaGFzU3Vic2NyaWJlcnMiLCJwdWJsaXNoIiwicmVxdWVzdCIsIm9uQm9keVNlbnQiLCJjaHVuayIsIm9uUmVxdWVzdFNlbnQiLCJib2R5U2VudCIsIm9uQ29ubmVjdCIsIm9uUmVzcG9uc2VTdGFydGVkIiwib25IZWFkZXJzIiwic3RhdHVzQ29kZSIsInJlc3VtZSIsInN0YXR1c1RleHQiLCJyZXNwb25zZSIsIm9uRGF0YSIsIm9uVXBncmFkZSIsInNvY2tldCIsIm9uQ29tcGxldGUiLCJ0cmFpbGVycyIsIm9uRmluYWxseSIsIm9uRXJyb3IiLCJvZmYiLCJhZGRIZWFkZXIiLCJrZXkiLCJ2YWx1ZSIsInZhbCIsImhlYWRlck5hbWUiLCJ0b0xvd2VyQ2FzZSIsImFyciIsInB1c2giLCJwYXJzZUludCIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/core/request.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/core/symbols.js":
/*!*************************************************!*\
  !*** ./node_modules/undici/lib/core/symbols.js ***!
  \*************************************************/
/***/ ((module) => {

eval("\nmodule.exports = {\n    kClose: Symbol(\"close\"),\n    kDestroy: Symbol(\"destroy\"),\n    kDispatch: Symbol(\"dispatch\"),\n    kUrl: Symbol(\"url\"),\n    kWriting: Symbol(\"writing\"),\n    kResuming: Symbol(\"resuming\"),\n    kQueue: Symbol(\"queue\"),\n    kConnect: Symbol(\"connect\"),\n    kConnecting: Symbol(\"connecting\"),\n    kKeepAliveDefaultTimeout: Symbol(\"default keep alive timeout\"),\n    kKeepAliveMaxTimeout: Symbol(\"max keep alive timeout\"),\n    kKeepAliveTimeoutThreshold: Symbol(\"keep alive timeout threshold\"),\n    kKeepAliveTimeoutValue: Symbol(\"keep alive timeout\"),\n    kKeepAlive: Symbol(\"keep alive\"),\n    kHeadersTimeout: Symbol(\"headers timeout\"),\n    kBodyTimeout: Symbol(\"body timeout\"),\n    kServerName: Symbol(\"server name\"),\n    kLocalAddress: Symbol(\"local address\"),\n    kHost: Symbol(\"host\"),\n    kNoRef: Symbol(\"no ref\"),\n    kBodyUsed: Symbol(\"used\"),\n    kBody: Symbol(\"abstracted request body\"),\n    kRunning: Symbol(\"running\"),\n    kBlocking: Symbol(\"blocking\"),\n    kPending: Symbol(\"pending\"),\n    kSize: Symbol(\"size\"),\n    kBusy: Symbol(\"busy\"),\n    kQueued: Symbol(\"queued\"),\n    kFree: Symbol(\"free\"),\n    kConnected: Symbol(\"connected\"),\n    kClosed: Symbol(\"closed\"),\n    kNeedDrain: Symbol(\"need drain\"),\n    kReset: Symbol(\"reset\"),\n    kDestroyed: Symbol.for(\"nodejs.stream.destroyed\"),\n    kResume: Symbol(\"resume\"),\n    kOnError: Symbol(\"on error\"),\n    kMaxHeadersSize: Symbol(\"max headers size\"),\n    kRunningIdx: Symbol(\"running index\"),\n    kPendingIdx: Symbol(\"pending index\"),\n    kError: Symbol(\"error\"),\n    kClients: Symbol(\"clients\"),\n    kClient: Symbol(\"client\"),\n    kParser: Symbol(\"parser\"),\n    kOnDestroyed: Symbol(\"destroy callbacks\"),\n    kPipelining: Symbol(\"pipelining\"),\n    kSocket: Symbol(\"socket\"),\n    kHostHeader: Symbol(\"host header\"),\n    kConnector: Symbol(\"connector\"),\n    kStrictContentLength: Symbol(\"strict content length\"),\n    kMaxRedirections: Symbol(\"maxRedirections\"),\n    kMaxRequests: Symbol(\"maxRequestsPerClient\"),\n    kProxy: Symbol(\"proxy agent options\"),\n    kCounter: Symbol(\"socket request counter\"),\n    kInterceptors: Symbol(\"dispatch interceptors\"),\n    kMaxResponseSize: Symbol(\"max response size\"),\n    kHTTP2Session: Symbol(\"http2Session\"),\n    kHTTP2SessionState: Symbol(\"http2Session state\"),\n    kRetryHandlerDefaultRetry: Symbol(\"retry agent default retry\"),\n    kConstruct: Symbol(\"constructable\"),\n    kListeners: Symbol(\"listeners\"),\n    kHTTPContext: Symbol(\"http context\"),\n    kMaxConcurrentStreams: Symbol(\"max concurrent streams\"),\n    kNoProxyAgent: Symbol(\"no proxy agent\"),\n    kHttpProxyAgent: Symbol(\"http proxy agent\"),\n    kHttpsProxyAgent: Symbol(\"https proxy agent\")\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9jb3JlL3N5bWJvbHMuanMiLCJtYXBwaW5ncyI6IjtBQUFBQSxPQUFPQyxPQUFPLEdBQUc7SUFDZkMsUUFBUUMsT0FBTztJQUNmQyxVQUFVRCxPQUFPO0lBQ2pCRSxXQUFXRixPQUFPO0lBQ2xCRyxNQUFNSCxPQUFPO0lBQ2JJLFVBQVVKLE9BQU87SUFDakJLLFdBQVdMLE9BQU87SUFDbEJNLFFBQVFOLE9BQU87SUFDZk8sVUFBVVAsT0FBTztJQUNqQlEsYUFBYVIsT0FBTztJQUNwQlMsMEJBQTBCVCxPQUFPO0lBQ2pDVSxzQkFBc0JWLE9BQU87SUFDN0JXLDRCQUE0QlgsT0FBTztJQUNuQ1ksd0JBQXdCWixPQUFPO0lBQy9CYSxZQUFZYixPQUFPO0lBQ25CYyxpQkFBaUJkLE9BQU87SUFDeEJlLGNBQWNmLE9BQU87SUFDckJnQixhQUFhaEIsT0FBTztJQUNwQmlCLGVBQWVqQixPQUFPO0lBQ3RCa0IsT0FBT2xCLE9BQU87SUFDZG1CLFFBQVFuQixPQUFPO0lBQ2ZvQixXQUFXcEIsT0FBTztJQUNsQnFCLE9BQU9yQixPQUFPO0lBQ2RzQixVQUFVdEIsT0FBTztJQUNqQnVCLFdBQVd2QixPQUFPO0lBQ2xCd0IsVUFBVXhCLE9BQU87SUFDakJ5QixPQUFPekIsT0FBTztJQUNkMEIsT0FBTzFCLE9BQU87SUFDZDJCLFNBQVMzQixPQUFPO0lBQ2hCNEIsT0FBTzVCLE9BQU87SUFDZDZCLFlBQVk3QixPQUFPO0lBQ25COEIsU0FBUzlCLE9BQU87SUFDaEIrQixZQUFZL0IsT0FBTztJQUNuQmdDLFFBQVFoQyxPQUFPO0lBQ2ZpQyxZQUFZakMsT0FBT2tDLEdBQUcsQ0FBQztJQUN2QkMsU0FBU25DLE9BQU87SUFDaEJvQyxVQUFVcEMsT0FBTztJQUNqQnFDLGlCQUFpQnJDLE9BQU87SUFDeEJzQyxhQUFhdEMsT0FBTztJQUNwQnVDLGFBQWF2QyxPQUFPO0lBQ3BCd0MsUUFBUXhDLE9BQU87SUFDZnlDLFVBQVV6QyxPQUFPO0lBQ2pCMEMsU0FBUzFDLE9BQU87SUFDaEIyQyxTQUFTM0MsT0FBTztJQUNoQjRDLGNBQWM1QyxPQUFPO0lBQ3JCNkMsYUFBYTdDLE9BQU87SUFDcEI4QyxTQUFTOUMsT0FBTztJQUNoQitDLGFBQWEvQyxPQUFPO0lBQ3BCZ0QsWUFBWWhELE9BQU87SUFDbkJpRCxzQkFBc0JqRCxPQUFPO0lBQzdCa0Qsa0JBQWtCbEQsT0FBTztJQUN6Qm1ELGNBQWNuRCxPQUFPO0lBQ3JCb0QsUUFBUXBELE9BQU87SUFDZnFELFVBQVVyRCxPQUFPO0lBQ2pCc0QsZUFBZXRELE9BQU87SUFDdEJ1RCxrQkFBa0J2RCxPQUFPO0lBQ3pCd0QsZUFBZXhELE9BQU87SUFDdEJ5RCxvQkFBb0J6RCxPQUFPO0lBQzNCMEQsMkJBQTJCMUQsT0FBTztJQUNsQzJELFlBQVkzRCxPQUFPO0lBQ25CNEQsWUFBWTVELE9BQU87SUFDbkI2RCxjQUFjN0QsT0FBTztJQUNyQjhELHVCQUF1QjlELE9BQU87SUFDOUIrRCxlQUFlL0QsT0FBTztJQUN0QmdFLGlCQUFpQmhFLE9BQU87SUFDeEJpRSxrQkFBa0JqRSxPQUFPO0FBQzNCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbW9ja3VwZmxvdy8uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2NvcmUvc3ltYm9scy5qcz9lNTdlIiwid2VicGFjazovL21vY2t1cGZsb3cvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9jb3JlL3N5bWJvbHMuanM/ZTU3ZSoiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSB7XG4gIGtDbG9zZTogU3ltYm9sKCdjbG9zZScpLFxuICBrRGVzdHJveTogU3ltYm9sKCdkZXN0cm95JyksXG4gIGtEaXNwYXRjaDogU3ltYm9sKCdkaXNwYXRjaCcpLFxuICBrVXJsOiBTeW1ib2woJ3VybCcpLFxuICBrV3JpdGluZzogU3ltYm9sKCd3cml0aW5nJyksXG4gIGtSZXN1bWluZzogU3ltYm9sKCdyZXN1bWluZycpLFxuICBrUXVldWU6IFN5bWJvbCgncXVldWUnKSxcbiAga0Nvbm5lY3Q6IFN5bWJvbCgnY29ubmVjdCcpLFxuICBrQ29ubmVjdGluZzogU3ltYm9sKCdjb25uZWN0aW5nJyksXG4gIGtLZWVwQWxpdmVEZWZhdWx0VGltZW91dDogU3ltYm9sKCdkZWZhdWx0IGtlZXAgYWxpdmUgdGltZW91dCcpLFxuICBrS2VlcEFsaXZlTWF4VGltZW91dDogU3ltYm9sKCdtYXgga2VlcCBhbGl2ZSB0aW1lb3V0JyksXG4gIGtLZWVwQWxpdmVUaW1lb3V0VGhyZXNob2xkOiBTeW1ib2woJ2tlZXAgYWxpdmUgdGltZW91dCB0aHJlc2hvbGQnKSxcbiAga0tlZXBBbGl2ZVRpbWVvdXRWYWx1ZTogU3ltYm9sKCdrZWVwIGFsaXZlIHRpbWVvdXQnKSxcbiAga0tlZXBBbGl2ZTogU3ltYm9sKCdrZWVwIGFsaXZlJyksXG4gIGtIZWFkZXJzVGltZW91dDogU3ltYm9sKCdoZWFkZXJzIHRpbWVvdXQnKSxcbiAga0JvZHlUaW1lb3V0OiBTeW1ib2woJ2JvZHkgdGltZW91dCcpLFxuICBrU2VydmVyTmFtZTogU3ltYm9sKCdzZXJ2ZXIgbmFtZScpLFxuICBrTG9jYWxBZGRyZXNzOiBTeW1ib2woJ2xvY2FsIGFkZHJlc3MnKSxcbiAga0hvc3Q6IFN5bWJvbCgnaG9zdCcpLFxuICBrTm9SZWY6IFN5bWJvbCgnbm8gcmVmJyksXG4gIGtCb2R5VXNlZDogU3ltYm9sKCd1c2VkJyksXG4gIGtCb2R5OiBTeW1ib2woJ2Fic3RyYWN0ZWQgcmVxdWVzdCBib2R5JyksXG4gIGtSdW5uaW5nOiBTeW1ib2woJ3J1bm5pbmcnKSxcbiAga0Jsb2NraW5nOiBTeW1ib2woJ2Jsb2NraW5nJyksXG4gIGtQZW5kaW5nOiBTeW1ib2woJ3BlbmRpbmcnKSxcbiAga1NpemU6IFN5bWJvbCgnc2l6ZScpLFxuICBrQnVzeTogU3ltYm9sKCdidXN5JyksXG4gIGtRdWV1ZWQ6IFN5bWJvbCgncXVldWVkJyksXG4gIGtGcmVlOiBTeW1ib2woJ2ZyZWUnKSxcbiAga0Nvbm5lY3RlZDogU3ltYm9sKCdjb25uZWN0ZWQnKSxcbiAga0Nsb3NlZDogU3ltYm9sKCdjbG9zZWQnKSxcbiAga05lZWREcmFpbjogU3ltYm9sKCduZWVkIGRyYWluJyksXG4gIGtSZXNldDogU3ltYm9sKCdyZXNldCcpLFxuICBrRGVzdHJveWVkOiBTeW1ib2wuZm9yKCdub2RlanMuc3RyZWFtLmRlc3Ryb3llZCcpLFxuICBrUmVzdW1lOiBTeW1ib2woJ3Jlc3VtZScpLFxuICBrT25FcnJvcjogU3ltYm9sKCdvbiBlcnJvcicpLFxuICBrTWF4SGVhZGVyc1NpemU6IFN5bWJvbCgnbWF4IGhlYWRlcnMgc2l6ZScpLFxuICBrUnVubmluZ0lkeDogU3ltYm9sKCdydW5uaW5nIGluZGV4JyksXG4gIGtQZW5kaW5nSWR4OiBTeW1ib2woJ3BlbmRpbmcgaW5kZXgnKSxcbiAga0Vycm9yOiBTeW1ib2woJ2Vycm9yJyksXG4gIGtDbGllbnRzOiBTeW1ib2woJ2NsaWVudHMnKSxcbiAga0NsaWVudDogU3ltYm9sKCdjbGllbnQnKSxcbiAga1BhcnNlcjogU3ltYm9sKCdwYXJzZXInKSxcbiAga09uRGVzdHJveWVkOiBTeW1ib2woJ2Rlc3Ryb3kgY2FsbGJhY2tzJyksXG4gIGtQaXBlbGluaW5nOiBTeW1ib2woJ3BpcGVsaW5pbmcnKSxcbiAga1NvY2tldDogU3ltYm9sKCdzb2NrZXQnKSxcbiAga0hvc3RIZWFkZXI6IFN5bWJvbCgnaG9zdCBoZWFkZXInKSxcbiAga0Nvbm5lY3RvcjogU3ltYm9sKCdjb25uZWN0b3InKSxcbiAga1N0cmljdENvbnRlbnRMZW5ndGg6IFN5bWJvbCgnc3RyaWN0IGNvbnRlbnQgbGVuZ3RoJyksXG4gIGtNYXhSZWRpcmVjdGlvbnM6IFN5bWJvbCgnbWF4UmVkaXJlY3Rpb25zJyksXG4gIGtNYXhSZXF1ZXN0czogU3ltYm9sKCdtYXhSZXF1ZXN0c1BlckNsaWVudCcpLFxuICBrUHJveHk6IFN5bWJvbCgncHJveHkgYWdlbnQgb3B0aW9ucycpLFxuICBrQ291bnRlcjogU3ltYm9sKCdzb2NrZXQgcmVxdWVzdCBjb3VudGVyJyksXG4gIGtJbnRlcmNlcHRvcnM6IFN5bWJvbCgnZGlzcGF0Y2ggaW50ZXJjZXB0b3JzJyksXG4gIGtNYXhSZXNwb25zZVNpemU6IFN5bWJvbCgnbWF4IHJlc3BvbnNlIHNpemUnKSxcbiAga0hUVFAyU2Vzc2lvbjogU3ltYm9sKCdodHRwMlNlc3Npb24nKSxcbiAga0hUVFAyU2Vzc2lvblN0YXRlOiBTeW1ib2woJ2h0dHAyU2Vzc2lvbiBzdGF0ZScpLFxuICBrUmV0cnlIYW5kbGVyRGVmYXVsdFJldHJ5OiBTeW1ib2woJ3JldHJ5IGFnZW50IGRlZmF1bHQgcmV0cnknKSxcbiAga0NvbnN0cnVjdDogU3ltYm9sKCdjb25zdHJ1Y3RhYmxlJyksXG4gIGtMaXN0ZW5lcnM6IFN5bWJvbCgnbGlzdGVuZXJzJyksXG4gIGtIVFRQQ29udGV4dDogU3ltYm9sKCdodHRwIGNvbnRleHQnKSxcbiAga01heENvbmN1cnJlbnRTdHJlYW1zOiBTeW1ib2woJ21heCBjb25jdXJyZW50IHN0cmVhbXMnKSxcbiAga05vUHJveHlBZ2VudDogU3ltYm9sKCdubyBwcm94eSBhZ2VudCcpLFxuICBrSHR0cFByb3h5QWdlbnQ6IFN5bWJvbCgnaHR0cCBwcm94eSBhZ2VudCcpLFxuICBrSHR0cHNQcm94eUFnZW50OiBTeW1ib2woJ2h0dHBzIHByb3h5IGFnZW50Jylcbn1cbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwia0Nsb3NlIiwiU3ltYm9sIiwia0Rlc3Ryb3kiLCJrRGlzcGF0Y2giLCJrVXJsIiwia1dyaXRpbmciLCJrUmVzdW1pbmciLCJrUXVldWUiLCJrQ29ubmVjdCIsImtDb25uZWN0aW5nIiwia0tlZXBBbGl2ZURlZmF1bHRUaW1lb3V0Iiwia0tlZXBBbGl2ZU1heFRpbWVvdXQiLCJrS2VlcEFsaXZlVGltZW91dFRocmVzaG9sZCIsImtLZWVwQWxpdmVUaW1lb3V0VmFsdWUiLCJrS2VlcEFsaXZlIiwia0hlYWRlcnNUaW1lb3V0Iiwia0JvZHlUaW1lb3V0Iiwia1NlcnZlck5hbWUiLCJrTG9jYWxBZGRyZXNzIiwia0hvc3QiLCJrTm9SZWYiLCJrQm9keVVzZWQiLCJrQm9keSIsImtSdW5uaW5nIiwia0Jsb2NraW5nIiwia1BlbmRpbmciLCJrU2l6ZSIsImtCdXN5Iiwia1F1ZXVlZCIsImtGcmVlIiwia0Nvbm5lY3RlZCIsImtDbG9zZWQiLCJrTmVlZERyYWluIiwia1Jlc2V0Iiwia0Rlc3Ryb3llZCIsImZvciIsImtSZXN1bWUiLCJrT25FcnJvciIsImtNYXhIZWFkZXJzU2l6ZSIsImtSdW5uaW5nSWR4Iiwia1BlbmRpbmdJZHgiLCJrRXJyb3IiLCJrQ2xpZW50cyIsImtDbGllbnQiLCJrUGFyc2VyIiwia09uRGVzdHJveWVkIiwia1BpcGVsaW5pbmciLCJrU29ja2V0Iiwia0hvc3RIZWFkZXIiLCJrQ29ubmVjdG9yIiwia1N0cmljdENvbnRlbnRMZW5ndGgiLCJrTWF4UmVkaXJlY3Rpb25zIiwia01heFJlcXVlc3RzIiwia1Byb3h5Iiwia0NvdW50ZXIiLCJrSW50ZXJjZXB0b3JzIiwia01heFJlc3BvbnNlU2l6ZSIsImtIVFRQMlNlc3Npb24iLCJrSFRUUDJTZXNzaW9uU3RhdGUiLCJrUmV0cnlIYW5kbGVyRGVmYXVsdFJldHJ5Iiwia0NvbnN0cnVjdCIsImtMaXN0ZW5lcnMiLCJrSFRUUENvbnRleHQiLCJrTWF4Q29uY3VycmVudFN0cmVhbXMiLCJrTm9Qcm94eUFnZW50Iiwia0h0dHBQcm94eUFnZW50Iiwia0h0dHBzUHJveHlBZ2VudCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/core/symbols.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/core/tree.js":
/*!**********************************************!*\
  !*** ./node_modules/undici/lib/core/tree.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { wellknownHeaderNames, headerNameLowerCasedRecord } = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/undici/lib/core/constants.js\");\nclass TstNode {\n    /**\n   * @param {string} key\n   * @param {any} value\n   * @param {number} index\n   */ constructor(key, value, index){\n        /** @type {any} */ this.value = null;\n        /** @type {null | TstNode} */ this.left = null;\n        /** @type {null | TstNode} */ this.middle = null;\n        /** @type {null | TstNode} */ this.right = null;\n        if (index === undefined || index >= key.length) {\n            throw new TypeError(\"Unreachable\");\n        }\n        const code = this.code = key.charCodeAt(index);\n        // check code is ascii string\n        if (code > 0x7F) {\n            throw new TypeError(\"key must be ascii string\");\n        }\n        if (key.length !== ++index) {\n            this.middle = new TstNode(key, value, index);\n        } else {\n            this.value = value;\n        }\n    }\n    /**\n   * @param {string} key\n   * @param {any} value\n   */ add(key, value) {\n        const length = key.length;\n        if (length === 0) {\n            throw new TypeError(\"Unreachable\");\n        }\n        let index = 0;\n        let node = this;\n        while(true){\n            const code = key.charCodeAt(index);\n            // check code is ascii string\n            if (code > 0x7F) {\n                throw new TypeError(\"key must be ascii string\");\n            }\n            if (node.code === code) {\n                if (length === ++index) {\n                    node.value = value;\n                    break;\n                } else if (node.middle !== null) {\n                    node = node.middle;\n                } else {\n                    node.middle = new TstNode(key, value, index);\n                    break;\n                }\n            } else if (node.code < code) {\n                if (node.left !== null) {\n                    node = node.left;\n                } else {\n                    node.left = new TstNode(key, value, index);\n                    break;\n                }\n            } else if (node.right !== null) {\n                node = node.right;\n            } else {\n                node.right = new TstNode(key, value, index);\n                break;\n            }\n        }\n    }\n    /**\n   * @param {Uint8Array} key\n   * @return {TstNode | null}\n   */ search(key) {\n        const keylength = key.length;\n        let index = 0;\n        let node = this;\n        while(node !== null && index < keylength){\n            let code = key[index];\n            // A-Z\n            // First check if it is bigger than 0x5a.\n            // Lowercase letters have higher char codes than uppercase ones.\n            // Also we assume that headers will mostly contain lowercase characters.\n            if (code <= 0x5a && code >= 0x41) {\n                // Lowercase for uppercase.\n                code |= 32;\n            }\n            while(node !== null){\n                if (code === node.code) {\n                    if (keylength === ++index) {\n                        // Returns Node since it is the last key.\n                        return node;\n                    }\n                    node = node.middle;\n                    break;\n                }\n                node = node.code < code ? node.left : node.right;\n            }\n        }\n        return null;\n    }\n}\nclass TernarySearchTree {\n    /**\n   * @param {string} key\n   * @param {any} value\n   * */ insert(key, value) {\n        if (this.node === null) {\n            this.node = new TstNode(key, value, 0);\n        } else {\n            this.node.add(key, value);\n        }\n    }\n    /**\n   * @param {Uint8Array} key\n   * @return {any}\n   */ lookup(key) {\n        return this.node?.search(key)?.value ?? null;\n    }\n    constructor(){\n        /** @type {TstNode | null} */ this.node = null;\n    }\n}\nconst tree = new TernarySearchTree();\nfor(let i = 0; i < wellknownHeaderNames.length; ++i){\n    const key = headerNameLowerCasedRecord[wellknownHeaderNames[i]];\n    tree.insert(key, key);\n}\nmodule.exports = {\n    TernarySearchTree,\n    tree\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9jb3JlL3RyZWUuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNLEVBQ0pBLG9CQUFvQixFQUNwQkMsMEJBQUFBLEVBQ0QsR0FBR0MsbUJBQU9BLENBQUM7QUFFWixNQUFNQztJQVdKOzs7O0dBSUYsR0FDRUMsWUFBYUMsR0FBRyxFQUFFQyxLQUFLLEVBQUVDLEtBQUssQ0FBRTtRQWZoQyx3QkFDQUQsUUFBUTtRQUNSLG1DQUNBRSxPQUFPO1FBQ1AsbUNBQ0FDLFNBQVM7UUFDVCxtQ0FDQUMsUUFBUTtRQVNOLElBQUlILFVBQVVJLGFBQWFKLFNBQVNGLElBQUlPLE1BQU0sRUFBRTtZQUM5QyxNQUFNLElBQUlDLFVBQVU7UUFDdEI7UUFDQSxNQUFNQyxPQUFPLElBQUksQ0FBQ0EsSUFBSSxHQUFHVCxJQUFJVSxVQUFVLENBQUNSO1FBQ3hDO1FBQ0EsSUFBSU8sT0FBTyxNQUFNO1lBQ2YsTUFBTSxJQUFJRCxVQUFVO1FBQ3RCO1FBQ0EsSUFBSVIsSUFBSU8sTUFBTSxLQUFLLEVBQUVMLE9BQU87WUFDMUIsSUFBSSxDQUFDRSxNQUFNLEdBQUcsSUFBSU4sUUFBUUUsS0FBS0MsT0FBT0M7UUFDeEMsT0FBTztZQUNMLElBQUksQ0FBQ0QsS0FBSyxHQUFHQTtRQUNmO0lBQ0Y7SUFFQTs7O0dBR0YsR0FDRVUsSUFBS1gsR0FBRyxFQUFFQyxLQUFLLEVBQUU7UUFDZixNQUFNTSxTQUFTUCxJQUFJTyxNQUFNO1FBQ3pCLElBQUlBLFdBQVcsR0FBRztZQUNoQixNQUFNLElBQUlDLFVBQVU7UUFDdEI7UUFDQSxJQUFJTixRQUFRO1FBQ1osSUFBSVUsT0FBTyxJQUFJO1FBQ2YsTUFBTyxLQUFNO1lBQ1gsTUFBTUgsT0FBT1QsSUFBSVUsVUFBVSxDQUFDUjtZQUM1QjtZQUNBLElBQUlPLE9BQU8sTUFBTTtnQkFDZixNQUFNLElBQUlELFVBQVU7WUFDdEI7WUFDQSxJQUFJSSxLQUFLSCxJQUFJLEtBQUtBLE1BQU07Z0JBQ3RCLElBQUlGLFdBQVcsRUFBRUwsT0FBTztvQkFDdEJVLEtBQUtYLEtBQUssR0FBR0E7b0JBQ2I7Z0JBQ0YsT0FBTyxJQUFJVyxLQUFLUixNQUFNLEtBQUssTUFBTTtvQkFDL0JRLE9BQU9BLEtBQUtSLE1BQU07Z0JBQ3BCLE9BQU87b0JBQ0xRLEtBQUtSLE1BQU0sR0FBRyxJQUFJTixRQUFRRSxLQUFLQyxPQUFPQztvQkFDdEM7Z0JBQ0Y7WUFDRixPQUFPLElBQUlVLEtBQUtILElBQUksR0FBR0EsTUFBTTtnQkFDM0IsSUFBSUcsS0FBS1QsSUFBSSxLQUFLLE1BQU07b0JBQ3RCUyxPQUFPQSxLQUFLVCxJQUFJO2dCQUNsQixPQUFPO29CQUNMUyxLQUFLVCxJQUFJLEdBQUcsSUFBSUwsUUFBUUUsS0FBS0MsT0FBT0M7b0JBQ3BDO2dCQUNGO1lBQ0YsT0FBTyxJQUFJVSxLQUFLUCxLQUFLLEtBQUssTUFBTTtnQkFDOUJPLE9BQU9BLEtBQUtQLEtBQUs7WUFDbkIsT0FBTztnQkFDTE8sS0FBS1AsS0FBSyxHQUFHLElBQUlQLFFBQVFFLEtBQUtDLE9BQU9DO2dCQUNyQztZQUNGO1FBQ0Y7SUFDRjtJQUVBOzs7R0FHRixHQUNFVyxPQUFRYixHQUFHLEVBQUU7UUFDWCxNQUFNYyxZQUFZZCxJQUFJTyxNQUFNO1FBQzVCLElBQUlMLFFBQVE7UUFDWixJQUFJVSxPQUFPLElBQUk7UUFDZixNQUFPQSxTQUFTLFFBQVFWLFFBQVFZLFVBQVc7WUFDekMsSUFBSUwsT0FBT1QsR0FBRyxDQUFDRSxNQUFNO1lBQ3JCO1lBQ0E7WUFDQTtZQUNBO1lBQ0EsSUFBSU8sUUFBUSxRQUFRQSxRQUFRLE1BQU07Z0JBQ2hDO2dCQUNBQSxRQUFRO1lBQ1Y7WUFDQSxNQUFPRyxTQUFTLEtBQU07Z0JBQ3BCLElBQUlILFNBQVNHLEtBQUtILElBQUksRUFBRTtvQkFDdEIsSUFBSUssY0FBYyxFQUFFWixPQUFPO3dCQUN6Qjt3QkFDQSxPQUFPVTtvQkFDVDtvQkFDQUEsT0FBT0EsS0FBS1IsTUFBTTtvQkFDbEI7Z0JBQ0Y7Z0JBQ0FRLE9BQU9BLEtBQUtILElBQUksR0FBR0EsT0FBT0csS0FBS1QsSUFBSSxHQUFHUyxLQUFLUCxLQUFLO1lBQ2xEO1FBQ0Y7UUFDQSxPQUFPO0lBQ1Q7QUFDRjtBQUVBLE1BQU1VO0lBSUo7OztLQUdGLEdBQ0VDLE9BQVFoQixHQUFHLEVBQUVDLEtBQUssRUFBRTtRQUNsQixJQUFJLElBQUksQ0FBQ1csSUFBSSxLQUFLLE1BQU07WUFDdEIsSUFBSSxDQUFDQSxJQUFJLEdBQUcsSUFBSWQsUUFBUUUsS0FBS0MsT0FBTztRQUN0QyxPQUFPO1lBQ0wsSUFBSSxDQUFDVyxJQUFJLENBQUNELEdBQUcsQ0FBQ1gsS0FBS0M7UUFDckI7SUFDRjtJQUVBOzs7R0FHRixHQUNFZ0IsT0FBUWpCLEdBQUcsRUFBRTtRQUNYLE9BQU8sSUFBSSxDQUFDWSxJQUFJLEVBQUVDLE9BQU9iLE1BQU1DLFNBQVM7SUFDMUM7O1FBckJBLG1DQUNBVyxPQUFPOztBQXFCVDtBQUVBLE1BQU1NLE9BQU8sSUFBSUg7QUFFakIsSUFBSyxJQUFJSSxJQUFJLEdBQUdBLElBQUl4QixxQkFBcUJZLE1BQU0sRUFBRSxFQUFFWSxFQUFHO0lBQ3BELE1BQU1uQixNQUFNSiwwQkFBMEIsQ0FBQ0Qsb0JBQW9CLENBQUN3QixFQUFFLENBQUM7SUFDL0RELEtBQUtGLE1BQU0sQ0FBQ2hCLEtBQUtBO0FBQ25CO0FBRUFvQixPQUFPQyxPQUFPLEdBQUc7SUFDZk47SUFDQUc7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL21vY2t1cGZsb3cvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9jb3JlL3RyZWUuanM/NTVlZCIsIndlYnBhY2s6Ly9tb2NrdXBmbG93Ly4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvY29yZS90cmVlLmpzPzU1ZWQqIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7XG4gIHdlbGxrbm93bkhlYWRlck5hbWVzLFxuICBoZWFkZXJOYW1lTG93ZXJDYXNlZFJlY29yZFxufSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJylcblxuY2xhc3MgVHN0Tm9kZSB7XG4gIC8qKiBAdHlwZSB7YW55fSAqL1xuICB2YWx1ZSA9IG51bGxcbiAgLyoqIEB0eXBlIHtudWxsIHwgVHN0Tm9kZX0gKi9cbiAgbGVmdCA9IG51bGxcbiAgLyoqIEB0eXBlIHtudWxsIHwgVHN0Tm9kZX0gKi9cbiAgbWlkZGxlID0gbnVsbFxuICAvKiogQHR5cGUge251bGwgfCBUc3ROb2RlfSAqL1xuICByaWdodCA9IG51bGxcbiAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gIGNvZGVcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICogQHBhcmFtIHthbnl9IHZhbHVlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICAgKi9cbiAgY29uc3RydWN0b3IgKGtleSwgdmFsdWUsIGluZGV4KSB7XG4gICAgaWYgKGluZGV4ID09PSB1bmRlZmluZWQgfHwgaW5kZXggPj0ga2V5Lmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5yZWFjaGFibGUnKVxuICAgIH1cbiAgICBjb25zdCBjb2RlID0gdGhpcy5jb2RlID0ga2V5LmNoYXJDb2RlQXQoaW5kZXgpXG4gICAgLy8gY2hlY2sgY29kZSBpcyBhc2NpaSBzdHJpbmdcbiAgICBpZiAoY29kZSA+IDB4N0YpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2tleSBtdXN0IGJlIGFzY2lpIHN0cmluZycpXG4gICAgfVxuICAgIGlmIChrZXkubGVuZ3RoICE9PSArK2luZGV4KSB7XG4gICAgICB0aGlzLm1pZGRsZSA9IG5ldyBUc3ROb2RlKGtleSwgdmFsdWUsIGluZGV4KVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnZhbHVlID0gdmFsdWVcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgKiBAcGFyYW0ge2FueX0gdmFsdWVcbiAgICovXG4gIGFkZCAoa2V5LCB2YWx1ZSkge1xuICAgIGNvbnN0IGxlbmd0aCA9IGtleS5sZW5ndGhcbiAgICBpZiAobGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbnJlYWNoYWJsZScpXG4gICAgfVxuICAgIGxldCBpbmRleCA9IDBcbiAgICBsZXQgbm9kZSA9IHRoaXNcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgY29uc3QgY29kZSA9IGtleS5jaGFyQ29kZUF0KGluZGV4KVxuICAgICAgLy8gY2hlY2sgY29kZSBpcyBhc2NpaSBzdHJpbmdcbiAgICAgIGlmIChjb2RlID4gMHg3Rikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdrZXkgbXVzdCBiZSBhc2NpaSBzdHJpbmcnKVxuICAgICAgfVxuICAgICAgaWYgKG5vZGUuY29kZSA9PT0gY29kZSkge1xuICAgICAgICBpZiAobGVuZ3RoID09PSArK2luZGV4KSB7XG4gICAgICAgICAgbm9kZS52YWx1ZSA9IHZhbHVlXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfSBlbHNlIGlmIChub2RlLm1pZGRsZSAhPT0gbnVsbCkge1xuICAgICAgICAgIG5vZGUgPSBub2RlLm1pZGRsZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vZGUubWlkZGxlID0gbmV3IFRzdE5vZGUoa2V5LCB2YWx1ZSwgaW5kZXgpXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChub2RlLmNvZGUgPCBjb2RlKSB7XG4gICAgICAgIGlmIChub2RlLmxlZnQgIT09IG51bGwpIHtcbiAgICAgICAgICBub2RlID0gbm9kZS5sZWZ0XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm9kZS5sZWZ0ID0gbmV3IFRzdE5vZGUoa2V5LCB2YWx1ZSwgaW5kZXgpXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChub2RlLnJpZ2h0ICE9PSBudWxsKSB7XG4gICAgICAgIG5vZGUgPSBub2RlLnJpZ2h0XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlLnJpZ2h0ID0gbmV3IFRzdE5vZGUoa2V5LCB2YWx1ZSwgaW5kZXgpXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VWludDhBcnJheX0ga2V5XG4gICAqIEByZXR1cm4ge1RzdE5vZGUgfCBudWxsfVxuICAgKi9cbiAgc2VhcmNoIChrZXkpIHtcbiAgICBjb25zdCBrZXlsZW5ndGggPSBrZXkubGVuZ3RoXG4gICAgbGV0IGluZGV4ID0gMFxuICAgIGxldCBub2RlID0gdGhpc1xuICAgIHdoaWxlIChub2RlICE9PSBudWxsICYmIGluZGV4IDwga2V5bGVuZ3RoKSB7XG4gICAgICBsZXQgY29kZSA9IGtleVtpbmRleF1cbiAgICAgIC8vIEEtWlxuICAgICAgLy8gRmlyc3QgY2hlY2sgaWYgaXQgaXMgYmlnZ2VyIHRoYW4gMHg1YS5cbiAgICAgIC8vIExvd2VyY2FzZSBsZXR0ZXJzIGhhdmUgaGlnaGVyIGNoYXIgY29kZXMgdGhhbiB1cHBlcmNhc2Ugb25lcy5cbiAgICAgIC8vIEFsc28gd2UgYXNzdW1lIHRoYXQgaGVhZGVycyB3aWxsIG1vc3RseSBjb250YWluIGxvd2VyY2FzZSBjaGFyYWN0ZXJzLlxuICAgICAgaWYgKGNvZGUgPD0gMHg1YSAmJiBjb2RlID49IDB4NDEpIHtcbiAgICAgICAgLy8gTG93ZXJjYXNlIGZvciB1cHBlcmNhc2UuXG4gICAgICAgIGNvZGUgfD0gMzJcbiAgICAgIH1cbiAgICAgIHdoaWxlIChub2RlICE9PSBudWxsKSB7XG4gICAgICAgIGlmIChjb2RlID09PSBub2RlLmNvZGUpIHtcbiAgICAgICAgICBpZiAoa2V5bGVuZ3RoID09PSArK2luZGV4KSB7XG4gICAgICAgICAgICAvLyBSZXR1cm5zIE5vZGUgc2luY2UgaXQgaXMgdGhlIGxhc3Qga2V5LlxuICAgICAgICAgICAgcmV0dXJuIG5vZGVcbiAgICAgICAgICB9XG4gICAgICAgICAgbm9kZSA9IG5vZGUubWlkZGxlXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBub2RlID0gbm9kZS5jb2RlIDwgY29kZSA/IG5vZGUubGVmdCA6IG5vZGUucmlnaHRcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGxcbiAgfVxufVxuXG5jbGFzcyBUZXJuYXJ5U2VhcmNoVHJlZSB7XG4gIC8qKiBAdHlwZSB7VHN0Tm9kZSB8IG51bGx9ICovXG4gIG5vZGUgPSBudWxsXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICogQHBhcmFtIHthbnl9IHZhbHVlXG4gICAqICovXG4gIGluc2VydCAoa2V5LCB2YWx1ZSkge1xuICAgIGlmICh0aGlzLm5vZGUgPT09IG51bGwpIHtcbiAgICAgIHRoaXMubm9kZSA9IG5ldyBUc3ROb2RlKGtleSwgdmFsdWUsIDApXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubm9kZS5hZGQoa2V5LCB2YWx1ZSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtVaW50OEFycmF5fSBrZXlcbiAgICogQHJldHVybiB7YW55fVxuICAgKi9cbiAgbG9va3VwIChrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5ub2RlPy5zZWFyY2goa2V5KT8udmFsdWUgPz8gbnVsbFxuICB9XG59XG5cbmNvbnN0IHRyZWUgPSBuZXcgVGVybmFyeVNlYXJjaFRyZWUoKVxuXG5mb3IgKGxldCBpID0gMDsgaSA8IHdlbGxrbm93bkhlYWRlck5hbWVzLmxlbmd0aDsgKytpKSB7XG4gIGNvbnN0IGtleSA9IGhlYWRlck5hbWVMb3dlckNhc2VkUmVjb3JkW3dlbGxrbm93bkhlYWRlck5hbWVzW2ldXVxuICB0cmVlLmluc2VydChrZXksIGtleSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFRlcm5hcnlTZWFyY2hUcmVlLFxuICB0cmVlXG59XG4iXSwibmFtZXMiOlsid2VsbGtub3duSGVhZGVyTmFtZXMiLCJoZWFkZXJOYW1lTG93ZXJDYXNlZFJlY29yZCIsInJlcXVpcmUiLCJUc3ROb2RlIiwiY29uc3RydWN0b3IiLCJrZXkiLCJ2YWx1ZSIsImluZGV4IiwibGVmdCIsIm1pZGRsZSIsInJpZ2h0IiwidW5kZWZpbmVkIiwibGVuZ3RoIiwiVHlwZUVycm9yIiwiY29kZSIsImNoYXJDb2RlQXQiLCJhZGQiLCJub2RlIiwic2VhcmNoIiwia2V5bGVuZ3RoIiwiVGVybmFyeVNlYXJjaFRyZWUiLCJpbnNlcnQiLCJsb29rdXAiLCJ0cmVlIiwiaSIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/core/tree.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/core/util.js":
/*!**********************************************!*\
  !*** ./node_modules/undici/lib/core/util.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\");\nconst { kDestroyed, kBodyUsed, kListeners, kBody } = __webpack_require__(/*! ./symbols */ \"(ssr)/./node_modules/undici/lib/core/symbols.js\");\nconst { IncomingMessage } = __webpack_require__(/*! node:http */ \"node:http\");\nconst stream = __webpack_require__(/*! node:stream */ \"node:stream\");\nconst net = __webpack_require__(/*! node:net */ \"node:net\");\nconst { Blob } = __webpack_require__(/*! node:buffer */ \"node:buffer\");\nconst nodeUtil = __webpack_require__(/*! node:util */ \"node:util\");\nconst { stringify } = __webpack_require__(/*! node:querystring */ \"node:querystring\");\nconst { EventEmitter: EE } = __webpack_require__(/*! node:events */ \"node:events\");\nconst { InvalidArgumentError } = __webpack_require__(/*! ./errors */ \"(ssr)/./node_modules/undici/lib/core/errors.js\");\nconst { headerNameLowerCasedRecord } = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/undici/lib/core/constants.js\");\nconst { tree } = __webpack_require__(/*! ./tree */ \"(ssr)/./node_modules/undici/lib/core/tree.js\");\nconst [nodeMajor, nodeMinor] = process.versions.node.split(\".\").map((v)=>Number(v));\nclass BodyAsyncIterable {\n    constructor(body){\n        this[kBody] = body;\n        this[kBodyUsed] = false;\n    }\n    async *[Symbol.asyncIterator]() {\n        assert(!this[kBodyUsed], \"disturbed\");\n        this[kBodyUsed] = true;\n        yield* this[kBody];\n    }\n}\nfunction wrapRequestBody(body) {\n    if (isStream(body)) {\n        // TODO (fix): Provide some way for the user to cache the file to e.g. /tmp\n        // so that it can be dispatched again?\n        // TODO (fix): Do we need 100-expect support to provide a way to do this properly?\n        if (bodyLength(body) === 0) {\n            body.on(\"data\", function() {\n                assert(false);\n            });\n        }\n        if (typeof body.readableDidRead !== \"boolean\") {\n            body[kBodyUsed] = false;\n            EE.prototype.on.call(body, \"data\", function() {\n                this[kBodyUsed] = true;\n            });\n        }\n        return body;\n    } else if (body && typeof body.pipeTo === \"function\") {\n        // TODO (fix): We can't access ReadableStream internal state\n        // to determine whether or not it has been disturbed. This is just\n        // a workaround.\n        return new BodyAsyncIterable(body);\n    } else if (body && typeof body !== \"string\" && !ArrayBuffer.isView(body) && isIterable(body)) {\n        // TODO: Should we allow re-using iterable if !this.opts.idempotent\n        // or through some other flag?\n        return new BodyAsyncIterable(body);\n    } else {\n        return body;\n    }\n}\nfunction nop() {}\nfunction isStream(obj) {\n    return obj && typeof obj === \"object\" && typeof obj.pipe === \"function\" && typeof obj.on === \"function\";\n}\n// based on https://github.com/node-fetch/fetch-blob/blob/8ab587d34080de94140b54f07168451e7d0b655e/index.js#L229-L241 (MIT License)\nfunction isBlobLike(object) {\n    if (object === null) {\n        return false;\n    } else if (object instanceof Blob) {\n        return true;\n    } else if (typeof object !== \"object\") {\n        return false;\n    } else {\n        const sTag = object[Symbol.toStringTag];\n        return (sTag === \"Blob\" || sTag === \"File\") && (\"stream\" in object && typeof object.stream === \"function\" || \"arrayBuffer\" in object && typeof object.arrayBuffer === \"function\");\n    }\n}\nfunction buildURL(url, queryParams) {\n    if (url.includes(\"?\") || url.includes(\"#\")) {\n        throw new Error('Query params cannot be passed when url already contains \"?\" or \"#\".');\n    }\n    const stringified = stringify(queryParams);\n    if (stringified) {\n        url += \"?\" + stringified;\n    }\n    return url;\n}\nfunction isValidPort(port) {\n    const value = parseInt(port, 10);\n    return value === Number(port) && value >= 0 && value <= 65535;\n}\nfunction isHttpOrHttpsPrefixed(value) {\n    return value != null && value[0] === \"h\" && value[1] === \"t\" && value[2] === \"t\" && value[3] === \"p\" && (value[4] === \":\" || value[4] === \"s\" && value[5] === \":\");\n}\nfunction parseURL(url) {\n    if (typeof url === \"string\") {\n        url = new URL(url);\n        if (!isHttpOrHttpsPrefixed(url.origin || url.protocol)) {\n            throw new InvalidArgumentError(\"Invalid URL protocol: the URL must start with `http:` or `https:`.\");\n        }\n        return url;\n    }\n    if (!url || typeof url !== \"object\") {\n        throw new InvalidArgumentError(\"Invalid URL: The URL argument must be a non-null object.\");\n    }\n    if (!(url instanceof URL)) {\n        if (url.port != null && url.port !== \"\" && isValidPort(url.port) === false) {\n            throw new InvalidArgumentError(\"Invalid URL: port must be a valid integer or a string representation of an integer.\");\n        }\n        if (url.path != null && typeof url.path !== \"string\") {\n            throw new InvalidArgumentError(\"Invalid URL path: the path must be a string or null/undefined.\");\n        }\n        if (url.pathname != null && typeof url.pathname !== \"string\") {\n            throw new InvalidArgumentError(\"Invalid URL pathname: the pathname must be a string or null/undefined.\");\n        }\n        if (url.hostname != null && typeof url.hostname !== \"string\") {\n            throw new InvalidArgumentError(\"Invalid URL hostname: the hostname must be a string or null/undefined.\");\n        }\n        if (url.origin != null && typeof url.origin !== \"string\") {\n            throw new InvalidArgumentError(\"Invalid URL origin: the origin must be a string or null/undefined.\");\n        }\n        if (!isHttpOrHttpsPrefixed(url.origin || url.protocol)) {\n            throw new InvalidArgumentError(\"Invalid URL protocol: the URL must start with `http:` or `https:`.\");\n        }\n        const port = url.port != null ? url.port : url.protocol === \"https:\" ? 443 : 80;\n        let origin = url.origin != null ? url.origin : `${url.protocol || \"\"}//${url.hostname || \"\"}:${port}`;\n        let path = url.path != null ? url.path : `${url.pathname || \"\"}${url.search || \"\"}`;\n        if (origin[origin.length - 1] === \"/\") {\n            origin = origin.slice(0, origin.length - 1);\n        }\n        if (path && path[0] !== \"/\") {\n            path = `/${path}`;\n        }\n        // new URL(path, origin) is unsafe when `path` contains an absolute URL\n        // From https://developer.mozilla.org/en-US/docs/Web/API/URL/URL:\n        // If first parameter is a relative URL, second param is required, and will be used as the base URL.\n        // If first parameter is an absolute URL, a given second param will be ignored.\n        return new URL(`${origin}${path}`);\n    }\n    if (!isHttpOrHttpsPrefixed(url.origin || url.protocol)) {\n        throw new InvalidArgumentError(\"Invalid URL protocol: the URL must start with `http:` or `https:`.\");\n    }\n    return url;\n}\nfunction parseOrigin(url) {\n    url = parseURL(url);\n    if (url.pathname !== \"/\" || url.search || url.hash) {\n        throw new InvalidArgumentError(\"invalid url\");\n    }\n    return url;\n}\nfunction getHostname(host) {\n    if (host[0] === \"[\") {\n        const idx = host.indexOf(\"]\");\n        assert(idx !== -1);\n        return host.substring(1, idx);\n    }\n    const idx = host.indexOf(\":\");\n    if (idx === -1) return host;\n    return host.substring(0, idx);\n}\n// IP addresses are not valid server names per RFC6066\n// > Currently, the only server names supported are DNS hostnames\nfunction getServerName(host) {\n    if (!host) {\n        return null;\n    }\n    assert.strictEqual(typeof host, \"string\");\n    const servername = getHostname(host);\n    if (net.isIP(servername)) {\n        return \"\";\n    }\n    return servername;\n}\nfunction deepClone(obj) {\n    return JSON.parse(JSON.stringify(obj));\n}\nfunction isAsyncIterable(obj) {\n    return !!(obj != null && typeof obj[Symbol.asyncIterator] === \"function\");\n}\nfunction isIterable(obj) {\n    return !!(obj != null && (typeof obj[Symbol.iterator] === \"function\" || typeof obj[Symbol.asyncIterator] === \"function\"));\n}\nfunction bodyLength(body) {\n    if (body == null) {\n        return 0;\n    } else if (isStream(body)) {\n        const state = body._readableState;\n        return state && state.objectMode === false && state.ended === true && Number.isFinite(state.length) ? state.length : null;\n    } else if (isBlobLike(body)) {\n        return body.size != null ? body.size : null;\n    } else if (isBuffer(body)) {\n        return body.byteLength;\n    }\n    return null;\n}\nfunction isDestroyed(body) {\n    return body && !!(body.destroyed || body[kDestroyed] || stream.isDestroyed?.(body));\n}\nfunction destroy(stream, err) {\n    if (stream == null || !isStream(stream) || isDestroyed(stream)) {\n        return;\n    }\n    if (typeof stream.destroy === \"function\") {\n        if (Object.getPrototypeOf(stream).constructor === IncomingMessage) {\n            // See: https://github.com/nodejs/node/pull/38505/files\n            stream.socket = null;\n        }\n        stream.destroy(err);\n    } else if (err) {\n        queueMicrotask(()=>{\n            stream.emit(\"error\", err);\n        });\n    }\n    if (stream.destroyed !== true) {\n        stream[kDestroyed] = true;\n    }\n}\nconst KEEPALIVE_TIMEOUT_EXPR = /timeout=(\\d+)/;\nfunction parseKeepAliveTimeout(val) {\n    const m = val.toString().match(KEEPALIVE_TIMEOUT_EXPR);\n    return m ? parseInt(m[1], 10) * 1000 : null;\n}\n/**\n * Retrieves a header name and returns its lowercase value.\n * @param {string | Buffer} value Header name\n * @returns {string}\n */ function headerNameToString(value) {\n    return typeof value === \"string\" ? headerNameLowerCasedRecord[value] ?? value.toLowerCase() : tree.lookup(value) ?? value.toString(\"latin1\").toLowerCase();\n}\n/**\n * Receive the buffer as a string and return its lowercase value.\n * @param {Buffer} value Header name\n * @returns {string}\n */ function bufferToLowerCasedHeaderName(value) {\n    return tree.lookup(value) ?? value.toString(\"latin1\").toLowerCase();\n}\n/**\n * @param {Record<string, string | string[]> | (Buffer | string | (Buffer | string)[])[]} headers\n * @param {Record<string, string | string[]>} [obj]\n * @returns {Record<string, string | string[]>}\n */ function parseHeaders(headers, obj) {\n    if (obj === undefined) obj = {};\n    for(let i = 0; i < headers.length; i += 2){\n        const key = headerNameToString(headers[i]);\n        let val = obj[key];\n        if (val) {\n            if (typeof val === \"string\") {\n                val = [\n                    val\n                ];\n                obj[key] = val;\n            }\n            val.push(headers[i + 1].toString(\"utf8\"));\n        } else {\n            const headersValue = headers[i + 1];\n            if (typeof headersValue === \"string\") {\n                obj[key] = headersValue;\n            } else {\n                obj[key] = Array.isArray(headersValue) ? headersValue.map((x)=>x.toString(\"utf8\")) : headersValue.toString(\"utf8\");\n            }\n        }\n    }\n    // See https://github.com/nodejs/node/pull/46528\n    if (\"content-length\" in obj && \"content-disposition\" in obj) {\n        obj[\"content-disposition\"] = Buffer.from(obj[\"content-disposition\"]).toString(\"latin1\");\n    }\n    return obj;\n}\nfunction parseRawHeaders(headers) {\n    const len = headers.length;\n    const ret = new Array(len);\n    let hasContentLength = false;\n    let contentDispositionIdx = -1;\n    let key;\n    let val;\n    let kLen = 0;\n    for(let n = 0; n < headers.length; n += 2){\n        key = headers[n];\n        val = headers[n + 1];\n        typeof key !== \"string\" && (key = key.toString());\n        typeof val !== \"string\" && (val = val.toString(\"utf8\"));\n        kLen = key.length;\n        if (kLen === 14 && key[7] === \"-\" && (key === \"content-length\" || key.toLowerCase() === \"content-length\")) {\n            hasContentLength = true;\n        } else if (kLen === 19 && key[7] === \"-\" && (key === \"content-disposition\" || key.toLowerCase() === \"content-disposition\")) {\n            contentDispositionIdx = n + 1;\n        }\n        ret[n] = key;\n        ret[n + 1] = val;\n    }\n    // See https://github.com/nodejs/node/pull/46528\n    if (hasContentLength && contentDispositionIdx !== -1) {\n        ret[contentDispositionIdx] = Buffer.from(ret[contentDispositionIdx]).toString(\"latin1\");\n    }\n    return ret;\n}\nfunction isBuffer(buffer) {\n    // See, https://github.com/mcollina/undici/pull/319\n    return buffer instanceof Uint8Array || Buffer.isBuffer(buffer);\n}\nfunction validateHandler(handler, method, upgrade) {\n    if (!handler || typeof handler !== \"object\") {\n        throw new InvalidArgumentError(\"handler must be an object\");\n    }\n    if (typeof handler.onConnect !== \"function\") {\n        throw new InvalidArgumentError(\"invalid onConnect method\");\n    }\n    if (typeof handler.onError !== \"function\") {\n        throw new InvalidArgumentError(\"invalid onError method\");\n    }\n    if (typeof handler.onBodySent !== \"function\" && handler.onBodySent !== undefined) {\n        throw new InvalidArgumentError(\"invalid onBodySent method\");\n    }\n    if (upgrade || method === \"CONNECT\") {\n        if (typeof handler.onUpgrade !== \"function\") {\n            throw new InvalidArgumentError(\"invalid onUpgrade method\");\n        }\n    } else {\n        if (typeof handler.onHeaders !== \"function\") {\n            throw new InvalidArgumentError(\"invalid onHeaders method\");\n        }\n        if (typeof handler.onData !== \"function\") {\n            throw new InvalidArgumentError(\"invalid onData method\");\n        }\n        if (typeof handler.onComplete !== \"function\") {\n            throw new InvalidArgumentError(\"invalid onComplete method\");\n        }\n    }\n}\n// A body is disturbed if it has been read from and it cannot\n// be re-used without losing state or data.\nfunction isDisturbed(body) {\n    // TODO (fix): Why is body[kBodyUsed] needed?\n    return !!(body && (stream.isDisturbed(body) || body[kBodyUsed]));\n}\nfunction isErrored(body) {\n    return !!(body && stream.isErrored(body));\n}\nfunction isReadable(body) {\n    return !!(body && stream.isReadable(body));\n}\nfunction getSocketInfo(socket) {\n    return {\n        localAddress: socket.localAddress,\n        localPort: socket.localPort,\n        remoteAddress: socket.remoteAddress,\n        remotePort: socket.remotePort,\n        remoteFamily: socket.remoteFamily,\n        timeout: socket.timeout,\n        bytesWritten: socket.bytesWritten,\n        bytesRead: socket.bytesRead\n    };\n}\n/** @type {globalThis['ReadableStream']} */ function ReadableStreamFrom(iterable) {\n    // We cannot use ReadableStream.from here because it does not return a byte stream.\n    let iterator;\n    return new ReadableStream({\n        async start () {\n            iterator = iterable[Symbol.asyncIterator]();\n        },\n        async pull (controller) {\n            const { done, value } = await iterator.next();\n            if (done) {\n                queueMicrotask(()=>{\n                    controller.close();\n                    controller.byobRequest?.respond(0);\n                });\n            } else {\n                const buf = Buffer.isBuffer(value) ? value : Buffer.from(value);\n                if (buf.byteLength) {\n                    controller.enqueue(new Uint8Array(buf));\n                }\n            }\n            return controller.desiredSize > 0;\n        },\n        async cancel (reason) {\n            await iterator.return();\n        },\n        type: \"bytes\"\n    });\n}\n// The chunk should be a FormData instance and contains\n// all the required methods.\nfunction isFormDataLike(object) {\n    return object && typeof object === \"object\" && typeof object.append === \"function\" && typeof object.delete === \"function\" && typeof object.get === \"function\" && typeof object.getAll === \"function\" && typeof object.has === \"function\" && typeof object.set === \"function\" && object[Symbol.toStringTag] === \"FormData\";\n}\nfunction addAbortListener(signal, listener) {\n    if (\"addEventListener\" in signal) {\n        signal.addEventListener(\"abort\", listener, {\n            once: true\n        });\n        return ()=>signal.removeEventListener(\"abort\", listener);\n    }\n    signal.addListener(\"abort\", listener);\n    return ()=>signal.removeListener(\"abort\", listener);\n}\nconst hasToWellFormed = typeof String.prototype.toWellFormed === \"function\";\nconst hasIsWellFormed = typeof String.prototype.isWellFormed === \"function\";\n/**\n * @param {string} val\n */ function toUSVString(val) {\n    return hasToWellFormed ? `${val}`.toWellFormed() : nodeUtil.toUSVString(val);\n}\n/**\n * @param {string} val\n */ // TODO: move this to webidl\nfunction isUSVString(val) {\n    return hasIsWellFormed ? `${val}`.isWellFormed() : toUSVString(val) === `${val}`;\n}\n/**\n * @see https://tools.ietf.org/html/rfc7230#section-3.2.6\n * @param {number} c\n */ function isTokenCharCode(c) {\n    switch(c){\n        case 0x22:\n        case 0x28:\n        case 0x29:\n        case 0x2c:\n        case 0x2f:\n        case 0x3a:\n        case 0x3b:\n        case 0x3c:\n        case 0x3d:\n        case 0x3e:\n        case 0x3f:\n        case 0x40:\n        case 0x5b:\n        case 0x5c:\n        case 0x5d:\n        case 0x7b:\n        case 0x7d:\n            // DQUOTE and \"(),/:;<=>?@[\\]{}\"\n            return false;\n        default:\n            // VCHAR %x21-7E\n            return c >= 0x21 && c <= 0x7e;\n    }\n}\n/**\n * @param {string} characters\n */ function isValidHTTPToken(characters) {\n    if (characters.length === 0) {\n        return false;\n    }\n    for(let i = 0; i < characters.length; ++i){\n        if (!isTokenCharCode(characters.charCodeAt(i))) {\n            return false;\n        }\n    }\n    return true;\n}\n// headerCharRegex have been lifted from\n// https://github.com/nodejs/node/blob/main/lib/_http_common.js\n/**\n * Matches if val contains an invalid field-vchar\n *  field-value    = *( field-content / obs-fold )\n *  field-content  = field-vchar [ 1*( SP / HTAB ) field-vchar ]\n *  field-vchar    = VCHAR / obs-text\n */ const headerCharRegex = /[^\\t\\x20-\\x7e\\x80-\\xff]/;\n/**\n * @param {string} characters\n */ function isValidHeaderValue(characters) {\n    return !headerCharRegex.test(characters);\n}\n// Parsed accordingly to RFC 9110\n// https://www.rfc-editor.org/rfc/rfc9110#field.content-range\nfunction parseRangeHeader(range) {\n    if (range == null || range === \"\") return {\n        start: 0,\n        end: null,\n        size: null\n    };\n    const m = range ? range.match(/^bytes (\\d+)-(\\d+)\\/(\\d+)?$/) : null;\n    return m ? {\n        start: parseInt(m[1]),\n        end: m[2] ? parseInt(m[2]) : null,\n        size: m[3] ? parseInt(m[3]) : null\n    } : null;\n}\nfunction addListener(obj, name, listener) {\n    const listeners = obj[kListeners] ??= [];\n    listeners.push([\n        name,\n        listener\n    ]);\n    obj.on(name, listener);\n    return obj;\n}\nfunction removeAllListeners(obj) {\n    for (const [name, listener] of obj[kListeners] ?? []){\n        obj.removeListener(name, listener);\n    }\n    obj[kListeners] = null;\n}\nfunction errorRequest(client, request, err) {\n    try {\n        request.onError(err);\n        assert(request.aborted);\n    } catch (err) {\n        client.emit(\"error\", err);\n    }\n}\nconst kEnumerableProperty = Object.create(null);\nkEnumerableProperty.enumerable = true;\nconst normalizedMethodRecordsBase = {\n    delete: \"DELETE\",\n    DELETE: \"DELETE\",\n    get: \"GET\",\n    GET: \"GET\",\n    head: \"HEAD\",\n    HEAD: \"HEAD\",\n    options: \"OPTIONS\",\n    OPTIONS: \"OPTIONS\",\n    post: \"POST\",\n    POST: \"POST\",\n    put: \"PUT\",\n    PUT: \"PUT\"\n};\nconst normalizedMethodRecords = {\n    ...normalizedMethodRecordsBase,\n    patch: \"patch\",\n    PATCH: \"PATCH\"\n};\n// Note: object prototypes should not be able to be referenced. e.g. `Object#hasOwnProperty`.\nObject.setPrototypeOf(normalizedMethodRecordsBase, null);\nObject.setPrototypeOf(normalizedMethodRecords, null);\nmodule.exports = {\n    kEnumerableProperty,\n    nop,\n    isDisturbed,\n    isErrored,\n    isReadable,\n    toUSVString,\n    isUSVString,\n    isBlobLike,\n    parseOrigin,\n    parseURL,\n    getServerName,\n    isStream,\n    isIterable,\n    isAsyncIterable,\n    isDestroyed,\n    headerNameToString,\n    bufferToLowerCasedHeaderName,\n    addListener,\n    removeAllListeners,\n    errorRequest,\n    parseRawHeaders,\n    parseHeaders,\n    parseKeepAliveTimeout,\n    destroy,\n    bodyLength,\n    deepClone,\n    ReadableStreamFrom,\n    isBuffer,\n    validateHandler,\n    getSocketInfo,\n    isFormDataLike,\n    buildURL,\n    addAbortListener,\n    isValidHTTPToken,\n    isValidHeaderValue,\n    isTokenCharCode,\n    parseRangeHeader,\n    normalizedMethodRecordsBase,\n    normalizedMethodRecords,\n    isValidPort,\n    isHttpOrHttpsPrefixed,\n    nodeMajor,\n    nodeMinor,\n    safeHTTPMethods: [\n        \"GET\",\n        \"HEAD\",\n        \"OPTIONS\",\n        \"TRACE\"\n    ],\n    wrapRequestBody\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9jb3JlL3V0aWwuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNQSxTQUFTQyxtQkFBT0EsQ0FBQztBQUN2QixNQUFNLEVBQUVDLFVBQVUsRUFBRUMsU0FBUyxFQUFFQyxVQUFVLEVBQUVDLEtBQUFBLEVBQU8sR0FBR0osbUJBQU9BLENBQUM7QUFDN0QsTUFBTSxFQUFFSyxlQUFBQSxFQUFpQixHQUFHTCxtQkFBT0EsQ0FBQztBQUNwQyxNQUFNTSxTQUFTTixtQkFBT0EsQ0FBQztBQUN2QixNQUFNTyxNQUFNUCxtQkFBT0EsQ0FBQztBQUNwQixNQUFNLEVBQUVRLElBQUFBLEVBQU0sR0FBR1IsbUJBQU9BLENBQUM7QUFDekIsTUFBTVMsV0FBV1QsbUJBQU9BLENBQUM7QUFDekIsTUFBTSxFQUFFVSxTQUFBQSxFQUFXLEdBQUdWLG1CQUFPQSxDQUFDO0FBQzlCLE1BQU0sRUFBRVcsY0FBY0MsRUFBQUEsRUFBSSxHQUFHWixtQkFBT0EsQ0FBQztBQUNyQyxNQUFNLEVBQUVhLG9CQUFBQSxFQUFzQixHQUFHYixtQkFBT0EsQ0FBQztBQUN6QyxNQUFNLEVBQUVjLDBCQUFBQSxFQUE0QixHQUFHZCxtQkFBT0EsQ0FBQztBQUMvQyxNQUFNLEVBQUVlLElBQUFBLEVBQU0sR0FBR2YsbUJBQU9BLENBQUM7QUFFekIsTUFBTSxDQUFDZ0IsV0FBV0MsVUFBVSxHQUFHQyxRQUFRQyxRQUFRLENBQUNDLElBQUksQ0FBQ0MsS0FBSyxDQUFDLEtBQUtDLEdBQUcsQ0FBQ0MsQ0FBQUEsSUFBS0MsT0FBT0Q7QUFFaEYsTUFBTUU7SUFDSkMsWUFBYUMsSUFBSSxDQUFFO1FBQ2pCLElBQUksQ0FBQ3ZCLE1BQU0sR0FBR3VCO1FBQ2QsSUFBSSxDQUFDekIsVUFBVSxHQUFHO0lBQ3BCO0lBRUEsUUFBUzBCLE9BQU9DLGFBQWEsSUFBSztRQUNoQzlCLE9BQU8sQ0FBQyxJQUFJLENBQUNHLFVBQVUsRUFBRTtRQUN6QixJQUFJLENB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QUFPO0FBQ1Q7QUFFQTtBQUNBckksT0FBT3NJLGNBQWMsQ0FBQ2QsNkJBQTZCO0FBQ25EeEgsT0FBT3NJLGNBQWMsQ0FBQ0gseUJBQXlCO0FBRS9DSSxPQUFPQyxPQUFPLEdBQUc7SUFDZm5CO0lBQ0E5SztJQUNBd0c7SUFDQUM7SUFDQUM7SUFDQWdEO0lBQ0FDO0lBQ0F4SjtJQUNBMEI7SUFDQVY7SUFDQWlCO0lBQ0E5QztJQUNBUztJQUNBNEM7SUFDQVU7SUFDQWU7SUFDQUc7SUFDQTRFO0lBQ0FzQjtJQUNBQztJQUNBdEY7SUFDQVo7SUFDQVQ7SUFDQVI7SUFDQWhFO0lBQ0FpRDtJQUNBNEU7SUFDQWpFO0lBQ0EwQztJQUNBYztJQUNBMkI7SUFDQTlIO0lBQ0FxSTtJQUNBaUI7SUFDQUk7SUFDQU47SUFDQVE7SUFDQWE7SUFDQVc7SUFDQTlLO0lBQ0FJO0lBQ0EzQztJQUNBQztJQUNBME4saUJBQWlCO1FBQUM7UUFBTztRQUFRO1FBQVc7S0FBUTtJQUNwRDdNO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tb2NrdXBmbG93Ly4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvY29yZS91dGlsLmpzPzBmYmQiLCJ3ZWJwYWNrOi8vbW9ja3VwZmxvdy8uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2NvcmUvdXRpbC5qcz8wZmJkKiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZSgnbm9kZTphc3NlcnQnKVxuY29uc3QgeyBrRGVzdHJveWVkLCBrQm9keVVzZWQsIGtMaXN0ZW5lcnMsIGtCb2R5IH0gPSByZXF1aXJlKCcuL3N5bWJvbHMnKVxuY29uc3QgeyBJbmNvbWluZ01lc3NhZ2UgfSA9IHJlcXVpcmUoJ25vZGU6aHR0cCcpXG5jb25zdCBzdHJlYW0gPSByZXF1aXJlKCdub2RlOnN0cmVhbScpXG5jb25zdCBuZXQgPSByZXF1aXJlKCdub2RlOm5ldCcpXG5jb25zdCB7IEJsb2IgfSA9IHJlcXVpcmUoJ25vZGU6YnVmZmVyJylcbmNvbnN0IG5vZGVVdGlsID0gcmVxdWlyZSgnbm9kZTp1dGlsJylcbmNvbnN0IHsgc3RyaW5naWZ5IH0gPSByZXF1aXJlKCdub2RlOnF1ZXJ5c3RyaW5nJylcbmNvbnN0IHsgRXZlbnRFbWl0dGVyOiBFRSB9ID0gcmVxdWlyZSgnbm9kZTpldmVudHMnKVxuY29uc3QgeyBJbnZhbGlkQXJndW1lbnRFcnJvciB9ID0gcmVxdWlyZSgnLi9lcnJvcnMnKVxuY29uc3QgeyBoZWFkZXJOYW1lTG93ZXJDYXNlZFJlY29yZCB9ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKVxuY29uc3QgeyB0cmVlIH0gPSByZXF1aXJlKCcuL3RyZWUnKVxuXG5jb25zdCBbbm9kZU1ham9yLCBub2RlTWlub3JdID0gcHJvY2Vzcy52ZXJzaW9ucy5ub2RlLnNwbGl0KCcuJykubWFwKHYgPT4gTnVtYmVyKHYpKVxuXG5jbGFzcyBCb2R5QXN5bmNJdGVyYWJsZSB7XG4gIGNvbnN0cnVjdG9yIChib2R5KSB7XG4gICAgdGhpc1trQm9keV0gPSBib2R5XG4gICAgdGhpc1trQm9keVVzZWRdID0gZmFsc2VcbiAgfVxuXG4gIGFzeW5jICogW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSAoKSB7XG4gICAgYXNzZXJ0KCF0aGlzW2tCb2R5VXNlZF0sICdkaXN0dXJiZWQnKVxuICAgIHRoaXNba0JvZHlVc2VkXSA9IHRydWVcbiAgICB5aWVsZCAqIHRoaXNba0JvZHldXG4gIH1cbn1cblxuZnVuY3Rpb24gd3JhcFJlcXVlc3RCb2R5IChib2R5KSB7XG4gIGlmIChpc1N0cmVhbShib2R5KSkge1xuICAgIC8vIFRPRE8gKGZpeCk6IFByb3ZpZGUgc29tZSB3YXkgZm9yIHRoZSB1c2VyIHRvIGNhY2hlIHRoZSBmaWxlIHRvIGUuZy4gL3RtcFxuICAgIC8vIHNvIHRoYXQgaXQgY2FuIGJlIGRpc3BhdGNoZWQgYWdhaW4/XG4gICAgLy8gVE9ETyAoZml4KTogRG8gd2UgbmVlZCAxMDAtZXhwZWN0IHN1cHBvcnQgdG8gcHJvdmlkZSBhIHdheSB0byBkbyB0aGlzIHByb3Blcmx5P1xuICAgIGlmIChib2R5TGVuZ3RoKGJvZHkpID09PSAwKSB7XG4gICAgICBib2R5XG4gICAgICAgIC5vbignZGF0YScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBhc3NlcnQoZmFsc2UpXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBib2R5LnJlYWRhYmxlRGlkUmVhZCAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICBib2R5W2tCb2R5VXNlZF0gPSBmYWxzZVxuICAgICAgRUUucHJvdG90eXBlLm9uLmNhbGwoYm9keSwgJ2RhdGEnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXNba0JvZHlVc2VkXSA9IHRydWVcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgcmV0dXJuIGJvZHlcbiAgfSBlbHNlIGlmIChib2R5ICYmIHR5cGVvZiBib2R5LnBpcGVUbyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIFRPRE8gKGZpeCk6IFdlIGNhbid0IGFjY2VzcyBSZWFkYWJsZVN0cmVhbSBpbnRlcm5hbCBzdGF0ZVxuICAgIC8vIHRvIGRldGVybWluZSB3aGV0aGVyIG9yIG5vdCBpdCBoYXMgYmVlbiBkaXN0dXJiZWQuIFRoaXMgaXMganVzdFxuICAgIC8vIGEgd29ya2Fyb3VuZC5cbiAgICByZXR1cm4gbmV3IEJvZHlBc3luY0l0ZXJhYmxlKGJvZHkpXG4gIH0gZWxzZSBpZiAoXG4gICAgYm9keSAmJlxuICAgIHR5cGVvZiBib2R5ICE9PSAnc3RyaW5nJyAmJlxuICAgICFBcnJheUJ1ZmZlci5pc1ZpZXcoYm9keSkgJiZcbiAgICBpc0l0ZXJhYmxlKGJvZHkpXG4gICkge1xuICAgIC8vIFRPRE86IFNob3VsZCB3ZSBhbGxvdyByZS11c2luZyBpdGVyYWJsZSBpZiAhdGhpcy5vcHRzLmlkZW1wb3RlbnRcbiAgICAvLyBvciB0aHJvdWdoIHNvbWUgb3RoZXIgZmxhZz9cbiAgICByZXR1cm4gbmV3IEJvZHlBc3luY0l0ZXJhYmxlKGJvZHkpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJvZHlcbiAgfVxufVxuXG5mdW5jdGlvbiBub3AgKCkge31cblxuZnVuY3Rpb24gaXNTdHJlYW0gKG9iaikge1xuICByZXR1cm4gb2JqICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIHR5cGVvZiBvYmoucGlwZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygb2JqLm9uID09PSAnZnVuY3Rpb24nXG59XG5cbi8vIGJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlLWZldGNoL2ZldGNoLWJsb2IvYmxvYi84YWI1ODdkMzQwODBkZTk0MTQwYjU0ZjA3MTY4NDUxZTdkMGI2NTVlL2luZGV4LmpzI0wyMjktTDI0MSAoTUlUIExpY2Vuc2UpXG5mdW5jdGlvbiBpc0Jsb2JMaWtlIChvYmplY3QpIHtcbiAgaWYgKG9iamVjdCA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZVxuICB9IGVsc2UgaWYgKG9iamVjdCBpbnN0YW5jZW9mIEJsb2IpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9IGVsc2UgaWYgKHR5cGVvZiBvYmplY3QgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH0gZWxzZSB7XG4gICAgY29uc3Qgc1RhZyA9IG9iamVjdFtTeW1ib2wudG9TdHJpbmdUYWddXG5cbiAgICByZXR1cm4gKHNUYWcgPT09ICdCbG9iJyB8fCBzVGFnID09PSAnRmlsZScpICYmIChcbiAgICAgICgnc3RyZWFtJyBpbiBvYmplY3QgJiYgdHlwZW9mIG9iamVjdC5zdHJlYW0gPT09ICdmdW5jdGlvbicpIHx8XG4gICAgICAoJ2FycmF5QnVmZmVyJyBpbiBvYmplY3QgJiYgdHlwZW9mIG9iamVjdC5hcnJheUJ1ZmZlciA9PT0gJ2Z1bmN0aW9uJylcbiAgICApXG4gIH1cbn1cblxuZnVuY3Rpb24gYnVpbGRVUkwgKHVybCwgcXVlcnlQYXJhbXMpIHtcbiAgaWYgKHVybC5pbmNsdWRlcygnPycpIHx8IHVybC5pbmNsdWRlcygnIycpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdRdWVyeSBwYXJhbXMgY2Fubm90IGJlIHBhc3NlZCB3aGVuIHVybCBhbHJlYWR5IGNvbnRhaW5zIFwiP1wiIG9yIFwiI1wiLicpXG4gIH1cblxuICBjb25zdCBzdHJpbmdpZmllZCA9IHN0cmluZ2lmeShxdWVyeVBhcmFtcylcblxuICBpZiAoc3RyaW5naWZpZWQpIHtcbiAgICB1cmwgKz0gJz8nICsgc3RyaW5naWZpZWRcbiAgfVxuXG4gIHJldHVybiB1cmxcbn1cblxuZnVuY3Rpb24gaXNWYWxpZFBvcnQgKHBvcnQpIHtcbiAgY29uc3QgdmFsdWUgPSBwYXJzZUludChwb3J0LCAxMClcbiAgcmV0dXJuIChcbiAgICB2YWx1ZSA9PT0gTnVtYmVyKHBvcnQpICYmXG4gICAgdmFsdWUgPj0gMCAmJlxuICAgIHZhbHVlIDw9IDY1NTM1XG4gIClcbn1cblxuZnVuY3Rpb24gaXNIdHRwT3JIdHRwc1ByZWZpeGVkICh2YWx1ZSkge1xuICByZXR1cm4gKFxuICAgIHZhbHVlICE9IG51bGwgJiZcbiAgICB2YWx1ZVswXSA9PT0gJ2gnICYmXG4gICAgdmFsdWVbMV0gPT09ICd0JyAmJlxuICAgIHZhbHVlWzJdID09PSAndCcgJiZcbiAgICB2YWx1ZVszXSA9PT0gJ3AnICYmXG4gICAgKFxuICAgICAgdmFsdWVbNF0gPT09ICc6JyB8fFxuICAgICAgKFxuICAgICAgICB2YWx1ZVs0XSA9PT0gJ3MnICYmXG4gICAgICAgIHZhbHVlWzVdID09PSAnOidcbiAgICAgIClcbiAgICApXG4gIClcbn1cblxuZnVuY3Rpb24gcGFyc2VVUkwgKHVybCkge1xuICBpZiAodHlwZW9mIHVybCA9PT0gJ3N0cmluZycpIHtcbiAgICB1cmwgPSBuZXcgVVJMKHVybClcblxuICAgIGlmICghaXNIdHRwT3JIdHRwc1ByZWZpeGVkKHVybC5vcmlnaW4gfHwgdXJsLnByb3RvY29sKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdJbnZhbGlkIFVSTCBwcm90b2NvbDogdGhlIFVSTCBtdXN0IHN0YXJ0IHdpdGggYGh0dHA6YCBvciBgaHR0cHM6YC4nKVxuICAgIH1cblxuICAgIHJldHVybiB1cmxcbiAgfVxuXG4gIGlmICghdXJsIHx8IHR5cGVvZiB1cmwgIT09ICdvYmplY3QnKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdJbnZhbGlkIFVSTDogVGhlIFVSTCBhcmd1bWVudCBtdXN0IGJlIGEgbm9uLW51bGwgb2JqZWN0LicpXG4gIH1cblxuICBpZiAoISh1cmwgaW5zdGFuY2VvZiBVUkwpKSB7XG4gICAgaWYgKHVybC5wb3J0ICE9IG51bGwgJiYgdXJsLnBvcnQgIT09ICcnICYmIGlzVmFsaWRQb3J0KHVybC5wb3J0KSA9PT0gZmFsc2UpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignSW52YWxpZCBVUkw6IHBvcnQgbXVzdCBiZSBhIHZhbGlkIGludGVnZXIgb3IgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW50ZWdlci4nKVxuICAgIH1cblxuICAgIGlmICh1cmwucGF0aCAhPSBudWxsICYmIHR5cGVvZiB1cmwucGF0aCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignSW52YWxpZCBVUkwgcGF0aDogdGhlIHBhdGggbXVzdCBiZSBhIHN0cmluZyBvciBudWxsL3VuZGVmaW5lZC4nKVxuICAgIH1cblxuICAgIGlmICh1cmwucGF0aG5hbWUgIT0gbnVsbCAmJiB0eXBlb2YgdXJsLnBhdGhuYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdJbnZhbGlkIFVSTCBwYXRobmFtZTogdGhlIHBhdGhuYW1lIG11c3QgYmUgYSBzdHJpbmcgb3IgbnVsbC91bmRlZmluZWQuJylcbiAgICB9XG5cbiAgICBpZiAodXJsLmhvc3RuYW1lICE9IG51bGwgJiYgdHlwZW9mIHVybC5ob3N0bmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignSW52YWxpZCBVUkwgaG9zdG5hbWU6IHRoZSBob3N0bmFtZSBtdXN0IGJlIGEgc3RyaW5nIG9yIG51bGwvdW5kZWZpbmVkLicpXG4gICAgfVxuXG4gICAgaWYgKHVybC5vcmlnaW4gIT0gbnVsbCAmJiB0eXBlb2YgdXJsLm9yaWdpbiAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignSW52YWxpZCBVUkwgb3JpZ2luOiB0aGUgb3JpZ2luIG11c3QgYmUgYSBzdHJpbmcgb3IgbnVsbC91bmRlZmluZWQuJylcbiAgICB9XG5cbiAgICBpZiAoIWlzSHR0cE9ySHR0cHNQcmVmaXhlZCh1cmwub3JpZ2luIHx8IHVybC5wcm90b2NvbCkpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignSW52YWxpZCBVUkwgcHJvdG9jb2w6IHRoZSBVUkwgbXVzdCBzdGFydCB3aXRoIGBodHRwOmAgb3IgYGh0dHBzOmAuJylcbiAgICB9XG5cbiAgICBjb25zdCBwb3J0ID0gdXJsLnBvcnQgIT0gbnVsbFxuICAgICAgPyB1cmwucG9ydFxuICAgICAgOiAodXJsLnByb3RvY29sID09PSAnaHR0cHM6JyA/IDQ0MyA6IDgwKVxuICAgIGxldCBvcmlnaW4gPSB1cmwub3JpZ2luICE9IG51bGxcbiAgICAgID8gdXJsLm9yaWdpblxuICAgICAgOiBgJHt1cmwucHJvdG9jb2wgfHwgJyd9Ly8ke3VybC5ob3N0bmFtZSB8fCAnJ306JHtwb3J0fWBcbiAgICBsZXQgcGF0aCA9IHVybC5wYXRoICE9IG51bGxcbiAgICAgID8gdXJsLnBhdGhcbiAgICAgIDogYCR7dXJsLnBhdGhuYW1lIHx8ICcnfSR7dXJsLnNlYXJjaCB8fCAnJ31gXG5cbiAgICBpZiAob3JpZ2luW29yaWdpbi5sZW5ndGggLSAxXSA9PT0gJy8nKSB7XG4gICAgICBvcmlnaW4gPSBvcmlnaW4uc2xpY2UoMCwgb3JpZ2luLmxlbmd0aCAtIDEpXG4gICAgfVxuXG4gICAgaWYgKHBhdGggJiYgcGF0aFswXSAhPT0gJy8nKSB7XG4gICAgICBwYXRoID0gYC8ke3BhdGh9YFxuICAgIH1cbiAgICAvLyBuZXcgVVJMKHBhdGgsIG9yaWdpbikgaXMgdW5zYWZlIHdoZW4gYHBhdGhgIGNvbnRhaW5zIGFuIGFic29sdXRlIFVSTFxuICAgIC8vIEZyb20gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1VSTC9VUkw6XG4gICAgLy8gSWYgZmlyc3QgcGFyYW1ldGVyIGlzIGEgcmVsYXRpdmUgVVJMLCBzZWNvbmQgcGFyYW0gaXMgcmVxdWlyZWQsIGFuZCB3aWxsIGJlIHVzZWQgYXMgdGhlIGJhc2UgVVJMLlxuICAgIC8vIElmIGZpcnN0IHBhcmFtZXRlciBpcyBhbiBhYnNvbHV0ZSBVUkwsIGEgZ2l2ZW4gc2Vjb25kIHBhcmFtIHdpbGwgYmUgaWdub3JlZC5cbiAgICByZXR1cm4gbmV3IFVSTChgJHtvcmlnaW59JHtwYXRofWApXG4gIH1cblxuICBpZiAoIWlzSHR0cE9ySHR0cHNQcmVmaXhlZCh1cmwub3JpZ2luIHx8IHVybC5wcm90b2NvbCkpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ0ludmFsaWQgVVJMIHByb3RvY29sOiB0aGUgVVJMIG11c3Qgc3RhcnQgd2l0aCBgaHR0cDpgIG9yIGBodHRwczpgLicpXG4gIH1cblxuICByZXR1cm4gdXJsXG59XG5cbmZ1bmN0aW9uIHBhcnNlT3JpZ2luICh1cmwpIHtcbiAgdXJsID0gcGFyc2VVUkwodXJsKVxuXG4gIGlmICh1cmwucGF0aG5hbWUgIT09ICcvJyB8fCB1cmwuc2VhcmNoIHx8IHVybC5oYXNoKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIHVybCcpXG4gIH1cblxuICByZXR1cm4gdXJsXG59XG5cbmZ1bmN0aW9uIGdldEhvc3RuYW1lIChob3N0KSB7XG4gIGlmIChob3N0WzBdID09PSAnWycpIHtcbiAgICBjb25zdCBpZHggPSBob3N0LmluZGV4T2YoJ10nKVxuXG4gICAgYXNzZXJ0KGlkeCAhPT0gLTEpXG4gICAgcmV0dXJuIGhvc3Quc3Vic3RyaW5nKDEsIGlkeClcbiAgfVxuXG4gIGNvbnN0IGlkeCA9IGhvc3QuaW5kZXhPZignOicpXG4gIGlmIChpZHggPT09IC0xKSByZXR1cm4gaG9zdFxuXG4gIHJldHVybiBob3N0LnN1YnN0cmluZygwLCBpZHgpXG59XG5cbi8vIElQIGFkZHJlc3NlcyBhcmUgbm90IHZhbGlkIHNlcnZlciBuYW1lcyBwZXIgUkZDNjA2NlxuLy8gPiBDdXJyZW50bHksIHRoZSBvbmx5IHNlcnZlciBuYW1lcyBzdXBwb3J0ZWQgYXJlIEROUyBob3N0bmFtZXNcbmZ1bmN0aW9uIGdldFNlcnZlck5hbWUgKGhvc3QpIHtcbiAgaWYgKCFob3N0KSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIGFzc2VydC5zdHJpY3RFcXVhbCh0eXBlb2YgaG9zdCwgJ3N0cmluZycpXG5cbiAgY29uc3Qgc2VydmVybmFtZSA9IGdldEhvc3RuYW1lKGhvc3QpXG4gIGlmIChuZXQuaXNJUChzZXJ2ZXJuYW1lKSkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgcmV0dXJuIHNlcnZlcm5hbWVcbn1cblxuZnVuY3Rpb24gZGVlcENsb25lIChvYmopIHtcbiAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob2JqKSlcbn1cblxuZnVuY3Rpb24gaXNBc3luY0l0ZXJhYmxlIChvYmopIHtcbiAgcmV0dXJuICEhKG9iaiAhPSBudWxsICYmIHR5cGVvZiBvYmpbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID09PSAnZnVuY3Rpb24nKVxufVxuXG5mdW5jdGlvbiBpc0l0ZXJhYmxlIChvYmopIHtcbiAgcmV0dXJuICEhKG9iaiAhPSBudWxsICYmICh0eXBlb2Ygb2JqW1N5bWJvbC5pdGVyYXRvcl0gPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIG9ialtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPT09ICdmdW5jdGlvbicpKVxufVxuXG5mdW5jdGlvbiBib2R5TGVuZ3RoIChib2R5KSB7XG4gIGlmIChib2R5ID09IG51bGwpIHtcbiAgICByZXR1cm4gMFxuICB9IGVsc2UgaWYgKGlzU3RyZWFtKGJvZHkpKSB7XG4gICAgY29uc3Qgc3RhdGUgPSBib2R5Ll9yZWFkYWJsZVN0YXRlXG4gICAgcmV0dXJuIHN0YXRlICYmIHN0YXRlLm9iamVjdE1vZGUgPT09IGZhbHNlICYmIHN0YXRlLmVuZGVkID09PSB0cnVlICYmIE51bWJlci5pc0Zpbml0ZShzdGF0ZS5sZW5ndGgpXG4gICAgICA/IHN0YXRlLmxlbmd0aFxuICAgICAgOiBudWxsXG4gIH0gZWxzZSBpZiAoaXNCbG9iTGlrZShib2R5KSkge1xuICAgIHJldHVybiBib2R5LnNpemUgIT0gbnVsbCA/IGJvZHkuc2l6ZSA6IG51bGxcbiAgfSBlbHNlIGlmIChpc0J1ZmZlcihib2R5KSkge1xuICAgIHJldHVybiBib2R5LmJ5dGVMZW5ndGhcbiAgfVxuXG4gIHJldHVybiBudWxsXG59XG5cbmZ1bmN0aW9uIGlzRGVzdHJveWVkIChib2R5KSB7XG4gIHJldHVybiBib2R5ICYmICEhKGJvZHkuZGVzdHJveWVkIHx8IGJvZHlba0Rlc3Ryb3llZF0gfHwgKHN0cmVhbS5pc0Rlc3Ryb3llZD8uKGJvZHkpKSlcbn1cblxuZnVuY3Rpb24gZGVzdHJveSAoc3RyZWFtLCBlcnIpIHtcbiAgaWYgKHN0cmVhbSA9PSBudWxsIHx8ICFpc1N0cmVhbShzdHJlYW0pIHx8IGlzRGVzdHJveWVkKHN0cmVhbSkpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGlmICh0eXBlb2Ygc3RyZWFtLmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAoT2JqZWN0LmdldFByb3RvdHlwZU9mKHN0cmVhbSkuY29uc3RydWN0b3IgPT09IEluY29taW5nTWVzc2FnZSkge1xuICAgICAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvcHVsbC8zODUwNS9maWxlc1xuICAgICAgc3RyZWFtLnNvY2tldCA9IG51bGxcbiAgICB9XG5cbiAgICBzdHJlYW0uZGVzdHJveShlcnIpXG4gIH0gZWxzZSBpZiAoZXJyKSB7XG4gICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXJyKVxuICAgIH0pXG4gIH1cblxuICBpZiAoc3RyZWFtLmRlc3Ryb3llZCAhPT0gdHJ1ZSkge1xuICAgIHN0cmVhbVtrRGVzdHJveWVkXSA9IHRydWVcbiAgfVxufVxuXG5jb25zdCBLRUVQQUxJVkVfVElNRU9VVF9FWFBSID0gL3RpbWVvdXQ9KFxcZCspL1xuZnVuY3Rpb24gcGFyc2VLZWVwQWxpdmVUaW1lb3V0ICh2YWwpIHtcbiAgY29uc3QgbSA9IHZhbC50b1N0cmluZygpLm1hdGNoKEtFRVBBTElWRV9USU1FT1VUX0VYUFIpXG4gIHJldHVybiBtID8gcGFyc2VJbnQobVsxXSwgMTApICogMTAwMCA6IG51bGxcbn1cblxuLyoqXG4gKiBSZXRyaWV2ZXMgYSBoZWFkZXIgbmFtZSBhbmQgcmV0dXJucyBpdHMgbG93ZXJjYXNlIHZhbHVlLlxuICogQHBhcmFtIHtzdHJpbmcgfCBCdWZmZXJ9IHZhbHVlIEhlYWRlciBuYW1lXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBoZWFkZXJOYW1lVG9TdHJpbmcgKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnXG4gICAgPyBoZWFkZXJOYW1lTG93ZXJDYXNlZFJlY29yZFt2YWx1ZV0gPz8gdmFsdWUudG9Mb3dlckNhc2UoKVxuICAgIDogdHJlZS5sb29rdXAodmFsdWUpID8/IHZhbHVlLnRvU3RyaW5nKCdsYXRpbjEnKS50b0xvd2VyQ2FzZSgpXG59XG5cbi8qKlxuICogUmVjZWl2ZSB0aGUgYnVmZmVyIGFzIGEgc3RyaW5nIGFuZCByZXR1cm4gaXRzIGxvd2VyY2FzZSB2YWx1ZS5cbiAqIEBwYXJhbSB7QnVmZmVyfSB2YWx1ZSBIZWFkZXIgbmFtZVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gYnVmZmVyVG9Mb3dlckNhc2VkSGVhZGVyTmFtZSAodmFsdWUpIHtcbiAgcmV0dXJuIHRyZWUubG9va3VwKHZhbHVlKSA/PyB2YWx1ZS50b1N0cmluZygnbGF0aW4xJykudG9Mb3dlckNhc2UoKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgc3RyaW5nIHwgc3RyaW5nW10+IHwgKEJ1ZmZlciB8IHN0cmluZyB8IChCdWZmZXIgfCBzdHJpbmcpW10pW119IGhlYWRlcnNcbiAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgc3RyaW5nIHwgc3RyaW5nW10+fSBbb2JqXVxuICogQHJldHVybnMge1JlY29yZDxzdHJpbmcsIHN0cmluZyB8IHN0cmluZ1tdPn1cbiAqL1xuZnVuY3Rpb24gcGFyc2VIZWFkZXJzIChoZWFkZXJzLCBvYmopIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSBvYmogPSB7fVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGhlYWRlcnMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICBjb25zdCBrZXkgPSBoZWFkZXJOYW1lVG9TdHJpbmcoaGVhZGVyc1tpXSlcbiAgICBsZXQgdmFsID0gb2JqW2tleV1cblxuICAgIGlmICh2YWwpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgICAgICB2YWwgPSBbdmFsXVxuICAgICAgICBvYmpba2V5XSA9IHZhbFxuICAgICAgfVxuICAgICAgdmFsLnB1c2goaGVhZGVyc1tpICsgMV0udG9TdHJpbmcoJ3V0ZjgnKSlcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgaGVhZGVyc1ZhbHVlID0gaGVhZGVyc1tpICsgMV1cbiAgICAgIGlmICh0eXBlb2YgaGVhZGVyc1ZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICBvYmpba2V5XSA9IGhlYWRlcnNWYWx1ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2JqW2tleV0gPSBBcnJheS5pc0FycmF5KGhlYWRlcnNWYWx1ZSkgPyBoZWFkZXJzVmFsdWUubWFwKHggPT4geC50b1N0cmluZygndXRmOCcpKSA6IGhlYWRlcnNWYWx1ZS50b1N0cmluZygndXRmOCcpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9wdWxsLzQ2NTI4XG4gIGlmICgnY29udGVudC1sZW5ndGgnIGluIG9iaiAmJiAnY29udGVudC1kaXNwb3NpdGlvbicgaW4gb2JqKSB7XG4gICAgb2JqWydjb250ZW50LWRpc3Bvc2l0aW9uJ10gPSBCdWZmZXIuZnJvbShvYmpbJ2NvbnRlbnQtZGlzcG9zaXRpb24nXSkudG9TdHJpbmcoJ2xhdGluMScpXG4gIH1cblxuICByZXR1cm4gb2JqXG59XG5cbmZ1bmN0aW9uIHBhcnNlUmF3SGVhZGVycyAoaGVhZGVycykge1xuICBjb25zdCBsZW4gPSBoZWFkZXJzLmxlbmd0aFxuICBjb25zdCByZXQgPSBuZXcgQXJyYXkobGVuKVxuXG4gIGxldCBoYXNDb250ZW50TGVuZ3RoID0gZmFsc2VcbiAgbGV0IGNvbnRlbnREaXNwb3NpdGlvbklkeCA9IC0xXG4gIGxldCBrZXlcbiAgbGV0IHZhbFxuICBsZXQga0xlbiA9IDBcblxuICBmb3IgKGxldCBuID0gMDsgbiA8IGhlYWRlcnMubGVuZ3RoOyBuICs9IDIpIHtcbiAgICBrZXkgPSBoZWFkZXJzW25dXG4gICAgdmFsID0gaGVhZGVyc1tuICsgMV1cblxuICAgIHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnICYmIChrZXkgPSBrZXkudG9TdHJpbmcoKSlcbiAgICB0eXBlb2YgdmFsICE9PSAnc3RyaW5nJyAmJiAodmFsID0gdmFsLnRvU3RyaW5nKCd1dGY4JykpXG5cbiAgICBrTGVuID0ga2V5Lmxlbmd0aFxuICAgIGlmIChrTGVuID09PSAxNCAmJiBrZXlbN10gPT09ICctJyAmJiAoa2V5ID09PSAnY29udGVudC1sZW5ndGgnIHx8IGtleS50b0xvd2VyQ2FzZSgpID09PSAnY29udGVudC1sZW5ndGgnKSkge1xuICAgICAgaGFzQ29udGVudExlbmd0aCA9IHRydWVcbiAgICB9IGVsc2UgaWYgKGtMZW4gPT09IDE5ICYmIGtleVs3XSA9PT0gJy0nICYmIChrZXkgPT09ICdjb250ZW50LWRpc3Bvc2l0aW9uJyB8fCBrZXkudG9Mb3dlckNhc2UoKSA9PT0gJ2NvbnRlbnQtZGlzcG9zaXRpb24nKSkge1xuICAgICAgY29udGVudERpc3Bvc2l0aW9uSWR4ID0gbiArIDFcbiAgICB9XG4gICAgcmV0W25dID0ga2V5XG4gICAgcmV0W24gKyAxXSA9IHZhbFxuICB9XG5cbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9wdWxsLzQ2NTI4XG4gIGlmIChoYXNDb250ZW50TGVuZ3RoICYmIGNvbnRlbnREaXNwb3NpdGlvbklkeCAhPT0gLTEpIHtcbiAgICByZXRbY29udGVudERpc3Bvc2l0aW9uSWR4XSA9IEJ1ZmZlci5mcm9tKHJldFtjb250ZW50RGlzcG9zaXRpb25JZHhdKS50b1N0cmluZygnbGF0aW4xJylcbiAgfVxuXG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gaXNCdWZmZXIgKGJ1ZmZlcikge1xuICAvLyBTZWUsIGh0dHBzOi8vZ2l0aHViLmNvbS9tY29sbGluYS91bmRpY2kvcHVsbC8zMTlcbiAgcmV0dXJuIGJ1ZmZlciBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgfHwgQnVmZmVyLmlzQnVmZmVyKGJ1ZmZlcilcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVIYW5kbGVyIChoYW5kbGVyLCBtZXRob2QsIHVwZ3JhZGUpIHtcbiAgaWYgKCFoYW5kbGVyIHx8IHR5cGVvZiBoYW5kbGVyICE9PSAnb2JqZWN0Jykge1xuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaGFuZGxlciBtdXN0IGJlIGFuIG9iamVjdCcpXG4gIH1cblxuICBpZiAodHlwZW9mIGhhbmRsZXIub25Db25uZWN0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIG9uQ29ubmVjdCBtZXRob2QnKVxuICB9XG5cbiAgaWYgKHR5cGVvZiBoYW5kbGVyLm9uRXJyb3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgb25FcnJvciBtZXRob2QnKVxuICB9XG5cbiAgaWYgKHR5cGVvZiBoYW5kbGVyLm9uQm9keVNlbnQgIT09ICdmdW5jdGlvbicgJiYgaGFuZGxlci5vbkJvZHlTZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgb25Cb2R5U2VudCBtZXRob2QnKVxuICB9XG5cbiAgaWYgKHVwZ3JhZGUgfHwgbWV0aG9kID09PSAnQ09OTkVDVCcpIHtcbiAgICBpZiAodHlwZW9mIGhhbmRsZXIub25VcGdyYWRlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgb25VcGdyYWRlIG1ldGhvZCcpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICh0eXBlb2YgaGFuZGxlci5vbkhlYWRlcnMgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBvbkhlYWRlcnMgbWV0aG9kJylcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGhhbmRsZXIub25EYXRhICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgb25EYXRhIG1ldGhvZCcpXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBoYW5kbGVyLm9uQ29tcGxldGUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBvbkNvbXBsZXRlIG1ldGhvZCcpXG4gICAgfVxuICB9XG59XG5cbi8vIEEgYm9keSBpcyBkaXN0dXJiZWQgaWYgaXQgaGFzIGJlZW4gcmVhZCBmcm9tIGFuZCBpdCBjYW5ub3Rcbi8vIGJlIHJlLXVzZWQgd2l0aG91dCBsb3Npbmcgc3RhdGUgb3IgZGF0YS5cbmZ1bmN0aW9uIGlzRGlzdHVyYmVkIChib2R5KSB7XG4gIC8vIFRPRE8gKGZpeCk6IFdoeSBpcyBib2R5W2tCb2R5VXNlZF0gbmVlZGVkP1xuICByZXR1cm4gISEoYm9keSAmJiAoc3RyZWFtLmlzRGlzdHVyYmVkKGJvZHkpIHx8IGJvZHlba0JvZHlVc2VkXSkpXG59XG5cbmZ1bmN0aW9uIGlzRXJyb3JlZCAoYm9keSkge1xuICByZXR1cm4gISEoYm9keSAmJiBzdHJlYW0uaXNFcnJvcmVkKGJvZHkpKVxufVxuXG5mdW5jdGlvbiBpc1JlYWRhYmxlIChib2R5KSB7XG4gIHJldHVybiAhIShib2R5ICYmIHN0cmVhbS5pc1JlYWRhYmxlKGJvZHkpKVxufVxuXG5mdW5jdGlvbiBnZXRTb2NrZXRJbmZvIChzb2NrZXQpIHtcbiAgcmV0dXJuIHtcbiAgICBsb2NhbEFkZHJlc3M6IHNvY2tldC5sb2NhbEFkZHJlc3MsXG4gICAgbG9jYWxQb3J0OiBzb2NrZXQubG9jYWxQb3J0LFxuICAgIHJlbW90ZUFkZHJlc3M6IHNvY2tldC5yZW1vdGVBZGRyZXNzLFxuICAgIHJlbW90ZVBvcnQ6IHNvY2tldC5yZW1vdGVQb3J0LFxuICAgIHJlbW90ZUZhbWlseTogc29ja2V0LnJlbW90ZUZhbWlseSxcbiAgICB0aW1lb3V0OiBzb2NrZXQudGltZW91dCxcbiAgICBieXRlc1dyaXR0ZW46IHNvY2tldC5ieXRlc1dyaXR0ZW4sXG4gICAgYnl0ZXNSZWFkOiBzb2NrZXQuYnl0ZXNSZWFkXG4gIH1cbn1cblxuLyoqIEB0eXBlIHtnbG9iYWxUaGlzWydSZWFkYWJsZVN0cmVhbSddfSAqL1xuZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1Gcm9tIChpdGVyYWJsZSkge1xuICAvLyBXZSBjYW5ub3QgdXNlIFJlYWRhYmxlU3RyZWFtLmZyb20gaGVyZSBiZWNhdXNlIGl0IGRvZXMgbm90IHJldHVybiBhIGJ5dGUgc3RyZWFtLlxuXG4gIGxldCBpdGVyYXRvclxuICByZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtKFxuICAgIHtcbiAgICAgIGFzeW5jIHN0YXJ0ICgpIHtcbiAgICAgICAgaXRlcmF0b3IgPSBpdGVyYWJsZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKVxuICAgICAgfSxcbiAgICAgIGFzeW5jIHB1bGwgKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgaXRlcmF0b3IubmV4dCgpXG4gICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgICAgICAgY29udHJvbGxlci5jbG9zZSgpXG4gICAgICAgICAgICBjb250cm9sbGVyLmJ5b2JSZXF1ZXN0Py5yZXNwb25kKDApXG4gICAgICAgICAgfSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBidWYgPSBCdWZmZXIuaXNCdWZmZXIodmFsdWUpID8gdmFsdWUgOiBCdWZmZXIuZnJvbSh2YWx1ZSlcbiAgICAgICAgICBpZiAoYnVmLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShuZXcgVWludDhBcnJheShidWYpKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29udHJvbGxlci5kZXNpcmVkU2l6ZSA+IDBcbiAgICAgIH0sXG4gICAgICBhc3luYyBjYW5jZWwgKHJlYXNvbikge1xuICAgICAgICBhd2FpdCBpdGVyYXRvci5yZXR1cm4oKVxuICAgICAgfSxcbiAgICAgIHR5cGU6ICdieXRlcydcbiAgICB9XG4gIClcbn1cblxuLy8gVGhlIGNodW5rIHNob3VsZCBiZSBhIEZvcm1EYXRhIGluc3RhbmNlIGFuZCBjb250YWluc1xuLy8gYWxsIHRoZSByZXF1aXJlZCBtZXRob2RzLlxuZnVuY3Rpb24gaXNGb3JtRGF0YUxpa2UgKG9iamVjdCkge1xuICByZXR1cm4gKFxuICAgIG9iamVjdCAmJlxuICAgIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmXG4gICAgdHlwZW9mIG9iamVjdC5hcHBlbmQgPT09ICdmdW5jdGlvbicgJiZcbiAgICB0eXBlb2Ygb2JqZWN0LmRlbGV0ZSA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIHR5cGVvZiBvYmplY3QuZ2V0ID09PSAnZnVuY3Rpb24nICYmXG4gICAgdHlwZW9mIG9iamVjdC5nZXRBbGwgPT09ICdmdW5jdGlvbicgJiZcbiAgICB0eXBlb2Ygb2JqZWN0LmhhcyA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIHR5cGVvZiBvYmplY3Quc2V0ID09PSAnZnVuY3Rpb24nICYmXG4gICAgb2JqZWN0W1N5bWJvbC50b1N0cmluZ1RhZ10gPT09ICdGb3JtRGF0YSdcbiAgKVxufVxuXG5mdW5jdGlvbiBhZGRBYm9ydExpc3RlbmVyIChzaWduYWwsIGxpc3RlbmVyKSB7XG4gIGlmICgnYWRkRXZlbnRMaXN0ZW5lcicgaW4gc2lnbmFsKSB7XG4gICAgc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgbGlzdGVuZXIsIHsgb25jZTogdHJ1ZSB9KVxuICAgIHJldHVybiAoKSA9PiBzaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBsaXN0ZW5lcilcbiAgfVxuICBzaWduYWwuYWRkTGlzdGVuZXIoJ2Fib3J0JywgbGlzdGVuZXIpXG4gIHJldHVybiAoKSA9PiBzaWduYWwucmVtb3ZlTGlzdGVuZXIoJ2Fib3J0JywgbGlzdGVuZXIpXG59XG5cbmNvbnN0IGhhc1RvV2VsbEZvcm1lZCA9IHR5cGVvZiBTdHJpbmcucHJvdG90eXBlLnRvV2VsbEZvcm1lZCA9PT0gJ2Z1bmN0aW9uJ1xuY29uc3QgaGFzSXNXZWxsRm9ybWVkID0gdHlwZW9mIFN0cmluZy5wcm90b3R5cGUuaXNXZWxsRm9ybWVkID09PSAnZnVuY3Rpb24nXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbFxuICovXG5mdW5jdGlvbiB0b1VTVlN0cmluZyAodmFsKSB7XG4gIHJldHVybiBoYXNUb1dlbGxGb3JtZWQgPyBgJHt2YWx9YC50b1dlbGxGb3JtZWQoKSA6IG5vZGVVdGlsLnRvVVNWU3RyaW5nKHZhbClcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsXG4gKi9cbi8vIFRPRE86IG1vdmUgdGhpcyB0byB3ZWJpZGxcbmZ1bmN0aW9uIGlzVVNWU3RyaW5nICh2YWwpIHtcbiAgcmV0dXJuIGhhc0lzV2VsbEZvcm1lZCA/IGAke3ZhbH1gLmlzV2VsbEZvcm1lZCgpIDogdG9VU1ZTdHJpbmcodmFsKSA9PT0gYCR7dmFsfWBcbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3MjMwI3NlY3Rpb24tMy4yLjZcbiAqIEBwYXJhbSB7bnVtYmVyfSBjXG4gKi9cbmZ1bmN0aW9uIGlzVG9rZW5DaGFyQ29kZSAoYykge1xuICBzd2l0Y2ggKGMpIHtcbiAgICBjYXNlIDB4MjI6XG4gICAgY2FzZSAweDI4OlxuICAgIGNhc2UgMHgyOTpcbiAgICBjYXNlIDB4MmM6XG4gICAgY2FzZSAweDJmOlxuICAgIGNhc2UgMHgzYTpcbiAgICBjYXNlIDB4M2I6XG4gICAgY2FzZSAweDNjOlxuICAgIGNhc2UgMHgzZDpcbiAgICBjYXNlIDB4M2U6XG4gICAgY2FzZSAweDNmOlxuICAgIGNhc2UgMHg0MDpcbiAgICBjYXNlIDB4NWI6XG4gICAgY2FzZSAweDVjOlxuICAgIGNhc2UgMHg1ZDpcbiAgICBjYXNlIDB4N2I6XG4gICAgY2FzZSAweDdkOlxuICAgICAgLy8gRFFVT1RFIGFuZCBcIigpLC86Ozw9Pj9AW1xcXXt9XCJcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIGRlZmF1bHQ6XG4gICAgICAvLyBWQ0hBUiAleDIxLTdFXG4gICAgICByZXR1cm4gYyA+PSAweDIxICYmIGMgPD0gMHg3ZVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGNoYXJhY3RlcnNcbiAqL1xuZnVuY3Rpb24gaXNWYWxpZEhUVFBUb2tlbiAoY2hhcmFjdGVycykge1xuICBpZiAoY2hhcmFjdGVycy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGNoYXJhY3RlcnMubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoIWlzVG9rZW5DaGFyQ29kZShjaGFyYWN0ZXJzLmNoYXJDb2RlQXQoaSkpKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxuLy8gaGVhZGVyQ2hhclJlZ2V4IGhhdmUgYmVlbiBsaWZ0ZWQgZnJvbVxuLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvbWFpbi9saWIvX2h0dHBfY29tbW9uLmpzXG5cbi8qKlxuICogTWF0Y2hlcyBpZiB2YWwgY29udGFpbnMgYW4gaW52YWxpZCBmaWVsZC12Y2hhclxuICogIGZpZWxkLXZhbHVlICAgID0gKiggZmllbGQtY29udGVudCAvIG9icy1mb2xkIClcbiAqICBmaWVsZC1jb250ZW50ICA9IGZpZWxkLXZjaGFyIFsgMSooIFNQIC8gSFRBQiApIGZpZWxkLXZjaGFyIF1cbiAqICBmaWVsZC12Y2hhciAgICA9IFZDSEFSIC8gb2JzLXRleHRcbiAqL1xuY29uc3QgaGVhZGVyQ2hhclJlZ2V4ID0gL1teXFx0XFx4MjAtXFx4N2VcXHg4MC1cXHhmZl0vXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGNoYXJhY3RlcnNcbiAqL1xuZnVuY3Rpb24gaXNWYWxpZEhlYWRlclZhbHVlIChjaGFyYWN0ZXJzKSB7XG4gIHJldHVybiAhaGVhZGVyQ2hhclJlZ2V4LnRlc3QoY2hhcmFjdGVycylcbn1cblxuLy8gUGFyc2VkIGFjY29yZGluZ2x5IHRvIFJGQyA5MTEwXG4vLyBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTExMCNmaWVsZC5jb250ZW50LXJhbmdlXG5mdW5jdGlvbiBwYXJzZVJhbmdlSGVhZGVyIChyYW5nZSkge1xuICBpZiAocmFuZ2UgPT0gbnVsbCB8fCByYW5nZSA9PT0gJycpIHJldHVybiB7IHN0YXJ0OiAwLCBlbmQ6IG51bGwsIHNpemU6IG51bGwgfVxuXG4gIGNvbnN0IG0gPSByYW5nZSA/IHJhbmdlLm1hdGNoKC9eYnl0ZXMgKFxcZCspLShcXGQrKVxcLyhcXGQrKT8kLykgOiBudWxsXG4gIHJldHVybiBtXG4gICAgPyB7XG4gICAgICAgIHN0YXJ0OiBwYXJzZUludChtWzFdKSxcbiAgICAgICAgZW5kOiBtWzJdID8gcGFyc2VJbnQobVsyXSkgOiBudWxsLFxuICAgICAgICBzaXplOiBtWzNdID8gcGFyc2VJbnQobVszXSkgOiBudWxsXG4gICAgICB9XG4gICAgOiBudWxsXG59XG5cbmZ1bmN0aW9uIGFkZExpc3RlbmVyIChvYmosIG5hbWUsIGxpc3RlbmVyKSB7XG4gIGNvbnN0IGxpc3RlbmVycyA9IChvYmpba0xpc3RlbmVyc10gPz89IFtdKVxuICBsaXN0ZW5lcnMucHVzaChbbmFtZSwgbGlzdGVuZXJdKVxuICBvYmoub24obmFtZSwgbGlzdGVuZXIpXG4gIHJldHVybiBvYmpcbn1cblxuZnVuY3Rpb24gcmVtb3ZlQWxsTGlzdGVuZXJzIChvYmopIHtcbiAgZm9yIChjb25zdCBbbmFtZSwgbGlzdGVuZXJdIG9mIG9ialtrTGlzdGVuZXJzXSA/PyBbXSkge1xuICAgIG9iai5yZW1vdmVMaXN0ZW5lcihuYW1lLCBsaXN0ZW5lcilcbiAgfVxuICBvYmpba0xpc3RlbmVyc10gPSBudWxsXG59XG5cbmZ1bmN0aW9uIGVycm9yUmVxdWVzdCAoY2xpZW50LCByZXF1ZXN0LCBlcnIpIHtcbiAgdHJ5IHtcbiAgICByZXF1ZXN0Lm9uRXJyb3IoZXJyKVxuICAgIGFzc2VydChyZXF1ZXN0LmFib3J0ZWQpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNsaWVudC5lbWl0KCdlcnJvcicsIGVycilcbiAgfVxufVxuXG5jb25zdCBrRW51bWVyYWJsZVByb3BlcnR5ID0gT2JqZWN0LmNyZWF0ZShudWxsKVxua0VudW1lcmFibGVQcm9wZXJ0eS5lbnVtZXJhYmxlID0gdHJ1ZVxuXG5jb25zdCBub3JtYWxpemVkTWV0aG9kUmVjb3Jkc0Jhc2UgPSB7XG4gIGRlbGV0ZTogJ0RFTEVURScsXG4gIERFTEVURTogJ0RFTEVURScsXG4gIGdldDogJ0dFVCcsXG4gIEdFVDogJ0dFVCcsXG4gIGhlYWQ6ICdIRUFEJyxcbiAgSEVBRDogJ0hFQUQnLFxuICBvcHRpb25zOiAnT1BUSU9OUycsXG4gIE9QVElPTlM6ICdPUFRJT05TJyxcbiAgcG9zdDogJ1BPU1QnLFxuICBQT1NUOiAnUE9TVCcsXG4gIHB1dDogJ1BVVCcsXG4gIFBVVDogJ1BVVCdcbn1cblxuY29uc3Qgbm9ybWFsaXplZE1ldGhvZFJlY29yZHMgPSB7XG4gIC4uLm5vcm1hbGl6ZWRNZXRob2RSZWNvcmRzQmFzZSxcbiAgcGF0Y2g6ICdwYXRjaCcsXG4gIFBBVENIOiAnUEFUQ0gnXG59XG5cbi8vIE5vdGU6IG9iamVjdCBwcm90b3R5cGVzIHNob3VsZCBub3QgYmUgYWJsZSB0byBiZSByZWZlcmVuY2VkLiBlLmcuIGBPYmplY3QjaGFzT3duUHJvcGVydHlgLlxuT2JqZWN0LnNldFByb3RvdHlwZU9mKG5vcm1hbGl6ZWRNZXRob2RSZWNvcmRzQmFzZSwgbnVsbClcbk9iamVjdC5zZXRQcm90b3R5cGVPZihub3JtYWxpemVkTWV0aG9kUmVjb3JkcywgbnVsbClcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIG5vcCxcbiAgaXNEaXN0dXJiZWQsXG4gIGlzRXJyb3JlZCxcbiAgaXNSZWFkYWJsZSxcbiAgdG9VU1ZTdHJpbmcsXG4gIGlzVVNWU3RyaW5nLFxuICBpc0Jsb2JMaWtlLFxuICBwYXJzZU9yaWdpbixcbiAgcGFyc2VVUkwsXG4gIGdldFNlcnZlck5hbWUsXG4gIGlzU3RyZWFtLFxuICBpc0l0ZXJhYmxlLFxuICBpc0FzeW5jSXRlcmFibGUsXG4gIGlzRGVzdHJveWVkLFxuICBoZWFkZXJOYW1lVG9TdHJpbmcsXG4gIGJ1ZmZlclRvTG93ZXJDYXNlZEhlYWRlck5hbWUsXG4gIGFkZExpc3RlbmVyLFxuICByZW1vdmVBbGxMaXN0ZW5lcnMsXG4gIGVycm9yUmVxdWVzdCxcbiAgcGFyc2VSYXdIZWFkZXJzLFxuICBwYXJzZUhlYWRlcnMsXG4gIHBhcnNlS2VlcEFsaXZlVGltZW91dCxcbiAgZGVzdHJveSxcbiAgYm9keUxlbmd0aCxcbiAgZGVlcENsb25lLFxuICBSZWFkYWJsZVN0cmVhbUZyb20sXG4gIGlzQnVmZmVyLFxuICB2YWxpZGF0ZUhhbmRsZXIsXG4gIGdldFNvY2tldEluZm8sXG4gIGlzRm9ybURhdGFMaWtlLFxuICBidWlsZFVSTCxcbiAgYWRkQWJvcnRMaXN0ZW5lcixcbiAgaXNWYWxpZEhUVFBUb2tlbixcbiAgaXNWYWxpZEhlYWRlclZhbHVlLFxuICBpc1Rva2VuQ2hhckNvZGUsXG4gIHBhcnNlUmFuZ2VIZWFkZXIsXG4gIG5vcm1hbGl6ZWRNZXRob2RSZWNvcmRzQmFzZSxcbiAgbm9ybWFsaXplZE1ldGhvZFJlY29yZHMsXG4gIGlzVmFsaWRQb3J0LFxuICBpc0h0dHBPckh0dHBzUHJlZml4ZWQsXG4gIG5vZGVNYWpvcixcbiAgbm9kZU1pbm9yLFxuICBzYWZlSFRUUE1ldGhvZHM6IFsnR0VUJywgJ0hFQUQnLCAnT1BUSU9OUycsICdUUkFDRSddLFxuICB3cmFwUmVxdWVzdEJvZHlcbn1cbiJdLCJuYW1lcyI6WyJhc3NlcnQiLCJyZXF1aXJlIiwia0Rlc3Ryb3llZCIsImtCb2R5VXNlZCIsImtMaXN0ZW5lcnMiLCJrQm9keSIsIkluY29taW5nTWVzc2FnZSIsInN0cmVhbSIsIm5ldCIsIkJsb2IiLCJub2RlVXRpbCIsInN0cmluZ2lmeSIsIkV2ZW50RW1pdHRlciIsIkVFIiwiSW52YWxpZEFyZ3VtZW50RXJyb3IiLCJoZWFkZXJOYW1lTG93ZXJDYXNlZFJlY29yZCIsInRyZWUiLCJub2RlTWFqb3IiLCJub2RlTWlub3IiLCJwcm9jZXNzIiwidmVyc2lvbnMiLCJub2RlIiwic3BsaXQiLCJtYXAiLCJ2IiwiTnVtYmVyIiwiQm9keUFzeW5jSXRlcmFibGUiLCJjb25zdHJ1Y3RvciIsImJvZHkiLCJTeW1ib2wiLCJhc3luY0l0ZXJhdG9yIiwid3JhcFJlcXVlc3RCb2R5IiwiaXNTdHJlYW0iLCJib2R5TGVuZ3RoIiwib24iLCJyZWFkYWJsZURpZFJlYWQiLCJwcm90b3R5cGUiLCJjYWxsIiwicGlwZVRvIiwiQXJyYXlCdWZmZXIiLCJpc1ZpZXciLCJpc0l0ZXJhYmxlIiwibm9wIiwib2JqIiwicGlwZSIsImlzQmxvYkxpa2UiLCJvYmplY3QiLCJzVGFnIiwidG9TdHJpbmdUYWciLCJhcnJheUJ1ZmZlciIsImJ1aWxkVVJMIiwidXJsIiwicXVlcnlQYXJhbXMiLCJpbmNsdWRlcyIsIkVycm9yIiwic3RyaW5naWZpZWQiLCJpc1ZhbGlkUG9ydCIsInBvcnQiLCJ2YWx1ZSIsInBhcnNlSW50IiwiaXNIdHRwT3JIdHRwc1ByZWZpeGVkIiwicGFyc2VVUkwiLCJVUkwiLCJvcmlnaW4iLCJwcm90b2NvbCIsInBhdGgiLCJwYXRobmFtZSIsImhvc3RuYW1lIiwic2VhcmNoIiwibGVuZ3RoIiwic2xpY2UiLCJwYXJzZU9yaWdpbiIsImhhc2giLCJnZXRIb3N0bmFtZSIsImhvc3QiLCJpZHgiLCJpbmRleE9mIiwic3Vic3RyaW5nIiwiZ2V0U2VydmVyTmFtZSIsInN0cmljdEVxdWFsIiwic2VydmVybmFtZSIsImlzSVAiLCJkZWVwQ2xvbmUiLCJKU09OIiwicGFyc2UiLCJpc0FzeW5jSXRlcmFibGUiLCJpdGVyYXRvciIsInN0YXRlIiwiX3JlYWRhYmxlU3RhdGUiLCJvYmplY3RNb2RlIiwiZW5kZWQiLCJpc0Zpbml0ZSIsInNpemUiLCJpc0J1ZmZlciIsImJ5dGVMZW5ndGgiLCJpc0Rlc3Ryb3llZCIsImRlc3Ryb3llZCIsImRlc3Ryb3kiLCJlcnIiLCJPYmplY3QiLCJnZXRQcm90b3R5cGVPZiIsInNvY2tldCIsInF1ZXVlTWljcm90YXNrIiwiZW1pdCIsIktFRVBBTElWRV9USU1FT1VUX0VYUFIiLCJwYXJzZUtlZXBBbGl2ZVRpbWVvdXQiLCJ2YWwiLCJtIiwidG9TdHJpbmciLCJtYXRjaCIsImhlYWRlck5hbWVUb1N0cmluZyIsInRvTG93ZXJDYXNlIiwibG9va3VwIiwiYnVmZmVyVG9Mb3dlckNhc2VkSGVhZGVyTmFtZSIsInBhcnNlSGVhZGVycyIsImhlYWRlcnMiLCJ1bmRlZmluZWQiLCJpIiwia2V5IiwicHVzaCIsImhlYWRlcnNWYWx1ZSIsIkFycmF5IiwiaXNBcnJheSIsIngiLCJCdWZmZXIiLCJmcm9tIiwicGFyc2VSYXdIZWFkZXJzIiwibGVuIiwicmV0IiwiaGFzQ29udGVudExlbmd0aCIsImNvbnRlbnREaXNwb3NpdGlvbklkeCIsImtMZW4iLCJuIiwiYnVmZmVyIiwiVWludDhBcnJheSIsInZhbGlkYXRlSGFuZGxlciIsImhhbmRsZXIiLCJtZXRob2QiLCJ1cGdyYWRlIiwib25Db25uZWN0Iiwib25FcnJvciIsIm9uQm9keVNlbnQiLCJvblVwZ3JhZGUiLCJvbkhlYWRlcnMiLCJvbkRhdGEiLCJvbkNvbXBsZXRlIiwiaXNEaXN0dXJiZWQiLCJpc0Vycm9yZWQiLCJpc1JlYWRhYmxlIiwiZ2V0U29ja2V0SW5mbyIsImxvY2FsQWRkcmVzcyIsImxvY2FsUG9ydCIsInJlbW90ZUFkZHJlc3MiLCJyZW1vdGVQb3J0IiwicmVtb3RlRmFtaWx5IiwidGltZW91dCIsImJ5dGVzV3JpdHRlbiIsImJ5dGVzUmVhZCIsIlJlYWRhYmxlU3RyZWFtRnJvbSIsIml0ZXJhYmxlIiwiUmVhZGFibGVTdHJlYW0iLCJzdGFydCIsInB1bGwiLCJjb250cm9sbGVyIiwiZG9uZSIsIm5leHQiLCJjbG9zZSIsImJ5b2JSZXF1ZXN0IiwicmVzcG9uZCIsImJ1ZiIsImVucXVldWUiLCJkZXNpcmVkU2l6ZSIsImNhbmNlbCIsInJlYXNvbiIsInJldHVybiIsInR5cGUiLCJpc0Zvcm1EYXRhTGlrZSIsImFwcGVuZCIsImRlbGV0ZSIsImdldCIsImdldEFsbCIsImhhcyIsInNldCIsImFkZEFib3J0TGlzdGVuZXIiLCJzaWduYWwiLCJsaXN0ZW5lciIsImFkZEV2ZW50TGlzdGVuZXIiLCJvbmNlIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImFkZExpc3RlbmVyIiwicmVtb3ZlTGlzdGVuZXIiLCJoYXNUb1dlbGxGb3JtZWQiLCJTdHJpbmciLCJ0b1dlbGxGb3JtZWQiLCJoYXNJc1dlbGxGb3JtZWQiLCJpc1dlbGxGb3JtZWQiLCJ0b1VTVlN0cmluZyIsImlzVVNWU3RyaW5nIiwiaXNUb2tlbkNoYXJDb2RlIiwiYyIsImlzVmFsaWRIVFRQVG9rZW4iLCJjaGFyYWN0ZXJzIiwiY2hhckNvZGVBdCIsImhlYWRlckNoYXJSZWdleCIsImlzVmFsaWRIZWFkZXJWYWx1ZSIsInRlc3QiLCJwYXJzZVJhbmdlSGVhZGVyIiwicmFuZ2UiLCJlbmQiLCJuYW1lIiwibGlzdGVuZXJzIiwicmVtb3ZlQWxsTGlzdGVuZXJzIiwiZXJyb3JSZXF1ZXN0IiwiY2xpZW50IiwicmVxdWVzdCIsImFib3J0ZWQiLCJrRW51bWVyYWJsZVByb3BlcnR5IiwiY3JlYXRlIiwiZW51bWVyYWJsZSIsIm5vcm1hbGl6ZWRNZXRob2RSZWNvcmRzQmFzZSIsIkRFTEVURSIsIkdFVCIsImhlYWQiLCJIRUFEIiwib3B0aW9ucyIsIk9QVElPTlMiLCJwb3N0IiwiUE9TVCIsInB1dCIsIlBVVCIsIm5vcm1hbGl6ZWRNZXRob2RSZWNvcmRzIiwicGF0Y2giLCJQQVRDSCIsInNldFByb3RvdHlwZU9mIiwibW9kdWxlIiwiZXhwb3J0cyIsInNhZmVIVFRQTWV0aG9kcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/core/util.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/dispatcher/agent.js":
/*!*****************************************************!*\
  !*** ./node_modules/undici/lib/dispatcher/agent.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { InvalidArgumentError } = __webpack_require__(/*! ../core/errors */ \"(ssr)/./node_modules/undici/lib/core/errors.js\");\nconst { kClients, kRunning, kClose, kDestroy, kDispatch, kInterceptors } = __webpack_require__(/*! ../core/symbols */ \"(ssr)/./node_modules/undici/lib/core/symbols.js\");\nconst DispatcherBase = __webpack_require__(/*! ./dispatcher-base */ \"(ssr)/./node_modules/undici/lib/dispatcher/dispatcher-base.js\");\nconst Pool = __webpack_require__(/*! ./pool */ \"(ssr)/./node_modules/undici/lib/dispatcher/pool.js\");\nconst Client = __webpack_require__(/*! ./client */ \"(ssr)/./node_modules/undici/lib/dispatcher/client.js\");\nconst util = __webpack_require__(/*! ../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\");\nconst createRedirectInterceptor = __webpack_require__(/*! ../interceptor/redirect-interceptor */ \"(ssr)/./node_modules/undici/lib/interceptor/redirect-interceptor.js\");\nconst kOnConnect = Symbol(\"onConnect\");\nconst kOnDisconnect = Symbol(\"onDisconnect\");\nconst kOnConnectionError = Symbol(\"onConnectionError\");\nconst kMaxRedirections = Symbol(\"maxRedirections\");\nconst kOnDrain = Symbol(\"onDrain\");\nconst kFactory = Symbol(\"factory\");\nconst kOptions = Symbol(\"options\");\nfunction defaultFactory(origin, opts) {\n    return opts && opts.connections === 1 ? new Client(origin, opts) : new Pool(origin, opts);\n}\nclass Agent extends DispatcherBase {\n    constructor({ factory = defaultFactory, maxRedirections = 0, connect, ...options } = {}){\n        super();\n        if (typeof factory !== \"function\") {\n            throw new InvalidArgumentError(\"factory must be a function.\");\n        }\n        if (connect != null && typeof connect !== \"function\" && typeof connect !== \"object\") {\n            throw new InvalidArgumentError(\"connect must be a function or an object\");\n        }\n        if (!Number.isInteger(maxRedirections) || maxRedirections < 0) {\n            throw new InvalidArgumentError(\"maxRedirections must be a positive number\");\n        }\n        if (connect && typeof connect !== \"function\") {\n            connect = {\n                ...connect\n            };\n        }\n        this[kInterceptors] = options.interceptors?.Agent && Array.isArray(options.interceptors.Agent) ? options.interceptors.Agent : [\n            createRedirectInterceptor({\n                maxRedirections\n            })\n        ];\n        this[kOptions] = {\n            ...util.deepClone(options),\n            connect\n        };\n        this[kOptions].interceptors = options.interceptors ? {\n            ...options.interceptors\n        } : undefined;\n        this[kMaxRedirections] = maxRedirections;\n        this[kFactory] = factory;\n        this[kClients] = new Map();\n        this[kOnDrain] = (origin, targets)=>{\n            this.emit(\"drain\", origin, [\n                this,\n                ...targets\n            ]);\n        };\n        this[kOnConnect] = (origin, targets)=>{\n            this.emit(\"connect\", origin, [\n                this,\n                ...targets\n            ]);\n        };\n        this[kOnDisconnect] = (origin, targets, err)=>{\n            this.emit(\"disconnect\", origin, [\n                this,\n                ...targets\n            ], err);\n        };\n        this[kOnConnectionError] = (origin, targets, err)=>{\n            this.emit(\"connectionError\", origin, [\n                this,\n                ...targets\n            ], err);\n        };\n    }\n    get [kRunning]() {\n        let ret = 0;\n        for (const client of this[kClients].values()){\n            ret += client[kRunning];\n        }\n        return ret;\n    }\n    [kDispatch](opts, handler) {\n        let key;\n        if (opts.origin && (typeof opts.origin === \"string\" || opts.origin instanceof URL)) {\n            key = String(opts.origin);\n        } else {\n            throw new InvalidArgumentError(\"opts.origin must be a non-empty string or URL.\");\n        }\n        let dispatcher = this[kClients].get(key);\n        if (!dispatcher) {\n            dispatcher = this[kFactory](opts.origin, this[kOptions]).on(\"drain\", this[kOnDrain]).on(\"connect\", this[kOnConnect]).on(\"disconnect\", this[kOnDisconnect]).on(\"connectionError\", this[kOnConnectionError]);\n            // This introduces a tiny memory leak, as dispatchers are never removed from the map.\n            // TODO(mcollina): remove te timer when the client/pool do not have any more\n            // active connections.\n            this[kClients].set(key, dispatcher);\n        }\n        return dispatcher.dispatch(opts, handler);\n    }\n    async [kClose]() {\n        const closePromises = [];\n        for (const client of this[kClients].values()){\n            closePromises.push(client.close());\n        }\n        this[kClients].clear();\n        await Promise.all(closePromises);\n    }\n    async [kDestroy](err) {\n        const destroyPromises = [];\n        for (const client of this[kClients].values()){\n            destroyPromises.push(client.destroy(err));\n        }\n        this[kClients].clear();\n        await Promise.all(destroyPromises);\n    }\n}\nmodule.exports = Agent;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9kaXNwYXRjaGVyL2FnZW50LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTSxFQUFFQSxvQkFBQUEsRUFBc0IsR0FBR0MsbUJBQU9BLENBQUM7QUFDekMsTUFBTSxFQUFFQyxRQUFRLEVBQUVDLFFBQVEsRUFBRUMsTUFBTSxFQUFFQyxRQUFRLEVBQUVDLFNBQVMsRUFBRUMsYUFBQUEsRUFBZSxHQUFHTixtQkFBT0EsQ0FBQztBQUNuRixNQUFNTyxpQkFBaUJQLG1CQUFPQSxDQUFDO0FBQy9CLE1BQU1RLE9BQU9SLG1CQUFPQSxDQUFDO0FBQ3JCLE1BQU1TLFNBQVNULG1CQUFPQSxDQUFDO0FBQ3ZCLE1BQU1VLE9BQU9WLG1CQUFPQSxDQUFDO0FBQ3JCLE1BQU1XLDRCQUE0QlgsbUJBQU9BLENBQUM7QUFFMUMsTUFBTVksYUFBYUMsT0FBTztBQUMxQixNQUFNQyxnQkFBZ0JELE9BQU87QUFDN0IsTUFBTUUscUJBQXFCRixPQUFPO0FBQ2xDLE1BQU1HLG1CQUFtQkgsT0FBTztBQUNoQyxNQUFNSSxXQUFXSixPQUFPO0FBQ3hCLE1BQU1LLFdBQVdMLE9BQU87QUFDeEIsTUFBTU0sV0FBV04sT0FBTztBQUV4QixTQUFTTyxlQUFnQkMsTUFBTSxFQUFFQyxJQUFJO0lBQ25DLE9BQU9BLFFBQVFBLEtBQUtDLFdBQVcsS0FBSyxJQUNoQyxJQUFJZCxPQUFPWSxRQUFRQyxRQUNuQixJQUFJZCxLQUFLYSxRQUFRQztBQUN2QjtBQUVBLE1BQU1FLGNBQWNqQjtJQUNsQmtCLFlBQWEsRUFBRUMsVUFBVU4sY0FBYyxFQUFFTyxrQkFBa0IsQ0FBQyxFQUFFQyxPQUFPLEVBQUUsR0FBR0MsU0FBUyxHQUFHLENBQUMsQ0FBQyxDQUFFO1FBQ3hGLEtBQUs7UUFFTCxJQUFJLE9BQU9ILFlBQVksWUFBWTtZQUNqQyxNQUFNLElBQUkzQixxQkFBcUI7UUFDakM7UUFFQSxJQUFJNkIsV0FBVyxRQUFRLE9BQU9BLFlBQVksY0FB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a0QsR0FBRyxDQUFDTixLQUFLRztRQUMxQjtRQUVBLE9BQU9BLFdBQVdJLFFBQVEsQ0FBQzlCLE1BQU1zQjtJQUNuQztJQUVBLE9BQU96QyxPQUFNLEdBQUs7UUFDaEIsTUFBTWtELGdCQUFnQixFQUFFO1FBQ3hCLEtBQUssTUFBTVgsVUFBVSxJQUFJLENBQUN6QyxTQUFTLENBQUMwQyxNQUFNLEdBQUk7WUFDNUNVLGNBQWNDLElBQUksQ0FBQ1osT0FBT2EsS0FBSztRQUNqQztRQUNBLElBQUksQ0FBQ3RELFNBQVMsQ0FBQ3VELEtBQUs7UUFFcEIsTUFBTUMsUUFBUUMsR0FBRyxDQUFDTDtJQUNwQjtJQUVBLE9BQU9qRCxTQUFRLENBQUdvQyxHQUFHLEVBQUU7UUFDckIsTUFBTW1CLGtCQUFrQixFQUFFO1FBQzFCLEtBQUssTUFBTWpCLFVBQVUsSUFBSSxDQUFDekMsU0FBUyxDQUFDMEMsTUFBTSxHQUFJO1lBQzVDZ0IsZ0JBQWdCTCxJQUFJLENBQUNaLE9BQU9rQixPQUFPLENBQUNwQjtRQUN0QztRQUNBLElBQUksQ0FBQ3ZDLFNBQVMsQ0FBQ3VELEtBQUs7UUFFcEIsTUFBTUMsUUFBUUMsR0FBRyxDQUFDQztJQUNwQjtBQUNGO0FBRUFFLE9BQU9DLE9BQU8sR0FBR3RDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbW9ja3VwZmxvdy8uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2Rpc3BhdGNoZXIvYWdlbnQuanM/ZjE2MiIsIndlYnBhY2s6Ly9tb2NrdXBmbG93Ly4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvZGlzcGF0Y2hlci9hZ2VudC5qcz9mMTYyKiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyBJbnZhbGlkQXJndW1lbnRFcnJvciB9ID0gcmVxdWlyZSgnLi4vY29yZS9lcnJvcnMnKVxuY29uc3QgeyBrQ2xpZW50cywga1J1bm5pbmcsIGtDbG9zZSwga0Rlc3Ryb3ksIGtEaXNwYXRjaCwga0ludGVyY2VwdG9ycyB9ID0gcmVxdWlyZSgnLi4vY29yZS9zeW1ib2xzJylcbmNvbnN0IERpc3BhdGNoZXJCYXNlID0gcmVxdWlyZSgnLi9kaXNwYXRjaGVyLWJhc2UnKVxuY29uc3QgUG9vbCA9IHJlcXVpcmUoJy4vcG9vbCcpXG5jb25zdCBDbGllbnQgPSByZXF1aXJlKCcuL2NsaWVudCcpXG5jb25zdCB1dGlsID0gcmVxdWlyZSgnLi4vY29yZS91dGlsJylcbmNvbnN0IGNyZWF0ZVJlZGlyZWN0SW50ZXJjZXB0b3IgPSByZXF1aXJlKCcuLi9pbnRlcmNlcHRvci9yZWRpcmVjdC1pbnRlcmNlcHRvcicpXG5cbmNvbnN0IGtPbkNvbm5lY3QgPSBTeW1ib2woJ29uQ29ubmVjdCcpXG5jb25zdCBrT25EaXNjb25uZWN0ID0gU3ltYm9sKCdvbkRpc2Nvbm5lY3QnKVxuY29uc3Qga09uQ29ubmVjdGlvbkVycm9yID0gU3ltYm9sKCdvbkNvbm5lY3Rpb25FcnJvcicpXG5jb25zdCBrTWF4UmVkaXJlY3Rpb25zID0gU3ltYm9sKCdtYXhSZWRpcmVjdGlvbnMnKVxuY29uc3Qga09uRHJhaW4gPSBTeW1ib2woJ29uRHJhaW4nKVxuY29uc3Qga0ZhY3RvcnkgPSBTeW1ib2woJ2ZhY3RvcnknKVxuY29uc3Qga09wdGlvbnMgPSBTeW1ib2woJ29wdGlvbnMnKVxuXG5mdW5jdGlvbiBkZWZhdWx0RmFjdG9yeSAob3JpZ2luLCBvcHRzKSB7XG4gIHJldHVybiBvcHRzICYmIG9wdHMuY29ubmVjdGlvbnMgPT09IDFcbiAgICA/IG5ldyBDbGllbnQob3JpZ2luLCBvcHRzKVxuICAgIDogbmV3IFBvb2wob3JpZ2luLCBvcHRzKVxufVxuXG5jbGFzcyBBZ2VudCBleHRlbmRzIERpc3BhdGNoZXJCYXNlIHtcbiAgY29uc3RydWN0b3IgKHsgZmFjdG9yeSA9IGRlZmF1bHRGYWN0b3J5LCBtYXhSZWRpcmVjdGlvbnMgPSAwLCBjb25uZWN0LCAuLi5vcHRpb25zIH0gPSB7fSkge1xuICAgIHN1cGVyKClcblxuICAgIGlmICh0eXBlb2YgZmFjdG9yeSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdmYWN0b3J5IG11c3QgYmUgYSBmdW5jdGlvbi4nKVxuICAgIH1cblxuICAgIGlmIChjb25uZWN0ICE9IG51bGwgJiYgdHlwZW9mIGNvbm5lY3QgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGNvbm5lY3QgIT09ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2Nvbm5lY3QgbXVzdCBiZSBhIGZ1bmN0aW9uIG9yIGFuIG9iamVjdCcpXG4gICAgfVxuXG4gICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKG1heFJlZGlyZWN0aW9ucykgfHwgbWF4UmVkaXJlY3Rpb25zIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdtYXhSZWRpcmVjdGlvbnMgbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicpXG4gICAgfVxuXG4gICAgaWYgKGNvbm5lY3QgJiYgdHlwZW9mIGNvbm5lY3QgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNvbm5lY3QgPSB7IC4uLmNvbm5lY3QgfVxuICAgIH1cblxuICAgIHRoaXNba0ludGVyY2VwdG9yc10gPSBvcHRpb25zLmludGVyY2VwdG9ycz8uQWdlbnQgJiYgQXJyYXkuaXNBcnJheShvcHRpb25zLmludGVyY2VwdG9ycy5BZ2VudClcbiAgICAgID8gb3B0aW9ucy5pbnRlcmNlcHRvcnMuQWdlbnRcbiAgICAgIDogW2NyZWF0ZVJlZGlyZWN0SW50ZXJjZXB0b3IoeyBtYXhSZWRpcmVjdGlvbnMgfSldXG5cbiAgICB0aGlzW2tPcHRpb25zXSA9IHsgLi4udXRpbC5kZWVwQ2xvbmUob3B0aW9ucyksIGNvbm5lY3QgfVxuICAgIHRoaXNba09wdGlvbnNdLmludGVyY2VwdG9ycyA9IG9wdGlvbnMuaW50ZXJjZXB0b3JzXG4gICAgICA/IHsgLi4ub3B0aW9ucy5pbnRlcmNlcHRvcnMgfVxuICAgICAgOiB1bmRlZmluZWRcbiAgICB0aGlzW2tNYXhSZWRpcmVjdGlvbnNdID0gbWF4UmVkaXJlY3Rpb25zXG4gICAgdGhpc1trRmFjdG9yeV0gPSBmYWN0b3J5XG4gICAgdGhpc1trQ2xpZW50c10gPSBuZXcgTWFwKClcblxuICAgIHRoaXNba09uRHJhaW5dID0gKG9yaWdpbiwgdGFyZ2V0cykgPT4ge1xuICAgICAgdGhpcy5lbWl0KCdkcmFpbicsIG9yaWdpbiwgW3RoaXMsIC4uLnRhcmdldHNdKVxuICAgIH1cblxuICAgIHRoaXNba09uQ29ubmVjdF0gPSAob3JpZ2luLCB0YXJnZXRzKSA9PiB7XG4gICAgICB0aGlzLmVtaXQoJ2Nvbm5lY3QnLCBvcmlnaW4sIFt0aGlzLCAuLi50YXJnZXRzXSlcbiAgICB9XG5cbiAgICB0aGlzW2tPbkRpc2Nvbm5lY3RdID0gKG9yaWdpbiwgdGFyZ2V0cywgZXJyKSA9PiB7XG4gICAgICB0aGlzLmVtaXQoJ2Rpc2Nvbm5lY3QnLCBvcmlnaW4sIFt0aGlzLCAuLi50YXJnZXRzXSwgZXJyKVxuICAgIH1cblxuICAgIHRoaXNba09uQ29ubmVjdGlvbkVycm9yXSA9IChvcmlnaW4sIHRhcmdldHMsIGVycikgPT4ge1xuICAgICAgdGhpcy5lbWl0KCdjb25uZWN0aW9uRXJyb3InLCBvcmlnaW4sIFt0aGlzLCAuLi50YXJnZXRzXSwgZXJyKVxuICAgIH1cbiAgfVxuXG4gIGdldCBba1J1bm5pbmddICgpIHtcbiAgICBsZXQgcmV0ID0gMFxuICAgIGZvciAoY29uc3QgY2xpZW50IG9mIHRoaXNba0NsaWVudHNdLnZhbHVlcygpKSB7XG4gICAgICByZXQgKz0gY2xpZW50W2tSdW5uaW5nXVxuICAgIH1cbiAgICByZXR1cm4gcmV0XG4gIH1cblxuICBba0Rpc3BhdGNoXSAob3B0cywgaGFuZGxlcikge1xuICAgIGxldCBrZXlcbiAgICBpZiAob3B0cy5vcmlnaW4gJiYgKHR5cGVvZiBvcHRzLm9yaWdpbiA9PT0gJ3N0cmluZycgfHwgb3B0cy5vcmlnaW4gaW5zdGFuY2VvZiBVUkwpKSB7XG4gICAgICBrZXkgPSBTdHJpbmcob3B0cy5vcmlnaW4pXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignb3B0cy5vcmlnaW4gbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgVVJMLicpXG4gICAgfVxuXG4gICAgbGV0IGRpc3BhdGNoZXIgPSB0aGlzW2tDbGllbnRzXS5nZXQoa2V5KVxuXG4gICAgaWYgKCFkaXNwYXRjaGVyKSB7XG4gICAgICBkaXNwYXRjaGVyID0gdGhpc1trRmFjdG9yeV0ob3B0cy5vcmlnaW4sIHRoaXNba09wdGlvbnNdKVxuICAgICAgICAub24oJ2RyYWluJywgdGhpc1trT25EcmFpbl0pXG4gICAgICAgIC5vbignY29ubmVjdCcsIHRoaXNba09uQ29ubmVjdF0pXG4gICAgICAgIC5vbignZGlzY29ubmVjdCcsIHRoaXNba09uRGlzY29ubmVjdF0pXG4gICAgICAgIC5vbignY29ubmVjdGlvbkVycm9yJywgdGhpc1trT25Db25uZWN0aW9uRXJyb3JdKVxuXG4gICAgICAvLyBUaGlzIGludHJvZHVjZXMgYSB0aW55IG1lbW9yeSBsZWFrLCBhcyBkaXNwYXRjaGVycyBhcmUgbmV2ZXIgcmVtb3ZlZCBmcm9tIHRoZSBtYXAuXG4gICAgICAvLyBUT0RPKG1jb2xsaW5hKTogcmVtb3ZlIHRlIHRpbWVyIHdoZW4gdGhlIGNsaWVudC9wb29sIGRvIG5vdCBoYXZlIGFueSBtb3JlXG4gICAgICAvLyBhY3RpdmUgY29ubmVjdGlvbnMuXG4gICAgICB0aGlzW2tDbGllbnRzXS5zZXQoa2V5LCBkaXNwYXRjaGVyKVxuICAgIH1cblxuICAgIHJldHVybiBkaXNwYXRjaGVyLmRpc3BhdGNoKG9wdHMsIGhhbmRsZXIpXG4gIH1cblxuICBhc3luYyBba0Nsb3NlXSAoKSB7XG4gICAgY29uc3QgY2xvc2VQcm9taXNlcyA9IFtdXG4gICAgZm9yIChjb25zdCBjbGllbnQgb2YgdGhpc1trQ2xpZW50c10udmFsdWVzKCkpIHtcbiAgICAgIGNsb3NlUHJvbWlzZXMucHVzaChjbGllbnQuY2xvc2UoKSlcbiAgICB9XG4gICAgdGhpc1trQ2xpZW50c10uY2xlYXIoKVxuXG4gICAgYXdhaXQgUHJvbWlzZS5hbGwoY2xvc2VQcm9taXNlcylcbiAgfVxuXG4gIGFzeW5jIFtrRGVzdHJveV0gKGVycikge1xuICAgIGNvbnN0IGRlc3Ryb3lQcm9taXNlcyA9IFtdXG4gICAgZm9yIChjb25zdCBjbGllbnQgb2YgdGhpc1trQ2xpZW50c10udmFsdWVzKCkpIHtcbiAgICAgIGRlc3Ryb3lQcm9taXNlcy5wdXNoKGNsaWVudC5kZXN0cm95KGVycikpXG4gICAgfVxuICAgIHRoaXNba0NsaWVudHNdLmNsZWFyKClcblxuICAgIGF3YWl0IFByb21pc2UuYWxsKGRlc3Ryb3lQcm9taXNlcylcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEFnZW50XG4iXSwibmFtZXMiOlsiSW52YWxpZEFyZ3VtZW50RXJyb3IiLCJyZXF1aXJlIiwia0NsaWVudHMiLCJrUnVubmluZyIsImtDbG9zZSIsImtEZXN0cm95Iiwia0Rpc3BhdGNoIiwia0ludGVyY2VwdG9ycyIsIkRpc3BhdGNoZXJCYXNlIiwiUG9vbCIsIkNsaWVudCIsInV0aWwiLCJjcmVhdGVSZWRpcmVjdEludGVyY2VwdG9yIiwia09uQ29ubmVjdCIsIlN5bWJvbCIsImtPbkRpc2Nvbm5lY3QiLCJrT25Db25uZWN0aW9uRXJyb3IiLCJrTWF4UmVkaXJlY3Rpb25zIiwia09uRHJhaW4iLCJrRmFjdG9yeSIsImtPcHRpb25zIiwiZGVmYXVsdEZhY3RvcnkiLCJvcmlnaW4iLCJvcHRzIiwiY29ubmVjdGlvbnMiLCJBZ2VudCIsImNvbnN0cnVjdG9yIiwiZmFjdG9yeSIsIm1heFJlZGlyZWN0aW9ucyIsImNvbm5lY3QiLCJvcHRpb25zIiwiTnVtYmVyIiwiaXNJbnRlZ2VyIiwiaW50ZXJjZXB0b3JzIiwiQXJyYXkiLCJpc0FycmF5IiwiZGVlcENsb25lIiwidW5kZWZpbmVkIiwiTWFwIiwidGFyZ2V0cyIsImVtaXQiLCJlcnIiLCJyZXQiLCJjbGllbnQiLCJ2YWx1ZXMiLCJoYW5kbGVyIiwia2V5IiwiVVJMIiwiU3RyaW5nIiwiZGlzcGF0Y2hlciIsImdldCIsIm9uIiwic2V0IiwiZGlzcGF0Y2giLCJjbG9zZVByb21pc2VzIiwicHVzaCIsImNsb3NlIiwiY2xlYXIiLCJQcm9taXNlIiwiYWxsIiwiZGVzdHJveVByb21pc2VzIiwiZGVzdHJveSIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/dispatcher/agent.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/dispatcher/balanced-pool.js":
/*!*************************************************************!*\
  !*** ./node_modules/undici/lib/dispatcher/balanced-pool.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { BalancedPoolMissingUpstreamError, InvalidArgumentError } = __webpack_require__(/*! ../core/errors */ \"(ssr)/./node_modules/undici/lib/core/errors.js\");\nconst { PoolBase, kClients, kNeedDrain, kAddClient, kRemoveClient, kGetDispatcher } = __webpack_require__(/*! ./pool-base */ \"(ssr)/./node_modules/undici/lib/dispatcher/pool-base.js\");\nconst Pool = __webpack_require__(/*! ./pool */ \"(ssr)/./node_modules/undici/lib/dispatcher/pool.js\");\nconst { kUrl, kInterceptors } = __webpack_require__(/*! ../core/symbols */ \"(ssr)/./node_modules/undici/lib/core/symbols.js\");\nconst { parseOrigin } = __webpack_require__(/*! ../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\");\nconst kFactory = Symbol(\"factory\");\nconst kOptions = Symbol(\"options\");\nconst kGreatestCommonDivisor = Symbol(\"kGreatestCommonDivisor\");\nconst kCurrentWeight = Symbol(\"kCurrentWeight\");\nconst kIndex = Symbol(\"kIndex\");\nconst kWeight = Symbol(\"kWeight\");\nconst kMaxWeightPerServer = Symbol(\"kMaxWeightPerServer\");\nconst kErrorPenalty = Symbol(\"kErrorPenalty\");\nfunction getGreatestCommonDivisor(a, b) {\n    if (b === 0) return a;\n    return getGreatestCommonDivisor(b, a % b);\n}\nfunction defaultFactory(origin, opts) {\n    return new Pool(origin, opts);\n}\nclass BalancedPool extends PoolBase {\n    constructor(upstreams = [], { factory = defaultFactory, ...opts } = {}){\n        super();\n        this[kOptions] = opts;\n        this[kIndex] = -1;\n        this[kCurrentWeight] = 0;\n        this[kMaxWeightPerServer] = this[kOptions].maxWeightPerServer || 100;\n        this[kErrorPenalty] = this[kOptions].errorPenalty || 15;\n        if (!Array.isArray(upstreams)) {\n            upstreams = [\n                upstreams\n            ];\n        }\n        if (typeof factory !== \"function\") {\n            throw new InvalidArgumentError(\"factory must be a function.\");\n        }\n        this[kInterceptors] = opts.interceptors?.BalancedPool && Array.isArray(opts.interceptors.BalancedPool) ? opts.interceptors.BalancedPool : [];\n        this[kFactory] = factory;\n        for (const upstream of upstreams){\n            this.addUpstream(upstream);\n        }\n        this._updateBalancedPoolStats();\n    }\n    addUpstream(upstream) {\n        const upstreamOrigin = parseOrigin(upstream).origin;\n        if (this[kClients].find((pool)=>pool[kUrl].origin === upstreamOrigin && pool.closed !== true && pool.destroyed !== true)) {\n            return this;\n        }\n        const pool = this[kFactory](upstreamOrigin, Object.assign({}, this[kOptions]));\n        this[kAddClient](pool);\n        pool.on(\"connect\", ()=>{\n            pool[kWeight] = Math.min(this[kMaxWeightPerServer], pool[kWeight] + this[kErrorPenalty]);\n        });\n        pool.on(\"connectionError\", ()=>{\n            pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty]);\n            this._updateBalancedPoolStats();\n        });\n        pool.on(\"disconnect\", (...args)=>{\n            const err = args[2];\n            if (err && err.code === \"UND_ERR_SOCKET\") {\n                // decrease the weight of the pool.\n                pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty]);\n                this._updateBalancedPoolStats();\n            }\n        });\n        for (const client of this[kClients]){\n            client[kWeight] = this[kMaxWeightPerServer];\n        }\n        this._updateBalancedPoolStats();\n        return this;\n    }\n    _updateBalancedPoolStats() {\n        this[kGreatestCommonDivisor] = this[kClients].map((p)=>p[kWeight]).reduce(getGreatestCommonDivisor, 0);\n    }\n    removeUpstream(upstream) {\n        const upstreamOrigin = parseOrigin(upstream).origin;\n        const pool = this[kClients].find((pool)=>pool[kUrl].origin === upstreamOrigin && pool.closed !== true && pool.destroyed !== true);\n        if (pool) {\n            this[kRemoveClient](pool);\n        }\n        return this;\n    }\n    get upstreams() {\n        return this[kClients].filter((dispatcher)=>dispatcher.closed !== true && dispatcher.destroyed !== true).map((p)=>p[kUrl].origin);\n    }\n    [kGetDispatcher]() {\n        // We validate that pools is greater than 0,\n        // otherwise we would have to wait until an upstream\n        // is added, which might never happen.\n        if (this[kClients].length === 0) {\n            throw new BalancedPoolMissingUpstreamError();\n        }\n        const dispatcher = this[kClients].find((dispatcher)=>!dispatcher[kNeedDrain] && dispatcher.closed !== true && dispatcher.destroyed !== true);\n        if (!dispatcher) {\n            return;\n        }\n        const allClientsBusy = this[kClients].map((pool)=>pool[kNeedDrain]).reduce((a, b)=>a && b, true);\n        if (allClientsBusy) {\n            return;\n        }\n        let counter = 0;\n        let maxWeightIndex = this[kClients].findIndex((pool)=>!pool[kNeedDrain]);\n        while(counter++ < this[kClients].length){\n            this[kIndex] = (this[kIndex] + 1) % this[kClients].length;\n            const pool = this[kClients][this[kIndex]];\n            // find pool index with the largest weight\n            if (pool[kWeight] > this[kClients][maxWeightIndex][kWeight] && !pool[kNeedDrain]) {\n                maxWeightIndex = this[kIndex];\n            }\n            // decrease the current weight every `this[kClients].length`.\n            if (this[kIndex] === 0) {\n                // Set the current weight to the next lower weight.\n                this[kCurrentWeight] = this[kCurrentWeight] - this[kGreatestCommonDivisor];\n                if (this[kCurrentWeight] <= 0) {\n                    this[kCurrentWeight] = this[kMaxWeightPerServer];\n                }\n            }\n            if (pool[kWeight] >= this[kCurrentWeight] && !pool[kNeedDrain]) {\n                return pool;\n            }\n        }\n        this[kCurrentWeight] = this[kClients][maxWeightIndex][kWeight];\n        this[kIndex] = maxWeightIndex;\n        return this[kClients][maxWeightIndex];\n    }\n}\nmodule.exports = BalancedPool;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9kaXNwYXRjaGVyL2JhbGFuY2VkLXBvb2wuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNLEVBQ0pBLGdDQUFnQyxFQUNoQ0Msb0JBQUFBLEVBQ0QsR0FBR0MsbUJBQU9BLENBQUM7QUFDWixNQUFNLEVBQ0pDLFFBQVEsRUFDUkMsUUFBUSxFQUNSQyxVQUFVLEVBQ1ZDLFVBQVUsRUFDVkMsYUFBYSxFQUNiQyxjQUFBQSxFQUNELEdBQUdOLG1CQUFPQSxDQUFDO0FBQ1osTUFBTU8sT0FBT1AsbUJBQU9BLENBQUM7QUFDckIsTUFBTSxFQUFFUSxJQUFJLEVBQUVDLGFBQUFBLEVBQWUsR0FBR1QsbUJBQU9BLENBQUM7QUFDeEMsTUFBTSxFQUFFVSxXQUFBQSxFQUFhLEdBQUdWLG1CQUFPQSxDQUFDO0FBQ2hDLE1BQU1XLFdBQVdDLE9BQU87QUFFeEIsTUFBTUMsV0FBV0QsT0FBTztBQUN4QixNQUFNRSx5QkFBeUJGLE9BQU87QUFDdEMsTUFBTUcsaUJBQWlCSCxPQUFPO0FBQzlCLE1BQU1JLFNBQVNKLE9BQU87QUFDdEIsTUFBTUssVUFBVUwsT0FBTztBQUN2QixNQUFNTSxzQkFBc0JOLE9BQU87QUFDbkMsTUFBTU8sZ0JBQWdCUCxPQUFPO0FBRTdCLFNBQVNRLHlCQUEwQkMsQ0FBQyxFQUFFQyxDQUFDO0lBQ3JDLElBQUlBLE1BQU0sR0FBRyxPQUFPRDtJQUNwQixPQUFPRCx5QkFBeUJFLEdBQUdELElBQUlDO0FBQ3pDO0FBRUEsU0FBU0MsZUFBZ0JDLE1BQU0sRUFBRUMsSUFBSTtJQUNuQyxPQUFPLElBQUlsQixLQUFLaUIsUUFBUUM7QUFDMUI7QUFFQSxNQUFNQyxxQkFBcUJ6QjtJQUN6QjBCLFlBQWFDLFlBQVksRUFBRSxFQUFFLEVBQUVDLFVBQVVOLGNBQWMsRUFBRSxHQUFHRSxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUU7UUFDdkUsS0FBSztRQUVMLElBQUksQ0FBQ1osU0FBUyxHQUFHWTtRQUNq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bW9ja3VwZmxvdy8uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2Rpc3BhdGNoZXIvYmFsYW5jZWQtcG9vbC5qcz9kZGM2Iiwid2VicGFjazovL21vY2t1cGZsb3cvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9kaXNwYXRjaGVyL2JhbGFuY2VkLXBvb2wuanM/ZGRjNioiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHtcbiAgQmFsYW5jZWRQb29sTWlzc2luZ1Vwc3RyZWFtRXJyb3IsXG4gIEludmFsaWRBcmd1bWVudEVycm9yXG59ID0gcmVxdWlyZSgnLi4vY29yZS9lcnJvcnMnKVxuY29uc3Qge1xuICBQb29sQmFzZSxcbiAga0NsaWVudHMsXG4gIGtOZWVkRHJhaW4sXG4gIGtBZGRDbGllbnQsXG4gIGtSZW1vdmVDbGllbnQsXG4gIGtHZXREaXNwYXRjaGVyXG59ID0gcmVxdWlyZSgnLi9wb29sLWJhc2UnKVxuY29uc3QgUG9vbCA9IHJlcXVpcmUoJy4vcG9vbCcpXG5jb25zdCB7IGtVcmwsIGtJbnRlcmNlcHRvcnMgfSA9IHJlcXVpcmUoJy4uL2NvcmUvc3ltYm9scycpXG5jb25zdCB7IHBhcnNlT3JpZ2luIH0gPSByZXF1aXJlKCcuLi9jb3JlL3V0aWwnKVxuY29uc3Qga0ZhY3RvcnkgPSBTeW1ib2woJ2ZhY3RvcnknKVxuXG5jb25zdCBrT3B0aW9ucyA9IFN5bWJvbCgnb3B0aW9ucycpXG5jb25zdCBrR3JlYXRlc3RDb21tb25EaXZpc29yID0gU3ltYm9sKCdrR3JlYXRlc3RDb21tb25EaXZpc29yJylcbmNvbnN0IGtDdXJyZW50V2VpZ2h0ID0gU3ltYm9sKCdrQ3VycmVudFdlaWdodCcpXG5jb25zdCBrSW5kZXggPSBTeW1ib2woJ2tJbmRleCcpXG5jb25zdCBrV2VpZ2h0ID0gU3ltYm9sKCdrV2VpZ2h0JylcbmNvbnN0IGtNYXhXZWlnaHRQZXJTZXJ2ZXIgPSBTeW1ib2woJ2tNYXhXZWlnaHRQZXJTZXJ2ZXInKVxuY29uc3Qga0Vycm9yUGVuYWx0eSA9IFN5bWJvbCgna0Vycm9yUGVuYWx0eScpXG5cbmZ1bmN0aW9uIGdldEdyZWF0ZXN0Q29tbW9uRGl2aXNvciAoYSwgYikge1xuICBpZiAoYiA9PT0gMCkgcmV0dXJuIGFcbiAgcmV0dXJuIGdldEdyZWF0ZXN0Q29tbW9uRGl2aXNvcihiLCBhICUgYilcbn1cblxuZnVuY3Rpb24gZGVmYXVsdEZhY3RvcnkgKG9yaWdpbiwgb3B0cykge1xuICByZXR1cm4gbmV3IFBvb2wob3JpZ2luLCBvcHRzKVxufVxuXG5jbGFzcyBCYWxhbmNlZFBvb2wgZXh0ZW5kcyBQb29sQmFzZSB7XG4gIGNvbnN0cnVjdG9yICh1cHN0cmVhbXMgPSBbXSwgeyBmYWN0b3J5ID0gZGVmYXVsdEZhY3RvcnksIC4uLm9wdHMgfSA9IHt9KSB7XG4gICAgc3VwZXIoKVxuXG4gICAgdGhpc1trT3B0aW9uc10gPSBvcHRzXG4gICAgdGhpc1trSW5kZXhdID0gLTFcbiAgICB0aGlzW2tDdXJyZW50V2VpZ2h0XSA9IDBcblxuICAgIHRoaXNba01heFdlaWdodFBlclNlcnZlcl0gPSB0aGlzW2tPcHRpb25zXS5tYXhXZWlnaHRQZXJTZXJ2ZXIgfHwgMTAwXG4gICAgdGhpc1trRXJyb3JQZW5hbHR5XSA9IHRoaXNba09wdGlvbnNdLmVycm9yUGVuYWx0eSB8fCAxNVxuXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHVwc3RyZWFtcykpIHtcbiAgICAgIHVwc3RyZWFtcyA9IFt1cHN0cmVhbXNdXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBmYWN0b3J5ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ZhY3RvcnkgbXVzdCBiZSBhIGZ1bmN0aW9uLicpXG4gICAgfVxuXG4gICAgdGhpc1trSW50ZXJjZXB0b3JzXSA9IG9wdHMuaW50ZXJjZXB0b3JzPy5CYWxhbmNlZFBvb2wgJiYgQXJyYXkuaXNBcnJheShvcHRzLmludGVyY2VwdG9ycy5CYWxhbmNlZFBvb2wpXG4gICAgICA/IG9wdHMuaW50ZXJjZXB0b3JzLkJhbGFuY2VkUG9vbFxuICAgICAgOiBbXVxuICAgIHRoaXNba0ZhY3RvcnldID0gZmFjdG9yeVxuXG4gICAgZm9yIChjb25zdCB1cHN0cmVhbSBvZiB1cHN0cmVhbXMpIHtcbiAgICAgIHRoaXMuYWRkVXBzdHJlYW0odXBzdHJlYW0pXG4gICAgfVxuICAgIHRoaXMuX3VwZGF0ZUJhbGFuY2VkUG9vbFN0YXRzKClcbiAgfVxuXG4gIGFkZFVwc3RyZWFtICh1cHN0cmVhbSkge1xuICAgIGNvbnN0IHVwc3RyZWFtT3JpZ2luID0gcGFyc2VPcmlnaW4odXBzdHJlYW0pLm9yaWdpblxuXG4gICAgaWYgKHRoaXNba0NsaWVudHNdLmZpbmQoKHBvb2wpID0+IChcbiAgICAgIHBvb2xba1VybF0ub3JpZ2luID09PSB1cHN0cmVhbU9yaWdpbiAmJlxuICAgICAgcG9vbC5jbG9zZWQgIT09IHRydWUgJiZcbiAgICAgIHBvb2wuZGVzdHJveWVkICE9PSB0cnVlXG4gICAgKSkpIHtcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuICAgIGNvbnN0IHBvb2wgPSB0aGlzW2tGYWN0b3J5XSh1cHN0cmVhbU9yaWdpbiwgT2JqZWN0LmFzc2lnbih7fSwgdGhpc1trT3B0aW9uc10pKVxuXG4gICAgdGhpc1trQWRkQ2xpZW50XShwb29sKVxuICAgIHBvb2wub24oJ2Nvbm5lY3QnLCAoKSA9PiB7XG4gICAgICBwb29sW2tXZWlnaHRdID0gTWF0aC5taW4odGhpc1trTWF4V2VpZ2h0UGVyU2VydmVyXSwgcG9vbFtrV2VpZ2h0XSArIHRoaXNba0Vycm9yUGVuYWx0eV0pXG4gICAgfSlcblxuICAgIHBvb2wub24oJ2Nvbm5lY3Rpb25FcnJvcicsICgpID0+IHtcbiAgICAgIHBvb2xba1dlaWdodF0gPSBNYXRoLm1heCgxLCBwb29sW2tXZWlnaHRdIC0gdGhpc1trRXJyb3JQZW5hbHR5XSlcbiAgICAgIHRoaXMuX3VwZGF0ZUJhbGFuY2VkUG9vbFN0YXRzKClcbiAgICB9KVxuXG4gICAgcG9vbC5vbignZGlzY29ubmVjdCcsICguLi5hcmdzKSA9PiB7XG4gICAgICBjb25zdCBlcnIgPSBhcmdzWzJdXG4gICAgICBpZiAoZXJyICYmIGVyci5jb2RlID09PSAnVU5EX0VSUl9TT0NLRVQnKSB7XG4gICAgICAgIC8vIGRlY3JlYXNlIHRoZSB3ZWlnaHQgb2YgdGhlIHBvb2wuXG4gICAgICAgIHBvb2xba1dlaWdodF0gPSBNYXRoLm1heCgxLCBwb29sW2tXZWlnaHRdIC0gdGhpc1trRXJyb3JQZW5hbHR5XSlcbiAgICAgICAgdGhpcy5fdXBkYXRlQmFsYW5jZWRQb29sU3RhdHMoKVxuICAgICAgfVxuICAgIH0pXG5cbiAgICBmb3IgKGNvbnN0IGNsaWVudCBvZiB0aGlzW2tDbGllbnRzXSkge1xuICAgICAgY2xpZW50W2tXZWlnaHRdID0gdGhpc1trTWF4V2VpZ2h0UGVyU2VydmVyXVxuICAgIH1cblxuICAgIHRoaXMuX3VwZGF0ZUJhbGFuY2VkUG9vbFN0YXRzKClcblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBfdXBkYXRlQmFsYW5jZWRQb29sU3RhdHMgKCkge1xuICAgIHRoaXNba0dyZWF0ZXN0Q29tbW9uRGl2aXNvcl0gPSB0aGlzW2tDbGllbnRzXS5tYXAocCA9PiBwW2tXZWlnaHRdKS5yZWR1Y2UoZ2V0R3JlYXRlc3RDb21tb25EaXZpc29yLCAwKVxuICB9XG5cbiAgcmVtb3ZlVXBzdHJlYW0gKHVwc3RyZWFtKSB7XG4gICAgY29uc3QgdXBzdHJlYW1PcmlnaW4gPSBwYXJzZU9yaWdpbih1cHN0cmVhbSkub3JpZ2luXG5cbiAgICBjb25zdCBwb29sID0gdGhpc1trQ2xpZW50c10uZmluZCgocG9vbCkgPT4gKFxuICAgICAgcG9vbFtrVXJsXS5vcmlnaW4gPT09IHVwc3RyZWFtT3JpZ2luICYmXG4gICAgICBwb29sLmNsb3NlZCAhPT0gdHJ1ZSAmJlxuICAgICAgcG9vbC5kZXN0cm95ZWQgIT09IHRydWVcbiAgICApKVxuXG4gICAgaWYgKHBvb2wpIHtcbiAgICAgIHRoaXNba1JlbW92ZUNsaWVudF0ocG9vbClcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgZ2V0IHVwc3RyZWFtcyAoKSB7XG4gICAgcmV0dXJuIHRoaXNba0NsaWVudHNdXG4gICAgICAuZmlsdGVyKGRpc3BhdGNoZXIgPT4gZGlzcGF0Y2hlci5jbG9zZWQgIT09IHRydWUgJiYgZGlzcGF0Y2hlci5kZXN0cm95ZWQgIT09IHRydWUpXG4gICAgICAubWFwKChwKSA9PiBwW2tVcmxdLm9yaWdpbilcbiAgfVxuXG4gIFtrR2V0RGlzcGF0Y2hlcl0gKCkge1xuICAgIC8vIFdlIHZhbGlkYXRlIHRoYXQgcG9vbHMgaXMgZ3JlYXRlciB0aGFuIDAsXG4gICAgLy8gb3RoZXJ3aXNlIHdlIHdvdWxkIGhhdmUgdG8gd2FpdCB1bnRpbCBhbiB1cHN0cmVhbVxuICAgIC8vIGlzIGFkZGVkLCB3aGljaCBtaWdodCBuZXZlciBoYXBwZW4uXG4gICAgaWYgKHRoaXNba0NsaWVudHNdLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEJhbGFuY2VkUG9vbE1pc3NpbmdVcHN0cmVhbUVycm9yKClcbiAgICB9XG5cbiAgICBjb25zdCBkaXNwYXRjaGVyID0gdGhpc1trQ2xpZW50c10uZmluZChkaXNwYXRjaGVyID0+IChcbiAgICAgICFkaXNwYXRjaGVyW2tOZWVkRHJhaW5dICYmXG4gICAgICBkaXNwYXRjaGVyLmNsb3NlZCAhPT0gdHJ1ZSAmJlxuICAgICAgZGlzcGF0Y2hlci5kZXN0cm95ZWQgIT09IHRydWVcbiAgICApKVxuXG4gICAgaWYgKCFkaXNwYXRjaGVyKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCBhbGxDbGllbnRzQnVzeSA9IHRoaXNba0NsaWVudHNdLm1hcChwb29sID0+IHBvb2xba05lZWREcmFpbl0pLnJlZHVjZSgoYSwgYikgPT4gYSAmJiBiLCB0cnVlKVxuXG4gICAgaWYgKGFsbENsaWVudHNCdXN5KSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBsZXQgY291bnRlciA9IDBcblxuICAgIGxldCBtYXhXZWlnaHRJbmRleCA9IHRoaXNba0NsaWVudHNdLmZpbmRJbmRleChwb29sID0+ICFwb29sW2tOZWVkRHJhaW5dKVxuXG4gICAgd2hpbGUgKGNvdW50ZXIrKyA8IHRoaXNba0NsaWVudHNdLmxlbmd0aCkge1xuICAgICAgdGhpc1trSW5kZXhdID0gKHRoaXNba0luZGV4XSArIDEpICUgdGhpc1trQ2xpZW50c10ubGVuZ3RoXG4gICAgICBjb25zdCBwb29sID0gdGhpc1trQ2xpZW50c11bdGhpc1trSW5kZXhdXVxuXG4gICAgICAvLyBmaW5kIHBvb2wgaW5kZXggd2l0aCB0aGUgbGFyZ2VzdCB3ZWlnaHRcbiAgICAgIGlmIChwb29sW2tXZWlnaHRdID4gdGhpc1trQ2xpZW50c11bbWF4V2VpZ2h0SW5kZXhdW2tXZWlnaHRdICYmICFwb29sW2tOZWVkRHJhaW5dKSB7XG4gICAgICAgIG1heFdlaWdodEluZGV4ID0gdGhpc1trSW5kZXhdXG4gICAgICB9XG5cbiAgICAgIC8vIGRlY3JlYXNlIHRoZSBjdXJyZW50IHdlaWdodCBldmVyeSBgdGhpc1trQ2xpZW50c10ubGVuZ3RoYC5cbiAgICAgIGlmICh0aGlzW2tJbmRleF0gPT09IDApIHtcbiAgICAgICAgLy8gU2V0IHRoZSBjdXJyZW50IHdlaWdodCB0byB0aGUgbmV4dCBsb3dlciB3ZWlnaHQuXG4gICAgICAgIHRoaXNba0N1cnJlbnRXZWlnaHRdID0gdGhpc1trQ3VycmVudFdlaWdodF0gLSB0aGlzW2tHcmVhdGVzdENvbW1vbkRpdmlzb3JdXG5cbiAgICAgICAgaWYgKHRoaXNba0N1cnJlbnRXZWlnaHRdIDw9IDApIHtcbiAgICAgICAgICB0aGlzW2tDdXJyZW50V2VpZ2h0XSA9IHRoaXNba01heFdlaWdodFBlclNlcnZlcl1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHBvb2xba1dlaWdodF0gPj0gdGhpc1trQ3VycmVudFdlaWdodF0gJiYgKCFwb29sW2tOZWVkRHJhaW5dKSkge1xuICAgICAgICByZXR1cm4gcG9vbFxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXNba0N1cnJlbnRXZWlnaHRdID0gdGhpc1trQ2xpZW50c11bbWF4V2VpZ2h0SW5kZXhdW2tXZWlnaHRdXG4gICAgdGhpc1trSW5kZXhdID0gbWF4V2VpZ2h0SW5kZXhcbiAgICByZXR1cm4gdGhpc1trQ2xpZW50c11bbWF4V2VpZ2h0SW5kZXhdXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBCYWxhbmNlZFBvb2xcbiJdLCJuYW1lcyI6WyJCYWxhbmNlZFBvb2xNaXNzaW5nVXBzdHJlYW1FcnJvciIsIkludmFsaWRBcmd1bWVudEVycm9yIiwicmVxdWlyZSIsIlBvb2xCYXNlIiwia0NsaWVudHMiLCJrTmVlZERyYWluIiwia0FkZENsaWVudCIsImtSZW1vdmVDbGllbnQiLCJrR2V0RGlzcGF0Y2hlciIsIlBvb2wiLCJrVXJsIiwia0ludGVyY2VwdG9ycyIsInBhcnNlT3JpZ2luIiwia0ZhY3RvcnkiLCJTeW1ib2wiLCJrT3B0aW9ucyIsImtHcmVhdGVzdENvbW1vbkRpdmlzb3IiLCJrQ3VycmVudFdlaWdodCIsImtJbmRleCIsImtXZWlnaHQiLCJrTWF4V2VpZ2h0UGVyU2VydmVyIiwia0Vycm9yUGVuYWx0eSIsImdldEdyZWF0ZXN0Q29tbW9uRGl2aXNvciIsImEiLCJiIiwiZGVmYXVsdEZhY3RvcnkiLCJvcmlnaW4iLCJvcHRzIiwiQmFsYW5jZWRQb29sIiwiY29uc3RydWN0b3IiLCJ1cHN0cmVhbXMiLCJmYWN0b3J5IiwibWF4V2VpZ2h0UGVyU2VydmVyIiwiZXJyb3JQZW5hbHR5IiwiQXJyYXkiLCJpc0FycmF5IiwiaW50ZXJjZXB0b3JzIiwidXBzdHJlYW0iLCJhZGRVcHN0cmVhbSIsIl91cGRhdGVCYWxhbmNlZFBvb2xTdGF0cyIsInVwc3RyZWFtT3JpZ2luIiwiZmluZCIsInBvb2wiLCJjbG9zZWQiLCJkZXN0cm95ZWQiLCJPYmplY3QiLCJhc3NpZ24iLCJvbiIsIk1hdGgiLCJtaW4iLCJtYXgiLCJhcmdzIiwiZXJyIiwiY29kZSIsImNsaWVudCIsIm1hcCIsInAiLCJyZWR1Y2UiLCJyZW1vdmVVcHN0cmVhbSIsImZpbHRlciIsImRpc3BhdGNoZXIiLCJsZW5ndGgiLCJhbGxDbGllbnRzQnVzeSIsImNvdW50ZXIiLCJtYXhXZWlnaHRJbmRleCIsImZpbmRJbmRleCIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/dispatcher/balanced-pool.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/dispatcher/client-h1.js":
/*!*********************************************************!*\
  !*** ./node_modules/undici/lib/dispatcher/client-h1.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n/* global WebAssembly */ const assert = __webpack_require__(/*! node:assert */ \"node:assert\");\nconst util = __webpack_require__(/*! ../core/util.js */ \"(ssr)/./node_modules/undici/lib/core/util.js\");\nconst { channels } = __webpack_require__(/*! ../core/diagnostics.js */ \"(ssr)/./node_modules/undici/lib/core/diagnostics.js\");\nconst timers = __webpack_require__(/*! ../util/timers.js */ \"(ssr)/./node_modules/undici/lib/util/timers.js\");\nconst { RequestContentLengthMismatchError, ResponseContentLengthMismatchError, RequestAbortedError, HeadersTimeoutError, HeadersOverflowError, SocketError, InformationalError, BodyTimeoutError, HTTPParserError, ResponseExceededMaxSizeError } = __webpack_require__(/*! ../core/errors.js */ \"(ssr)/./node_modules/undici/lib/core/errors.js\");\nconst { kUrl, kReset, kClient, kParser, kBlocking, kRunning, kPending, kSize, kWriting, kQueue, kNoRef, kKeepAliveDefaultTimeout, kHostHeader, kPendingIdx, kRunningIdx, kError, kPipelining, kSocket, kKeepAliveTimeoutValue, kMaxHeadersSize, kKeepAliveMaxTimeout, kKeepAliveTimeoutThreshold, kHeadersTimeout, kBodyTimeout, kStrictContentLength, kMaxRequests, kCounter, kMaxResponseSize, kOnError, kResume, kHTTPContext } = __webpack_require__(/*! ../core/symbols.js */ \"(ssr)/./node_modules/undici/lib/core/symbols.js\");\nconst constants = __webpack_require__(/*! ../llhttp/constants.js */ \"(ssr)/./node_modules/undici/lib/llhttp/constants.js\");\nconst EMPTY_BUF = Buffer.alloc(0);\nconst FastBuffer = Buffer[Symbol.species];\nconst addListener = util.addListener;\nconst removeAllListeners = util.removeAllListeners;\nlet extractBody;\nasync function lazyllhttp() {\n    const llhttpWasmData = process.env.JEST_WORKER_ID ? __webpack_require__(/*! ../llhttp/llhttp-wasm.js */ \"(ssr)/./node_modules/undici/lib/llhttp/llhttp-wasm.js\") : undefined;\n    let mod;\n    try {\n        mod = await WebAssembly.compile(__webpack_require__(/*! ../llhttp/llhttp_simd-wasm.js */ \"(ssr)/./node_modules/undici/lib/llhttp/llhttp_simd-wasm.js\"));\n    } catch (e) {\n        /* istanbul ignore next */ // We could check if the error was caused by the simd option not\n        // being enabled, but the occurring of this other error\n        // * https://github.com/emscripten-core/emscripten/issues/11495\n        // got me to remove that check to avoid breaking Node 12.\n        mod = await WebAssembly.compile(llhttpWasmData || __webpack_require__(/*! ../llhttp/llhttp-wasm.js */ \"(ssr)/./node_modules/undici/lib/llhttp/llhttp-wasm.js\"));\n    }\n    return await WebAssembly.instantiate(mod, {\n        env: {\n            /* eslint-disable camelcase */ wasm_on_url: (p, at, len)=>{\n                /* istanbul ignore next */ return 0;\n            },\n            wasm_on_status: (p, at, len)=>{\n                assert.strictEqual(currentParser.ptr, p);\n                const start = at - currentBufferPtr + currentBufferRef.byteOffset;\n                return currentParser.onStatus(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;\n            },\n            wasm_on_message_begin: (p)=>{\n                assert.strictEqual(currentParser.ptr, p);\n                return currentParser.onMessageBegin() || 0;\n            },\n            wasm_on_header_field: (p, at, len)=>{\n                assert.strictEqual(currentParser.ptr, p);\n                const start = at - currentBufferPtr + currentBufferRef.byteOffset;\n                return currentParser.onHeaderField(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;\n            },\n            wasm_on_header_value: (p, at, len)=>{\n                assert.strictEqual(currentParser.ptr, p);\n                const start = at - currentBufferPtr + currentBufferRef.byteOffset;\n                return currentParser.onHeaderValue(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;\n            },\n            wasm_on_headers_complete: (p, statusCode, upgrade, shouldKeepAlive)=>{\n                assert.strictEqual(currentParser.ptr, p);\n                return currentParser.onHeadersComplete(statusCode, Boolean(upgrade), Boolean(shouldKeepAlive)) || 0;\n            },\n            wasm_on_body: (p, at, len)=>{\n                assert.strictEqual(currentParser.ptr, p);\n                const start = at - currentBufferPtr + currentBufferRef.byteOffset;\n                return currentParser.onBody(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;\n            },\n            wasm_on_message_complete: (p)=>{\n                assert.strictEqual(currentParser.ptr, p);\n                return currentParser.onMessageComplete() || 0;\n            }\n        }\n    });\n}\nlet llhttpInstance = null;\nlet llhttpPromise = lazyllhttp();\nllhttpPromise.catch();\nlet currentParser = null;\nlet currentBufferRef = null;\nlet currentBufferSize = 0;\nlet currentBufferPtr = null;\nconst TIMEOUT_HEADERS = 1;\nconst TIMEOUT_BODY = 2;\nconst TIMEOUT_IDLE = 3;\nclass Parser {\n    constructor(client, socket, { exports }){\n        assert(Number.isFinite(client[kMaxHeadersSize]) && client[kMaxHeadersSize] > 0);\n        this.llhttp = exports;\n        this.ptr = this.llhttp.llhttp_alloc(constants.TYPE.RESPONSE);\n        this.client = client;\n        this.socket = socket;\n        this.timeout = null;\n        this.timeoutValue = null;\n        this.timeoutType = null;\n        this.statusCode = null;\n        this.statusText = \"\";\n        this.upgrade = false;\n        this.headers = [];\n        this.headersSize = 0;\n        this.headersMaxSize = client[kMaxHeadersSize];\n        this.shouldKeepAlive = false;\n        this.paused = false;\n        this.resume = this.resume.bind(this);\n        this.bytesRead = 0;\n        this.keepAlive = \"\";\n        this.contentLength = \"\";\n        this.connection = \"\";\n        this.maxResponseSize = client[kMaxResponseSize];\n    }\n    setTimeout(value, type) {\n        this.timeoutType = type;\n        if (value !== this.timeoutValue) {\n            timers.clearTimeout(this.timeout);\n            if (value) {\n                this.timeout = timers.setTimeout(onParserTimeout, value, this);\n                // istanbul ignore else: only for jest\n                if (this.timeout.unref) {\n                    this.timeout.unref();\n                }\n            } else {\n                this.timeout = null;\n            }\n            this.timeoutValue = value;\n        } else if (this.timeout) {\n            // istanbul ignore else: only for jest\n            if (this.timeout.refresh) {\n                this.timeout.refresh();\n            }\n        }\n    }\n    resume() {\n        if (this.socket.destroyed || !this.paused) {\n            return;\n        }\n        assert(this.ptr != null);\n        assert(currentParser == null);\n        this.llhttp.llhttp_resume(this.ptr);\n        assert(this.timeoutType === TIMEOUT_BODY);\n        if (this.timeout) {\n            // istanbul ignore else: only for jest\n            if (this.timeout.refresh) {\n                this.timeout.refresh();\n            }\n        }\n        this.paused = false;\n        this.execute(this.socket.read() || EMPTY_BUF); // Flush parser.\n        this.readMore();\n    }\n    readMore() {\n        while(!this.paused && this.ptr){\n            const chunk = this.socket.read();\n            if (chunk === null) {\n                break;\n            }\n            this.execute(chunk);\n        }\n    }\n    execute(data) {\n        assert(this.ptr != null);\n        assert(currentParser == null);\n        assert(!this.paused);\n        const { socket, llhttp } = this;\n        if (data.length > currentBufferSize) {\n            if (currentBufferPtr) {\n                llhttp.free(currentBufferPtr);\n            }\n            currentBufferSize = Math.ceil(data.length / 4096) * 4096;\n            currentBufferPtr = llhttp.malloc(currentBufferSize);\n        }\n        new Uint8Array(llhttp.memory.buffer, currentBufferPtr, currentBufferSize).set(data);\n        // Call `execute` on the wasm parser.\n        // We pass the `llhttp_parser` pointer address, the pointer address of buffer view data,\n        // and finally the length of bytes to parse.\n        // The return value is an error code or `constants.ERROR.OK`.\n        try {\n            let ret;\n            try {\n                currentBufferRef = data;\n                currentParser = this;\n                ret = llhttp.llhttp_execute(this.ptr, currentBufferPtr, data.length);\n            /* eslint-disable-next-line no-useless-catch */ } catch (err) {\n                /* istanbul ignore next: difficult to make a test case for */ throw err;\n            } finally{\n                currentParser = null;\n                currentBufferRef = null;\n            }\n            const offset = llhttp.llhttp_get_error_pos(this.ptr) - currentBufferPtr;\n            if (ret === constants.ERROR.PAUSED_UPGRADE) {\n                this.onUpgrade(data.slice(offset));\n            } else if (ret === constants.ERROR.PAUSED) {\n                this.paused = true;\n                socket.unshift(data.slice(offset));\n            } else if (ret !== constants.ERROR.OK) {\n                const ptr = llhttp.llhttp_get_error_reason(this.ptr);\n                let message = \"\";\n                /* istanbul ignore else: difficult to make a test case for */ if (ptr) {\n                    const len = new Uint8Array(llhttp.memory.buffer, ptr).indexOf(0);\n                    message = \"Response does not match the HTTP/1.1 protocol (\" + Buffer.from(llhttp.memory.buffer, ptr, len).toString() + \")\";\n                }\n                throw new HTTPParserError(message, constants.ERROR[ret], data.slice(offset));\n            }\n        } catch (err) {\n            util.destroy(socket, err);\n        }\n    }\n    destroy() {\n        assert(this.ptr != null);\n        assert(currentParser == null);\n        this.llhttp.llhttp_free(this.ptr);\n        this.ptr = null;\n        timers.clearTimeout(this.timeout);\n        this.timeout = null;\n        this.timeoutValue = null;\n        this.timeoutType = null;\n        this.paused = false;\n    }\n    onStatus(buf) {\n        this.statusText = buf.toString();\n    }\n    onMessageBegin() {\n        const { socket, client } = this;\n        /* istanbul ignore next: difficult to make a test case for */ if (socket.destroyed) {\n            return -1;\n        }\n        const request = client[kQueue][client[kRunningIdx]];\n        if (!request) {\n            return -1;\n        }\n        request.onResponseStarted();\n    }\n    onHeaderField(buf) {\n        const len = this.headers.length;\n        if ((len & 1) === 0) {\n            this.headers.push(buf);\n        } else {\n            this.headers[len - 1] = Buffer.concat([\n                this.headers[len - 1],\n                buf\n            ]);\n        }\n        this.trackHeader(buf.length);\n    }\n    onHeaderValue(buf) {\n        let len = this.headers.length;\n        if ((len & 1) === 1) {\n            this.headers.push(buf);\n            len += 1;\n        } else {\n            this.headers[len - 1] = Buffer.concat([\n                this.headers[len - 1],\n                buf\n            ]);\n        }\n        const key = this.headers[len - 2];\n        if (key.length === 10) {\n            const headerName = util.bufferToLowerCasedHeaderName(key);\n            if (headerName === \"keep-alive\") {\n                this.keepAlive += buf.toString();\n            } else if (headerName === \"connection\") {\n                this.connection += buf.toString();\n            }\n        } else if (key.length === 14 && util.bufferToLowerCasedHeaderName(key) === \"content-length\") {\n            this.contentLength += buf.toString();\n        }\n        this.trackHeader(buf.length);\n    }\n    trackHeader(len) {\n        this.headersSize += len;\n        if (this.headersSize >= this.headersMaxSize) {\n            util.destroy(this.socket, new HeadersOverflowError());\n        }\n    }\n    onUpgrade(head) {\n        const { upgrade, client, socket, headers, statusCode } = this;\n        assert(upgrade);\n        const request = client[kQueue][client[kRunningIdx]];\n        assert(request);\n        assert(!socket.destroyed);\n        assert(socket === client[kSocket]);\n        assert(!this.paused);\n        assert(request.upgrade || request.method === \"CONNECT\");\n        this.statusCode = null;\n        this.statusText = \"\";\n        this.shouldKeepAlive = null;\n        assert(this.headers.length % 2 === 0);\n        this.headers = [];\n        this.headersSize = 0;\n        socket.unshift(head);\n        socket[kParser].destroy();\n        socket[kParser] = null;\n        socket[kClient] = null;\n        socket[kError] = null;\n        removeAllListeners(socket);\n        client[kSocket] = null;\n        client[kHTTPContext] = null; // TODO (fix): This is hacky...\n        client[kQueue][client[kRunningIdx]++] = null;\n        client.emit(\"disconnect\", client[kUrl], [\n            client\n        ], new InformationalError(\"upgrade\"));\n        try {\n            request.onUpgrade(statusCode, headers, socket);\n        } catch (err) {\n            util.destroy(socket, err);\n        }\n        client[kResume]();\n    }\n    onHeadersComplete(statusCode, upgrade, shouldKeepAlive) {\n        const { client, socket, headers, statusText } = this;\n        /* istanbul ignore next: difficult to make a test case for */ if (socket.destroyed) {\n            return -1;\n        }\n        const request = client[kQueue][client[kRunningIdx]];\n        /* istanbul ignore next: difficult to make a test case for */ if (!request) {\n            return -1;\n        }\n        assert(!this.upgrade);\n        assert(this.statusCode < 200);\n        if (statusCode === 100) {\n            util.destroy(socket, new SocketError(\"bad response\", util.getSocketInfo(socket)));\n            return -1;\n        }\n        /* this can only happen if server is misbehaving */ if (upgrade && !request.upgrade) {\n            util.destroy(socket, new SocketError(\"bad upgrade\", util.getSocketInfo(socket)));\n            return -1;\n        }\n        assert.strictEqual(this.timeoutType, TIMEOUT_HEADERS);\n        this.statusCode = statusCode;\n        this.shouldKeepAlive = shouldKeepAlive || // Override llhttp value which does not allow keepAlive for HEAD.\n        request.method === \"HEAD\" && !socket[kReset] && this.connection.toLowerCase() === \"keep-alive\";\n        if (this.statusCode >= 200) {\n            const bodyTimeout = request.bodyTimeout != null ? request.bodyTimeout : client[kBodyTimeout];\n            this.setTimeout(bodyTimeout, TIMEOUT_BODY);\n        } else if (this.timeout) {\n            // istanbul ignore else: only for jest\n            if (this.timeout.refresh) {\n                this.timeout.refresh();\n            }\n        }\n        if (request.method === \"CONNECT\") {\n            assert(client[kRunning] === 1);\n            this.upgrade = true;\n            return 2;\n        }\n        if (upgrade) {\n            assert(client[kRunning] === 1);\n            this.upgrade = true;\n            return 2;\n        }\n        assert(this.headers.length % 2 === 0);\n        this.headers = [];\n        this.headersSize = 0;\n        if (this.shouldKeepAlive && client[kPipelining]) {\n            const keepAliveTimeout = this.keepAlive ? util.parseKeepAliveTimeout(this.keepAlive) : null;\n            if (keepAliveTimeout != null) {\n                const timeout = Math.min(keepAliveTimeout - client[kKeepAliveTimeoutThreshold], client[kKeepAliveMaxTimeout]);\n                if (timeout <= 0) {\n                    socket[kReset] = true;\n                } else {\n                    client[kKeepAliveTimeoutValue] = timeout;\n                }\n            } else {\n                client[kKeepAliveTimeoutValue] = client[kKeepAliveDefaultTimeout];\n            }\n        } else {\n            // Stop more requests from being dispatched.\n            socket[kReset] = true;\n        }\n        const pause = request.onHeaders(statusCode, headers, this.resume, statusText) === false;\n        if (request.aborted) {\n            return -1;\n        }\n        if (request.method === \"HEAD\") {\n            return 1;\n        }\n        if (statusCode < 200) {\n            return 1;\n        }\n        if (socket[kBlocking]) {\n            socket[kBlocking] = false;\n            client[kResume]();\n        }\n        return pause ? constants.ERROR.PAUSED : 0;\n    }\n    onBody(buf) {\n        const { client, socket, statusCode, maxResponseSize } = this;\n        if (socket.destroyed) {\n            return -1;\n        }\n        const request = client[kQueue][client[kRunningIdx]];\n        assert(request);\n        assert.strictEqual(this.timeoutType, TIMEOUT_BODY);\n        if (this.timeout) {\n            // istanbul ignore else: only for jest\n            if (this.timeout.refresh) {\n                this.timeout.refresh();\n            }\n        }\n        assert(statusCode >= 200);\n        if (maxResponseSize > -1 && this.bytesRead + buf.length > maxResponseSize) {\n            util.destroy(socket, new ResponseExceededMaxSizeError());\n            return -1;\n        }\n        this.bytesRead += buf.length;\n        if (request.onData(buf) === false) {\n            return constants.ERROR.PAUSED;\n        }\n    }\n    onMessageComplete() {\n        const { client, socket, statusCode, upgrade, headers, contentLength, bytesRead, shouldKeepAlive } = this;\n        if (socket.destroyed && (!statusCode || shouldKeepAlive)) {\n            return -1;\n        }\n        if (upgrade) {\n            return;\n        }\n        const request = client[kQueue][client[kRunningIdx]];\n        assert(request);\n        assert(statusCode >= 100);\n        this.statusCode = null;\n        this.statusText = \"\";\n        this.bytesRead = 0;\n        this.contentLength = \"\";\n        this.keepAlive = \"\";\n        this.connection = \"\";\n        assert(this.headers.length % 2 === 0);\n        this.headers = [];\n        this.headersSize = 0;\n        if (statusCode < 200) {\n            return;\n        }\n        /* istanbul ignore next: should be handled by llhttp? */ if (request.method !== \"HEAD\" && contentLength && bytesRead !== parseInt(contentLength, 10)) {\n            util.destroy(socket, new ResponseContentLengthMismatchError());\n            return -1;\n        }\n        request.onComplete(headers);\n        client[kQueue][client[kRunningIdx]++] = null;\n        if (socket[kWriting]) {\n            assert.strictEqual(client[kRunning], 0);\n            // Response completed before request.\n            util.destroy(socket, new InformationalError(\"reset\"));\n            return constants.ERROR.PAUSED;\n        } else if (!shouldKeepAlive) {\n            util.destroy(socket, new InformationalError(\"reset\"));\n            return constants.ERROR.PAUSED;\n        } else if (socket[kReset] && client[kRunning] === 0) {\n            // Destroy socket once all requests have completed.\n            // The request at the tail of the pipeline is the one\n            // that requested reset and no further requests should\n            // have been queued since then.\n            util.destroy(socket, new InformationalError(\"reset\"));\n            return constants.ERROR.PAUSED;\n        } else if (client[kPipelining] == null || client[kPipelining] === 1) {\n            // We must wait a full event loop cycle to reuse this socket to make sure\n            // that non-spec compliant servers are not closing the connection even if they\n            // said they won't.\n            setImmediate(()=>client[kResume]());\n        } else {\n            client[kResume]();\n        }\n    }\n}\nfunction onParserTimeout(parser) {\n    const { socket, timeoutType, client } = parser;\n    /* istanbul ignore else */ if (timeoutType === TIMEOUT_HEADERS) {\n        if (!socket[kWriting] || socket.writableNeedDrain || client[kRunning] > 1) {\n            assert(!parser.paused, \"cannot be paused while waiting for headers\");\n            util.destroy(socket, new HeadersTimeoutError());\n        }\n    } else if (timeoutType === TIMEOUT_BODY) {\n        if (!parser.paused) {\n            util.destroy(socket, new BodyTimeoutError());\n        }\n    } else if (timeoutType === TIMEOUT_IDLE) {\n        assert(client[kRunning] === 0 && client[kKeepAliveTimeoutValue]);\n        util.destroy(socket, new InformationalError(\"socket idle timeout\"));\n    }\n}\nasync function connectH1(client, socket) {\n    client[kSocket] = socket;\n    if (!llhttpInstance) {\n        llhttpInstance = await llhttpPromise;\n        llhttpPromise = null;\n    }\n    socket[kNoRef] = false;\n    socket[kWriting] = false;\n    socket[kReset] = false;\n    socket[kBlocking] = false;\n    socket[kParser] = new Parser(client, socket, llhttpInstance);\n    addListener(socket, \"error\", function(err) {\n        const parser = this[kParser];\n        assert(err.code !== \"ERR_TLS_CERT_ALTNAME_INVALID\");\n        // On Mac OS, we get an ECONNRESET even if there is a full body to be forwarded\n        // to the user.\n        if (err.code === \"ECONNRESET\" && parser.statusCode && !parser.shouldKeepAlive) {\n            // We treat all incoming data so for as a valid response.\n            parser.onMessageComplete();\n            return;\n        }\n        this[kError] = err;\n        this[kClient][kOnError](err);\n    });\n    addListener(socket, \"readable\", function() {\n        const parser = this[kParser];\n        if (parser) {\n            parser.readMore();\n        }\n    });\n    addListener(socket, \"end\", function() {\n        const parser = this[kParser];\n        if (parser.statusCode && !parser.shouldKeepAlive) {\n            // We treat all incoming data so far as a valid response.\n            parser.onMessageComplete();\n            return;\n        }\n        util.destroy(this, new SocketError(\"other side closed\", util.getSocketInfo(this)));\n    });\n    addListener(socket, \"close\", function() {\n        const client = this[kClient];\n        const parser = this[kParser];\n        if (parser) {\n            if (!this[kError] && parser.statusCode && !parser.shouldKeepAlive) {\n                // We treat all incoming data so far as a valid response.\n                parser.onMessageComplete();\n            }\n            this[kParser].destroy();\n            this[kParser] = null;\n        }\n        const err = this[kError] || new SocketError(\"closed\", util.getSocketInfo(this));\n        client[kSocket] = null;\n        client[kHTTPContext] = null; // TODO (fix): This is hacky...\n        if (client.destroyed) {\n            assert(client[kPending] === 0);\n            // Fail entire queue.\n            const requests = client[kQueue].splice(client[kRunningIdx]);\n            for(let i = 0; i < requests.length; i++){\n                const request = requests[i];\n                util.errorRequest(client, request, err);\n            }\n        } else if (client[kRunning] > 0 && err.code !== \"UND_ERR_INFO\") {\n            // Fail head of pipeline.\n            const request = client[kQueue][client[kRunningIdx]];\n            client[kQueue][client[kRunningIdx]++] = null;\n            util.errorRequest(client, request, err);\n        }\n        client[kPendingIdx] = client[kRunningIdx];\n        assert(client[kRunning] === 0);\n        client.emit(\"disconnect\", client[kUrl], [\n            client\n        ], err);\n        client[kResume]();\n    });\n    let closed = false;\n    socket.on(\"close\", ()=>{\n        closed = true;\n    });\n    return {\n        version: \"h1\",\n        defaultPipelining: 1,\n        write (...args) {\n            return writeH1(client, ...args);\n        },\n        resume () {\n            resumeH1(client);\n        },\n        destroy (err, callback) {\n            if (closed) {\n                queueMicrotask(callback);\n            } else {\n                socket.destroy(err).on(\"close\", callback);\n            }\n        },\n        get destroyed () {\n            return socket.destroyed;\n        },\n        busy (request) {\n            if (socket[kWriting] || socket[kReset] || socket[kBlocking]) {\n                return true;\n            }\n            if (request) {\n                if (client[kRunning] > 0 && !request.idempotent) {\n                    // Non-idempotent request cannot be retried.\n                    // Ensure that no other requests are inflight and\n                    // could cause failure.\n                    return true;\n                }\n                if (client[kRunning] > 0 && (request.upgrade || request.method === \"CONNECT\")) {\n                    // Don't dispatch an upgrade until all preceding requests have completed.\n                    // A misbehaving server might upgrade the connection before all pipelined\n                    // request has completed.\n                    return true;\n                }\n                if (client[kRunning] > 0 && util.bodyLength(request.body) !== 0 && (util.isStream(request.body) || util.isAsyncIterable(request.body) || util.isFormDataLike(request.body))) {\n                    // Request with stream or iterator body can error while other requests\n                    // are inflight and indirectly error those as well.\n                    // Ensure this doesn't happen by waiting for inflight\n                    // to complete before dispatching.\n                    // Request with stream or iterator body cannot be retried.\n                    // Ensure that no other requests are inflight and\n                    // could cause failure.\n                    return true;\n                }\n            }\n            return false;\n        }\n    };\n}\nfunction resumeH1(client) {\n    const socket = client[kSocket];\n    if (socket && !socket.destroyed) {\n        if (client[kSize] === 0) {\n            if (!socket[kNoRef] && socket.unref) {\n                socket.unref();\n                socket[kNoRef] = true;\n            }\n        } else if (socket[kNoRef] && socket.ref) {\n            socket.ref();\n            socket[kNoRef] = false;\n        }\n        if (client[kSize] === 0) {\n            if (socket[kParser].timeoutType !== TIMEOUT_IDLE) {\n                socket[kParser].setTimeout(client[kKeepAliveTimeoutValue], TIMEOUT_IDLE);\n            }\n        } else if (client[kRunning] > 0 && socket[kParser].statusCode < 200) {\n            if (socket[kParser].timeoutType !== TIMEOUT_HEADERS) {\n                const request = client[kQueue][client[kRunningIdx]];\n                const headersTimeout = request.headersTimeout != null ? request.headersTimeout : client[kHeadersTimeout];\n                socket[kParser].setTimeout(headersTimeout, TIMEOUT_HEADERS);\n            }\n        }\n    }\n}\n// https://www.rfc-editor.org/rfc/rfc7230#section-3.3.2\nfunction shouldSendContentLength(method) {\n    return method !== \"GET\" && method !== \"HEAD\" && method !== \"OPTIONS\" && method !== \"TRACE\" && method !== \"CONNECT\";\n}\nfunction writeH1(client, request) {\n    const { method, path, host, upgrade, blocking, reset } = request;\n    let { body, headers, contentLength } = request;\n    // https://tools.ietf.org/html/rfc7231#section-4.3.1\n    // https://tools.ietf.org/html/rfc7231#section-4.3.2\n    // https://tools.ietf.org/html/rfc7231#section-4.3.5\n    // Sending a payload body on a request that does not\n    // expect it can cause undefined behavior on some\n    // servers and corrupt connection state. Do not\n    // re-use the connection for further requests.\n    const expectsPayload = method === \"PUT\" || method === \"POST\" || method === \"PATCH\";\n    if (util.isFormDataLike(body)) {\n        if (!extractBody) {\n            extractBody = (__webpack_require__(/*! ../web/fetch/body.js */ \"(ssr)/./node_modules/undici/lib/web/fetch/body.js\").extractBody);\n        }\n        const [bodyStream, contentType] = extractBody(body);\n        if (request.contentType == null) {\n            headers.push(\"content-type\", contentType);\n        }\n        body = bodyStream.stream;\n        contentLength = bodyStream.length;\n    } else if (util.isBlobLike(body) && request.contentType == null && body.type) {\n        headers.push(\"content-type\", body.type);\n    }\n    if (body && typeof body.read === \"function\") {\n        // Try to read EOF in order to get length.\n        body.read(0);\n    }\n    const bodyLength = util.bodyLength(body);\n    contentLength = bodyLength ?? contentLength;\n    if (contentLength === null) {\n        contentLength = request.contentLength;\n    }\n    if (contentLength === 0 && !expectsPayload) {\n        // https://tools.ietf.org/html/rfc7230#section-3.3.2\n        // A user agent SHOULD NOT send a Content-Length header field when\n        // the request message does not contain a payload body and the method\n        // semantics do not anticipate such a body.\n        contentLength = null;\n    }\n    // https://github.com/nodejs/undici/issues/2046\n    // A user agent may send a Content-Length header with 0 value, this should be allowed.\n    if (shouldSendContentLength(method) && contentLength > 0 && request.contentLength !== null && request.contentLength !== contentLength) {\n        if (client[kStrictContentLength]) {\n            util.errorRequest(client, request, new RequestContentLengthMismatchError());\n            return false;\n        }\n        process.emitWarning(new RequestContentLengthMismatchError());\n    }\n    const socket = client[kSocket];\n    const abort = (err)=>{\n        if (request.aborted || request.completed) {\n            return;\n        }\n        util.errorRequest(client, request, err || new RequestAbortedError());\n        util.destroy(body);\n        util.destroy(socket, new InformationalError(\"aborted\"));\n    };\n    try {\n        request.onConnect(abort);\n    } catch (err) {\n        util.errorRequest(client, request, err);\n    }\n    if (request.aborted) {\n        return false;\n    }\n    if (method === \"HEAD\") {\n        // https://github.com/mcollina/undici/issues/258\n        // Close after a HEAD request to interop with misbehaving servers\n        // that may send a body in the response.\n        socket[kReset] = true;\n    }\n    if (upgrade || method === \"CONNECT\") {\n        // On CONNECT or upgrade, block pipeline from dispatching further\n        // requests on this connection.\n        socket[kReset] = true;\n    }\n    if (reset != null) {\n        socket[kReset] = reset;\n    }\n    if (client[kMaxRequests] && socket[kCounter]++ >= client[kMaxRequests]) {\n        socket[kReset] = true;\n    }\n    if (blocking) {\n        socket[kBlocking] = true;\n    }\n    let header = `${method} ${path} HTTP/1.1\\r\\n`;\n    if (typeof host === \"string\") {\n        header += `host: ${host}\\r\\n`;\n    } else {\n        header += client[kHostHeader];\n    }\n    if (upgrade) {\n        header += `connection: upgrade\\r\\nupgrade: ${upgrade}\\r\\n`;\n    } else if (client[kPipelining] && !socket[kReset]) {\n        header += \"connection: keep-alive\\r\\n\";\n    } else {\n        header += \"connection: close\\r\\n\";\n    }\n    if (Array.isArray(headers)) {\n        for(let n = 0; n < headers.length; n += 2){\n            const key = headers[n + 0];\n            const val = headers[n + 1];\n            if (Array.isArray(val)) {\n                for(let i = 0; i < val.length; i++){\n                    header += `${key}: ${val[i]}\\r\\n`;\n                }\n            } else {\n                header += `${key}: ${val}\\r\\n`;\n            }\n        }\n    }\n    if (channels.sendHeaders.hasSubscribers) {\n        channels.sendHeaders.publish({\n            request,\n            headers: header,\n            socket\n        });\n    }\n    /* istanbul ignore else: assertion */ if (!body || bodyLength === 0) {\n        writeBuffer(abort, null, client, request, socket, contentLength, header, expectsPayload);\n    } else if (util.isBuffer(body)) {\n        writeBuffer(abort, body, client, request, socket, contentLength, header, expectsPayload);\n    } else if (util.isBlobLike(body)) {\n        if (typeof body.stream === \"function\") {\n            writeIterable(abort, body.stream(), client, request, socket, contentLength, header, expectsPayload);\n        } else {\n            writeBlob(abort, body, client, request, socket, contentLength, header, expectsPayload);\n        }\n    } else if (util.isStream(body)) {\n        writeStream(abort, body, client, request, socket, contentLength, header, expectsPayload);\n    } else if (util.isIterable(body)) {\n        writeIterable(abort, body, client, request, socket, contentLength, header, expectsPayload);\n    } else {\n        assert(false);\n    }\n    return true;\n}\nfunction writeStream(abort, body, client, request, socket, contentLength, header, expectsPayload) {\n    assert(contentLength !== 0 || client[kRunning] === 0, \"stream body cannot be pipelined\");\n    let finished = false;\n    const writer = new AsyncWriter({\n        abort,\n        socket,\n        request,\n        contentLength,\n        client,\n        expectsPayload,\n        header\n    });\n    const onData = function(chunk) {\n        if (finished) {\n            return;\n        }\n        try {\n            if (!writer.write(chunk) && this.pause) {\n                this.pause();\n            }\n        } catch (err) {\n            util.destroy(this, err);\n        }\n    };\n    const onDrain = function() {\n        if (finished) {\n            return;\n        }\n        if (body.resume) {\n            body.resume();\n        }\n    };\n    const onClose = function() {\n        // 'close' might be emitted *before* 'error' for\n        // broken streams. Wait a tick to avoid this case.\n        queueMicrotask(()=>{\n            // It's only safe to remove 'error' listener after\n            // 'close'.\n            body.removeListener(\"error\", onFinished);\n        });\n        if (!finished) {\n            const err = new RequestAbortedError();\n            queueMicrotask(()=>onFinished(err));\n        }\n    };\n    const onFinished = function(err) {\n        if (finished) {\n            return;\n        }\n        finished = true;\n        assert(socket.destroyed || socket[kWriting] && client[kRunning] <= 1);\n        socket.off(\"drain\", onDrain).off(\"error\", onFinished);\n        body.removeListener(\"data\", onData).removeListener(\"end\", onFinished).removeListener(\"close\", onClose);\n        if (!err) {\n            try {\n                writer.end();\n            } catch (er) {\n                err = er;\n            }\n        }\n        writer.destroy(err);\n        if (err && (err.code !== \"UND_ERR_INFO\" || err.message !== \"reset\")) {\n            util.destroy(body, err);\n        } else {\n            util.destroy(body);\n        }\n    };\n    body.on(\"data\", onData).on(\"end\", onFinished).on(\"error\", onFinished).on(\"close\", onClose);\n    if (body.resume) {\n        body.resume();\n    }\n    socket.on(\"drain\", onDrain).on(\"error\", onFinished);\n    if (body.errorEmitted ?? body.errored) {\n        setImmediate(()=>onFinished(body.errored));\n    } else if (body.endEmitted ?? body.readableEnded) {\n        setImmediate(()=>onFinished(null));\n    }\n    if (body.closeEmitted ?? body.closed) {\n        setImmediate(onClose);\n    }\n}\nfunction writeBuffer(abort, body, client, request, socket, contentLength, header, expectsPayload) {\n    try {\n        if (!body) {\n            if (contentLength === 0) {\n                socket.write(`${header}content-length: 0\\r\\n\\r\\n`, \"latin1\");\n            } else {\n                assert(contentLength === null, \"no body must not have content length\");\n                socket.write(`${header}\\r\\n`, \"latin1\");\n            }\n        } else if (util.isBuffer(body)) {\n            assert(contentLength === body.byteLength, \"buffer body must have content length\");\n            socket.cork();\n            socket.write(`${header}content-length: ${contentLength}\\r\\n\\r\\n`, \"latin1\");\n            socket.write(body);\n            socket.uncork();\n            request.onBodySent(body);\n            if (!expectsPayload) {\n                socket[kReset] = true;\n            }\n        }\n        request.onRequestSent();\n        client[kResume]();\n    } catch (err) {\n        abort(err);\n    }\n}\nasync function writeBlob(abort, body, client, request, socket, contentLength, header, expectsPayload) {\n    assert(contentLength === body.size, \"blob body must have content length\");\n    try {\n        if (contentLength != null && contentLength !== body.size) {\n            throw new RequestContentLengthMismatchError();\n        }\n        const buffer = Buffer.from(await body.arrayBuffer());\n        socket.cork();\n        socket.write(`${header}content-length: ${contentLength}\\r\\n\\r\\n`, \"latin1\");\n        socket.write(buffer);\n        socket.uncork();\n        request.onBodySent(buffer);\n        request.onRequestSent();\n        if (!expectsPayload) {\n            socket[kReset] = true;\n        }\n        client[kResume]();\n    } catch (err) {\n        abort(err);\n    }\n}\nasync function writeIterable(abort, body, client, request, socket, contentLength, header, expectsPayload) {\n    assert(contentLength !== 0 || client[kRunning] === 0, \"iterator body cannot be pipelined\");\n    let callback = null;\n    function onDrain() {\n        if (callback) {\n            const cb = callback;\n            callback = null;\n            cb();\n        }\n    }\n    const waitForDrain = ()=>new Promise((resolve, reject)=>{\n            assert(callback === null);\n            if (socket[kError]) {\n                reject(socket[kError]);\n            } else {\n                callback = resolve;\n            }\n        });\n    socket.on(\"close\", onDrain).on(\"drain\", onDrain);\n    const writer = new AsyncWriter({\n        abort,\n        socket,\n        request,\n        contentLength,\n        client,\n        expectsPayload,\n        header\n    });\n    try {\n        // It's up to the user to somehow abort the async iterable.\n        for await (const chunk of body){\n            if (socket[kError]) {\n                throw socket[kError];\n            }\n            if (!writer.write(chunk)) {\n                await waitForDrain();\n            }\n        }\n        writer.end();\n    } catch (err) {\n        writer.destroy(err);\n    } finally{\n        socket.off(\"close\", onDrain).off(\"drain\", onDrain);\n    }\n}\nclass AsyncWriter {\n    constructor({ abort, socket, request, contentLength, client, expectsPayload, header }){\n        this.socket = socket;\n        this.request = request;\n        this.contentLength = contentLength;\n        this.client = client;\n        this.bytesWritten = 0;\n        this.expectsPayload = expectsPayload;\n        this.header = header;\n        this.abort = abort;\n        socket[kWriting] = true;\n    }\n    write(chunk) {\n        const { socket, request, contentLength, client, bytesWritten, expectsPayload, header } = this;\n        if (socket[kError]) {\n            throw socket[kError];\n        }\n        if (socket.destroyed) {\n            return false;\n        }\n        const len = Buffer.byteLength(chunk);\n        if (!len) {\n            return true;\n        }\n        // We should defer writing chunks.\n        if (contentLength !== null && bytesWritten + len > contentLength) {\n            if (client[kStrictContentLength]) {\n                throw new RequestContentLengthMismatchError();\n            }\n            process.emitWarning(new RequestContentLengthMismatchError());\n        }\n        socket.cork();\n        if (bytesWritten === 0) {\n            if (!expectsPayload) {\n                socket[kReset] = true;\n            }\n            if (contentLength === null) {\n                socket.write(`${header}transfer-encoding: chunked\\r\\n`, \"latin1\");\n            } else {\n                socket.write(`${header}content-length: ${contentLength}\\r\\n\\r\\n`, \"latin1\");\n            }\n        }\n        if (contentLength === null) {\n            socket.write(`\\r\\n${len.toString(16)}\\r\\n`, \"latin1\");\n        }\n        this.bytesWritten += len;\n        const ret = socket.write(chunk);\n        socket.uncork();\n        request.onBodySent(chunk);\n        if (!ret) {\n            if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {\n                // istanbul ignore else: only for jest\n                if (socket[kParser].timeout.refresh) {\n                    socket[kParser].timeout.refresh();\n                }\n            }\n        }\n        return ret;\n    }\n    end() {\n        const { socket, contentLength, client, bytesWritten, expectsPayload, header, request } = this;\n        request.onRequestSent();\n        socket[kWriting] = false;\n        if (socket[kError]) {\n            throw socket[kError];\n        }\n        if (socket.destroyed) {\n            return;\n        }\n        if (bytesWritten === 0) {\n            if (expectsPayload) {\n                // https://tools.ietf.org/html/rfc7230#section-3.3.2\n                // A user agent SHOULD send a Content-Length in a request message when\n                // no Transfer-Encoding is sent and the request method defines a meaning\n                // for an enclosed payload body.\n                socket.write(`${header}content-length: 0\\r\\n\\r\\n`, \"latin1\");\n            } else {\n                socket.write(`${header}\\r\\n`, \"latin1\");\n            }\n        } else if (contentLength === null) {\n            socket.write(\"\\r\\n0\\r\\n\\r\\n\", \"latin1\");\n        }\n        if (contentLength !== null && bytesWritten !== contentLength) {\n            if (client[kStrictContentLength]) {\n                throw new RequestContentLengthMismatchError();\n            } else {\n                process.emitWarning(new RequestContentLengthMismatchError());\n            }\n        }\n        if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {\n            // istanbul ignore else: only for jest\n            if (socket[kParser].timeout.refresh) {\n                socket[kParser].timeout.refresh();\n            }\n        }\n        client[kResume]();\n    }\n    destroy(err) {\n        const { socket, client, abort } = this;\n        socket[kWriting] = false;\n        if (err) {\n            assert(client[kRunning] <= 1, \"pipeline should only contain this request\");\n            abort(err);\n        }\n    }\n}\nmodule.exports = connectH1;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9kaXNwYXRjaGVyL2NsaWVudC1oMS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLHlCQUVBLE1BQU1BLFNBQVNDLG1CQUFPQSxDQUFDO0FBQ3ZCLE1BQU1DLE9BQU9ELG1CQUFPQSxDQUFDO0FBQ3JCLE1BQU0sRUFBRUUsUUFBQUEsRUFBVSxHQUFHRixtQkFBT0EsQ0FBQztBQUM3QixNQUFNRyxTQUFTSCxtQkFBT0EsQ0FBQztBQUN2QixNQUFNLEVBQ0pJLGlDQUFpQyxFQUNqQ0Msa0NBQWtDLEVBQ2xDQyxtQkFBbUIsRUFDbkJDLG1CQUFtQixFQUNuQkMsb0JBQW9CLEVBQ3BCQyxXQUFXLEVBQ1hDLGtCQUFrQixFQUNsQkMsZ0JBQWdCLEVBQ2hCQyxlQUFlLEVBQ2ZDLDRCQUFBQSxFQUNELEdBQUdiLG1CQUFPQSxDQUFDO0FBQ1osTUFBTSxFQUNKYyxJQUFJLEVBQ0pDLE1BQU0sRUFDTkMsT0FBTyxFQUNQQyxPQUFPLEVBQ1BDLFNBQVMsRUFDVEMsUUFBUSxFQUNSQyxRQUFRLEVBQ1JDLEtBQUssRUFDTEMsUUFBUSxFQUNSQyxNQUFNLEVBQ05DLE1BQU0sRUFDTkMsd0JBQXdCLEVBQ3hCQyxXQUFXLEVBQ1hDLFdBQVcsRUFDWEMsV0FBVyxFQUNYQyxNQUFNLEVBQ05DLFdBQVcsRUFDWEMsT0FBTyxFQUNQQyxzQkFBc0IsRUFDdEJDLGVBQWUsRUFDZkMsb0JBQW9CLEVBQ3BCQywwQkFBMEIsRUFDMUJDLGVBQWUsRUFDZkMsWUFBWSxFQUNaQyxvQkFBb0IsRUFDcEJDLFlBQVksRUFDWkMsUUFBUSxFQUNSQyxnQkFBZ0IsRUFDaEJDLFFBQVEsRUFDUkMsT0FBTyxFQUNQQyxZQUFBQSxFQUNELEdBQUc1QyxtQkFBT0EsQ0FBQztBQUVaLE1BQU02QyxZQUFZN0MsbUJBQU9BLENBQUM7QUFDMUIsTUFBTThDLFlBQVlDLE9BQU9DLEtBQUssQ0FBQztBQUMvQixNQUFNQyxhQUFhRixNQUFNLENBQUNHLE9BQU9DLE9B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QyxJQUFJcE87WUFDMUI7UUFDRjtRQUVBLElBQUlzRyxNQUFNLENBQUN6RixRQUFRLENBQUNpRyxPQUFPLElBQUlSLE1BQU0sQ0FBQ3pGLFFBQVEsQ0FBQ21HLFdBQVcsS0FBS2hCLGlCQUFpQjtZQUM5RTtZQUNBLElBQUlNLE1BQU0sQ0FBQ3pGLFFBQVEsQ0FBQ2lHLE9BQU8sQ0FBQ3FCLE9BQU8sRUFBRTtnQkFDbkM3QixNQUFNLENBQUN6RixRQUFRLENBQUNpRyxPQUFPLENBQUNxQixPQUFPO1lBQ2pDO1FBQ0Y7UUFFQTlCLE1BQU0sQ0FBQzlELFFBQVE7SUFDakI7SUFFQTZILFFBQVNmLEdBQUcsRUFBRTtRQUNaLE1BQU0sRUFBRS9DLE1BQU0sRUFBRUQsTUFBTSxFQUFFZ0ksS0FBQUEsRUFBTyxHQUFHLElBQUk7UUFFdEMvSCxNQUFNLENBQUNwRixTQUFTLEdBQUc7UUFFbkIsSUFBSW1JLEtBQUs7WUFDUDFKLE9BQU8wRyxNQUFNLENBQUN0RixTQUFTLElBQUksR0FBRztZQUM5QnNOLE1BQU1oRjtRQUNSO0lBQ0Y7QUFDRjtBQUVBNkgsT0FBTzNLLE9BQU8sR0FBRzBGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbW9ja3VwZmxvdy8uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2Rpc3BhdGNoZXIvY2xpZW50LWgxLmpzP2IxMDgiLCJ3ZWJwYWNrOi8vbW9ja3VwZmxvdy8uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2Rpc3BhdGNoZXIvY2xpZW50LWgxLmpzP2IxMDgqIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG4vKiBnbG9iYWwgV2ViQXNzZW1ibHkgKi9cblxuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZSgnbm9kZTphc3NlcnQnKVxuY29uc3QgdXRpbCA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbC5qcycpXG5jb25zdCB7IGNoYW5uZWxzIH0gPSByZXF1aXJlKCcuLi9jb3JlL2RpYWdub3N0aWNzLmpzJylcbmNvbnN0IHRpbWVycyA9IHJlcXVpcmUoJy4uL3V0aWwvdGltZXJzLmpzJylcbmNvbnN0IHtcbiAgUmVxdWVzdENvbnRlbnRMZW5ndGhNaXNtYXRjaEVycm9yLFxuICBSZXNwb25zZUNvbnRlbnRMZW5ndGhNaXNtYXRjaEVycm9yLFxuICBSZXF1ZXN0QWJvcnRlZEVycm9yLFxuICBIZWFkZXJzVGltZW91dEVycm9yLFxuICBIZWFkZXJzT3ZlcmZsb3dFcnJvcixcbiAgU29ja2V0RXJyb3IsXG4gIEluZm9ybWF0aW9uYWxFcnJvcixcbiAgQm9keVRpbWVvdXRFcnJvcixcbiAgSFRUUFBhcnNlckVycm9yLFxuICBSZXNwb25zZUV4Y2VlZGVkTWF4U2l6ZUVycm9yXG59ID0gcmVxdWlyZSgnLi4vY29yZS9lcnJvcnMuanMnKVxuY29uc3Qge1xuICBrVXJsLFxuICBrUmVzZXQsXG4gIGtDbGllbnQsXG4gIGtQYXJzZXIsXG4gIGtCbG9ja2luZyxcbiAga1J1bm5pbmcsXG4gIGtQZW5kaW5nLFxuICBrU2l6ZSxcbiAga1dyaXRpbmcsXG4gIGtRdWV1ZSxcbiAga05vUmVmLFxuICBrS2VlcEFsaXZlRGVmYXVsdFRpbWVvdXQsXG4gIGtIb3N0SGVhZGVyLFxuICBrUGVuZGluZ0lkeCxcbiAga1J1bm5pbmdJZHgsXG4gIGtFcnJvcixcbiAga1BpcGVsaW5pbmcsXG4gIGtTb2NrZXQsXG4gIGtLZWVwQWxpdmVUaW1lb3V0VmFsdWUsXG4gIGtNYXhIZWFkZXJzU2l6ZSxcbiAga0tlZXBBbGl2ZU1heFRpbWVvdXQsXG4gIGtLZWVwQWxpdmVUaW1lb3V0VGhyZXNob2xkLFxuICBrSGVhZGVyc1RpbWVvdXQsXG4gIGtCb2R5VGltZW91dCxcbiAga1N0cmljdENvbnRlbnRMZW5ndGgsXG4gIGtNYXhSZXF1ZXN0cyxcbiAga0NvdW50ZXIsXG4gIGtNYXhSZXNwb25zZVNpemUsXG4gIGtPbkVycm9yLFxuICBrUmVzdW1lLFxuICBrSFRUUENvbnRleHRcbn0gPSByZXF1aXJlKCcuLi9jb3JlL3N5bWJvbHMuanMnKVxuXG5jb25zdCBjb25zdGFudHMgPSByZXF1aXJlKCcuLi9sbGh0dHAvY29uc3RhbnRzLmpzJylcbmNvbnN0IEVNUFRZX0JVRiA9IEJ1ZmZlci5hbGxvYygwKVxuY29uc3QgRmFzdEJ1ZmZlciA9IEJ1ZmZlcltTeW1ib2wuc3BlY2llc11cbmNvbnN0IGFkZExpc3RlbmVyID0gdXRpbC5hZGRMaXN0ZW5lclxuY29uc3QgcmVtb3ZlQWxsTGlzdGVuZXJzID0gdXRpbC5yZW1vdmVBbGxMaXN0ZW5lcnNcblxubGV0IGV4dHJhY3RCb2R5XG5cbmFzeW5jIGZ1bmN0aW9uIGxhenlsbGh0dHAgKCkge1xuICBjb25zdCBsbGh0dHBXYXNtRGF0YSA9IHByb2Nlc3MuZW52LkpFU1RfV09SS0VSX0lEID8gcmVxdWlyZSgnLi4vbGxodHRwL2xsaHR0cC13YXNtLmpzJykgOiB1bmRlZmluZWRcblxuICBsZXQgbW9kXG4gIHRyeSB7XG4gICAgbW9kID0gYXdhaXQgV2ViQXNzZW1ibHkuY29tcGlsZShyZXF1aXJlKCcuLi9sbGh0dHAvbGxodHRwX3NpbWQtd2FzbS5qcycpKVxuICB9IGNhdGNoIChlKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblxuICAgIC8vIFdlIGNvdWxkIGNoZWNrIGlmIHRoZSBlcnJvciB3YXMgY2F1c2VkIGJ5IHRoZSBzaW1kIG9wdGlvbiBub3RcbiAgICAvLyBiZWluZyBlbmFibGVkLCBidXQgdGhlIG9jY3VycmluZyBvZiB0aGlzIG90aGVyIGVycm9yXG4gICAgLy8gKiBodHRwczovL2dpdGh1Yi5jb20vZW1zY3JpcHRlbi1jb3JlL2Vtc2NyaXB0ZW4vaXNzdWVzLzExNDk1XG4gICAgLy8gZ290IG1lIHRvIHJlbW92ZSB0aGF0IGNoZWNrIHRvIGF2b2lkIGJyZWFraW5nIE5vZGUgMTIuXG4gICAgbW9kID0gYXdhaXQgV2ViQXNzZW1ibHkuY29tcGlsZShsbGh0dHBXYXNtRGF0YSB8fCByZXF1aXJlKCcuLi9sbGh0dHAvbGxodHRwLXdhc20uanMnKSlcbiAgfVxuXG4gIHJldHVybiBhd2FpdCBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZShtb2QsIHtcbiAgICBlbnY6IHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIGNhbWVsY2FzZSAqL1xuXG4gICAgICB3YXNtX29uX3VybDogKHAsIGF0LCBsZW4pID0+IHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgcmV0dXJuIDBcbiAgICAgIH0sXG4gICAgICB3YXNtX29uX3N0YXR1czogKHAsIGF0LCBsZW4pID0+IHtcbiAgICAgICAgYXNzZXJ0LnN0cmljdEVxdWFsKGN1cnJlbnRQYXJzZXIucHRyLCBwKVxuICAgICAgICBjb25zdCBzdGFydCA9IGF0IC0gY3VycmVudEJ1ZmZlclB0ciArIGN1cnJlbnRCdWZmZXJSZWYuYnl0ZU9mZnNldFxuICAgICAgICByZXR1cm4gY3VycmVudFBhcnNlci5vblN0YXR1cyhuZXcgRmFzdEJ1ZmZlcihjdXJyZW50QnVmZmVyUmVmLmJ1ZmZlciwgc3RhcnQsIGxlbikpIHx8IDBcbiAgICAgIH0sXG4gICAgICB3YXNtX29uX21lc3NhZ2VfYmVnaW46IChwKSA9PiB7XG4gICAgICAgIGFzc2VydC5zdHJpY3RFcXVhbChjdXJyZW50UGFyc2VyLnB0ciwgcClcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRQYXJzZXIub25NZXNzYWdlQmVnaW4oKSB8fCAwXG4gICAgICB9LFxuICAgICAgd2FzbV9vbl9oZWFkZXJfZmllbGQ6IChwLCBhdCwgbGVuKSA9PiB7XG4gICAgICAgIGFzc2VydC5zdHJpY3RFcXVhbChjdXJyZW50UGFyc2VyLnB0ciwgcClcbiAgICAgICAgY29uc3Qgc3RhcnQgPSBhdCAtIGN1cnJlbnRCdWZmZXJQdHIgKyBjdXJyZW50QnVmZmVyUmVmLmJ5dGVPZmZzZXRcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRQYXJzZXIub25IZWFkZXJGaWVsZChuZXcgRmFzdEJ1ZmZlcihjdXJyZW50QnVmZmVyUmVmLmJ1ZmZlciwgc3RhcnQsIGxlbikpIHx8IDBcbiAgICAgIH0sXG4gICAgICB3YXNtX29uX2hlYWRlcl92YWx1ZTogKHAsIGF0LCBsZW4pID0+IHtcbiAgICAgICAgYXNzZXJ0LnN0cmljdEVxdWFsKGN1cnJlbnRQYXJzZXIucHRyLCBwKVxuICAgICAgICBjb25zdCBzdGFydCA9IGF0IC0gY3VycmVudEJ1ZmZlclB0ciArIGN1cnJlbnRCdWZmZXJSZWYuYnl0ZU9mZnNldFxuICAgICAgICByZXR1cm4gY3VycmVudFBhcnNlci5vbkhlYWRlclZhbHVlKG5ldyBGYXN0QnVmZmVyKGN1cnJlbnRCdWZmZXJSZWYuYnVmZmVyLCBzdGFydCwgbGVuKSkgfHwgMFxuICAgICAgfSxcbiAgICAgIHdhc21fb25faGVhZGVyc19jb21wbGV0ZTogKHAsIHN0YXR1c0NvZGUsIHVwZ3JhZGUsIHNob3VsZEtlZXBBbGl2ZSkgPT4ge1xuICAgICAgICBhc3NlcnQuc3RyaWN0RXF1YWwoY3VycmVudFBhcnNlci5wdHIsIHApXG4gICAgICAgIHJldHVybiBjdXJyZW50UGFyc2VyLm9uSGVhZGVyc0NvbXBsZXRlKHN0YXR1c0NvZGUsIEJvb2xlYW4odXBncmFkZSksIEJvb2xlYW4oc2hvdWxkS2VlcEFsaXZlKSkgfHwgMFxuICAgICAgfSxcbiAgICAgIHdhc21fb25fYm9keTogKHAsIGF0LCBsZW4pID0+IHtcbiAgICAgICAgYXNzZXJ0LnN0cmljdEVxdWFsKGN1cnJlbnRQYXJzZXIucHRyLCBwKVxuICAgICAgICBjb25zdCBzdGFydCA9IGF0IC0gY3VycmVudEJ1ZmZlclB0ciArIGN1cnJlbnRCdWZmZXJSZWYuYnl0ZU9mZnNldFxuICAgICAgICByZXR1cm4gY3VycmVudFBhcnNlci5vbkJvZHkobmV3IEZhc3RCdWZmZXIoY3VycmVudEJ1ZmZlclJlZi5idWZmZXIsIHN0YXJ0LCBsZW4pKSB8fCAwXG4gICAgICB9LFxuICAgICAgd2FzbV9vbl9tZXNzYWdlX2NvbXBsZXRlOiAocCkgPT4ge1xuICAgICAgICBhc3NlcnQuc3RyaWN0RXF1YWwoY3VycmVudFBhcnNlci5wdHIsIHApXG4gICAgICAgIHJldHVybiBjdXJyZW50UGFyc2VyLm9uTWVzc2FnZUNvbXBsZXRlKCkgfHwgMFxuICAgICAgfVxuXG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIGNhbWVsY2FzZSAqL1xuICAgIH1cbiAgfSlcbn1cblxubGV0IGxsaHR0cEluc3RhbmNlID0gbnVsbFxubGV0IGxsaHR0cFByb21pc2UgPSBsYXp5bGxodHRwKClcbmxsaHR0cFByb21pc2UuY2F0Y2goKVxuXG5sZXQgY3VycmVudFBhcnNlciA9IG51bGxcbmxldCBjdXJyZW50QnVmZmVyUmVmID0gbnVsbFxubGV0IGN1cnJlbnRCdWZmZXJTaXplID0gMFxubGV0IGN1cnJlbnRCdWZmZXJQdHIgPSBudWxsXG5cbmNvbnN0IFRJTUVPVVRfSEVBREVSUyA9IDFcbmNvbnN0IFRJTUVPVVRfQk9EWSA9IDJcbmNvbnN0IFRJTUVPVVRfSURMRSA9IDNcblxuY2xhc3MgUGFyc2VyIHtcbiAgY29uc3RydWN0b3IgKGNsaWVudCwgc29ja2V0LCB7IGV4cG9ydHMgfSkge1xuICAgIGFzc2VydChOdW1iZXIuaXNGaW5pdGUoY2xpZW50W2tNYXhIZWFkZXJzU2l6ZV0pICYmIGNsaWVudFtrTWF4SGVhZGVyc1NpemVdID4gMClcblxuICAgIHRoaXMubGxodHRwID0gZXhwb3J0c1xuICAgIHRoaXMucHRyID0gdGhpcy5sbGh0dHAubGxodHRwX2FsbG9jKGNvbnN0YW50cy5UWVBFLlJFU1BPTlNFKVxuICAgIHRoaXMuY2xpZW50ID0gY2xpZW50XG4gICAgdGhpcy5zb2NrZXQgPSBzb2NrZXRcbiAgICB0aGlzLnRpbWVvdXQgPSBudWxsXG4gICAgdGhpcy50aW1lb3V0VmFsdWUgPSBudWxsXG4gICAgdGhpcy50aW1lb3V0VHlwZSA9IG51bGxcbiAgICB0aGlzLnN0YXR1c0NvZGUgPSBudWxsXG4gICAgdGhpcy5zdGF0dXNUZXh0ID0gJydcbiAgICB0aGlzLnVwZ3JhZGUgPSBmYWxzZVxuICAgIHRoaXMuaGVhZGVycyA9IFtdXG4gICAgdGhpcy5oZWFkZXJzU2l6ZSA9IDBcbiAgICB0aGlzLmhlYWRlcnNNYXhTaXplID0gY2xpZW50W2tNYXhIZWFkZXJzU2l6ZV1cbiAgICB0aGlzLnNob3VsZEtlZXBBbGl2ZSA9IGZhbHNlXG4gICAgdGhpcy5wYXVzZWQgPSBmYWxzZVxuICAgIHRoaXMucmVzdW1lID0gdGhpcy5yZXN1bWUuYmluZCh0aGlzKVxuXG4gICAgdGhpcy5ieXRlc1JlYWQgPSAwXG5cbiAgICB0aGlzLmtlZXBBbGl2ZSA9ICcnXG4gICAgdGhpcy5jb250ZW50TGVuZ3RoID0gJydcbiAgICB0aGlzLmNvbm5lY3Rpb24gPSAnJ1xuICAgIHRoaXMubWF4UmVzcG9uc2VTaXplID0gY2xpZW50W2tNYXhSZXNwb25zZVNpemVdXG4gIH1cblxuICBzZXRUaW1lb3V0ICh2YWx1ZSwgdHlwZSkge1xuICAgIHRoaXMudGltZW91dFR5cGUgPSB0eXBlXG4gICAgaWYgKHZhbHVlICE9PSB0aGlzLnRpbWVvdXRWYWx1ZSkge1xuICAgICAgdGltZXJzLmNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXQpXG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy50aW1lb3V0ID0gdGltZXJzLnNldFRpbWVvdXQob25QYXJzZXJUaW1lb3V0LCB2YWx1ZSwgdGhpcylcbiAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIGVsc2U6IG9ubHkgZm9yIGplc3RcbiAgICAgICAgaWYgKHRoaXMudGltZW91dC51bnJlZikge1xuICAgICAgICAgIHRoaXMudGltZW91dC51bnJlZigpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudGltZW91dCA9IG51bGxcbiAgICAgIH1cbiAgICAgIHRoaXMudGltZW91dFZhbHVlID0gdmFsdWVcbiAgICB9IGVsc2UgaWYgKHRoaXMudGltZW91dCkge1xuICAgICAgLy8gaXN0YW5idWwgaWdub3JlIGVsc2U6IG9ubHkgZm9yIGplc3RcbiAgICAgIGlmICh0aGlzLnRpbWVvdXQucmVmcmVzaCkge1xuICAgICAgICB0aGlzLnRpbWVvdXQucmVmcmVzaCgpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmVzdW1lICgpIHtcbiAgICBpZiAodGhpcy5zb2NrZXQuZGVzdHJveWVkIHx8ICF0aGlzLnBhdXNlZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgYXNzZXJ0KHRoaXMucHRyICE9IG51bGwpXG4gICAgYXNzZXJ0KGN1cnJlbnRQYXJzZXIgPT0gbnVsbClcblxuICAgIHRoaXMubGxodHRwLmxsaHR0cF9yZXN1bWUodGhpcy5wdHIpXG5cbiAgICBhc3NlcnQodGhpcy50aW1lb3V0VHlwZSA9PT0gVElNRU9VVF9CT0RZKVxuICAgIGlmICh0aGlzLnRpbWVvdXQpIHtcbiAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBlbHNlOiBvbmx5IGZvciBqZXN0XG4gICAgICBpZiAodGhpcy50aW1lb3V0LnJlZnJlc2gpIHtcbiAgICAgICAgdGhpcy50aW1lb3V0LnJlZnJlc2goKVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMucGF1c2VkID0gZmFsc2VcbiAgICB0aGlzLmV4ZWN1dGUodGhpcy5zb2NrZXQucmVhZCgpIHx8IEVNUFRZX0JVRikgLy8gRmx1c2ggcGFyc2VyLlxuICAgIHRoaXMucmVhZE1vcmUoKVxuICB9XG5cbiAgcmVhZE1vcmUgKCkge1xuICAgIHdoaWxlICghdGhpcy5wYXVzZWQgJiYgdGhpcy5wdHIpIHtcbiAgICAgIGNvbnN0IGNodW5rID0gdGhpcy5zb2NrZXQucmVhZCgpXG4gICAgICBpZiAoY2h1bmsgPT09IG51bGwpIHtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIHRoaXMuZXhlY3V0ZShjaHVuaylcbiAgICB9XG4gIH1cblxuICBleGVjdXRlIChkYXRhKSB7XG4gICAgYXNzZXJ0KHRoaXMucHRyICE9IG51bGwpXG4gICAgYXNzZXJ0KGN1cnJlbnRQYXJzZXIgPT0gbnVsbClcbiAgICBhc3NlcnQoIXRoaXMucGF1c2VkKVxuXG4gICAgY29uc3QgeyBzb2NrZXQsIGxsaHR0cCB9ID0gdGhpc1xuXG4gICAgaWYgKGRhdGEubGVuZ3RoID4gY3VycmVudEJ1ZmZlclNpemUpIHtcbiAgICAgIGlmIChjdXJyZW50QnVmZmVyUHRyKSB7XG4gICAgICAgIGxsaHR0cC5mcmVlKGN1cnJlbnRCdWZmZXJQdHIpXG4gICAgICB9XG4gICAgICBjdXJyZW50QnVmZmVyU2l6ZSA9IE1hdGguY2VpbChkYXRhLmxlbmd0aCAvIDQwOTYpICogNDA5NlxuICAgICAgY3VycmVudEJ1ZmZlclB0ciA9IGxsaHR0cC5tYWxsb2MoY3VycmVudEJ1ZmZlclNpemUpXG4gICAgfVxuXG4gICAgbmV3IFVpbnQ4QXJyYXkobGxodHRwLm1lbW9yeS5idWZmZXIsIGN1cnJlbnRCdWZmZXJQdHIsIGN1cnJlbnRCdWZmZXJTaXplKS5zZXQoZGF0YSlcblxuICAgIC8vIENhbGwgYGV4ZWN1dGVgIG9uIHRoZSB3YXNtIHBhcnNlci5cbiAgICAvLyBXZSBwYXNzIHRoZSBgbGxodHRwX3BhcnNlcmAgcG9pbnRlciBhZGRyZXNzLCB0aGUgcG9pbnRlciBhZGRyZXNzIG9mIGJ1ZmZlciB2aWV3IGRhdGEsXG4gICAgLy8gYW5kIGZpbmFsbHkgdGhlIGxlbmd0aCBvZiBieXRlcyB0byBwYXJzZS5cbiAgICAvLyBUaGUgcmV0dXJuIHZhbHVlIGlzIGFuIGVycm9yIGNvZGUgb3IgYGNvbnN0YW50cy5FUlJPUi5PS2AuXG4gICAgdHJ5IHtcbiAgICAgIGxldCByZXRcblxuICAgICAgdHJ5IHtcbiAgICAgICAgY3VycmVudEJ1ZmZlclJlZiA9IGRhdGFcbiAgICAgICAgY3VycmVudFBhcnNlciA9IHRoaXNcbiAgICAgICAgcmV0ID0gbGxodHRwLmxsaHR0cF9leGVjdXRlKHRoaXMucHRyLCBjdXJyZW50QnVmZmVyUHRyLCBkYXRhLmxlbmd0aClcbiAgICAgICAgLyogZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVzZWxlc3MtY2F0Y2ggKi9cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogZGlmZmljdWx0IHRvIG1ha2UgYSB0ZXN0IGNhc2UgZm9yICovXG4gICAgICAgIHRocm93IGVyclxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgY3VycmVudFBhcnNlciA9IG51bGxcbiAgICAgICAgY3VycmVudEJ1ZmZlclJlZiA9IG51bGxcbiAgICAgIH1cblxuICAgICAgY29uc3Qgb2Zmc2V0ID0gbGxodHRwLmxsaHR0cF9nZXRfZXJyb3JfcG9zKHRoaXMucHRyKSAtIGN1cnJlbnRCdWZmZXJQdHJcblxuICAgICAgaWYgKHJldCA9PT0gY29uc3RhbnRzLkVSUk9SLlBBVVNFRF9VUEdSQURFKSB7XG4gICAgICAgIHRoaXMub25VcGdyYWRlKGRhdGEuc2xpY2Uob2Zmc2V0KSlcbiAgICAgIH0gZWxzZSBpZiAocmV0ID09PSBjb25zdGFudHMuRVJST1IuUEFVU0VEKSB7XG4gICAgICAgIHRoaXMucGF1c2VkID0gdHJ1ZVxuICAgICAgICBzb2NrZXQudW5zaGlmdChkYXRhLnNsaWNlKG9mZnNldCkpXG4gICAgICB9IGVsc2UgaWYgKHJldCAhPT0gY29uc3RhbnRzLkVSUk9SLk9LKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IGxsaHR0cC5sbGh0dHBfZ2V0X2Vycm9yX3JlYXNvbih0aGlzLnB0cilcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSAnJ1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZTogZGlmZmljdWx0IHRvIG1ha2UgYSB0ZXN0IGNhc2UgZm9yICovXG4gICAgICAgIGlmIChwdHIpIHtcbiAgICAgICAgICBjb25zdCBsZW4gPSBuZXcgVWludDhBcnJheShsbGh0dHAubWVtb3J5LmJ1ZmZlciwgcHRyKS5pbmRleE9mKDApXG4gICAgICAgICAgbWVzc2FnZSA9XG4gICAgICAgICAgICAnUmVzcG9uc2UgZG9lcyBub3QgbWF0Y2ggdGhlIEhUVFAvMS4xIHByb3RvY29sICgnICtcbiAgICAgICAgICAgIEJ1ZmZlci5mcm9tKGxsaHR0cC5tZW1vcnkuYnVmZmVyLCBwdHIsIGxlbikudG9TdHJpbmcoKSArXG4gICAgICAgICAgICAnKSdcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgSFRUUFBhcnNlckVycm9yKG1lc3NhZ2UsIGNvbnN0YW50cy5FUlJPUltyZXRdLCBkYXRhLnNsaWNlKG9mZnNldCkpXG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB1dGlsLmRlc3Ryb3koc29ja2V0LCBlcnIpXG4gICAgfVxuICB9XG5cbiAgZGVzdHJveSAoKSB7XG4gICAgYXNzZXJ0KHRoaXMucHRyICE9IG51bGwpXG4gICAgYXNzZXJ0KGN1cnJlbnRQYXJzZXIgPT0gbnVsbClcblxuICAgIHRoaXMubGxodHRwLmxsaHR0cF9mcmVlKHRoaXMucHRyKVxuICAgIHRoaXMucHRyID0gbnVsbFxuXG4gICAgdGltZXJzLmNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXQpXG4gICAgdGhpcy50aW1lb3V0ID0gbnVsbFxuICAgIHRoaXMudGltZW91dFZhbHVlID0gbnVsbFxuICAgIHRoaXMudGltZW91dFR5cGUgPSBudWxsXG5cbiAgICB0aGlzLnBhdXNlZCA9IGZhbHNlXG4gIH1cblxuICBvblN0YXR1cyAoYnVmKSB7XG4gICAgdGhpcy5zdGF0dXNUZXh0ID0gYnVmLnRvU3RyaW5nKClcbiAgfVxuXG4gIG9uTWVzc2FnZUJlZ2luICgpIHtcbiAgICBjb25zdCB7IHNvY2tldCwgY2xpZW50IH0gPSB0aGlzXG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogZGlmZmljdWx0IHRvIG1ha2UgYSB0ZXN0IGNhc2UgZm9yICovXG4gICAgaWYgKHNvY2tldC5kZXN0cm95ZWQpIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cblxuICAgIGNvbnN0IHJlcXVlc3QgPSBjbGllbnRba1F1ZXVlXVtjbGllbnRba1J1bm5pbmdJZHhdXVxuICAgIGlmICghcmVxdWVzdCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuICAgIHJlcXVlc3Qub25SZXNwb25zZVN0YXJ0ZWQoKVxuICB9XG5cbiAgb25IZWFkZXJGaWVsZCAoYnVmKSB7XG4gICAgY29uc3QgbGVuID0gdGhpcy5oZWFkZXJzLmxlbmd0aFxuXG4gICAgaWYgKChsZW4gJiAxKSA9PT0gMCkge1xuICAgICAgdGhpcy5oZWFkZXJzLnB1c2goYnVmKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmhlYWRlcnNbbGVuIC0gMV0gPSBCdWZmZXIuY29uY2F0KFt0aGlzLmhlYWRlcnNbbGVuIC0gMV0sIGJ1Zl0pXG4gICAgfVxuXG4gICAgdGhpcy50cmFja0hlYWRlcihidWYubGVuZ3RoKVxuICB9XG5cbiAgb25IZWFkZXJWYWx1ZSAoYnVmKSB7XG4gICAgbGV0IGxlbiA9IHRoaXMuaGVhZGVycy5sZW5ndGhcblxuICAgIGlmICgobGVuICYgMSkgPT09IDEpIHtcbiAgICAgIHRoaXMuaGVhZGVycy5wdXNoKGJ1ZilcbiAgICAgIGxlbiArPSAxXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaGVhZGVyc1tsZW4gLSAxXSA9IEJ1ZmZlci5jb25jYXQoW3RoaXMuaGVhZGVyc1tsZW4gLSAxXSwgYnVmXSlcbiAgICB9XG5cbiAgICBjb25zdCBrZXkgPSB0aGlzLmhlYWRlcnNbbGVuIC0gMl1cbiAgICBpZiAoa2V5Lmxlbmd0aCA9PT0gMTApIHtcbiAgICAgIGNvbnN0IGhlYWRlck5hbWUgPSB1dGlsLmJ1ZmZlclRvTG93ZXJDYXNlZEhlYWRlck5hbWUoa2V5KVxuICAgICAgaWYgKGhlYWRlck5hbWUgPT09ICdrZWVwLWFsaXZlJykge1xuICAgICAgICB0aGlzLmtlZXBBbGl2ZSArPSBidWYudG9TdHJpbmcoKVxuICAgICAgfSBlbHNlIGlmIChoZWFkZXJOYW1lID09PSAnY29ubmVjdGlvbicpIHtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uICs9IGJ1Zi50b1N0cmluZygpXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChrZXkubGVuZ3RoID09PSAxNCAmJiB1dGlsLmJ1ZmZlclRvTG93ZXJDYXNlZEhlYWRlck5hbWUoa2V5KSA9PT0gJ2NvbnRlbnQtbGVuZ3RoJykge1xuICAgICAgdGhpcy5jb250ZW50TGVuZ3RoICs9IGJ1Zi50b1N0cmluZygpXG4gICAgfVxuXG4gICAgdGhpcy50cmFja0hlYWRlcihidWYubGVuZ3RoKVxuICB9XG5cbiAgdHJhY2tIZWFkZXIgKGxlbikge1xuICAgIHRoaXMuaGVhZGVyc1NpemUgKz0gbGVuXG4gICAgaWYgKHRoaXMuaGVhZGVyc1NpemUgPj0gdGhpcy5oZWFkZXJzTWF4U2l6ZSkge1xuICAgICAgdXRpbC5kZXN0cm95KHRoaXMuc29ja2V0LCBuZXcgSGVhZGVyc092ZXJmbG93RXJyb3IoKSlcbiAgICB9XG4gIH1cblxuICBvblVwZ3JhZGUgKGhlYWQpIHtcbiAgICBjb25zdCB7IHVwZ3JhZGUsIGNsaWVudCwgc29ja2V0LCBoZWFkZXJzLCBzdGF0dXNDb2RlIH0gPSB0aGlzXG5cbiAgICBhc3NlcnQodXBncmFkZSlcblxuICAgIGNvbnN0IHJlcXVlc3QgPSBjbGllbnRba1F1ZXVlXVtjbGllbnRba1J1bm5pbmdJZHhdXVxuICAgIGFzc2VydChyZXF1ZXN0KVxuXG4gICAgYXNzZXJ0KCFzb2NrZXQuZGVzdHJveWVkKVxuICAgIGFzc2VydChzb2NrZXQgPT09IGNsaWVudFtrU29ja2V0XSlcbiAgICBhc3NlcnQoIXRoaXMucGF1c2VkKVxuICAgIGFzc2VydChyZXF1ZXN0LnVwZ3JhZGUgfHwgcmVxdWVzdC5tZXRob2QgPT09ICdDT05ORUNUJylcblxuICAgIHRoaXMuc3RhdHVzQ29kZSA9IG51bGxcbiAgICB0aGlzLnN0YXR1c1RleHQgPSAnJ1xuICAgIHRoaXMuc2hvdWxkS2VlcEFsaXZlID0gbnVsbFxuXG4gICAgYXNzZXJ0KHRoaXMuaGVhZGVycy5sZW5ndGggJSAyID09PSAwKVxuICAgIHRoaXMuaGVhZGVycyA9IFtdXG4gICAgdGhpcy5oZWFkZXJzU2l6ZSA9IDBcblxuICAgIHNvY2tldC51bnNoaWZ0KGhlYWQpXG5cbiAgICBzb2NrZXRba1BhcnNlcl0uZGVzdHJveSgpXG4gICAgc29ja2V0W2tQYXJzZXJdID0gbnVsbFxuXG4gICAgc29ja2V0W2tDbGllbnRdID0gbnVsbFxuICAgIHNvY2tldFtrRXJyb3JdID0gbnVsbFxuXG4gICAgcmVtb3ZlQWxsTGlzdGVuZXJzKHNvY2tldClcblxuICAgIGNsaWVudFtrU29ja2V0XSA9IG51bGxcbiAgICBjbGllbnRba0hUVFBDb250ZXh0XSA9IG51bGwgLy8gVE9ETyAoZml4KTogVGhpcyBpcyBoYWNreS4uLlxuICAgIGNsaWVudFtrUXVldWVdW2NsaWVudFtrUnVubmluZ0lkeF0rK10gPSBudWxsXG4gICAgY2xpZW50LmVtaXQoJ2Rpc2Nvbm5lY3QnLCBjbGllbnRba1VybF0sIFtjbGllbnRdLCBuZXcgSW5mb3JtYXRpb25hbEVycm9yKCd1cGdyYWRlJykpXG5cbiAgICB0cnkge1xuICAgICAgcmVxdWVzdC5vblVwZ3JhZGUoc3RhdHVzQ29kZSwgaGVhZGVycywgc29ja2V0KVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdXRpbC5kZXN0cm95KHNvY2tldCwgZXJyKVxuICAgIH1cblxuICAgIGNsaWVudFtrUmVzdW1lXSgpXG4gIH1cblxuICBvbkhlYWRlcnNDb21wbGV0ZSAoc3RhdHVzQ29kZSwgdXBncmFkZSwgc2hvdWxkS2VlcEFsaXZlKSB7XG4gICAgY29uc3QgeyBjbGllbnQsIHNvY2tldCwgaGVhZGVycywgc3RhdHVzVGV4dCB9ID0gdGhpc1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IGRpZmZpY3VsdCB0byBtYWtlIGEgdGVzdCBjYXNlIGZvciAqL1xuICAgIGlmIChzb2NrZXQuZGVzdHJveWVkKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG5cbiAgICBjb25zdCByZXF1ZXN0ID0gY2xpZW50W2tRdWV1ZV1bY2xpZW50W2tSdW5uaW5nSWR4XV1cblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBkaWZmaWN1bHQgdG8gbWFrZSBhIHRlc3QgY2FzZSBmb3IgKi9cbiAgICBpZiAoIXJlcXVlc3QpIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cblxuICAgIGFzc2VydCghdGhpcy51cGdyYWRlKVxuICAgIGFzc2VydCh0aGlzLnN0YXR1c0NvZGUgPCAyMDApXG5cbiAgICBpZiAoc3RhdHVzQ29kZSA9PT0gMTAwKSB7XG4gICAgICB1dGlsLmRlc3Ryb3koc29ja2V0LCBuZXcgU29ja2V0RXJyb3IoJ2JhZCByZXNwb25zZScsIHV0aWwuZ2V0U29ja2V0SW5mbyhzb2NrZXQpKSlcbiAgICAgIHJldHVybiAtMVxuICAgIH1cblxuICAgIC8qIHRoaXMgY2FuIG9ubHkgaGFwcGVuIGlmIHNlcnZlciBpcyBtaXNiZWhhdmluZyAqL1xuICAgIGlmICh1cGdyYWRlICYmICFyZXF1ZXN0LnVwZ3JhZGUpIHtcbiAgICAgIHV0aWwuZGVzdHJveShzb2NrZXQsIG5ldyBTb2NrZXRFcnJvcignYmFkIHVwZ3JhZGUnLCB1dGlsLmdldFNvY2tldEluZm8oc29ja2V0KSkpXG4gICAgICByZXR1cm4gLTFcbiAgICB9XG5cbiAgICBhc3NlcnQuc3RyaWN0RXF1YWwodGhpcy50aW1lb3V0VHlwZSwgVElNRU9VVF9IRUFERVJTKVxuXG4gICAgdGhpcy5zdGF0dXNDb2RlID0gc3RhdHVzQ29kZVxuICAgIHRoaXMuc2hvdWxkS2VlcEFsaXZlID0gKFxuICAgICAgc2hvdWxkS2VlcEFsaXZlIHx8XG4gICAgICAvLyBPdmVycmlkZSBsbGh0dHAgdmFsdWUgd2hpY2ggZG9lcyBub3QgYWxsb3cga2VlcEFsaXZlIGZvciBIRUFELlxuICAgICAgKHJlcXVlc3QubWV0aG9kID09PSAnSEVBRCcgJiYgIXNvY2tldFtrUmVzZXRdICYmIHRoaXMuY29ubmVjdGlvbi50b0xvd2VyQ2FzZSgpID09PSAna2VlcC1hbGl2ZScpXG4gICAgKVxuXG4gICAgaWYgKHRoaXMuc3RhdHVzQ29kZSA+PSAyMDApIHtcbiAgICAgIGNvbnN0IGJvZHlUaW1lb3V0ID0gcmVxdWVzdC5ib2R5VGltZW91dCAhPSBudWxsXG4gICAgICAgID8gcmVxdWVzdC5ib2R5VGltZW91dFxuICAgICAgICA6IGNsaWVudFtrQm9keVRpbWVvdXRdXG4gICAgICB0aGlzLnNldFRpbWVvdXQoYm9keVRpbWVvdXQsIFRJTUVPVVRfQk9EWSlcbiAgICB9IGVsc2UgaWYgKHRoaXMudGltZW91dCkge1xuICAgICAgLy8gaXN0YW5idWwgaWdub3JlIGVsc2U6IG9ubHkgZm9yIGplc3RcbiAgICAgIGlmICh0aGlzLnRpbWVvdXQucmVmcmVzaCkge1xuICAgICAgICB0aGlzLnRpbWVvdXQucmVmcmVzaCgpXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHJlcXVlc3QubWV0aG9kID09PSAnQ09OTkVDVCcpIHtcbiAgICAgIGFzc2VydChjbGllbnRba1J1bm5pbmddID09PSAxKVxuICAgICAgdGhpcy51cGdyYWRlID0gdHJ1ZVxuICAgICAgcmV0dXJuIDJcbiAgICB9XG5cbiAgICBpZiAodXBncmFkZSkge1xuICAgICAgYXNzZXJ0KGNsaWVudFtrUnVubmluZ10gPT09IDEpXG4gICAgICB0aGlzLnVwZ3JhZGUgPSB0cnVlXG4gICAgICByZXR1cm4gMlxuICAgIH1cblxuICAgIGFzc2VydCh0aGlzLmhlYWRlcnMubGVuZ3RoICUgMiA9PT0gMClcbiAgICB0aGlzLmhlYWRlcnMgPSBbXVxuICAgIHRoaXMuaGVhZGVyc1NpemUgPSAwXG5cbiAgICBpZiAodGhpcy5zaG91bGRLZWVwQWxpdmUgJiYgY2xpZW50W2tQaXBlbGluaW5nXSkge1xuICAgICAgY29uc3Qga2VlcEFsaXZlVGltZW91dCA9IHRoaXMua2VlcEFsaXZlID8gdXRpbC5wYXJzZUtlZXBBbGl2ZVRpbWVvdXQodGhpcy5rZWVwQWxpdmUpIDogbnVsbFxuXG4gICAgICBpZiAoa2VlcEFsaXZlVGltZW91dCAhPSBudWxsKSB7XG4gICAgICAgIGNvbnN0IHRpbWVvdXQgPSBNYXRoLm1pbihcbiAgICAgICAgICBrZWVwQWxpdmVUaW1lb3V0IC0gY2xpZW50W2tLZWVwQWxpdmVUaW1lb3V0VGhyZXNob2xkXSxcbiAgICAgICAgICBjbGllbnRba0tlZXBBbGl2ZU1heFRpbWVvdXRdXG4gICAgICAgIClcbiAgICAgICAgaWYgKHRpbWVvdXQgPD0gMCkge1xuICAgICAgICAgIHNvY2tldFtrUmVzZXRdID0gdHJ1ZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNsaWVudFtrS2VlcEFsaXZlVGltZW91dFZhbHVlXSA9IHRpbWVvdXRcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2xpZW50W2tLZWVwQWxpdmVUaW1lb3V0VmFsdWVdID0gY2xpZW50W2tLZWVwQWxpdmVEZWZhdWx0VGltZW91dF1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU3RvcCBtb3JlIHJlcXVlc3RzIGZyb20gYmVpbmcgZGlzcGF0Y2hlZC5cbiAgICAgIHNvY2tldFtrUmVzZXRdID0gdHJ1ZVxuICAgIH1cblxuICAgIGNvbnN0IHBhdXNlID0gcmVxdWVzdC5vbkhlYWRlcnMoc3RhdHVzQ29kZSwgaGVhZGVycywgdGhpcy5yZXN1bWUsIHN0YXR1c1RleHQpID09PSBmYWxzZVxuXG4gICAgaWYgKHJlcXVlc3QuYWJvcnRlZCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuXG4gICAgaWYgKHJlcXVlc3QubWV0aG9kID09PSAnSEVBRCcpIHtcbiAgICAgIHJldHVybiAxXG4gICAgfVxuXG4gICAgaWYgKHN0YXR1c0NvZGUgPCAyMDApIHtcbiAgICAgIHJldHVybiAxXG4gICAgfVxuXG4gICAgaWYgKHNvY2tldFtrQmxvY2tpbmddKSB7XG4gICAgICBzb2NrZXRba0Jsb2NraW5nXSA9IGZhbHNlXG4gICAgICBjbGllbnRba1Jlc3VtZV0oKVxuICAgIH1cblxuICAgIHJldHVybiBwYXVzZSA/IGNvbnN0YW50cy5FUlJPUi5QQVVTRUQgOiAwXG4gIH1cblxuICBvbkJvZHkgKGJ1Zikge1xuICAgIGNvbnN0IHsgY2xpZW50LCBzb2NrZXQsIHN0YXR1c0NvZGUsIG1heFJlc3BvbnNlU2l6ZSB9ID0gdGhpc1xuXG4gICAgaWYgKHNvY2tldC5kZXN0cm95ZWQpIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cblxuICAgIGNvbnN0IHJlcXVlc3QgPSBjbGllbnRba1F1ZXVlXVtjbGllbnRba1J1bm5pbmdJZHhdXVxuICAgIGFzc2VydChyZXF1ZXN0KVxuXG4gICAgYXNzZXJ0LnN0cmljdEVxdWFsKHRoaXMudGltZW91dFR5cGUsIFRJTUVPVVRfQk9EWSlcbiAgICBpZiAodGhpcy50aW1lb3V0KSB7XG4gICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgZWxzZTogb25seSBmb3IgamVzdFxuICAgICAgaWYgKHRoaXMudGltZW91dC5yZWZyZXNoKSB7XG4gICAgICAgIHRoaXMudGltZW91dC5yZWZyZXNoKClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBhc3NlcnQoc3RhdHVzQ29kZSA+PSAyMDApXG5cbiAgICBpZiAobWF4UmVzcG9uc2VTaXplID4gLTEgJiYgdGhpcy5ieXRlc1JlYWQgKyBidWYubGVuZ3RoID4gbWF4UmVzcG9uc2VTaXplKSB7XG4gICAgICB1dGlsLmRlc3Ryb3koc29ja2V0LCBuZXcgUmVzcG9uc2VFeGNlZWRlZE1heFNpemVFcnJvcigpKVxuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuXG4gICAgdGhpcy5ieXRlc1JlYWQgKz0gYnVmLmxlbmd0aFxuXG4gICAgaWYgKHJlcXVlc3Qub25EYXRhKGJ1ZikgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gY29uc3RhbnRzLkVSUk9SLlBBVVNFRFxuICAgIH1cbiAgfVxuXG4gIG9uTWVzc2FnZUNvbXBsZXRlICgpIHtcbiAgICBjb25zdCB7IGNsaWVudCwgc29ja2V0LCBzdGF0dXNDb2RlLCB1cGdyYWRlLCBoZWFkZXJzLCBjb250ZW50TGVuZ3RoLCBieXRlc1JlYWQsIHNob3VsZEtlZXBBbGl2ZSB9ID0gdGhpc1xuXG4gICAgaWYgKHNvY2tldC5kZXN0cm95ZWQgJiYgKCFzdGF0dXNDb2RlIHx8IHNob3VsZEtlZXBBbGl2ZSkpIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cblxuICAgIGlmICh1cGdyYWRlKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCByZXF1ZXN0ID0gY2xpZW50W2tRdWV1ZV1bY2xpZW50W2tSdW5uaW5nSWR4XV1cbiAgICBhc3NlcnQocmVxdWVzdClcblxuICAgIGFzc2VydChzdGF0dXNDb2RlID49IDEwMClcblxuICAgIHRoaXMuc3RhdHVzQ29kZSA9IG51bGxcbiAgICB0aGlzLnN0YXR1c1RleHQgPSAnJ1xuICAgIHRoaXMuYnl0ZXNSZWFkID0gMFxuICAgIHRoaXMuY29udGVudExlbmd0aCA9ICcnXG4gICAgdGhpcy5rZWVwQWxpdmUgPSAnJ1xuICAgIHRoaXMuY29ubmVjdGlvbiA9ICcnXG5cbiAgICBhc3NlcnQodGhpcy5oZWFkZXJzLmxlbmd0aCAlIDIgPT09IDApXG4gICAgdGhpcy5oZWFkZXJzID0gW11cbiAgICB0aGlzLmhlYWRlcnNTaXplID0gMFxuXG4gICAgaWYgKHN0YXR1c0NvZGUgPCAyMDApIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBzaG91bGQgYmUgaGFuZGxlZCBieSBsbGh0dHA/ICovXG4gICAgaWYgKHJlcXVlc3QubWV0aG9kICE9PSAnSEVBRCcgJiYgY29udGVudExlbmd0aCAmJiBieXRlc1JlYWQgIT09IHBhcnNlSW50KGNvbnRlbnRMZW5ndGgsIDEwKSkge1xuICAgICAgdXRpbC5kZXN0cm95KHNvY2tldCwgbmV3IFJlc3BvbnNlQ29udGVudExlbmd0aE1pc21hdGNoRXJyb3IoKSlcbiAgICAgIHJldHVybiAtMVxuICAgIH1cblxuICAgIHJlcXVlc3Qub25Db21wbGV0ZShoZWFkZXJzKVxuXG4gICAgY2xpZW50W2tRdWV1ZV1bY2xpZW50W2tSdW5uaW5nSWR4XSsrXSA9IG51bGxcblxuICAgIGlmIChzb2NrZXRba1dyaXRpbmddKSB7XG4gICAgICBhc3NlcnQuc3RyaWN0RXF1YWwoY2xpZW50W2tSdW5uaW5nXSwgMClcbiAgICAgIC8vIFJlc3BvbnNlIGNvbXBsZXRlZCBiZWZvcmUgcmVxdWVzdC5cbiAgICAgIHV0aWwuZGVzdHJveShzb2NrZXQsIG5ldyBJbmZvcm1hdGlvbmFsRXJyb3IoJ3Jlc2V0JykpXG4gICAgICByZXR1cm4gY29uc3RhbnRzLkVSUk9SLlBBVVNFRFxuICAgIH0gZWxzZSBpZiAoIXNob3VsZEtlZXBBbGl2ZSkge1xuICAgICAgdXRpbC5kZXN0cm95KHNvY2tldCwgbmV3IEluZm9ybWF0aW9uYWxFcnJvcigncmVzZXQnKSlcbiAgICAgIHJldHVybiBjb25zdGFudHMuRVJST1IuUEFVU0VEXG4gICAgfSBlbHNlIGlmIChzb2NrZXRba1Jlc2V0XSAmJiBjbGllbnRba1J1bm5pbmddID09PSAwKSB7XG4gICAgICAvLyBEZXN0cm95IHNvY2tldCBvbmNlIGFsbCByZXF1ZXN0cyBoYXZlIGNvbXBsZXRlZC5cbiAgICAgIC8vIFRoZSByZXF1ZXN0IGF0IHRoZSB0YWlsIG9mIHRoZSBwaXBlbGluZSBpcyB0aGUgb25lXG4gICAgICAvLyB0aGF0IHJlcXVlc3RlZCByZXNldCBhbmQgbm8gZnVydGhlciByZXF1ZXN0cyBzaG91bGRcbiAgICAgIC8vIGhhdmUgYmVlbiBxdWV1ZWQgc2luY2UgdGhlbi5cbiAgICAgIHV0aWwuZGVzdHJveShzb2NrZXQsIG5ldyBJbmZvcm1hdGlvbmFsRXJyb3IoJ3Jlc2V0JykpXG4gICAgICByZXR1cm4gY29uc3RhbnRzLkVSUk9SLlBBVVNFRFxuICAgIH0gZWxzZSBpZiAoY2xpZW50W2tQaXBlbGluaW5nXSA9PSBudWxsIHx8IGNsaWVudFtrUGlwZWxpbmluZ10gPT09IDEpIHtcbiAgICAgIC8vIFdlIG11c3Qgd2FpdCBhIGZ1bGwgZXZlbnQgbG9vcCBjeWNsZSB0byByZXVzZSB0aGlzIHNvY2tldCB0byBtYWtlIHN1cmVcbiAgICAgIC8vIHRoYXQgbm9uLXNwZWMgY29tcGxpYW50IHNlcnZlcnMgYXJlIG5vdCBjbG9zaW5nIHRoZSBjb25uZWN0aW9uIGV2ZW4gaWYgdGhleVxuICAgICAgLy8gc2FpZCB0aGV5IHdvbid0LlxuICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IGNsaWVudFtrUmVzdW1lXSgpKVxuICAgIH0gZWxzZSB7XG4gICAgICBjbGllbnRba1Jlc3VtZV0oKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBvblBhcnNlclRpbWVvdXQgKHBhcnNlcikge1xuICBjb25zdCB7IHNvY2tldCwgdGltZW91dFR5cGUsIGNsaWVudCB9ID0gcGFyc2VyXG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKHRpbWVvdXRUeXBlID09PSBUSU1FT1VUX0hFQURFUlMpIHtcbiAgICBpZiAoIXNvY2tldFtrV3JpdGluZ10gfHwgc29ja2V0LndyaXRhYmxlTmVlZERyYWluIHx8IGNsaWVudFtrUnVubmluZ10gPiAxKSB7XG4gICAgICBhc3NlcnQoIXBhcnNlci5wYXVzZWQsICdjYW5ub3QgYmUgcGF1c2VkIHdoaWxlIHdhaXRpbmcgZm9yIGhlYWRlcnMnKVxuICAgICAgdXRpbC5kZXN0cm95KHNvY2tldCwgbmV3IEhlYWRlcnNUaW1lb3V0RXJyb3IoKSlcbiAgICB9XG4gIH0gZWxzZSBpZiAodGltZW91dFR5cGUgPT09IFRJTUVPVVRfQk9EWSkge1xuICAgIGlmICghcGFyc2VyLnBhdXNlZCkge1xuICAgICAgdXRpbC5kZXN0cm95KHNvY2tldCwgbmV3IEJvZHlUaW1lb3V0RXJyb3IoKSlcbiAgICB9XG4gIH0gZWxzZSBpZiAodGltZW91dFR5cGUgPT09IFRJTUVPVVRfSURMRSkge1xuICAgIGFzc2VydChjbGllbnRba1J1bm5pbmddID09PSAwICYmIGNsaWVudFtrS2VlcEFsaXZlVGltZW91dFZhbHVlXSlcbiAgICB1dGlsLmRlc3Ryb3koc29ja2V0LCBuZXcgSW5mb3JtYXRpb25hbEVycm9yKCdzb2NrZXQgaWRsZSB0aW1lb3V0JykpXG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gY29ubmVjdEgxIChjbGllbnQsIHNvY2tldCkge1xuICBjbGllbnRba1NvY2tldF0gPSBzb2NrZXRcblxuICBpZiAoIWxsaHR0cEluc3RhbmNlKSB7XG4gICAgbGxodHRwSW5zdGFuY2UgPSBhd2FpdCBsbGh0dHBQcm9taXNlXG4gICAgbGxodHRwUHJvbWlzZSA9IG51bGxcbiAgfVxuXG4gIHNvY2tldFtrTm9SZWZdID0gZmFsc2VcbiAgc29ja2V0W2tXcml0aW5nXSA9IGZhbHNlXG4gIHNvY2tldFtrUmVzZXRdID0gZmFsc2VcbiAgc29ja2V0W2tCbG9ja2luZ10gPSBmYWxzZVxuICBzb2NrZXRba1BhcnNlcl0gPSBuZXcgUGFyc2VyKGNsaWVudCwgc29ja2V0LCBsbGh0dHBJbnN0YW5jZSlcblxuICBhZGRMaXN0ZW5lcihzb2NrZXQsICdlcnJvcicsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzW2tQYXJzZXJdXG5cbiAgICBhc3NlcnQoZXJyLmNvZGUgIT09ICdFUlJfVExTX0NFUlRfQUxUTkFNRV9JTlZBTElEJylcblxuICAgIC8vIE9uIE1hYyBPUywgd2UgZ2V0IGFuIEVDT05OUkVTRVQgZXZlbiBpZiB0aGVyZSBpcyBhIGZ1bGwgYm9keSB0byBiZSBmb3J3YXJkZWRcbiAgICAvLyB0byB0aGUgdXNlci5cbiAgICBpZiAoZXJyLmNvZGUgPT09ICdFQ09OTlJFU0VUJyAmJiBwYXJzZXIuc3RhdHVzQ29kZSAmJiAhcGFyc2VyLnNob3VsZEtlZXBBbGl2ZSkge1xuICAgICAgLy8gV2UgdHJlYXQgYWxsIGluY29taW5nIGRhdGEgc28gZm9yIGFzIGEgdmFsaWQgcmVzcG9uc2UuXG4gICAgICBwYXJzZXIub25NZXNzYWdlQ29tcGxldGUoKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpc1trRXJyb3JdID0gZXJyXG5cbiAgICB0aGlzW2tDbGllbnRdW2tPbkVycm9yXShlcnIpXG4gIH0pXG4gIGFkZExpc3RlbmVyKHNvY2tldCwgJ3JlYWRhYmxlJywgZnVuY3Rpb24gKCkge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXNba1BhcnNlcl1cblxuICAgIGlmIChwYXJzZXIpIHtcbiAgICAgIHBhcnNlci5yZWFkTW9yZSgpXG4gICAgfVxuICB9KVxuICBhZGRMaXN0ZW5lcihzb2NrZXQsICdlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpc1trUGFyc2VyXVxuXG4gICAgaWYgKHBhcnNlci5zdGF0dXNDb2RlICYmICFwYXJzZXIuc2hvdWxkS2VlcEFsaXZlKSB7XG4gICAgICAvLyBXZSB0cmVhdCBhbGwgaW5jb21pbmcgZGF0YSBzbyBmYXIgYXMgYSB2YWxpZCByZXNwb25zZS5cbiAgICAgIHBhcnNlci5vbk1lc3NhZ2VDb21wbGV0ZSgpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB1dGlsLmRlc3Ryb3kodGhpcywgbmV3IFNvY2tldEVycm9yKCdvdGhlciBzaWRlIGNsb3NlZCcsIHV0aWwuZ2V0U29ja2V0SW5mbyh0aGlzKSkpXG4gIH0pXG4gIGFkZExpc3RlbmVyKHNvY2tldCwgJ2Nsb3NlJywgZnVuY3Rpb24gKCkge1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXNba0NsaWVudF1cbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzW2tQYXJzZXJdXG5cbiAgICBpZiAocGFyc2VyKSB7XG4gICAgICBpZiAoIXRoaXNba0Vycm9yXSAmJiBwYXJzZXIuc3RhdHVzQ29kZSAmJiAhcGFyc2VyLnNob3VsZEtlZXBBbGl2ZSkge1xuICAgICAgICAvLyBXZSB0cmVhdCBhbGwgaW5jb21pbmcgZGF0YSBzbyBmYXIgYXMgYSB2YWxpZCByZXNwb25zZS5cbiAgICAgICAgcGFyc2VyLm9uTWVzc2FnZUNvbXBsZXRlKClcbiAgICAgIH1cblxuICAgICAgdGhpc1trUGFyc2VyXS5kZXN0cm95KClcbiAgICAgIHRoaXNba1BhcnNlcl0gPSBudWxsXG4gICAgfVxuXG4gICAgY29uc3QgZXJyID0gdGhpc1trRXJyb3JdIHx8IG5ldyBTb2NrZXRFcnJvcignY2xvc2VkJywgdXRpbC5nZXRTb2NrZXRJbmZvKHRoaXMpKVxuXG4gICAgY2xpZW50W2tTb2NrZXRdID0gbnVsbFxuICAgIGNsaWVudFtrSFRUUENvbnRleHRdID0gbnVsbCAvLyBUT0RPIChmaXgpOiBUaGlzIGlzIGhhY2t5Li4uXG5cbiAgICBpZiAoY2xpZW50LmRlc3Ryb3llZCkge1xuICAgICAgYXNzZXJ0KGNsaWVudFtrUGVuZGluZ10gPT09IDApXG5cbiAgICAgIC8vIEZhaWwgZW50aXJlIHF1ZXVlLlxuICAgICAgY29uc3QgcmVxdWVzdHMgPSBjbGllbnRba1F1ZXVlXS5zcGxpY2UoY2xpZW50W2tSdW5uaW5nSWR4XSlcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVxdWVzdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHJlcXVlc3RzW2ldXG4gICAgICAgIHV0aWwuZXJyb3JSZXF1ZXN0KGNsaWVudCwgcmVxdWVzdCwgZXJyKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY2xpZW50W2tSdW5uaW5nXSA+IDAgJiYgZXJyLmNvZGUgIT09ICdVTkRfRVJSX0lORk8nKSB7XG4gICAgICAvLyBGYWlsIGhlYWQgb2YgcGlwZWxpbmUuXG4gICAgICBjb25zdCByZXF1ZXN0ID0gY2xpZW50W2tRdWV1ZV1bY2xpZW50W2tSdW5uaW5nSWR4XV1cbiAgICAgIGNsaWVudFtrUXVldWVdW2NsaWVudFtrUnVubmluZ0lkeF0rK10gPSBudWxsXG5cbiAgICAgIHV0aWwuZXJyb3JSZXF1ZXN0KGNsaWVudCwgcmVxdWVzdCwgZXJyKVxuICAgIH1cblxuICAgIGNsaWVudFtrUGVuZGluZ0lkeF0gPSBjbGllbnRba1J1bm5pbmdJZHhdXG5cbiAgICBhc3NlcnQoY2xpZW50W2tSdW5uaW5nXSA9PT0gMClcblxuICAgIGNsaWVudC5lbWl0KCdkaXNjb25uZWN0JywgY2xpZW50W2tVcmxdLCBbY2xpZW50XSwgZXJyKVxuXG4gICAgY2xpZW50W2tSZXN1bWVdKClcbiAgfSlcblxuICBsZXQgY2xvc2VkID0gZmFsc2VcbiAgc29ja2V0Lm9uKCdjbG9zZScsICgpID0+IHtcbiAgICBjbG9zZWQgPSB0cnVlXG4gIH0pXG5cbiAgcmV0dXJuIHtcbiAgICB2ZXJzaW9uOiAnaDEnLFxuICAgIGRlZmF1bHRQaXBlbGluaW5nOiAxLFxuICAgIHdyaXRlICguLi5hcmdzKSB7XG4gICAgICByZXR1cm4gd3JpdGVIMShjbGllbnQsIC4uLmFyZ3MpXG4gICAgfSxcbiAgICByZXN1bWUgKCkge1xuICAgICAgcmVzdW1lSDEoY2xpZW50KVxuICAgIH0sXG4gICAgZGVzdHJveSAoZXJyLCBjYWxsYmFjaykge1xuICAgICAgaWYgKGNsb3NlZCkge1xuICAgICAgICBxdWV1ZU1pY3JvdGFzayhjYWxsYmFjaylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNvY2tldC5kZXN0cm95KGVycikub24oJ2Nsb3NlJywgY2FsbGJhY2spXG4gICAgICB9XG4gICAgfSxcbiAgICBnZXQgZGVzdHJveWVkICgpIHtcbiAgICAgIHJldHVybiBzb2NrZXQuZGVzdHJveWVkXG4gICAgfSxcbiAgICBidXN5IChyZXF1ZXN0KSB7XG4gICAgICBpZiAoc29ja2V0W2tXcml0aW5nXSB8fCBzb2NrZXRba1Jlc2V0XSB8fCBzb2NrZXRba0Jsb2NraW5nXSkge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuXG4gICAgICBpZiAocmVxdWVzdCkge1xuICAgICAgICBpZiAoY2xpZW50W2tSdW5uaW5nXSA+IDAgJiYgIXJlcXVlc3QuaWRlbXBvdGVudCkge1xuICAgICAgICAgIC8vIE5vbi1pZGVtcG90ZW50IHJlcXVlc3QgY2Fubm90IGJlIHJldHJpZWQuXG4gICAgICAgICAgLy8gRW5zdXJlIHRoYXQgbm8gb3RoZXIgcmVxdWVzdHMgYXJlIGluZmxpZ2h0IGFuZFxuICAgICAgICAgIC8vIGNvdWxkIGNhdXNlIGZhaWx1cmUuXG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjbGllbnRba1J1bm5pbmddID4gMCAmJiAocmVxdWVzdC51cGdyYWRlIHx8IHJlcXVlc3QubWV0aG9kID09PSAnQ09OTkVDVCcpKSB7XG4gICAgICAgICAgLy8gRG9uJ3QgZGlzcGF0Y2ggYW4gdXBncmFkZSB1bnRpbCBhbGwgcHJlY2VkaW5nIHJlcXVlc3RzIGhhdmUgY29tcGxldGVkLlxuICAgICAgICAgIC8vIEEgbWlzYmVoYXZpbmcgc2VydmVyIG1pZ2h0IHVwZ3JhZGUgdGhlIGNvbm5lY3Rpb24gYmVmb3JlIGFsbCBwaXBlbGluZWRcbiAgICAgICAgICAvLyByZXF1ZXN0IGhhcyBjb21wbGV0ZWQuXG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjbGllbnRba1J1bm5pbmddID4gMCAmJiB1dGlsLmJvZHlMZW5ndGgocmVxdWVzdC5ib2R5KSAhPT0gMCAmJlxuICAgICAgICAgICh1dGlsLmlzU3RyZWFtKHJlcXVlc3QuYm9keSkgfHwgdXRpbC5pc0FzeW5jSXRlcmFibGUocmVxdWVzdC5ib2R5KSB8fCB1dGlsLmlzRm9ybURhdGFMaWtlKHJlcXVlc3QuYm9keSkpKSB7XG4gICAgICAgICAgLy8gUmVxdWVzdCB3aXRoIHN0cmVhbSBvciBpdGVyYXRvciBib2R5IGNhbiBlcnJvciB3aGlsZSBvdGhlciByZXF1ZXN0c1xuICAgICAgICAgIC8vIGFyZSBpbmZsaWdodCBhbmQgaW5kaXJlY3RseSBlcnJvciB0aG9zZSBhcyB3ZWxsLlxuICAgICAgICAgIC8vIEVuc3VyZSB0aGlzIGRvZXNuJ3QgaGFwcGVuIGJ5IHdhaXRpbmcgZm9yIGluZmxpZ2h0XG4gICAgICAgICAgLy8gdG8gY29tcGxldGUgYmVmb3JlIGRpc3BhdGNoaW5nLlxuXG4gICAgICAgICAgLy8gUmVxdWVzdCB3aXRoIHN0cmVhbSBvciBpdGVyYXRvciBib2R5IGNhbm5vdCBiZSByZXRyaWVkLlxuICAgICAgICAgIC8vIEVuc3VyZSB0aGF0IG5vIG90aGVyIHJlcXVlc3RzIGFyZSBpbmZsaWdodCBhbmRcbiAgICAgICAgICAvLyBjb3VsZCBjYXVzZSBmYWlsdXJlLlxuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlc3VtZUgxIChjbGllbnQpIHtcbiAgY29uc3Qgc29ja2V0ID0gY2xpZW50W2tTb2NrZXRdXG5cbiAgaWYgKHNvY2tldCAmJiAhc29ja2V0LmRlc3Ryb3llZCkge1xuICAgIGlmIChjbGllbnRba1NpemVdID09PSAwKSB7XG4gICAgICBpZiAoIXNvY2tldFtrTm9SZWZdICYmIHNvY2tldC51bnJlZikge1xuICAgICAgICBzb2NrZXQudW5yZWYoKVxuICAgICAgICBzb2NrZXRba05vUmVmXSA9IHRydWVcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHNvY2tldFtrTm9SZWZdICYmIHNvY2tldC5yZWYpIHtcbiAgICAgIHNvY2tldC5yZWYoKVxuICAgICAgc29ja2V0W2tOb1JlZl0gPSBmYWxzZVxuICAgIH1cblxuICAgIGlmIChjbGllbnRba1NpemVdID09PSAwKSB7XG4gICAgICBpZiAoc29ja2V0W2tQYXJzZXJdLnRpbWVvdXRUeXBlICE9PSBUSU1FT1VUX0lETEUpIHtcbiAgICAgICAgc29ja2V0W2tQYXJzZXJdLnNldFRpbWVvdXQoY2xpZW50W2tLZWVwQWxpdmVUaW1lb3V0VmFsdWVdLCBUSU1FT1VUX0lETEUpXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjbGllbnRba1J1bm5pbmddID4gMCAmJiBzb2NrZXRba1BhcnNlcl0uc3RhdHVzQ29kZSA8IDIwMCkge1xuICAgICAgaWYgKHNvY2tldFtrUGFyc2VyXS50aW1lb3V0VHlwZSAhPT0gVElNRU9VVF9IRUFERVJTKSB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSBjbGllbnRba1F1ZXVlXVtjbGllbnRba1J1bm5pbmdJZHhdXVxuICAgICAgICBjb25zdCBoZWFkZXJzVGltZW91dCA9IHJlcXVlc3QuaGVhZGVyc1RpbWVvdXQgIT0gbnVsbFxuICAgICAgICAgID8gcmVxdWVzdC5oZWFkZXJzVGltZW91dFxuICAgICAgICAgIDogY2xpZW50W2tIZWFkZXJzVGltZW91dF1cbiAgICAgICAgc29ja2V0W2tQYXJzZXJdLnNldFRpbWVvdXQoaGVhZGVyc1RpbWVvdXQsIFRJTUVPVVRfSEVBREVSUylcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLy8gaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzcyMzAjc2VjdGlvbi0zLjMuMlxuZnVuY3Rpb24gc2hvdWxkU2VuZENvbnRlbnRMZW5ndGggKG1ldGhvZCkge1xuICByZXR1cm4gbWV0aG9kICE9PSAnR0VUJyAmJiBtZXRob2QgIT09ICdIRUFEJyAmJiBtZXRob2QgIT09ICdPUFRJT05TJyAmJiBtZXRob2QgIT09ICdUUkFDRScgJiYgbWV0aG9kICE9PSAnQ09OTkVDVCdcbn1cblxuZnVuY3Rpb24gd3JpdGVIMSAoY2xpZW50LCByZXF1ZXN0KSB7XG4gIGNvbnN0IHsgbWV0aG9kLCBwYXRoLCBob3N0LCB1cGdyYWRlLCBibG9ja2luZywgcmVzZXQgfSA9IHJlcXVlc3RcblxuICBsZXQgeyBib2R5LCBoZWFkZXJzLCBjb250ZW50TGVuZ3RoIH0gPSByZXF1ZXN0XG5cbiAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzcyMzEjc2VjdGlvbi00LjMuMVxuICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzIzMSNzZWN0aW9uLTQuMy4yXG4gIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3MjMxI3NlY3Rpb24tNC4zLjVcblxuICAvLyBTZW5kaW5nIGEgcGF5bG9hZCBib2R5IG9uIGEgcmVxdWVzdCB0aGF0IGRvZXMgbm90XG4gIC8vIGV4cGVjdCBpdCBjYW4gY2F1c2UgdW5kZWZpbmVkIGJlaGF2aW9yIG9uIHNvbWVcbiAgLy8gc2VydmVycyBhbmQgY29ycnVwdCBjb25uZWN0aW9uIHN0YXRlLiBEbyBub3RcbiAgLy8gcmUtdXNlIHRoZSBjb25uZWN0aW9uIGZvciBmdXJ0aGVyIHJlcXVlc3RzLlxuXG4gIGNvbnN0IGV4cGVjdHNQYXlsb2FkID0gKFxuICAgIG1ldGhvZCA9PT0gJ1BVVCcgfHxcbiAgICBtZXRob2QgPT09ICdQT1NUJyB8fFxuICAgIG1ldGhvZCA9PT0gJ1BBVENIJ1xuICApXG5cbiAgaWYgKHV0aWwuaXNGb3JtRGF0YUxpa2UoYm9keSkpIHtcbiAgICBpZiAoIWV4dHJhY3RCb2R5KSB7XG4gICAgICBleHRyYWN0Qm9keSA9IHJlcXVpcmUoJy4uL3dlYi9mZXRjaC9ib2R5LmpzJykuZXh0cmFjdEJvZHlcbiAgICB9XG5cbiAgICBjb25zdCBbYm9keVN0cmVhbSwgY29udGVudFR5cGVdID0gZXh0cmFjdEJvZHkoYm9keSlcbiAgICBpZiAocmVxdWVzdC5jb250ZW50VHlwZSA9PSBudWxsKSB7XG4gICAgICBoZWFkZXJzLnB1c2goJ2NvbnRlbnQtdHlwZScsIGNvbnRlbnRUeXBlKVxuICAgIH1cbiAgICBib2R5ID0gYm9keVN0cmVhbS5zdHJlYW1cbiAgICBjb250ZW50TGVuZ3RoID0gYm9keVN0cmVhbS5sZW5ndGhcbiAgfSBlbHNlIGlmICh1dGlsLmlzQmxvYkxpa2UoYm9keSkgJiYgcmVxdWVzdC5jb250ZW50VHlwZSA9PSBudWxsICYmIGJvZHkudHlwZSkge1xuICAgIGhlYWRlcnMucHVzaCgnY29udGVudC10eXBlJywgYm9keS50eXBlKVxuICB9XG5cbiAgaWYgKGJvZHkgJiYgdHlwZW9mIGJvZHkucmVhZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIFRyeSB0byByZWFkIEVPRiBpbiBvcmRlciB0byBnZXQgbGVuZ3RoLlxuICAgIGJvZHkucmVhZCgwKVxuICB9XG5cbiAgY29uc3QgYm9keUxlbmd0aCA9IHV0aWwuYm9keUxlbmd0aChib2R5KVxuXG4gIGNvbnRlbnRMZW5ndGggPSBib2R5TGVuZ3RoID8/IGNvbnRlbnRMZW5ndGhcblxuICBpZiAoY29udGVudExlbmd0aCA9PT0gbnVsbCkge1xuICAgIGNvbnRlbnRMZW5ndGggPSByZXF1ZXN0LmNvbnRlbnRMZW5ndGhcbiAgfVxuXG4gIGlmIChjb250ZW50TGVuZ3RoID09PSAwICYmICFleHBlY3RzUGF5bG9hZCkge1xuICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3MjMwI3NlY3Rpb24tMy4zLjJcbiAgICAvLyBBIHVzZXIgYWdlbnQgU0hPVUxEIE5PVCBzZW5kIGEgQ29udGVudC1MZW5ndGggaGVhZGVyIGZpZWxkIHdoZW5cbiAgICAvLyB0aGUgcmVxdWVzdCBtZXNzYWdlIGRvZXMgbm90IGNvbnRhaW4gYSBwYXlsb2FkIGJvZHkgYW5kIHRoZSBtZXRob2RcbiAgICAvLyBzZW1hbnRpY3MgZG8gbm90IGFudGljaXBhdGUgc3VjaCBhIGJvZHkuXG5cbiAgICBjb250ZW50TGVuZ3RoID0gbnVsbFxuICB9XG5cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy91bmRpY2kvaXNzdWVzLzIwNDZcbiAgLy8gQSB1c2VyIGFnZW50IG1heSBzZW5kIGEgQ29udGVudC1MZW5ndGggaGVhZGVyIHdpdGggMCB2YWx1ZSwgdGhpcyBzaG91bGQgYmUgYWxsb3dlZC5cbiAgaWYgKHNob3VsZFNlbmRDb250ZW50TGVuZ3RoKG1ldGhvZCkgJiYgY29udGVudExlbmd0aCA+IDAgJiYgcmVxdWVzdC5jb250ZW50TGVuZ3RoICE9PSBudWxsICYmIHJlcXVlc3QuY29udGVudExlbmd0aCAhPT0gY29udGVudExlbmd0aCkge1xuICAgIGlmIChjbGllbnRba1N0cmljdENvbnRlbnRMZW5ndGhdKSB7XG4gICAgICB1dGlsLmVycm9yUmVxdWVzdChjbGllbnQsIHJlcXVlc3QsIG5ldyBSZXF1ZXN0Q29udGVudExlbmd0aE1pc21hdGNoRXJyb3IoKSlcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIHByb2Nlc3MuZW1pdFdhcm5pbmcobmV3IFJlcXVlc3RDb250ZW50TGVuZ3RoTWlzbWF0Y2hFcnJvcigpKVxuICB9XG5cbiAgY29uc3Qgc29ja2V0ID0gY2xpZW50W2tTb2NrZXRdXG5cbiAgY29uc3QgYWJvcnQgPSAoZXJyKSA9PiB7XG4gICAgaWYgKHJlcXVlc3QuYWJvcnRlZCB8fCByZXF1ZXN0LmNvbXBsZXRlZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdXRpbC5lcnJvclJlcXVlc3QoY2xpZW50LCByZXF1ZXN0LCBlcnIgfHwgbmV3IFJlcXVlc3RBYm9ydGVkRXJyb3IoKSlcblxuICAgIHV0aWwuZGVzdHJveShib2R5KVxuICAgIHV0aWwuZGVzdHJveShzb2NrZXQsIG5ldyBJbmZvcm1hdGlvbmFsRXJyb3IoJ2Fib3J0ZWQnKSlcbiAgfVxuXG4gIHRyeSB7XG4gICAgcmVxdWVzdC5vbkNvbm5lY3QoYWJvcnQpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHV0aWwuZXJyb3JSZXF1ZXN0KGNsaWVudCwgcmVxdWVzdCwgZXJyKVxuICB9XG5cbiAgaWYgKHJlcXVlc3QuYWJvcnRlZCkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgaWYgKG1ldGhvZCA9PT0gJ0hFQUQnKSB7XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21jb2xsaW5hL3VuZGljaS9pc3N1ZXMvMjU4XG4gICAgLy8gQ2xvc2UgYWZ0ZXIgYSBIRUFEIHJlcXVlc3QgdG8gaW50ZXJvcCB3aXRoIG1pc2JlaGF2aW5nIHNlcnZlcnNcbiAgICAvLyB0aGF0IG1heSBzZW5kIGEgYm9keSBpbiB0aGUgcmVzcG9uc2UuXG5cbiAgICBzb2NrZXRba1Jlc2V0XSA9IHRydWVcbiAgfVxuXG4gIGlmICh1cGdyYWRlIHx8IG1ldGhvZCA9PT0gJ0NPTk5FQ1QnKSB7XG4gICAgLy8gT24gQ09OTkVDVCBvciB1cGdyYWRlLCBibG9jayBwaXBlbGluZSBmcm9tIGRpc3BhdGNoaW5nIGZ1cnRoZXJcbiAgICAvLyByZXF1ZXN0cyBvbiB0aGlzIGNvbm5lY3Rpb24uXG5cbiAgICBzb2NrZXRba1Jlc2V0XSA9IHRydWVcbiAgfVxuXG4gIGlmIChyZXNldCAhPSBudWxsKSB7XG4gICAgc29ja2V0W2tSZXNldF0gPSByZXNldFxuICB9XG5cbiAgaWYgKGNsaWVudFtrTWF4UmVxdWVzdHNdICYmIHNvY2tldFtrQ291bnRlcl0rKyA+PSBjbGllbnRba01heFJlcXVlc3RzXSkge1xuICAgIHNvY2tldFtrUmVzZXRdID0gdHJ1ZVxuICB9XG5cbiAgaWYgKGJsb2NraW5nKSB7XG4gICAgc29ja2V0W2tCbG9ja2luZ10gPSB0cnVlXG4gIH1cblxuICBsZXQgaGVhZGVyID0gYCR7bWV0aG9kfSAke3BhdGh9IEhUVFAvMS4xXFxyXFxuYFxuXG4gIGlmICh0eXBlb2YgaG9zdCA9PT0gJ3N0cmluZycpIHtcbiAgICBoZWFkZXIgKz0gYGhvc3Q6ICR7aG9zdH1cXHJcXG5gXG4gIH0gZWxzZSB7XG4gICAgaGVhZGVyICs9IGNsaWVudFtrSG9zdEhlYWRlcl1cbiAgfVxuXG4gIGlmICh1cGdyYWRlKSB7XG4gICAgaGVhZGVyICs9IGBjb25uZWN0aW9uOiB1cGdyYWRlXFxyXFxudXBncmFkZTogJHt1cGdyYWRlfVxcclxcbmBcbiAgfSBlbHNlIGlmIChjbGllbnRba1BpcGVsaW5pbmddICYmICFzb2NrZXRba1Jlc2V0XSkge1xuICAgIGhlYWRlciArPSAnY29ubmVjdGlvbjoga2VlcC1hbGl2ZVxcclxcbidcbiAgfSBlbHNlIHtcbiAgICBoZWFkZXIgKz0gJ2Nvbm5lY3Rpb246IGNsb3NlXFxyXFxuJ1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoaGVhZGVycykpIHtcbiAgICBmb3IgKGxldCBuID0gMDsgbiA8IGhlYWRlcnMubGVuZ3RoOyBuICs9IDIpIHtcbiAgICAgIGNvbnN0IGtleSA9IGhlYWRlcnNbbiArIDBdXG4gICAgICBjb25zdCB2YWwgPSBoZWFkZXJzW24gKyAxXVxuXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaGVhZGVyICs9IGAke2tleX06ICR7dmFsW2ldfVxcclxcbmBcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaGVhZGVyICs9IGAke2tleX06ICR7dmFsfVxcclxcbmBcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoY2hhbm5lbHMuc2VuZEhlYWRlcnMuaGFzU3Vic2NyaWJlcnMpIHtcbiAgICBjaGFubmVscy5zZW5kSGVhZGVycy5wdWJsaXNoKHsgcmVxdWVzdCwgaGVhZGVyczogaGVhZGVyLCBzb2NrZXQgfSlcbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlOiBhc3NlcnRpb24gKi9cbiAgaWYgKCFib2R5IHx8IGJvZHlMZW5ndGggPT09IDApIHtcbiAgICB3cml0ZUJ1ZmZlcihhYm9ydCwgbnVsbCwgY2xpZW50LCByZXF1ZXN0LCBzb2NrZXQsIGNvbnRlbnRMZW5ndGgsIGhlYWRlciwgZXhwZWN0c1BheWxvYWQpXG4gIH0gZWxzZSBpZiAodXRpbC5pc0J1ZmZlcihib2R5KSkge1xuICAgIHdyaXRlQnVmZmVyKGFib3J0LCBib2R5LCBjbGllbnQsIHJlcXVlc3QsIHNvY2tldCwgY29udGVudExlbmd0aCwgaGVhZGVyLCBleHBlY3RzUGF5bG9hZClcbiAgfSBlbHNlIGlmICh1dGlsLmlzQmxvYkxpa2UoYm9keSkpIHtcbiAgICBpZiAodHlwZW9mIGJvZHkuc3RyZWFtID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB3cml0ZUl0ZXJhYmxlKGFib3J0LCBib2R5LnN0cmVhbSgpLCBjbGllbnQsIHJlcXVlc3QsIHNvY2tldCwgY29udGVudExlbmd0aCwgaGVhZGVyLCBleHBlY3RzUGF5bG9hZClcbiAgICB9IGVsc2Uge1xuICAgICAgd3JpdGVCbG9iKGFib3J0LCBib2R5LCBjbGllbnQsIHJlcXVlc3QsIHNvY2tldCwgY29udGVudExlbmd0aCwgaGVhZGVyLCBleHBlY3RzUGF5bG9hZClcbiAgICB9XG4gIH0gZWxzZSBpZiAodXRpbC5pc1N0cmVhbShib2R5KSkge1xuICAgIHdyaXRlU3RyZWFtKGFib3J0LCBib2R5LCBjbGllbnQsIHJlcXVlc3QsIHNvY2tldCwgY29udGVudExlbmd0aCwgaGVhZGVyLCBleHBlY3RzUGF5bG9hZClcbiAgfSBlbHNlIGlmICh1dGlsLmlzSXRlcmFibGUoYm9keSkpIHtcbiAgICB3cml0ZUl0ZXJhYmxlKGFib3J0LCBib2R5LCBjbGllbnQsIHJlcXVlc3QsIHNvY2tldCwgY29udGVudExlbmd0aCwgaGVhZGVyLCBleHBlY3RzUGF5bG9hZClcbiAgfSBlbHNlIHtcbiAgICBhc3NlcnQoZmFsc2UpXG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuXG5mdW5jdGlvbiB3cml0ZVN0cmVhbSAoYWJvcnQsIGJvZHksIGNsaWVudCwgcmVxdWVzdCwgc29ja2V0LCBjb250ZW50TGVuZ3RoLCBoZWFkZXIsIGV4cGVjdHNQYXlsb2FkKSB7XG4gIGFzc2VydChjb250ZW50TGVuZ3RoICE9PSAwIHx8IGNsaWVudFtrUnVubmluZ10gPT09IDAsICdzdHJlYW0gYm9keSBjYW5ub3QgYmUgcGlwZWxpbmVkJylcblxuICBsZXQgZmluaXNoZWQgPSBmYWxzZVxuXG4gIGNvbnN0IHdyaXRlciA9IG5ldyBBc3luY1dyaXRlcih7IGFib3J0LCBzb2NrZXQsIHJlcXVlc3QsIGNvbnRlbnRMZW5ndGgsIGNsaWVudCwgZXhwZWN0c1BheWxvYWQsIGhlYWRlciB9KVxuXG4gIGNvbnN0IG9uRGF0YSA9IGZ1bmN0aW9uIChjaHVuaykge1xuICAgIGlmIChmaW5pc2hlZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGlmICghd3JpdGVyLndyaXRlKGNodW5rKSAmJiB0aGlzLnBhdXNlKSB7XG4gICAgICAgIHRoaXMucGF1c2UoKVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdXRpbC5kZXN0cm95KHRoaXMsIGVycilcbiAgICB9XG4gIH1cbiAgY29uc3Qgb25EcmFpbiA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoZmluaXNoZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChib2R5LnJlc3VtZSkge1xuICAgICAgYm9keS5yZXN1bWUoKVxuICAgIH1cbiAgfVxuICBjb25zdCBvbkNsb3NlID0gZnVuY3Rpb24gKCkge1xuICAgIC8vICdjbG9zZScgbWlnaHQgYmUgZW1pdHRlZCAqYmVmb3JlKiAnZXJyb3InIGZvclxuICAgIC8vIGJyb2tlbiBzdHJlYW1zLiBXYWl0IGEgdGljayB0byBhdm9pZCB0aGlzIGNhc2UuXG4gICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgLy8gSXQncyBvbmx5IHNhZmUgdG8gcmVtb3ZlICdlcnJvcicgbGlzdGVuZXIgYWZ0ZXJcbiAgICAgIC8vICdjbG9zZScuXG4gICAgICBib2R5LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uRmluaXNoZWQpXG4gICAgfSlcblxuICAgIGlmICghZmluaXNoZWQpIHtcbiAgICAgIGNvbnN0IGVyciA9IG5ldyBSZXF1ZXN0QWJvcnRlZEVycm9yKClcbiAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IG9uRmluaXNoZWQoZXJyKSlcbiAgICB9XG4gIH1cbiAgY29uc3Qgb25GaW5pc2hlZCA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoZmluaXNoZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGZpbmlzaGVkID0gdHJ1ZVxuXG4gICAgYXNzZXJ0KHNvY2tldC5kZXN0cm95ZWQgfHwgKHNvY2tldFtrV3JpdGluZ10gJiYgY2xpZW50W2tSdW5uaW5nXSA8PSAxKSlcblxuICAgIHNvY2tldFxuICAgICAgLm9mZignZHJhaW4nLCBvbkRyYWluKVxuICAgICAgLm9mZignZXJyb3InLCBvbkZpbmlzaGVkKVxuXG4gICAgYm9keVxuICAgICAgLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25EYXRhKVxuICAgICAgLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbkZpbmlzaGVkKVxuICAgICAgLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uQ2xvc2UpXG5cbiAgICBpZiAoIWVycikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgd3JpdGVyLmVuZCgpXG4gICAgICB9IGNhdGNoIChlcikge1xuICAgICAgICBlcnIgPSBlclxuICAgICAgfVxuICAgIH1cblxuICAgIHdyaXRlci5kZXN0cm95KGVycilcblxuICAgIGlmIChlcnIgJiYgKGVyci5jb2RlICE9PSAnVU5EX0VSUl9JTkZPJyB8fCBlcnIubWVzc2FnZSAhPT0gJ3Jlc2V0JykpIHtcbiAgICAgIHV0aWwuZGVzdHJveShib2R5LCBlcnIpXG4gICAgfSBlbHNlIHtcbiAgICAgIHV0aWwuZGVzdHJveShib2R5KVxuICAgIH1cbiAgfVxuXG4gIGJvZHlcbiAgICAub24oJ2RhdGEnLCBvbkRhdGEpXG4gICAgLm9uKCdlbmQnLCBvbkZpbmlzaGVkKVxuICAgIC5vbignZXJyb3InLCBvbkZpbmlzaGVkKVxuICAgIC5vbignY2xvc2UnLCBvbkNsb3NlKVxuXG4gIGlmIChib2R5LnJlc3VtZSkge1xuICAgIGJvZHkucmVzdW1lKClcbiAgfVxuXG4gIHNvY2tldFxuICAgIC5vbignZHJhaW4nLCBvbkRyYWluKVxuICAgIC5vbignZXJyb3InLCBvbkZpbmlzaGVkKVxuXG4gIGlmIChib2R5LmVycm9yRW1pdHRlZCA/PyBib2R5LmVycm9yZWQpIHtcbiAgICBzZXRJbW1lZGlhdGUoKCkgPT4gb25GaW5pc2hlZChib2R5LmVycm9yZWQpKVxuICB9IGVsc2UgaWYgKGJvZHkuZW5kRW1pdHRlZCA/PyBib2R5LnJlYWRhYmxlRW5kZWQpIHtcbiAgICBzZXRJbW1lZGlhdGUoKCkgPT4gb25GaW5pc2hlZChudWxsKSlcbiAgfVxuXG4gIGlmIChib2R5LmNsb3NlRW1pdHRlZCA/PyBib2R5LmNsb3NlZCkge1xuICAgIHNldEltbWVkaWF0ZShvbkNsb3NlKVxuICB9XG59XG5cbmZ1bmN0aW9uIHdyaXRlQnVmZmVyIChhYm9ydCwgYm9keSwgY2xpZW50LCByZXF1ZXN0LCBzb2NrZXQsIGNvbnRlbnRMZW5ndGgsIGhlYWRlciwgZXhwZWN0c1BheWxvYWQpIHtcbiAgdHJ5IHtcbiAgICBpZiAoIWJvZHkpIHtcbiAgICAgIGlmIChjb250ZW50TGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHNvY2tldC53cml0ZShgJHtoZWFkZXJ9Y29udGVudC1sZW5ndGg6IDBcXHJcXG5cXHJcXG5gLCAnbGF0aW4xJylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFzc2VydChjb250ZW50TGVuZ3RoID09PSBudWxsLCAnbm8gYm9keSBtdXN0IG5vdCBoYXZlIGNvbnRlbnQgbGVuZ3RoJylcbiAgICAgICAgc29ja2V0LndyaXRlKGAke2hlYWRlcn1cXHJcXG5gLCAnbGF0aW4xJylcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHV0aWwuaXNCdWZmZXIoYm9keSkpIHtcbiAgICAgIGFzc2VydChjb250ZW50TGVuZ3RoID09PSBib2R5LmJ5dGVMZW5ndGgsICdidWZmZXIgYm9keSBtdXN0IGhhdmUgY29udGVudCBsZW5ndGgnKVxuXG4gICAgICBzb2NrZXQuY29yaygpXG4gICAgICBzb2NrZXQud3JpdGUoYCR7aGVhZGVyfWNvbnRlbnQtbGVuZ3RoOiAke2NvbnRlbnRMZW5ndGh9XFxyXFxuXFxyXFxuYCwgJ2xhdGluMScpXG4gICAgICBzb2NrZXQud3JpdGUoYm9keSlcbiAgICAgIHNvY2tldC51bmNvcmsoKVxuICAgICAgcmVxdWVzdC5vbkJvZHlTZW50KGJvZHkpXG5cbiAgICAgIGlmICghZXhwZWN0c1BheWxvYWQpIHtcbiAgICAgICAgc29ja2V0W2tSZXNldF0gPSB0cnVlXG4gICAgICB9XG4gICAgfVxuICAgIHJlcXVlc3Qub25SZXF1ZXN0U2VudCgpXG5cbiAgICBjbGllbnRba1Jlc3VtZV0oKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBhYm9ydChlcnIpXG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gd3JpdGVCbG9iIChhYm9ydCwgYm9keSwgY2xpZW50LCByZXF1ZXN0LCBzb2NrZXQsIGNvbnRlbnRMZW5ndGgsIGhlYWRlciwgZXhwZWN0c1BheWxvYWQpIHtcbiAgYXNzZXJ0KGNvbnRlbnRMZW5ndGggPT09IGJvZHkuc2l6ZSwgJ2Jsb2IgYm9keSBtdXN0IGhhdmUgY29udGVudCBsZW5ndGgnKVxuXG4gIHRyeSB7XG4gICAgaWYgKGNvbnRlbnRMZW5ndGggIT0gbnVsbCAmJiBjb250ZW50TGVuZ3RoICE9PSBib2R5LnNpemUpIHtcbiAgICAgIHRocm93IG5ldyBSZXF1ZXN0Q29udGVudExlbmd0aE1pc21hdGNoRXJyb3IoKVxuICAgIH1cblxuICAgIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5mcm9tKGF3YWl0IGJvZHkuYXJyYXlCdWZmZXIoKSlcblxuICAgIHNvY2tldC5jb3JrKClcbiAgICBzb2NrZXQud3JpdGUoYCR7aGVhZGVyfWNvbnRlbnQtbGVuZ3RoOiAke2NvbnRlbnRMZW5ndGh9XFxyXFxuXFxyXFxuYCwgJ2xhdGluMScpXG4gICAgc29ja2V0LndyaXRlKGJ1ZmZlcilcbiAgICBzb2NrZXQudW5jb3JrKClcblxuICAgIHJlcXVlc3Qub25Cb2R5U2VudChidWZmZXIpXG4gICAgcmVxdWVzdC5vblJlcXVlc3RTZW50KClcblxuICAgIGlmICghZXhwZWN0c1BheWxvYWQpIHtcbiAgICAgIHNvY2tldFtrUmVzZXRdID0gdHJ1ZVxuICAgIH1cblxuICAgIGNsaWVudFtrUmVzdW1lXSgpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGFib3J0KGVycilcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiB3cml0ZUl0ZXJhYmxlIChhYm9ydCwgYm9keSwgY2xpZW50LCByZXF1ZXN0LCBzb2NrZXQsIGNvbnRlbnRMZW5ndGgsIGhlYWRlciwgZXhwZWN0c1BheWxvYWQpIHtcbiAgYXNzZXJ0KGNvbnRlbnRMZW5ndGggIT09IDAgfHwgY2xpZW50W2tSdW5uaW5nXSA9PT0gMCwgJ2l0ZXJhdG9yIGJvZHkgY2Fubm90IGJlIHBpcGVsaW5lZCcpXG5cbiAgbGV0IGNhbGxiYWNrID0gbnVsbFxuICBmdW5jdGlvbiBvbkRyYWluICgpIHtcbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIGNvbnN0IGNiID0gY2FsbGJhY2tcbiAgICAgIGNhbGxiYWNrID0gbnVsbFxuICAgICAgY2IoKVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHdhaXRGb3JEcmFpbiA9ICgpID0+IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBhc3NlcnQoY2FsbGJhY2sgPT09IG51bGwpXG5cbiAgICBpZiAoc29ja2V0W2tFcnJvcl0pIHtcbiAgICAgIHJlamVjdChzb2NrZXRba0Vycm9yXSlcbiAgICB9IGVsc2Uge1xuICAgICAgY2FsbGJhY2sgPSByZXNvbHZlXG4gICAgfVxuICB9KVxuXG4gIHNvY2tldFxuICAgIC5vbignY2xvc2UnLCBvbkRyYWluKVxuICAgIC5vbignZHJhaW4nLCBvbkRyYWluKVxuXG4gIGNvbnN0IHdyaXRlciA9IG5ldyBBc3luY1dyaXRlcih7IGFib3J0LCBzb2NrZXQsIHJlcXVlc3QsIGNvbnRlbnRMZW5ndGgsIGNsaWVudCwgZXhwZWN0c1BheWxvYWQsIGhlYWRlciB9KVxuICB0cnkge1xuICAgIC8vIEl0J3MgdXAgdG8gdGhlIHVzZXIgdG8gc29tZWhvdyBhYm9ydCB0aGUgYXN5bmMgaXRlcmFibGUuXG4gICAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBib2R5KSB7XG4gICAgICBpZiAoc29ja2V0W2tFcnJvcl0pIHtcbiAgICAgICAgdGhyb3cgc29ja2V0W2tFcnJvcl1cbiAgICAgIH1cblxuICAgICAgaWYgKCF3cml0ZXIud3JpdGUoY2h1bmspKSB7XG4gICAgICAgIGF3YWl0IHdhaXRGb3JEcmFpbigpXG4gICAgICB9XG4gICAgfVxuXG4gICAgd3JpdGVyLmVuZCgpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHdyaXRlci5kZXN0cm95KGVycilcbiAgfSBmaW5hbGx5IHtcbiAgICBzb2NrZXRcbiAgICAgIC5vZmYoJ2Nsb3NlJywgb25EcmFpbilcbiAgICAgIC5vZmYoJ2RyYWluJywgb25EcmFpbilcbiAgfVxufVxuXG5jbGFzcyBBc3luY1dyaXRlciB7XG4gIGNvbnN0cnVjdG9yICh7IGFib3J0LCBzb2NrZXQsIHJlcXVlc3QsIGNvbnRlbnRMZW5ndGgsIGNsaWVudCwgZXhwZWN0c1BheWxvYWQsIGhlYWRlciB9KSB7XG4gICAgdGhpcy5zb2NrZXQgPSBzb2NrZXRcbiAgICB0aGlzLnJlcXVlc3QgPSByZXF1ZXN0XG4gICAgdGhpcy5jb250ZW50TGVuZ3RoID0gY29udGVudExlbmd0aFxuICAgIHRoaXMuY2xpZW50ID0gY2xpZW50XG4gICAgdGhpcy5ieXRlc1dyaXR0ZW4gPSAwXG4gICAgdGhpcy5leHBlY3RzUGF5bG9hZCA9IGV4cGVjdHNQYXlsb2FkXG4gICAgdGhpcy5oZWFkZXIgPSBoZWFkZXJcbiAgICB0aGlzLmFib3J0ID0gYWJvcnRcblxuICAgIHNvY2tldFtrV3JpdGluZ10gPSB0cnVlXG4gIH1cblxuICB3cml0ZSAoY2h1bmspIHtcbiAgICBjb25zdCB7IHNvY2tldCwgcmVxdWVzdCwgY29udGVudExlbmd0aCwgY2xpZW50LCBieXRlc1dyaXR0ZW4sIGV4cGVjdHNQYXlsb2FkLCBoZWFkZXIgfSA9IHRoaXNcblxuICAgIGlmIChzb2NrZXRba0Vycm9yXSkge1xuICAgICAgdGhyb3cgc29ja2V0W2tFcnJvcl1cbiAgICB9XG5cbiAgICBpZiAoc29ja2V0LmRlc3Ryb3llZCkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgY29uc3QgbGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgoY2h1bmspXG4gICAgaWYgKCFsZW4pIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgLy8gV2Ugc2hvdWxkIGRlZmVyIHdyaXRpbmcgY2h1bmtzLlxuICAgIGlmIChjb250ZW50TGVuZ3RoICE9PSBudWxsICYmIGJ5dGVzV3JpdHRlbiArIGxlbiA+IGNvbnRlbnRMZW5ndGgpIHtcbiAgICAgIGlmIChjbGllbnRba1N0cmljdENvbnRlbnRMZW5ndGhdKSB7XG4gICAgICAgIHRocm93IG5ldyBSZXF1ZXN0Q29udGVudExlbmd0aE1pc21hdGNoRXJyb3IoKVxuICAgICAgfVxuXG4gICAgICBwcm9jZXNzLmVtaXRXYXJuaW5nKG5ldyBSZXF1ZXN0Q29udGVudExlbmd0aE1pc21hdGNoRXJyb3IoKSlcbiAgICB9XG5cbiAgICBzb2NrZXQuY29yaygpXG5cbiAgICBpZiAoYnl0ZXNXcml0dGVuID09PSAwKSB7XG4gICAgICBpZiAoIWV4cGVjdHNQYXlsb2FkKSB7XG4gICAgICAgIHNvY2tldFtrUmVzZXRdID0gdHJ1ZVxuICAgICAgfVxuXG4gICAgICBpZiAoY29udGVudExlbmd0aCA9PT0gbnVsbCkge1xuICAgICAgICBzb2NrZXQud3JpdGUoYCR7aGVhZGVyfXRyYW5zZmVyLWVuY29kaW5nOiBjaHVua2VkXFxyXFxuYCwgJ2xhdGluMScpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzb2NrZXQud3JpdGUoYCR7aGVhZGVyfWNvbnRlbnQtbGVuZ3RoOiAke2NvbnRlbnRMZW5ndGh9XFxyXFxuXFxyXFxuYCwgJ2xhdGluMScpXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvbnRlbnRMZW5ndGggPT09IG51bGwpIHtcbiAgICAgIHNvY2tldC53cml0ZShgXFxyXFxuJHtsZW4udG9TdHJpbmcoMTYpfVxcclxcbmAsICdsYXRpbjEnKVxuICAgIH1cblxuICAgIHRoaXMuYnl0ZXNXcml0dGVuICs9IGxlblxuXG4gICAgY29uc3QgcmV0ID0gc29ja2V0LndyaXRlKGNodW5rKVxuXG4gICAgc29ja2V0LnVuY29yaygpXG5cbiAgICByZXF1ZXN0Lm9uQm9keVNlbnQoY2h1bmspXG5cbiAgICBpZiAoIXJldCkge1xuICAgICAgaWYgKHNvY2tldFtrUGFyc2VyXS50aW1lb3V0ICYmIHNvY2tldFtrUGFyc2VyXS50aW1lb3V0VHlwZSA9PT0gVElNRU9VVF9IRUFERVJTKSB7XG4gICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBlbHNlOiBvbmx5IGZvciBqZXN0XG4gICAgICAgIGlmIChzb2NrZXRba1BhcnNlcl0udGltZW91dC5yZWZyZXNoKSB7XG4gICAgICAgICAgc29ja2V0W2tQYXJzZXJdLnRpbWVvdXQucmVmcmVzaCgpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmV0XG4gIH1cblxuICBlbmQgKCkge1xuICAgIGNvbnN0IHsgc29ja2V0LCBjb250ZW50TGVuZ3RoLCBjbGllbnQsIGJ5dGVzV3JpdHRlbiwgZXhwZWN0c1BheWxvYWQsIGhlYWRlciwgcmVxdWVzdCB9ID0gdGhpc1xuICAgIHJlcXVlc3Qub25SZXF1ZXN0U2VudCgpXG5cbiAgICBzb2NrZXRba1dyaXRpbmddID0gZmFsc2VcblxuICAgIGlmIChzb2NrZXRba0Vycm9yXSkge1xuICAgICAgdGhyb3cgc29ja2V0W2tFcnJvcl1cbiAgICB9XG5cbiAgICBpZiAoc29ja2V0LmRlc3Ryb3llZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKGJ5dGVzV3JpdHRlbiA9PT0gMCkge1xuICAgICAgaWYgKGV4cGVjdHNQYXlsb2FkKSB7XG4gICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3MjMwI3NlY3Rpb24tMy4zLjJcbiAgICAgICAgLy8gQSB1c2VyIGFnZW50IFNIT1VMRCBzZW5kIGEgQ29udGVudC1MZW5ndGggaW4gYSByZXF1ZXN0IG1lc3NhZ2Ugd2hlblxuICAgICAgICAvLyBubyBUcmFuc2Zlci1FbmNvZGluZyBpcyBzZW50IGFuZCB0aGUgcmVxdWVzdCBtZXRob2QgZGVmaW5lcyBhIG1lYW5pbmdcbiAgICAgICAgLy8gZm9yIGFuIGVuY2xvc2VkIHBheWxvYWQgYm9keS5cblxuICAgICAgICBzb2NrZXQud3JpdGUoYCR7aGVhZGVyfWNvbnRlbnQtbGVuZ3RoOiAwXFxyXFxuXFxyXFxuYCwgJ2xhdGluMScpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzb2NrZXQud3JpdGUoYCR7aGVhZGVyfVxcclxcbmAsICdsYXRpbjEnKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY29udGVudExlbmd0aCA9PT0gbnVsbCkge1xuICAgICAgc29ja2V0LndyaXRlKCdcXHJcXG4wXFxyXFxuXFxyXFxuJywgJ2xhdGluMScpXG4gICAgfVxuXG4gICAgaWYgKGNvbnRlbnRMZW5ndGggIT09IG51bGwgJiYgYnl0ZXNXcml0dGVuICE9PSBjb250ZW50TGVuZ3RoKSB7XG4gICAgICBpZiAoY2xpZW50W2tTdHJpY3RDb250ZW50TGVuZ3RoXSkge1xuICAgICAgICB0aHJvdyBuZXcgUmVxdWVzdENvbnRlbnRMZW5ndGhNaXNtYXRjaEVycm9yKClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb2Nlc3MuZW1pdFdhcm5pbmcobmV3IFJlcXVlc3RDb250ZW50TGVuZ3RoTWlzbWF0Y2hFcnJvcigpKVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzb2NrZXRba1BhcnNlcl0udGltZW91dCAmJiBzb2NrZXRba1BhcnNlcl0udGltZW91dFR5cGUgPT09IFRJTUVPVVRfSEVBREVSUykge1xuICAgICAgLy8gaXN0YW5idWwgaWdub3JlIGVsc2U6IG9ubHkgZm9yIGplc3RcbiAgICAgIGlmIChzb2NrZXRba1BhcnNlcl0udGltZW91dC5yZWZyZXNoKSB7XG4gICAgICAgIHNvY2tldFtrUGFyc2VyXS50aW1lb3V0LnJlZnJlc2goKVxuICAgICAgfVxuICAgIH1cblxuICAgIGNsaWVudFtrUmVzdW1lXSgpXG4gIH1cblxuICBkZXN0cm95IChlcnIpIHtcbiAgICBjb25zdCB7IHNvY2tldCwgY2xpZW50LCBhYm9ydCB9ID0gdGhpc1xuXG4gICAgc29ja2V0W2tXcml0aW5nXSA9IGZhbHNlXG5cbiAgICBpZiAoZXJyKSB7XG4gICAgICBhc3NlcnQoY2xpZW50W2tSdW5uaW5nXSA8PSAxLCAncGlwZWxpbmUgc2hvdWxkIG9ubHkgY29udGFpbiB0aGlzIHJlcXVlc3QnKVxuICAgICAgYWJvcnQoZXJyKVxuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbm5lY3RIMVxuIl0sIm5hbWVzIjpbImFzc2VydCIsInJlcXVpcmUiLCJ1dGlsIiwiY2hhbm5lbHMiLCJ0aW1lcnMiLCJSZXF1ZXN0Q29udGVudExlbmd0aE1pc21hdGNoRXJyb3IiLCJSZXNwb25zZUNvbnRlbnRMZW5ndGhNaXNtYXRjaEVycm9yIiwiUmVxdWVzdEFib3J0ZWRFcnJvciIsIkhlYWRlcnNUaW1lb3V0RXJyb3IiLCJIZWFkZXJzT3ZlcmZsb3dFcnJvciIsIlNvY2tldEVycm9yIiwiSW5mb3JtYXRpb25hbEVycm9yIiwiQm9keVRpbWVvdXRFcnJvciIsIkhUVFBQYXJzZXJFcnJvciIsIlJlc3BvbnNlRXhjZWVkZWRNYXhTaXplRXJyb3IiLCJrVXJsIiwia1Jlc2V0Iiwia0NsaWVudCIsImtQYXJzZXIiLCJrQmxvY2tpbmciLCJrUnVubmluZyIsImtQZW5kaW5nIiwia1NpemUiLCJrV3JpdGluZyIsImtRdWV1ZSIsImtOb1JlZiIsImtLZWVwQWxpdmVEZWZhdWx0VGltZW91dCIsImtIb3N0SGVhZGVyIiwia1BlbmRpbmdJZHgiLCJrUnVubmluZ0lkeCIsImtFcnJvciIsImtQaXBlbGluaW5nIiwia1NvY2tldCIsImtLZWVwQWxpdmVUaW1lb3V0VmFsdWUiLCJrTWF4SGVhZGVyc1NpemUiLCJrS2VlcEFsaXZlTWF4VGltZW91dCIsImtLZWVwQWxpdmVUaW1lb3V0VGhyZXNob2xkIiwia0hlYWRlcnNUaW1lb3V0Iiwia0JvZHlUaW1lb3V0Iiwia1N0cmljdENvbnRlbnRMZW5ndGgiLCJrTWF4UmVxdWVzdHMiLCJrQ291bnRlciIsImtNYXhSZXNwb25zZVNpemUiLCJrT25FcnJvciIsImtSZXN1bWUiLCJrSFRUUENvbnRleHQiLCJjb25zdGFudHMiLCJFTVBUWV9CVUYiLCJCdWZmZXIiLCJhbGxvYyIsIkZhc3RCdWZmZXIiLCJTeW1ib2wiLCJzcGVjaWVzIiwiYWRkTGlzdGVuZXIiLCJyZW1vdmVBbGxMaXN0ZW5lcnMiLCJleHRyYWN0Qm9keSIsImxhenlsbGh0dHAiLCJsbGh0dHBXYXNtRGF0YSIsInByb2Nlc3MiLCJlbnYiLCJKRVNUX1dPUktFUl9JRCIsInVuZGVmaW5lZCIsIm1vZCIsIldlYkFzc2VtYmx5IiwiY29tcGlsZSIsImUiLCJpbnN0YW50aWF0ZSIsIndhc21fb25fdXJsIiwicCIsImF0IiwibGVuIiwid2FzbV9vbl9zdGF0dXMiLCJzdHJpY3RFcXVhbCIsImN1cnJlbnRQYXJzZXIiLCJwdHIiLCJzdGFydCIsImN1cnJlbnRCdWZmZXJQdHIiLCJjdXJyZW50QnVmZmVyUmVmIiwiYnl0ZU9mZnNldCIsIm9uU3RhdHVzIiwiYnVmZmVyIiwid2FzbV9vbl9tZXNzYWdlX2JlZ2luIiwib25NZXNzYWdlQmVnaW4iLCJ3YXNtX29uX2hlYWRlcl9maWVsZCIsIm9uSGVhZGVyRmllbGQiLCJ3YXNtX29uX2hlYWRlcl92YWx1ZSIsIm9uSGVhZGVyVmFsdWUiLCJ3YXNtX29uX2hlYWRlcnNfY29tcGxldGUiLCJzdGF0dXNDb2RlIiwidXBncmFkZSIsInNob3VsZEtlZXBBbGl2ZSIsIm9uSGVhZGVyc0NvbXBsZXRlIiwiQm9vbGVhbiIsIndhc21fb25fYm9keSIsIm9uQm9keSIsIndhc21fb25fbWVzc2FnZV9jb21wbGV0ZSIsIm9uTWVzc2FnZUNvbXBsZXRlIiwibGxodHRwSW5zdGFuY2UiLCJsbGh0dHBQcm9taXNlIiwiY2F0Y2giLCJjdXJyZW50QnVmZmVyU2l6ZSIsIlRJTUVPVVRfSEVBREVSUyIsIlRJTUVPVVRfQk9EWSIsIlRJTUVPVVRfSURMRSIsIlBhcnNlciIsImNvbnN0cnVjdG9yIiwiY2xpZW50Iiwic29ja2V0IiwiZXhwb3J0cyIsIk51bWJlciIsImlzRmluaXRlIiwibGxodHRwIiwibGxodHRwX2FsbG9jIiwiVFlQRSIsIlJFU1BPTlNFIiwidGltZW91dCIsInRpbWVvdXRWYWx1ZSIsInRpbWVvdXRUeXBlIiwic3RhdHVzVGV4dCIsImhlYWRlcnMiLCJoZWFkZXJzU2l6ZSIsImhlYWRlcnNNYXhTaXplIiwicGF1c2VkIiwicmVzdW1lIiwiYmluZCIsImJ5dGVzUmVhZCIsImtlZXBBbGl2ZSIsImNvbnRlbnRMZW5ndGgiLCJjb25uZWN0aW9uIiwibWF4UmVzcG9uc2VTaXplIiwic2V0VGltZW91dCIsInZhbHVlIiwidHlwZSIsImNsZWFyVGltZW91dCIsIm9uUGFyc2VyVGltZW91dCIsInVucmVmIiwicmVmcmVzaCIsImRlc3Ryb3llZCIsImxsaHR0cF9yZXN1bWUiLCJleGVjdXRlIiwicmVhZCIsInJlYWRNb3JlIiwiY2h1bmsiLCJkYXRhIiwibGVuZ3RoIiwiZnJlZSIsIk1hdGgiLCJjZWlsIiwibWFsbG9jIiwiVWludDhBcnJheSIsIm1lbW9yeSIsInNldCIsInJldCIsImxsaHR0cF9leGVjdXRlIiwiZXJyIiwib2Zmc2V0IiwibGxodHRwX2dldF9lcnJvcl9wb3MiLCJFUlJPUiIsIlBBVVNFRF9VUEdSQURFIiwib25VcGdyYWRlIiwic2xpY2UiLCJQQVVTRUQiLCJ1bnNoaWZ0IiwiT0siLCJsbGh0dHBfZ2V0X2Vycm9yX3JlYXNvbiIsIm1lc3NhZ2UiLCJpbmRleE9mIiwiZnJvbSIsInRvU3RyaW5nIiwiZGVzdHJveSIsImxsaHR0cF9mcmVlIiwiYnVmIiwicmVxdWVzdCIsIm9uUmVzcG9uc2VTdGFydGVkIiwicHVzaCIsImNvbmNhdCIsInRyYWNrSGVhZGVyIiwia2V5IiwiaGVhZGVyTmFtZSIsImJ1ZmZlclRvTG93ZXJDYXNlZEhlYWRlck5hbWUiLCJoZWFkIiwibWV0aG9kIiwiZW1pdCIsImdldFNvY2tldEluZm8iLCJ0b0xvd2VyQ2FzZSIsImJvZHlUaW1lb3V0Iiwia2VlcEFsaXZlVGltZW91dCIsInBhcnNlS2VlcEFsaXZlVGltZW91dCIsIm1pbiIsInBhdXNlIiwib25IZWFkZXJzIiwiYWJvcnRlZCIsIm9uRGF0YSIsInBhcnNlSW50Iiwib25Db21wbGV0ZSIsInNldEltbWVkaWF0ZSIsInBhcnNlciIsIndyaXRhYmxlTmVlZERyYWluIiwiY29ubmVjdEgxIiwiY29kZSIsInJlcXVlc3RzIiwic3BsaWNlIiwiaSIsImVycm9yUmVxdWVzdCIsImNsb3NlZCIsIm9uIiwidmVyc2lvbiIsImRlZmF1bHRQaXBlbGluaW5nIiwid3JpdGUiLCJhcmdzIiwid3JpdGVIMSIsInJlc3VtZUgxIiwiY2FsbGJhY2siLCJxdWV1ZU1pY3JvdGFzayIsImJ1c3kiLCJpZGVtcG90ZW50IiwiYm9keUxlbmd0aCIsImJvZHkiLCJpc1N0cmVhbSIsImlzQXN5bmNJdGVyYWJsZSIsImlzRm9ybURhdGFMaWtlIiwicmVmIiwiaGVhZGVyc1RpbWVvdXQiLCJzaG91bGRTZW5kQ29udGVudExlbmd0aCIsInBhdGgiLCJob3N0IiwiYmxvY2tpbmciLCJyZXNldCIsImV4cGVjdHNQYXlsb2FkIiwiYm9keVN0cmVhbSIsImNvbnRlbnRUeXBlIiwic3RyZWFtIiwiaXNCbG9iTGlrZSIsImVtaXRXYXJuaW5nIiwiYWJvcnQiLCJjb21wbGV0ZWQiLCJvbkNvbm5lY3QiLCJoZWFkZXIiLCJBcnJheSIsImlzQXJyYXkiLCJuIiwidmFsIiwic2VuZEhlYWRlcnMiLCJoYXNTdWJzY3JpYmVycyIsInB1Ymxpc2giLCJ3cml0ZUJ1ZmZlciIsImlzQnVmZmVyIiwid3JpdGVJdGVyYWJsZSIsIndyaXRlQmxvYiIsIndyaXRlU3RyZWFtIiwiaXNJdGVyYWJsZSIsImZpbmlzaGVkIiwid3JpdGVyIiwiQXN5bmNXcml0ZXIiLCJvbkRyYWluIiwib25DbG9zZSIsInJlbW92ZUxpc3RlbmVyIiwib25GaW5pc2hlZCIsIm9mZiIsImVuZCIsImVyIiwiZXJyb3JFbWl0dGVkIiwiZXJyb3JlZCIsImVuZEVtaXR0ZWQiLCJyZWFkYWJsZUVuZGVkIiwiY2xvc2VFbWl0dGVkIiwiYnl0ZUxlbmd0aCIsImNvcmsiLCJ1bmNvcmsiLCJvbkJvZHlTZW50Iiwib25SZXF1ZXN0U2VudCIsInNpemUiLCJhcnJheUJ1ZmZlciIsImNiIiwid2FpdEZvckRyYWluIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJieXRlc1dyaXR0ZW4iLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/dispatcher/client-h1.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/dispatcher/client-h2.js":
/*!*********************************************************!*\
  !*** ./node_modules/undici/lib/dispatcher/client-h2.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\");\nconst { pipeline } = __webpack_require__(/*! node:stream */ \"node:stream\");\nconst util = __webpack_require__(/*! ../core/util.js */ \"(ssr)/./node_modules/undici/lib/core/util.js\");\nconst { RequestContentLengthMismatchError, RequestAbortedError, SocketError, InformationalError } = __webpack_require__(/*! ../core/errors.js */ \"(ssr)/./node_modules/undici/lib/core/errors.js\");\nconst { kUrl, kReset, kClient, kRunning, kPending, kQueue, kPendingIdx, kRunningIdx, kError, kSocket, kStrictContentLength, kOnError, kMaxConcurrentStreams, kHTTP2Session, kResume } = __webpack_require__(/*! ../core/symbols.js */ \"(ssr)/./node_modules/undici/lib/core/symbols.js\");\nconst kOpenStreams = Symbol(\"open streams\");\n// Experimental\nlet h2ExperimentalWarned = false;\n/** @type {import('http2')} */ let http2;\ntry {\n    http2 = __webpack_require__(/*! node:http2 */ \"node:http2\");\n} catch  {\n    // @ts-ignore\n    http2 = {\n        constants: {}\n    };\n}\nconst { constants: { HTTP2_HEADER_AUTHORITY, HTTP2_HEADER_METHOD, HTTP2_HEADER_PATH, HTTP2_HEADER_SCHEME, HTTP2_HEADER_CONTENT_LENGTH, HTTP2_HEADER_EXPECT, HTTP2_HEADER_STATUS } } = http2;\nfunction parseH2Headers(headers) {\n    const result = [];\n    for (const [name, value] of Object.entries(headers)){\n        // h2 may concat the header value by array\n        // e.g. Set-Cookie\n        if (Array.isArray(value)) {\n            for (const subvalue of value){\n                // we need to provide each header value of header name\n                // because the headers handler expect name-value pair\n                result.push(Buffer.from(name), Buffer.from(subvalue));\n            }\n        } else {\n            result.push(Buffer.from(name), Buffer.from(value));\n        }\n    }\n    return result;\n}\nasync function connectH2(client, socket) {\n    client[kSocket] = socket;\n    if (!h2ExperimentalWarned) {\n        h2ExperimentalWarned = true;\n        process.emitWarning(\"H2 support is experimental, expect them to change at any time.\", {\n            code: \"UNDICI-H2\"\n        });\n    }\n    const session = http2.connect(client[kUrl], {\n        createConnection: ()=>socket,\n        peerMaxConcurrentStreams: client[kMaxConcurrentStreams]\n    });\n    session[kOpenStreams] = 0;\n    session[kClient] = client;\n    session[kSocket] = socket;\n    util.addListener(session, \"error\", onHttp2SessionError);\n    util.addListener(session, \"frameError\", onHttp2FrameError);\n    util.addListener(session, \"end\", onHttp2SessionEnd);\n    util.addListener(session, \"goaway\", onHTTP2GoAway);\n    util.addListener(session, \"close\", function() {\n        const { [kClient]: client } = this;\n        const { [kSocket]: socket } = client;\n        const err = this[kSocket][kError] || this[kError] || new SocketError(\"closed\", util.getSocketInfo(socket));\n        client[kHTTP2Session] = null;\n        if (client.destroyed) {\n            assert(client[kPending] === 0);\n            // Fail entire queue.\n            const requests = client[kQueue].splice(client[kRunningIdx]);\n            for(let i = 0; i < requests.length; i++){\n                const request = requests[i];\n                util.errorRequest(client, request, err);\n            }\n        }\n    });\n    session.unref();\n    client[kHTTP2Session] = session;\n    socket[kHTTP2Session] = session;\n    util.addListener(socket, \"error\", function(err) {\n        assert(err.code !== \"ERR_TLS_CERT_ALTNAME_INVALID\");\n        this[kError] = err;\n        this[kClient][kOnError](err);\n    });\n    util.addListener(socket, \"end\", function() {\n        util.destroy(this, new SocketError(\"other side closed\", util.getSocketInfo(this)));\n    });\n    util.addListener(socket, \"close\", function() {\n        const err = this[kError] || new SocketError(\"closed\", util.getSocketInfo(this));\n        client[kSocket] = null;\n        if (this[kHTTP2Session] != null) {\n            this[kHTTP2Session].destroy(err);\n        }\n        client[kPendingIdx] = client[kRunningIdx];\n        assert(client[kRunning] === 0);\n        client.emit(\"disconnect\", client[kUrl], [\n            client\n        ], err);\n        client[kResume]();\n    });\n    let closed = false;\n    socket.on(\"close\", ()=>{\n        closed = true;\n    });\n    return {\n        version: \"h2\",\n        defaultPipelining: Infinity,\n        write (...args) {\n            // TODO (fix): return\n            writeH2(client, ...args);\n        },\n        resume () {},\n        destroy (err, callback) {\n            if (closed) {\n                queueMicrotask(callback);\n            } else {\n                // Destroying the socket will trigger the session close\n                socket.destroy(err).on(\"close\", callback);\n            }\n        },\n        get destroyed () {\n            return socket.destroyed;\n        },\n        busy () {\n            return false;\n        }\n    };\n}\nfunction onHttp2SessionError(err) {\n    assert(err.code !== \"ERR_TLS_CERT_ALTNAME_INVALID\");\n    this[kSocket][kError] = err;\n    this[kClient][kOnError](err);\n}\nfunction onHttp2FrameError(type, code, id) {\n    if (id === 0) {\n        const err = new InformationalError(`HTTP/2: \"frameError\" received - type ${type}, code ${code}`);\n        this[kSocket][kError] = err;\n        this[kClient][kOnError](err);\n    }\n}\nfunction onHttp2SessionEnd() {\n    const err = new SocketError(\"other side closed\", util.getSocketInfo(this[kSocket]));\n    this.destroy(err);\n    util.destroy(this[kSocket], err);\n}\n/**\n * This is the root cause of #3011\n * We need to handle GOAWAY frames properly, and trigger the session close\n * along with the socket right away\n */ function onHTTP2GoAway(code) {\n    const err = new RequestAbortedError(`HTTP/2: \"GOAWAY\" frame received with code ${code}`);\n    // We need to trigger the close cycle right away\n    // We need to destroy the session and the socket\n    // Requests should be failed with the error after the current one is handled\n    this[kSocket][kError] = err;\n    this[kClient][kOnError](err);\n    this.unref();\n    util.destroy(this[kSocket], err);\n}\n// https://www.rfc-editor.org/rfc/rfc7230#section-3.3.2\nfunction shouldSendContentLength(method) {\n    return method !== \"GET\" && method !== \"HEAD\" && method !== \"OPTIONS\" && method !== \"TRACE\" && method !== \"CONNECT\";\n}\nfunction writeH2(client, request) {\n    const session = client[kHTTP2Session];\n    const { body, method, path, host, upgrade, expectContinue, signal, headers: reqHeaders } = request;\n    if (upgrade) {\n        util.errorRequest(client, request, new Error(\"Upgrade not supported for H2\"));\n        return false;\n    }\n    if (request.aborted) {\n        return false;\n    }\n    const headers = {};\n    for(let n = 0; n < reqHeaders.length; n += 2){\n        const key = reqHeaders[n + 0];\n        const val = reqHeaders[n + 1];\n        if (Array.isArray(val)) {\n            for(let i = 0; i < val.length; i++){\n                if (headers[key]) {\n                    headers[key] += `,${val[i]}`;\n                } else {\n                    headers[key] = val[i];\n                }\n            }\n        } else {\n            headers[key] = val;\n        }\n    }\n    /** @type {import('node:http2').ClientHttp2Stream} */ let stream;\n    const { hostname, port } = client[kUrl];\n    headers[HTTP2_HEADER_AUTHORITY] = host || `${hostname}${port ? `:${port}` : \"\"}`;\n    headers[HTTP2_HEADER_METHOD] = method;\n    const abort = (err)=>{\n        if (request.aborted || request.completed) {\n            return;\n        }\n        err = err || new RequestAbortedError();\n        util.errorRequest(client, request, err);\n        if (stream != null) {\n            util.destroy(stream, err);\n        }\n        // We do not destroy the socket as we can continue using the session\n        // the stream get's destroyed and the session remains to create new streams\n        util.destroy(body, err);\n    };\n    try {\n        // We are already connected, streams are pending.\n        // We can call on connect, and wait for abort\n        request.onConnect(abort);\n    } catch (err) {\n        util.errorRequest(client, request, err);\n    }\n    if (method === \"CONNECT\") {\n        session.ref();\n        // We are already connected, streams are pending, first request\n        // will create a new stream. We trigger a request to create the stream and wait until\n        // `ready` event is triggered\n        // We disabled endStream to allow the user to write to the stream\n        stream = session.request(headers, {\n            endStream: false,\n            signal\n        });\n        if (stream.id && !stream.pending) {\n            request.onUpgrade(null, null, stream);\n            ++session[kOpenStreams];\n        } else {\n            stream.once(\"ready\", ()=>{\n                request.onUpgrade(null, null, stream);\n                ++session[kOpenStreams];\n            });\n        }\n        stream.once(\"close\", ()=>{\n            session[kOpenStreams] -= 1;\n            if (session[kOpenStreams] === 0) session.unref();\n        });\n        return true;\n    }\n    // https://tools.ietf.org/html/rfc7540#section-8.3\n    // :path and :scheme headers must be omitted when sending CONNECT\n    headers[HTTP2_HEADER_PATH] = path;\n    headers[HTTP2_HEADER_SCHEME] = \"https\";\n    // https://tools.ietf.org/html/rfc7231#section-4.3.1\n    // https://tools.ietf.org/html/rfc7231#section-4.3.2\n    // https://tools.ietf.org/html/rfc7231#section-4.3.5\n    // Sending a payload body on a request that does not\n    // expect it can cause undefined behavior on some\n    // servers and corrupt connection state. Do not\n    // re-use the connection for further requests.\n    const expectsPayload = method === \"PUT\" || method === \"POST\" || method === \"PATCH\";\n    if (body && typeof body.read === \"function\") {\n        // Try to read EOF in order to get length.\n        body.read(0);\n    }\n    let contentLength = util.bodyLength(body);\n    if (contentLength == null) {\n        contentLength = request.contentLength;\n    }\n    if (contentLength === 0 || !expectsPayload) {\n        // https://tools.ietf.org/html/rfc7230#section-3.3.2\n        // A user agent SHOULD NOT send a Content-Length header field when\n        // the request message does not contain a payload body and the method\n        // semantics do not anticipate such a body.\n        contentLength = null;\n    }\n    // https://github.com/nodejs/undici/issues/2046\n    // A user agent may send a Content-Length header with 0 value, this should be allowed.\n    if (shouldSendContentLength(method) && contentLength > 0 && request.contentLength != null && request.contentLength !== contentLength) {\n        if (client[kStrictContentLength]) {\n            util.errorRequest(client, request, new RequestContentLengthMismatchError());\n            return false;\n        }\n        process.emitWarning(new RequestContentLengthMismatchError());\n    }\n    if (contentLength != null) {\n        assert(body, \"no body must not have content length\");\n        headers[HTTP2_HEADER_CONTENT_LENGTH] = `${contentLength}`;\n    }\n    session.ref();\n    const shouldEndStream = method === \"GET\" || method === \"HEAD\" || body === null;\n    if (expectContinue) {\n        headers[HTTP2_HEADER_EXPECT] = \"100-continue\";\n        stream = session.request(headers, {\n            endStream: shouldEndStream,\n            signal\n        });\n        stream.once(\"continue\", writeBodyH2);\n    } else {\n        stream = session.request(headers, {\n            endStream: shouldEndStream,\n            signal\n        });\n        writeBodyH2();\n    }\n    // Increment counter as we have new streams open\n    ++session[kOpenStreams];\n    stream.once(\"response\", (headers)=>{\n        const { [HTTP2_HEADER_STATUS]: statusCode, ...realHeaders } = headers;\n        request.onResponseStarted();\n        // Due to the stream nature, it is possible we face a race condition\n        // where the stream has been assigned, but the request has been aborted\n        // the request remains in-flight and headers hasn't been received yet\n        // for those scenarios, best effort is to destroy the stream immediately\n        // as there's no value to keep it open.\n        if (request.aborted) {\n            const err = new RequestAbortedError();\n            util.errorRequest(client, request, err);\n            util.destroy(stream, err);\n            return;\n        }\n        if (request.onHeaders(Number(statusCode), parseH2Headers(realHeaders), stream.resume.bind(stream), \"\") === false) {\n            stream.pause();\n        }\n        stream.on(\"data\", (chunk)=>{\n            if (request.onData(chunk) === false) {\n                stream.pause();\n            }\n        });\n    });\n    stream.once(\"end\", ()=>{\n        // When state is null, it means we haven't consumed body and the stream still do not have\n        // a state.\n        // Present specially when using pipeline or stream\n        if (stream.state?.state == null || stream.state.state < 6) {\n            request.onComplete([]);\n            return;\n        }\n        // Stream is closed or half-closed-remote (6), decrement counter and cleanup\n        // It does not have sense to continue working with the stream as we do not\n        // have yet RST_STREAM support on client-side\n        if (session[kOpenStreams] === 0) {\n            session.unref();\n        }\n        abort(new InformationalError(\"HTTP/2: stream half-closed (remote)\"));\n    });\n    stream.once(\"close\", ()=>{\n        session[kOpenStreams] -= 1;\n        if (session[kOpenStreams] === 0) {\n            session.unref();\n        }\n    });\n    stream.once(\"error\", function(err) {\n        abort(err);\n    });\n    stream.once(\"frameError\", (type, code)=>{\n        abort(new InformationalError(`HTTP/2: \"frameError\" received - type ${type}, code ${code}`));\n    });\n    // stream.on('aborted', () => {\n    //   // TODO(HTTP/2): Support aborted\n    // })\n    // stream.on('timeout', () => {\n    //   // TODO(HTTP/2): Support timeout\n    // })\n    // stream.on('push', headers => {\n    //   // TODO(HTTP/2): Support push\n    // })\n    // stream.on('trailers', headers => {\n    //   // TODO(HTTP/2): Support trailers\n    // })\n    return true;\n    function writeBodyH2() {\n        /* istanbul ignore else: assertion */ if (!body || contentLength === 0) {\n            writeBuffer(abort, stream, null, client, request, client[kSocket], contentLength, expectsPayload);\n        } else if (util.isBuffer(body)) {\n            writeBuffer(abort, stream, body, client, request, client[kSocket], contentLength, expectsPayload);\n        } else if (util.isBlobLike(body)) {\n            if (typeof body.stream === \"function\") {\n                writeIterable(abort, stream, body.stream(), client, request, client[kSocket], contentLength, expectsPayload);\n            } else {\n                writeBlob(abort, stream, body, client, request, client[kSocket], contentLength, expectsPayload);\n            }\n        } else if (util.isStream(body)) {\n            writeStream(abort, client[kSocket], expectsPayload, stream, body, client, request, contentLength);\n        } else if (util.isIterable(body)) {\n            writeIterable(abort, stream, body, client, request, client[kSocket], contentLength, expectsPayload);\n        } else {\n            assert(false);\n        }\n    }\n}\nfunction writeBuffer(abort, h2stream, body, client, request, socket, contentLength, expectsPayload) {\n    try {\n        if (body != null && util.isBuffer(body)) {\n            assert(contentLength === body.byteLength, \"buffer body must have content length\");\n            h2stream.cork();\n            h2stream.write(body);\n            h2stream.uncork();\n            h2stream.end();\n            request.onBodySent(body);\n        }\n        if (!expectsPayload) {\n            socket[kReset] = true;\n        }\n        request.onRequestSent();\n        client[kResume]();\n    } catch (error) {\n        abort(error);\n    }\n}\nfunction writeStream(abort, socket, expectsPayload, h2stream, body, client, request, contentLength) {\n    assert(contentLength !== 0 || client[kRunning] === 0, \"stream body cannot be pipelined\");\n    // For HTTP/2, is enough to pipe the stream\n    const pipe = pipeline(body, h2stream, (err)=>{\n        if (err) {\n            util.destroy(pipe, err);\n            abort(err);\n        } else {\n            util.removeAllListeners(pipe);\n            request.onRequestSent();\n            if (!expectsPayload) {\n                socket[kReset] = true;\n            }\n            client[kResume]();\n        }\n    });\n    util.addListener(pipe, \"data\", onPipeData);\n    function onPipeData(chunk) {\n        request.onBodySent(chunk);\n    }\n}\nasync function writeBlob(abort, h2stream, body, client, request, socket, contentLength, expectsPayload) {\n    assert(contentLength === body.size, \"blob body must have content length\");\n    try {\n        if (contentLength != null && contentLength !== body.size) {\n            throw new RequestContentLengthMismatchError();\n        }\n        const buffer = Buffer.from(await body.arrayBuffer());\n        h2stream.cork();\n        h2stream.write(buffer);\n        h2stream.uncork();\n        h2stream.end();\n        request.onBodySent(buffer);\n        request.onRequestSent();\n        if (!expectsPayload) {\n            socket[kReset] = true;\n        }\n        client[kResume]();\n    } catch (err) {\n        abort(err);\n    }\n}\nasync function writeIterable(abort, h2stream, body, client, request, socket, contentLength, expectsPayload) {\n    assert(contentLength !== 0 || client[kRunning] === 0, \"iterator body cannot be pipelined\");\n    let callback = null;\n    function onDrain() {\n        if (callback) {\n            const cb = callback;\n            callback = null;\n            cb();\n        }\n    }\n    const waitForDrain = ()=>new Promise((resolve, reject)=>{\n            assert(callback === null);\n            if (socket[kError]) {\n                reject(socket[kError]);\n            } else {\n                callback = resolve;\n            }\n        });\n    h2stream.on(\"close\", onDrain).on(\"drain\", onDrain);\n    try {\n        // It's up to the user to somehow abort the async iterable.\n        for await (const chunk of body){\n            if (socket[kError]) {\n                throw socket[kError];\n            }\n            const res = h2stream.write(chunk);\n            request.onBodySent(chunk);\n            if (!res) {\n                await waitForDrain();\n            }\n        }\n        h2stream.end();\n        request.onRequestSent();\n        if (!expectsPayload) {\n            socket[kReset] = true;\n        }\n        client[kResume]();\n    } catch (err) {\n        abort(err);\n    } finally{\n        h2stream.off(\"close\", onDrain).off(\"drain\", onDrain);\n    }\n}\nmodule.exports = connectH2;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9kaXNwYXRjaGVyL2NsaWVudC1oMi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU1BLFNBQVNDLG1CQUFPQSxDQUFDO0FBQ3ZCLE1BQU0sRUFBRUMsUUFBQUEsRUFBVSxHQUFHRCxtQkFBT0EsQ0FBQztBQUM3QixNQUFNRSxPQUFPRixtQkFBT0EsQ0FBQztBQUNyQixNQUFNLEVBQ0pHLGlDQUFpQyxFQUNqQ0MsbUJBQW1CLEVBQ25CQyxXQUFXLEVBQ1hDLGtCQUFBQSxFQUNELEdBQUdOLG1CQUFPQSxDQUFDO0FBQ1osTUFBTSxFQUNKTyxJQUFJLEVBQ0pDLE1BQU0sRUFDTkMsT0FBTyxFQUNQQyxRQUFRLEVBQ1JDLFFBQVEsRUFDUkMsTUFBTSxFQUNOQyxXQUFXLEVBQ1hDLFdBQVcsRUFDWEMsTUFBTSxFQUNOQyxPQUFPLEVBQ1BDLG9CQUFvQixFQUNwQkMsUUFBUSxFQUNSQyxxQkFBcUIsRUFDckJDLGFBQWEsRUFDYkMsT0FBQUEsRUFDRCxHQUFHckIsbUJBQU9BLENBQUM7QUFFWixNQUFNc0IsZUFBZUMsT0FBTztBQUU1QjtBQUNBLElBQUlDLHVCQUF1QjtBQUUzQiwrQkFDQSxJQUFJQztBQUNKLElBQUk7SUFDRkEsUUFBUXpCLG1CQUFPQSxDQUFDO0FBQ2xCLEVBQUUsT0FBTTtJQUNOO0lBQ0F5QixRQUFRO1FBQUVDLFdBQVcsQ0FBQztJQUFFO0FBQzFCO0FBRUEsTUFBTSxFQUNKQSxXQUFXLEVBQ1RDLHNCQUFzQixFQUN0QkMsbUJBQW1CLEVBQ25CQyxpQkFBaUIsRUFDakJDLG1CQUFtQixFQUNuQkMsMkJBQTJCLEVBQzNCQyxtQkFBbUIsRUFDbkJDLG1CQUFBQSxFQUNGLEVBQ0QsR0FBR1I7QUFFSixTQUFTUyxlQUFnQkMsT0FBTztJQUM5QixNQUFNQyxTQUFTLEVBQUU7SUFFakIsS0FBSyxNQUFNLENBQUNDLE1BQU1DLE1BQU0sSUFBSUMsT0FBT0MsT0FBTyxDQUFDTCxTQUFVO1FBQ25EO1FB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bGliL2Rpc3BhdGNoZXIvY2xpZW50LWgyLmpzPzFiNjMiLCJ3ZWJwYWNrOi8vbW9ja3VwZmxvdy8uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2Rpc3BhdGNoZXIvY2xpZW50LWgyLmpzPzFiNjMqIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdub2RlOmFzc2VydCcpXG5jb25zdCB7IHBpcGVsaW5lIH0gPSByZXF1aXJlKCdub2RlOnN0cmVhbScpXG5jb25zdCB1dGlsID0gcmVxdWlyZSgnLi4vY29yZS91dGlsLmpzJylcbmNvbnN0IHtcbiAgUmVxdWVzdENvbnRlbnRMZW5ndGhNaXNtYXRjaEVycm9yLFxuICBSZXF1ZXN0QWJvcnRlZEVycm9yLFxuICBTb2NrZXRFcnJvcixcbiAgSW5mb3JtYXRpb25hbEVycm9yXG59ID0gcmVxdWlyZSgnLi4vY29yZS9lcnJvcnMuanMnKVxuY29uc3Qge1xuICBrVXJsLFxuICBrUmVzZXQsXG4gIGtDbGllbnQsXG4gIGtSdW5uaW5nLFxuICBrUGVuZGluZyxcbiAga1F1ZXVlLFxuICBrUGVuZGluZ0lkeCxcbiAga1J1bm5pbmdJZHgsXG4gIGtFcnJvcixcbiAga1NvY2tldCxcbiAga1N0cmljdENvbnRlbnRMZW5ndGgsXG4gIGtPbkVycm9yLFxuICBrTWF4Q29uY3VycmVudFN0cmVhbXMsXG4gIGtIVFRQMlNlc3Npb24sXG4gIGtSZXN1bWVcbn0gPSByZXF1aXJlKCcuLi9jb3JlL3N5bWJvbHMuanMnKVxuXG5jb25zdCBrT3BlblN0cmVhbXMgPSBTeW1ib2woJ29wZW4gc3RyZWFtcycpXG5cbi8vIEV4cGVyaW1lbnRhbFxubGV0IGgyRXhwZXJpbWVudGFsV2FybmVkID0gZmFsc2VcblxuLyoqIEB0eXBlIHtpbXBvcnQoJ2h0dHAyJyl9ICovXG5sZXQgaHR0cDJcbnRyeSB7XG4gIGh0dHAyID0gcmVxdWlyZSgnbm9kZTpodHRwMicpXG59IGNhdGNoIHtcbiAgLy8gQHRzLWlnbm9yZVxuICBodHRwMiA9IHsgY29uc3RhbnRzOiB7fSB9XG59XG5cbmNvbnN0IHtcbiAgY29uc3RhbnRzOiB7XG4gICAgSFRUUDJfSEVBREVSX0FVVEhPUklUWSxcbiAgICBIVFRQMl9IRUFERVJfTUVUSE9ELFxuICAgIEhUVFAyX0hFQURFUl9QQVRILFxuICAgIEhUVFAyX0hFQURFUl9TQ0hFTUUsXG4gICAgSFRUUDJfSEVBREVSX0NPTlRFTlRfTEVOR1RILFxuICAgIEhUVFAyX0hFQURFUl9FWFBFQ1QsXG4gICAgSFRUUDJfSEVBREVSX1NUQVRVU1xuICB9XG59ID0gaHR0cDJcblxuZnVuY3Rpb24gcGFyc2VIMkhlYWRlcnMgKGhlYWRlcnMpIHtcbiAgY29uc3QgcmVzdWx0ID0gW11cblxuICBmb3IgKGNvbnN0IFtuYW1lLCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoaGVhZGVycykpIHtcbiAgICAvLyBoMiBtYXkgY29uY2F0IHRoZSBoZWFkZXIgdmFsdWUgYnkgYXJyYXlcbiAgICAvLyBlLmcuIFNldC1Db29raWVcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIGZvciAoY29uc3Qgc3VidmFsdWUgb2YgdmFsdWUpIHtcbiAgICAgICAgLy8gd2UgbmVlZCB0byBwcm92aWRlIGVhY2ggaGVhZGVyIHZhbHVlIG9mIGhlYWRlciBuYW1lXG4gICAgICAgIC8vIGJlY2F1c2UgdGhlIGhlYWRlcnMgaGFuZGxlciBleHBlY3QgbmFtZS12YWx1ZSBwYWlyXG4gICAgICAgIHJlc3VsdC5wdXNoKEJ1ZmZlci5mcm9tKG5hbWUpLCBCdWZmZXIuZnJvbShzdWJ2YWx1ZSkpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5wdXNoKEJ1ZmZlci5mcm9tKG5hbWUpLCBCdWZmZXIuZnJvbSh2YWx1ZSkpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5hc3luYyBmdW5jdGlvbiBjb25uZWN0SDIgKGNsaWVudCwgc29ja2V0KSB7XG4gIGNsaWVudFtrU29ja2V0XSA9IHNvY2tldFxuXG4gIGlmICghaDJFeHBlcmltZW50YWxXYXJuZWQpIHtcbiAgICBoMkV4cGVyaW1lbnRhbFdhcm5lZCA9IHRydWVcbiAgICBwcm9jZXNzLmVtaXRXYXJuaW5nKCdIMiBzdXBwb3J0IGlzIGV4cGVyaW1lbnRhbCwgZXhwZWN0IHRoZW0gdG8gY2hhbmdlIGF0IGFueSB0aW1lLicsIHtcbiAgICAgIGNvZGU6ICdVTkRJQ0ktSDInXG4gICAgfSlcbiAgfVxuXG4gIGNvbnN0IHNlc3Npb24gPSBodHRwMi5jb25uZWN0KGNsaWVudFtrVXJsXSwge1xuICAgIGNyZWF0ZUNvbm5lY3Rpb246ICgpID0+IHNvY2tldCxcbiAgICBwZWVyTWF4Q29uY3VycmVudFN0cmVhbXM6IGNsaWVudFtrTWF4Q29uY3VycmVudFN0cmVhbXNdXG4gIH0pXG5cbiAgc2Vzc2lvbltrT3BlblN0cmVhbXNdID0gMFxuICBzZXNzaW9uW2tDbGllbnRdID0gY2xpZW50XG4gIHNlc3Npb25ba1NvY2tldF0gPSBzb2NrZXRcblxuICB1dGlsLmFkZExpc3RlbmVyKHNlc3Npb24sICdlcnJvcicsIG9uSHR0cDJTZXNzaW9uRXJyb3IpXG4gIHV0aWwuYWRkTGlzdGVuZXIoc2Vzc2lvbiwgJ2ZyYW1lRXJyb3InLCBvbkh0dHAyRnJhbWVFcnJvcilcbiAgdXRpbC5hZGRMaXN0ZW5lcihzZXNzaW9uLCAnZW5kJywgb25IdHRwMlNlc3Npb25FbmQpXG4gIHV0aWwuYWRkTGlzdGVuZXIoc2Vzc2lvbiwgJ2dvYXdheScsIG9uSFRUUDJHb0F3YXkpXG4gIHV0aWwuYWRkTGlzdGVuZXIoc2Vzc2lvbiwgJ2Nsb3NlJywgZnVuY3Rpb24gKCkge1xuICAgIGNvbnN0IHsgW2tDbGllbnRdOiBjbGllbnQgfSA9IHRoaXNcbiAgICBjb25zdCB7IFtrU29ja2V0XTogc29ja2V0IH0gPSBjbGllbnRcblxuICAgIGNvbnN0IGVyciA9IHRoaXNba1NvY2tldF1ba0Vycm9yXSB8fCB0aGlzW2tFcnJvcl0gfHwgbmV3IFNvY2tldEVycm9yKCdjbG9zZWQnLCB1dGlsLmdldFNvY2tldEluZm8oc29ja2V0KSlcblxuICAgIGNsaWVudFtrSFRUUDJTZXNzaW9uXSA9IG51bGxcblxuICAgIGlmIChjbGllbnQuZGVzdHJveWVkKSB7XG4gICAgICBhc3NlcnQoY2xpZW50W2tQZW5kaW5nXSA9PT0gMClcblxuICAgICAgLy8gRmFpbCBlbnRpcmUgcXVldWUuXG4gICAgICBjb25zdCByZXF1ZXN0cyA9IGNsaWVudFtrUXVldWVdLnNwbGljZShjbGllbnRba1J1bm5pbmdJZHhdKVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXF1ZXN0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0gcmVxdWVzdHNbaV1cbiAgICAgICAgdXRpbC5lcnJvclJlcXVlc3QoY2xpZW50LCByZXF1ZXN0LCBlcnIpXG4gICAgICB9XG4gICAgfVxuICB9KVxuXG4gIHNlc3Npb24udW5yZWYoKVxuXG4gIGNsaWVudFtrSFRUUDJTZXNzaW9uXSA9IHNlc3Npb25cbiAgc29ja2V0W2tIVFRQMlNlc3Npb25dID0gc2Vzc2lvblxuXG4gIHV0aWwuYWRkTGlzdGVuZXIoc29ja2V0LCAnZXJyb3InLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgYXNzZXJ0KGVyci5jb2RlICE9PSAnRVJSX1RMU19DRVJUX0FMVE5BTUVfSU5WQUxJRCcpXG5cbiAgICB0aGlzW2tFcnJvcl0gPSBlcnJcblxuICAgIHRoaXNba0NsaWVudF1ba09uRXJyb3JdKGVycilcbiAgfSlcblxuICB1dGlsLmFkZExpc3RlbmVyKHNvY2tldCwgJ2VuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICB1dGlsLmRlc3Ryb3kodGhpcywgbmV3IFNvY2tldEVycm9yKCdvdGhlciBzaWRlIGNsb3NlZCcsIHV0aWwuZ2V0U29ja2V0SW5mbyh0aGlzKSkpXG4gIH0pXG5cbiAgdXRpbC5hZGRMaXN0ZW5lcihzb2NrZXQsICdjbG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICBjb25zdCBlcnIgPSB0aGlzW2tFcnJvcl0gfHwgbmV3IFNvY2tldEVycm9yKCdjbG9zZWQnLCB1dGlsLmdldFNvY2tldEluZm8odGhpcykpXG5cbiAgICBjbGllbnRba1NvY2tldF0gPSBudWxsXG5cbiAgICBpZiAodGhpc1trSFRUUDJTZXNzaW9uXSAhPSBudWxsKSB7XG4gICAgICB0aGlzW2tIVFRQMlNlc3Npb25dLmRlc3Ryb3koZXJyKVxuICAgIH1cblxuICAgIGNsaWVudFtrUGVuZGluZ0lkeF0gPSBjbGllbnRba1J1bm5pbmdJZHhdXG5cbiAgICBhc3NlcnQoY2xpZW50W2tSdW5uaW5nXSA9PT0gMClcblxuICAgIGNsaWVudC5lbWl0KCdkaXNjb25uZWN0JywgY2xpZW50W2tVcmxdLCBbY2xpZW50XSwgZXJyKVxuXG4gICAgY2xpZW50W2tSZXN1bWVdKClcbiAgfSlcblxuICBsZXQgY2xvc2VkID0gZmFsc2VcbiAgc29ja2V0Lm9uKCdjbG9zZScsICgpID0+IHtcbiAgICBjbG9zZWQgPSB0cnVlXG4gIH0pXG5cbiAgcmV0dXJuIHtcbiAgICB2ZXJzaW9uOiAnaDInLFxuICAgIGRlZmF1bHRQaXBlbGluaW5nOiBJbmZpbml0eSxcbiAgICB3cml0ZSAoLi4uYXJncykge1xuICAgICAgLy8gVE9ETyAoZml4KTogcmV0dXJuXG4gICAgICB3cml0ZUgyKGNsaWVudCwgLi4uYXJncylcbiAgICB9LFxuICAgIHJlc3VtZSAoKSB7XG5cbiAgICB9LFxuICAgIGRlc3Ryb3kgKGVyciwgY2FsbGJhY2spIHtcbiAgICAgIGlmIChjbG9zZWQpIHtcbiAgICAgICAgcXVldWVNaWNyb3Rhc2soY2FsbGJhY2spXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBEZXN0cm95aW5nIHRoZSBzb2NrZXQgd2lsbCB0cmlnZ2VyIHRoZSBzZXNzaW9uIGNsb3NlXG4gICAgICAgIHNvY2tldC5kZXN0cm95KGVycikub24oJ2Nsb3NlJywgY2FsbGJhY2spXG4gICAgICB9XG4gICAgfSxcbiAgICBnZXQgZGVzdHJveWVkICgpIHtcbiAgICAgIHJldHVybiBzb2NrZXQuZGVzdHJveWVkXG4gICAgfSxcbiAgICBidXN5ICgpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBvbkh0dHAyU2Vzc2lvbkVycm9yIChlcnIpIHtcbiAgYXNzZXJ0KGVyci5jb2RlICE9PSAnRVJSX1RMU19DRVJUX0FMVE5BTUVfSU5WQUxJRCcpXG5cbiAgdGhpc1trU29ja2V0XVtrRXJyb3JdID0gZXJyXG4gIHRoaXNba0NsaWVudF1ba09uRXJyb3JdKGVycilcbn1cblxuZnVuY3Rpb24gb25IdHRwMkZyYW1lRXJyb3IgKHR5cGUsIGNvZGUsIGlkKSB7XG4gIGlmIChpZCA9PT0gMCkge1xuICAgIGNvbnN0IGVyciA9IG5ldyBJbmZvcm1hdGlvbmFsRXJyb3IoYEhUVFAvMjogXCJmcmFtZUVycm9yXCIgcmVjZWl2ZWQgLSB0eXBlICR7dHlwZX0sIGNvZGUgJHtjb2RlfWApXG4gICAgdGhpc1trU29ja2V0XVtrRXJyb3JdID0gZXJyXG4gICAgdGhpc1trQ2xpZW50XVtrT25FcnJvcl0oZXJyKVxuICB9XG59XG5cbmZ1bmN0aW9uIG9uSHR0cDJTZXNzaW9uRW5kICgpIHtcbiAgY29uc3QgZXJyID0gbmV3IFNvY2tldEVycm9yKCdvdGhlciBzaWRlIGNsb3NlZCcsIHV0aWwuZ2V0U29ja2V0SW5mbyh0aGlzW2tTb2NrZXRdKSlcbiAgdGhpcy5kZXN0cm95KGVycilcbiAgdXRpbC5kZXN0cm95KHRoaXNba1NvY2tldF0sIGVycilcbn1cblxuLyoqXG4gKiBUaGlzIGlzIHRoZSByb290IGNhdXNlIG9mICMzMDExXG4gKiBXZSBuZWVkIHRvIGhhbmRsZSBHT0FXQVkgZnJhbWVzIHByb3Blcmx5LCBhbmQgdHJpZ2dlciB0aGUgc2Vzc2lvbiBjbG9zZVxuICogYWxvbmcgd2l0aCB0aGUgc29ja2V0IHJpZ2h0IGF3YXlcbiAqL1xuZnVuY3Rpb24gb25IVFRQMkdvQXdheSAoY29kZSkge1xuICBjb25zdCBlcnIgPSBuZXcgUmVxdWVzdEFib3J0ZWRFcnJvcihgSFRUUC8yOiBcIkdPQVdBWVwiIGZyYW1lIHJlY2VpdmVkIHdpdGggY29kZSAke2NvZGV9YClcblxuICAvLyBXZSBuZWVkIHRvIHRyaWdnZXIgdGhlIGNsb3NlIGN5Y2xlIHJpZ2h0IGF3YXlcbiAgLy8gV2UgbmVlZCB0byBkZXN0cm95IHRoZSBzZXNzaW9uIGFuZCB0aGUgc29ja2V0XG4gIC8vIFJlcXVlc3RzIHNob3VsZCBiZSBmYWlsZWQgd2l0aCB0aGUgZXJyb3IgYWZ0ZXIgdGhlIGN1cnJlbnQgb25lIGlzIGhhbmRsZWRcbiAgdGhpc1trU29ja2V0XVtrRXJyb3JdID0gZXJyXG4gIHRoaXNba0NsaWVudF1ba09uRXJyb3JdKGVycilcblxuICB0aGlzLnVucmVmKClcblxuICB1dGlsLmRlc3Ryb3kodGhpc1trU29ja2V0XSwgZXJyKVxufVxuXG4vLyBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjNzIzMCNzZWN0aW9uLTMuMy4yXG5mdW5jdGlvbiBzaG91bGRTZW5kQ29udGVudExlbmd0aCAobWV0aG9kKSB7XG4gIHJldHVybiBtZXRob2QgIT09ICdHRVQnICYmIG1ldGhvZCAhPT0gJ0hFQUQnICYmIG1ldGhvZCAhPT0gJ09QVElPTlMnICYmIG1ldGhvZCAhPT0gJ1RSQUNFJyAmJiBtZXRob2QgIT09ICdDT05ORUNUJ1xufVxuXG5mdW5jdGlvbiB3cml0ZUgyIChjbGllbnQsIHJlcXVlc3QpIHtcbiAgY29uc3Qgc2Vzc2lvbiA9IGNsaWVudFtrSFRUUDJTZXNzaW9uXVxuICBjb25zdCB7IGJvZHksIG1ldGhvZCwgcGF0aCwgaG9zdCwgdXBncmFkZSwgZXhwZWN0Q29udGludWUsIHNpZ25hbCwgaGVhZGVyczogcmVxSGVhZGVycyB9ID0gcmVxdWVzdFxuXG4gIGlmICh1cGdyYWRlKSB7XG4gICAgdXRpbC5lcnJvclJlcXVlc3QoY2xpZW50LCByZXF1ZXN0LCBuZXcgRXJyb3IoJ1VwZ3JhZGUgbm90IHN1cHBvcnRlZCBmb3IgSDInKSlcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGlmIChyZXF1ZXN0LmFib3J0ZWQpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGNvbnN0IGhlYWRlcnMgPSB7fVxuICBmb3IgKGxldCBuID0gMDsgbiA8IHJlcUhlYWRlcnMubGVuZ3RoOyBuICs9IDIpIHtcbiAgICBjb25zdCBrZXkgPSByZXFIZWFkZXJzW24gKyAwXVxuICAgIGNvbnN0IHZhbCA9IHJlcUhlYWRlcnNbbiArIDFdXG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbC5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaGVhZGVyc1trZXldKSB7XG4gICAgICAgICAgaGVhZGVyc1trZXldICs9IGAsJHt2YWxbaV19YFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGhlYWRlcnNba2V5XSA9IHZhbFtpXVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGhlYWRlcnNba2V5XSA9IHZhbFxuICAgIH1cbiAgfVxuXG4gIC8qKiBAdHlwZSB7aW1wb3J0KCdub2RlOmh0dHAyJykuQ2xpZW50SHR0cDJTdHJlYW19ICovXG4gIGxldCBzdHJlYW1cblxuICBjb25zdCB7IGhvc3RuYW1lLCBwb3J0IH0gPSBjbGllbnRba1VybF1cblxuICBoZWFkZXJzW0hUVFAyX0hFQURFUl9BVVRIT1JJVFldID0gaG9zdCB8fCBgJHtob3N0bmFtZX0ke3BvcnQgPyBgOiR7cG9ydH1gIDogJyd9YFxuICBoZWFkZXJzW0hUVFAyX0hFQURFUl9NRVRIT0RdID0gbWV0aG9kXG5cbiAgY29uc3QgYWJvcnQgPSAoZXJyKSA9PiB7XG4gICAgaWYgKHJlcXVlc3QuYWJvcnRlZCB8fCByZXF1ZXN0LmNvbXBsZXRlZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgZXJyID0gZXJyIHx8IG5ldyBSZXF1ZXN0QWJvcnRlZEVycm9yKClcblxuICAgIHV0aWwuZXJyb3JSZXF1ZXN0KGNsaWVudCwgcmVxdWVzdCwgZXJyKVxuXG4gICAgaWYgKHN0cmVhbSAhPSBudWxsKSB7XG4gICAgICB1dGlsLmRlc3Ryb3koc3RyZWFtLCBlcnIpXG4gICAgfVxuXG4gICAgLy8gV2UgZG8gbm90IGRlc3Ryb3kgdGhlIHNvY2tldCBhcyB3ZSBjYW4gY29udGludWUgdXNpbmcgdGhlIHNlc3Npb25cbiAgICAvLyB0aGUgc3RyZWFtIGdldCdzIGRlc3Ryb3llZCBhbmQgdGhlIHNlc3Npb24gcmVtYWlucyB0byBjcmVhdGUgbmV3IHN0cmVhbXNcbiAgICB1dGlsLmRlc3Ryb3koYm9keSwgZXJyKVxuICB9XG5cbiAgdHJ5IHtcbiAgICAvLyBXZSBhcmUgYWxyZWFkeSBjb25uZWN0ZWQsIHN0cmVhbXMgYXJlIHBlbmRpbmcuXG4gICAgLy8gV2UgY2FuIGNhbGwgb24gY29ubmVjdCwgYW5kIHdhaXQgZm9yIGFib3J0XG4gICAgcmVxdWVzdC5vbkNvbm5lY3QoYWJvcnQpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHV0aWwuZXJyb3JSZXF1ZXN0KGNsaWVudCwgcmVxdWVzdCwgZXJyKVxuICB9XG5cbiAgaWYgKG1ldGhvZCA9PT0gJ0NPTk5FQ1QnKSB7XG4gICAgc2Vzc2lvbi5yZWYoKVxuICAgIC8vIFdlIGFyZSBhbHJlYWR5IGNvbm5lY3RlZCwgc3RyZWFtcyBhcmUgcGVuZGluZywgZmlyc3QgcmVxdWVzdFxuICAgIC8vIHdpbGwgY3JlYXRlIGEgbmV3IHN0cmVhbS4gV2UgdHJpZ2dlciBhIHJlcXVlc3QgdG8gY3JlYXRlIHRoZSBzdHJlYW0gYW5kIHdhaXQgdW50aWxcbiAgICAvLyBgcmVhZHlgIGV2ZW50IGlzIHRyaWdnZXJlZFxuICAgIC8vIFdlIGRpc2FibGVkIGVuZFN0cmVhbSB0byBhbGxvdyB0aGUgdXNlciB0byB3cml0ZSB0byB0aGUgc3RyZWFtXG4gICAgc3RyZWFtID0gc2Vzc2lvbi5yZXF1ZXN0KGhlYWRlcnMsIHsgZW5kU3RyZWFtOiBmYWxzZSwgc2lnbmFsIH0pXG5cbiAgICBpZiAoc3RyZWFtLmlkICYmICFzdHJlYW0ucGVuZGluZykge1xuICAgICAgcmVxdWVzdC5vblVwZ3JhZGUobnVsbCwgbnVsbCwgc3RyZWFtKVxuICAgICAgKytzZXNzaW9uW2tPcGVuU3RyZWFtc11cbiAgICB9IGVsc2Uge1xuICAgICAgc3RyZWFtLm9uY2UoJ3JlYWR5JywgKCkgPT4ge1xuICAgICAgICByZXF1ZXN0Lm9uVXBncmFkZShudWxsLCBudWxsLCBzdHJlYW0pXG4gICAgICAgICsrc2Vzc2lvbltrT3BlblN0cmVhbXNdXG4gICAgICB9KVxuICAgIH1cblxuICAgIHN0cmVhbS5vbmNlKCdjbG9zZScsICgpID0+IHtcbiAgICAgIHNlc3Npb25ba09wZW5TdHJlYW1zXSAtPSAxXG4gICAgICBpZiAoc2Vzc2lvbltrT3BlblN0cmVhbXNdID09PSAwKSBzZXNzaW9uLnVucmVmKClcbiAgICB9KVxuXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3NTQwI3NlY3Rpb24tOC4zXG4gIC8vIDpwYXRoIGFuZCA6c2NoZW1lIGhlYWRlcnMgbXVzdCBiZSBvbWl0dGVkIHdoZW4gc2VuZGluZyBDT05ORUNUXG5cbiAgaGVhZGVyc1tIVFRQMl9IRUFERVJfUEFUSF0gPSBwYXRoXG4gIGhlYWRlcnNbSFRUUDJfSEVBREVSX1NDSEVNRV0gPSAnaHR0cHMnXG5cbiAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzcyMzEjc2VjdGlvbi00LjMuMVxuICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzIzMSNzZWN0aW9uLTQuMy4yXG4gIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3MjMxI3NlY3Rpb24tNC4zLjVcblxuICAvLyBTZW5kaW5nIGEgcGF5bG9hZCBib2R5IG9uIGEgcmVxdWVzdCB0aGF0IGRvZXMgbm90XG4gIC8vIGV4cGVjdCBpdCBjYW4gY2F1c2UgdW5kZWZpbmVkIGJlaGF2aW9yIG9uIHNvbWVcbiAgLy8gc2VydmVycyBhbmQgY29ycnVwdCBjb25uZWN0aW9uIHN0YXRlLiBEbyBub3RcbiAgLy8gcmUtdXNlIHRoZSBjb25uZWN0aW9uIGZvciBmdXJ0aGVyIHJlcXVlc3RzLlxuXG4gIGNvbnN0IGV4cGVjdHNQYXlsb2FkID0gKFxuICAgIG1ldGhvZCA9PT0gJ1BVVCcgfHxcbiAgICBtZXRob2QgPT09ICdQT1NUJyB8fFxuICAgIG1ldGhvZCA9PT0gJ1BBVENIJ1xuICApXG5cbiAgaWYgKGJvZHkgJiYgdHlwZW9mIGJvZHkucmVhZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIFRyeSB0byByZWFkIEVPRiBpbiBvcmRlciB0byBnZXQgbGVuZ3RoLlxuICAgIGJvZHkucmVhZCgwKVxuICB9XG5cbiAgbGV0IGNvbnRlbnRMZW5ndGggPSB1dGlsLmJvZHlMZW5ndGgoYm9keSlcblxuICBpZiAoY29udGVudExlbmd0aCA9PSBudWxsKSB7XG4gICAgY29udGVudExlbmd0aCA9IHJlcXVlc3QuY29udGVudExlbmd0aFxuICB9XG5cbiAgaWYgKGNvbnRlbnRMZW5ndGggPT09IDAgfHwgIWV4cGVjdHNQYXlsb2FkKSB7XG4gICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzcyMzAjc2VjdGlvbi0zLjMuMlxuICAgIC8vIEEgdXNlciBhZ2VudCBTSE9VTEQgTk9UIHNlbmQgYSBDb250ZW50LUxlbmd0aCBoZWFkZXIgZmllbGQgd2hlblxuICAgIC8vIHRoZSByZXF1ZXN0IG1lc3NhZ2UgZG9lcyBub3QgY29udGFpbiBhIHBheWxvYWQgYm9keSBhbmQgdGhlIG1ldGhvZFxuICAgIC8vIHNlbWFudGljcyBkbyBub3QgYW50aWNpcGF0ZSBzdWNoIGEgYm9keS5cblxuICAgIGNvbnRlbnRMZW5ndGggPSBudWxsXG4gIH1cblxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL3VuZGljaS9pc3N1ZXMvMjA0NlxuICAvLyBBIHVzZXIgYWdlbnQgbWF5IHNlbmQgYSBDb250ZW50LUxlbmd0aCBoZWFkZXIgd2l0aCAwIHZhbHVlLCB0aGlzIHNob3VsZCBiZSBhbGxvd2VkLlxuICBpZiAoc2hvdWxkU2VuZENvbnRlbnRMZW5ndGgobWV0aG9kKSAmJiBjb250ZW50TGVuZ3RoID4gMCAmJiByZXF1ZXN0LmNvbnRlbnRMZW5ndGggIT0gbnVsbCAmJiByZXF1ZXN0LmNvbnRlbnRMZW5ndGggIT09IGNvbnRlbnRMZW5ndGgpIHtcbiAgICBpZiAoY2xpZW50W2tTdHJpY3RDb250ZW50TGVuZ3RoXSkge1xuICAgICAgdXRpbC5lcnJvclJlcXVlc3QoY2xpZW50LCByZXF1ZXN0LCBuZXcgUmVxdWVzdENvbnRlbnRMZW5ndGhNaXNtYXRjaEVycm9yKCkpXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICBwcm9jZXNzLmVtaXRXYXJuaW5nKG5ldyBSZXF1ZXN0Q29udGVudExlbmd0aE1pc21hdGNoRXJyb3IoKSlcbiAgfVxuXG4gIGlmIChjb250ZW50TGVuZ3RoICE9IG51bGwpIHtcbiAgICBhc3NlcnQoYm9keSwgJ25vIGJvZHkgbXVzdCBub3QgaGF2ZSBjb250ZW50IGxlbmd0aCcpXG4gICAgaGVhZGVyc1tIVFRQMl9IRUFERVJfQ09OVEVOVF9MRU5HVEhdID0gYCR7Y29udGVudExlbmd0aH1gXG4gIH1cblxuICBzZXNzaW9uLnJlZigpXG5cbiAgY29uc3Qgc2hvdWxkRW5kU3RyZWFtID0gbWV0aG9kID09PSAnR0VUJyB8fCBtZXRob2QgPT09ICdIRUFEJyB8fCBib2R5ID09PSBudWxsXG4gIGlmIChleHBlY3RDb250aW51ZSkge1xuICAgIGhlYWRlcnNbSFRUUDJfSEVBREVSX0VYUEVDVF0gPSAnMTAwLWNvbnRpbnVlJ1xuICAgIHN0cmVhbSA9IHNlc3Npb24ucmVxdWVzdChoZWFkZXJzLCB7IGVuZFN0cmVhbTogc2hvdWxkRW5kU3RyZWFtLCBzaWduYWwgfSlcblxuICAgIHN0cmVhbS5vbmNlKCdjb250aW51ZScsIHdyaXRlQm9keUgyKVxuICB9IGVsc2Uge1xuICAgIHN0cmVhbSA9IHNlc3Npb24ucmVxdWVzdChoZWFkZXJzLCB7XG4gICAgICBlbmRTdHJlYW06IHNob3VsZEVuZFN0cmVhbSxcbiAgICAgIHNpZ25hbFxuICAgIH0pXG4gICAgd3JpdGVCb2R5SDIoKVxuICB9XG5cbiAgLy8gSW5jcmVtZW50IGNvdW50ZXIgYXMgd2UgaGF2ZSBuZXcgc3RyZWFtcyBvcGVuXG4gICsrc2Vzc2lvbltrT3BlblN0cmVhbXNdXG5cbiAgc3RyZWFtLm9uY2UoJ3Jlc3BvbnNlJywgaGVhZGVycyA9PiB7XG4gICAgY29uc3QgeyBbSFRUUDJfSEVBREVSX1NUQVRVU106IHN0YXR1c0NvZGUsIC4uLnJlYWxIZWFkZXJzIH0gPSBoZWFkZXJzXG4gICAgcmVxdWVzdC5vblJlc3BvbnNlU3RhcnRlZCgpXG5cbiAgICAvLyBEdWUgdG8gdGhlIHN0cmVhbSBuYXR1cmUsIGl0IGlzIHBvc3NpYmxlIHdlIGZhY2UgYSByYWNlIGNvbmRpdGlvblxuICAgIC8vIHdoZXJlIHRoZSBzdHJlYW0gaGFzIGJlZW4gYXNzaWduZWQsIGJ1dCB0aGUgcmVxdWVzdCBoYXMgYmVlbiBhYm9ydGVkXG4gICAgLy8gdGhlIHJlcXVlc3QgcmVtYWlucyBpbi1mbGlnaHQgYW5kIGhlYWRlcnMgaGFzbid0IGJlZW4gcmVjZWl2ZWQgeWV0XG4gICAgLy8gZm9yIHRob3NlIHNjZW5hcmlvcywgYmVzdCBlZmZvcnQgaXMgdG8gZGVzdHJveSB0aGUgc3RyZWFtIGltbWVkaWF0ZWx5XG4gICAgLy8gYXMgdGhlcmUncyBubyB2YWx1ZSB0byBrZWVwIGl0IG9wZW4uXG4gICAgaWYgKHJlcXVlc3QuYWJvcnRlZCkge1xuICAgICAgY29uc3QgZXJyID0gbmV3IFJlcXVlc3RBYm9ydGVkRXJyb3IoKVxuICAgICAgdXRpbC5lcnJvclJlcXVlc3QoY2xpZW50LCByZXF1ZXN0LCBlcnIpXG4gICAgICB1dGlsLmRlc3Ryb3koc3RyZWFtLCBlcnIpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAocmVxdWVzdC5vbkhlYWRlcnMoTnVtYmVyKHN0YXR1c0NvZGUpLCBwYXJzZUgySGVhZGVycyhyZWFsSGVhZGVycyksIHN0cmVhbS5yZXN1bWUuYmluZChzdHJlYW0pLCAnJykgPT09IGZhbHNlKSB7XG4gICAgICBzdHJlYW0ucGF1c2UoKVxuICAgIH1cblxuICAgIHN0cmVhbS5vbignZGF0YScsIChjaHVuaykgPT4ge1xuICAgICAgaWYgKHJlcXVlc3Qub25EYXRhKGNodW5rKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgc3RyZWFtLnBhdXNlKClcbiAgICAgIH1cbiAgICB9KVxuICB9KVxuXG4gIHN0cmVhbS5vbmNlKCdlbmQnLCAoKSA9PiB7XG4gICAgLy8gV2hlbiBzdGF0ZSBpcyBudWxsLCBpdCBtZWFucyB3ZSBoYXZlbid0IGNvbnN1bWVkIGJvZHkgYW5kIHRoZSBzdHJlYW0gc3RpbGwgZG8gbm90IGhhdmVcbiAgICAvLyBhIHN0YXRlLlxuICAgIC8vIFByZXNlbnQgc3BlY2lhbGx5IHdoZW4gdXNpbmcgcGlwZWxpbmUgb3Igc3RyZWFtXG4gICAgaWYgKHN0cmVhbS5zdGF0ZT8uc3RhdGUgPT0gbnVsbCB8fCBzdHJlYW0uc3RhdGUuc3RhdGUgPCA2KSB7XG4gICAgICByZXF1ZXN0Lm9uQ29tcGxldGUoW10pXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBTdHJlYW0gaXMgY2xvc2VkIG9yIGhhbGYtY2xvc2VkLXJlbW90ZSAoNiksIGRlY3JlbWVudCBjb3VudGVyIGFuZCBjbGVhbnVwXG4gICAgLy8gSXQgZG9lcyBub3QgaGF2ZSBzZW5zZSB0byBjb250aW51ZSB3b3JraW5nIHdpdGggdGhlIHN0cmVhbSBhcyB3ZSBkbyBub3RcbiAgICAvLyBoYXZlIHlldCBSU1RfU1RSRUFNIHN1cHBvcnQgb24gY2xpZW50LXNpZGVcbiAgICBpZiAoc2Vzc2lvbltrT3BlblN0cmVhbXNdID09PSAwKSB7XG4gICAgICBzZXNzaW9uLnVucmVmKClcbiAgICB9XG5cbiAgICBhYm9ydChuZXcgSW5mb3JtYXRpb25hbEVycm9yKCdIVFRQLzI6IHN0cmVhbSBoYWxmLWNsb3NlZCAocmVtb3RlKScpKVxuICB9KVxuXG4gIHN0cmVhbS5vbmNlKCdjbG9zZScsICgpID0+IHtcbiAgICBzZXNzaW9uW2tPcGVuU3RyZWFtc10gLT0gMVxuICAgIGlmIChzZXNzaW9uW2tPcGVuU3RyZWFtc10gPT09IDApIHtcbiAgICAgIHNlc3Npb24udW5yZWYoKVxuICAgIH1cbiAgfSlcblxuICBzdHJlYW0ub25jZSgnZXJyb3InLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgYWJvcnQoZXJyKVxuICB9KVxuXG4gIHN0cmVhbS5vbmNlKCdmcmFtZUVycm9yJywgKHR5cGUsIGNvZGUpID0+IHtcbiAgICBhYm9ydChuZXcgSW5mb3JtYXRpb25hbEVycm9yKGBIVFRQLzI6IFwiZnJhbWVFcnJvclwiIHJlY2VpdmVkIC0gdHlwZSAke3R5cGV9LCBjb2RlICR7Y29kZX1gKSlcbiAgfSlcblxuICAvLyBzdHJlYW0ub24oJ2Fib3J0ZWQnLCAoKSA9PiB7XG4gIC8vICAgLy8gVE9ETyhIVFRQLzIpOiBTdXBwb3J0IGFib3J0ZWRcbiAgLy8gfSlcblxuICAvLyBzdHJlYW0ub24oJ3RpbWVvdXQnLCAoKSA9PiB7XG4gIC8vICAgLy8gVE9ETyhIVFRQLzIpOiBTdXBwb3J0IHRpbWVvdXRcbiAgLy8gfSlcblxuICAvLyBzdHJlYW0ub24oJ3B1c2gnLCBoZWFkZXJzID0+IHtcbiAgLy8gICAvLyBUT0RPKEhUVFAvMik6IFN1cHBvcnQgcHVzaFxuICAvLyB9KVxuXG4gIC8vIHN0cmVhbS5vbigndHJhaWxlcnMnLCBoZWFkZXJzID0+IHtcbiAgLy8gICAvLyBUT0RPKEhUVFAvMik6IFN1cHBvcnQgdHJhaWxlcnNcbiAgLy8gfSlcblxuICByZXR1cm4gdHJ1ZVxuXG4gIGZ1bmN0aW9uIHdyaXRlQm9keUgyICgpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZTogYXNzZXJ0aW9uICovXG4gICAgaWYgKCFib2R5IHx8IGNvbnRlbnRMZW5ndGggPT09IDApIHtcbiAgICAgIHdyaXRlQnVmZmVyKFxuICAgICAgICBhYm9ydCxcbiAgICAgICAgc3RyZWFtLFxuICAgICAgICBudWxsLFxuICAgICAgICBjbGllbnQsXG4gICAgICAgIHJlcXVlc3QsXG4gICAgICAgIGNsaWVudFtrU29ja2V0XSxcbiAgICAgICAgY29udGVudExlbmd0aCxcbiAgICAgICAgZXhwZWN0c1BheWxvYWRcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKHV0aWwuaXNCdWZmZXIoYm9keSkpIHtcbiAgICAgIHdyaXRlQnVmZmVyKFxuICAgICAgICBhYm9ydCxcbiAgICAgICAgc3RyZWFtLFxuICAgICAgICBib2R5LFxuICAgICAgICBjbGllbnQsXG4gICAgICAgIHJlcXVlc3QsXG4gICAgICAgIGNsaWVudFtrU29ja2V0XSxcbiAgICAgICAgY29udGVudExlbmd0aCxcbiAgICAgICAgZXhwZWN0c1BheWxvYWRcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKHV0aWwuaXNCbG9iTGlrZShib2R5KSkge1xuICAgICAgaWYgKHR5cGVvZiBib2R5LnN0cmVhbSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB3cml0ZUl0ZXJhYmxlKFxuICAgICAgICAgIGFib3J0LFxuICAgICAgICAgIHN0cmVhbSxcbiAgICAgICAgICBib2R5LnN0cmVhbSgpLFxuICAgICAgICAgIGNsaWVudCxcbiAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgIGNsaWVudFtrU29ja2V0XSxcbiAgICAgICAgICBjb250ZW50TGVuZ3RoLFxuICAgICAgICAgIGV4cGVjdHNQYXlsb2FkXG4gICAgICAgIClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdyaXRlQmxvYihcbiAgICAgICAgICBhYm9ydCxcbiAgICAgICAgICBzdHJlYW0sXG4gICAgICAgICAgYm9keSxcbiAgICAgICAgICBjbGllbnQsXG4gICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICBjbGllbnRba1NvY2tldF0sXG4gICAgICAgICAgY29udGVudExlbmd0aCxcbiAgICAgICAgICBleHBlY3RzUGF5bG9hZFxuICAgICAgICApXG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh1dGlsLmlzU3RyZWFtKGJvZHkpKSB7XG4gICAgICB3cml0ZVN0cmVhbShcbiAgICAgICAgYWJvcnQsXG4gICAgICAgIGNsaWVudFtrU29ja2V0XSxcbiAgICAgICAgZXhwZWN0c1BheWxvYWQsXG4gICAgICAgIHN0cmVhbSxcbiAgICAgICAgYm9keSxcbiAgICAgICAgY2xpZW50LFxuICAgICAgICByZXF1ZXN0LFxuICAgICAgICBjb250ZW50TGVuZ3RoXG4gICAgICApXG4gICAgfSBlbHNlIGlmICh1dGlsLmlzSXRlcmFibGUoYm9keSkpIHtcbiAgICAgIHdyaXRlSXRlcmFibGUoXG4gICAgICAgIGFib3J0LFxuICAgICAgICBzdHJlYW0sXG4gICAgICAgIGJvZHksXG4gICAgICAgIGNsaWVudCxcbiAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgY2xpZW50W2tTb2NrZXRdLFxuICAgICAgICBjb250ZW50TGVuZ3RoLFxuICAgICAgICBleHBlY3RzUGF5bG9hZFxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICBhc3NlcnQoZmFsc2UpXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHdyaXRlQnVmZmVyIChhYm9ydCwgaDJzdHJlYW0sIGJvZHksIGNsaWVudCwgcmVxdWVzdCwgc29ja2V0LCBjb250ZW50TGVuZ3RoLCBleHBlY3RzUGF5bG9hZCkge1xuICB0cnkge1xuICAgIGlmIChib2R5ICE9IG51bGwgJiYgdXRpbC5pc0J1ZmZlcihib2R5KSkge1xuICAgICAgYXNzZXJ0KGNvbnRlbnRMZW5ndGggPT09IGJvZHkuYnl0ZUxlbmd0aCwgJ2J1ZmZlciBib2R5IG11c3QgaGF2ZSBjb250ZW50IGxlbmd0aCcpXG4gICAgICBoMnN0cmVhbS5jb3JrKClcbiAgICAgIGgyc3RyZWFtLndyaXRlKGJvZHkpXG4gICAgICBoMnN0cmVhbS51bmNvcmsoKVxuICAgICAgaDJzdHJlYW0uZW5kKClcblxuICAgICAgcmVxdWVzdC5vbkJvZHlTZW50KGJvZHkpXG4gICAgfVxuXG4gICAgaWYgKCFleHBlY3RzUGF5bG9hZCkge1xuICAgICAgc29ja2V0W2tSZXNldF0gPSB0cnVlXG4gICAgfVxuXG4gICAgcmVxdWVzdC5vblJlcXVlc3RTZW50KClcbiAgICBjbGllbnRba1Jlc3VtZV0oKVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGFib3J0KGVycm9yKVxuICB9XG59XG5cbmZ1bmN0aW9uIHdyaXRlU3RyZWFtIChhYm9ydCwgc29ja2V0LCBleHBlY3RzUGF5bG9hZCwgaDJzdHJlYW0sIGJvZHksIGNsaWVudCwgcmVxdWVzdCwgY29udGVudExlbmd0aCkge1xuICBhc3NlcnQoY29udGVudExlbmd0aCAhPT0gMCB8fCBjbGllbnRba1J1bm5pbmddID09PSAwLCAnc3RyZWFtIGJvZHkgY2Fubm90IGJlIHBpcGVsaW5lZCcpXG5cbiAgLy8gRm9yIEhUVFAvMiwgaXMgZW5vdWdoIHRvIHBpcGUgdGhlIHN0cmVhbVxuICBjb25zdCBwaXBlID0gcGlwZWxpbmUoXG4gICAgYm9keSxcbiAgICBoMnN0cmVhbSxcbiAgICAoZXJyKSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHV0aWwuZGVzdHJveShwaXBlLCBlcnIpXG4gICAgICAgIGFib3J0KGVycilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHV0aWwucmVtb3ZlQWxsTGlzdGVuZXJzKHBpcGUpXG4gICAgICAgIHJlcXVlc3Qub25SZXF1ZXN0U2VudCgpXG5cbiAgICAgICAgaWYgKCFleHBlY3RzUGF5bG9hZCkge1xuICAgICAgICAgIHNvY2tldFtrUmVzZXRdID0gdHJ1ZVxuICAgICAgICB9XG5cbiAgICAgICAgY2xpZW50W2tSZXN1bWVdKClcbiAgICAgIH1cbiAgICB9XG4gIClcblxuICB1dGlsLmFkZExpc3RlbmVyKHBpcGUsICdkYXRhJywgb25QaXBlRGF0YSlcblxuICBmdW5jdGlvbiBvblBpcGVEYXRhIChjaHVuaykge1xuICAgIHJlcXVlc3Qub25Cb2R5U2VudChjaHVuaylcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiB3cml0ZUJsb2IgKGFib3J0LCBoMnN0cmVhbSwgYm9keSwgY2xpZW50LCByZXF1ZXN0LCBzb2NrZXQsIGNvbnRlbnRMZW5ndGgsIGV4cGVjdHNQYXlsb2FkKSB7XG4gIGFzc2VydChjb250ZW50TGVuZ3RoID09PSBib2R5LnNpemUsICdibG9iIGJvZHkgbXVzdCBoYXZlIGNvbnRlbnQgbGVuZ3RoJylcblxuICB0cnkge1xuICAgIGlmIChjb250ZW50TGVuZ3RoICE9IG51bGwgJiYgY29udGVudExlbmd0aCAhPT0gYm9keS5zaXplKSB7XG4gICAgICB0aHJvdyBuZXcgUmVxdWVzdENvbnRlbnRMZW5ndGhNaXNtYXRjaEVycm9yKClcbiAgICB9XG5cbiAgICBjb25zdCBidWZmZXIgPSBCdWZmZXIuZnJvbShhd2FpdCBib2R5LmFycmF5QnVmZmVyKCkpXG5cbiAgICBoMnN0cmVhbS5jb3JrKClcbiAgICBoMnN0cmVhbS53cml0ZShidWZmZXIpXG4gICAgaDJzdHJlYW0udW5jb3JrKClcbiAgICBoMnN0cmVhbS5lbmQoKVxuXG4gICAgcmVxdWVzdC5vbkJvZHlTZW50KGJ1ZmZlcilcbiAgICByZXF1ZXN0Lm9uUmVxdWVzdFNlbnQoKVxuXG4gICAgaWYgKCFleHBlY3RzUGF5bG9hZCkge1xuICAgICAgc29ja2V0W2tSZXNldF0gPSB0cnVlXG4gICAgfVxuXG4gICAgY2xpZW50W2tSZXN1bWVdKClcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgYWJvcnQoZXJyKVxuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHdyaXRlSXRlcmFibGUgKGFib3J0LCBoMnN0cmVhbSwgYm9keSwgY2xpZW50LCByZXF1ZXN0LCBzb2NrZXQsIGNvbnRlbnRMZW5ndGgsIGV4cGVjdHNQYXlsb2FkKSB7XG4gIGFzc2VydChjb250ZW50TGVuZ3RoICE9PSAwIHx8IGNsaWVudFtrUnVubmluZ10gPT09IDAsICdpdGVyYXRvciBib2R5IGNhbm5vdCBiZSBwaXBlbGluZWQnKVxuXG4gIGxldCBjYWxsYmFjayA9IG51bGxcbiAgZnVuY3Rpb24gb25EcmFpbiAoKSB7XG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICBjb25zdCBjYiA9IGNhbGxiYWNrXG4gICAgICBjYWxsYmFjayA9IG51bGxcbiAgICAgIGNiKClcbiAgICB9XG4gIH1cblxuICBjb25zdCB3YWl0Rm9yRHJhaW4gPSAoKSA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgYXNzZXJ0KGNhbGxiYWNrID09PSBudWxsKVxuXG4gICAgaWYgKHNvY2tldFtrRXJyb3JdKSB7XG4gICAgICByZWplY3Qoc29ja2V0W2tFcnJvcl0pXG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGxiYWNrID0gcmVzb2x2ZVxuICAgIH1cbiAgfSlcblxuICBoMnN0cmVhbVxuICAgIC5vbignY2xvc2UnLCBvbkRyYWluKVxuICAgIC5vbignZHJhaW4nLCBvbkRyYWluKVxuXG4gIHRyeSB7XG4gICAgLy8gSXQncyB1cCB0byB0aGUgdXNlciB0byBzb21laG93IGFib3J0IHRoZSBhc3luYyBpdGVyYWJsZS5cbiAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIGJvZHkpIHtcbiAgICAgIGlmIChzb2NrZXRba0Vycm9yXSkge1xuICAgICAgICB0aHJvdyBzb2NrZXRba0Vycm9yXVxuICAgICAgfVxuXG4gICAgICBjb25zdCByZXMgPSBoMnN0cmVhbS53cml0ZShjaHVuaylcbiAgICAgIHJlcXVlc3Qub25Cb2R5U2VudChjaHVuaylcbiAgICAgIGlmICghcmVzKSB7XG4gICAgICAgIGF3YWl0IHdhaXRGb3JEcmFpbigpXG4gICAgICB9XG4gICAgfVxuXG4gICAgaDJzdHJlYW0uZW5kKClcblxuICAgIHJlcXVlc3Qub25SZXF1ZXN0U2VudCgpXG5cbiAgICBpZiAoIWV4cGVjdHNQYXlsb2FkKSB7XG4gICAgICBzb2NrZXRba1Jlc2V0XSA9IHRydWVcbiAgICB9XG5cbiAgICBjbGllbnRba1Jlc3VtZV0oKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBhYm9ydChlcnIpXG4gIH0gZmluYWxseSB7XG4gICAgaDJzdHJlYW1cbiAgICAgIC5vZmYoJ2Nsb3NlJywgb25EcmFpbilcbiAgICAgIC5vZmYoJ2RyYWluJywgb25EcmFpbilcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbm5lY3RIMlxuIl0sIm5hbWVzIjpbImFzc2VydCIsInJlcXVpcmUiLCJwaXBlbGluZSIsInV0aWwiLCJSZXF1ZXN0Q29udGVudExlbmd0aE1pc21hdGNoRXJyb3IiLCJSZXF1ZXN0QWJvcnRlZEVycm9yIiwiU29ja2V0RXJyb3IiLCJJbmZvcm1hdGlvbmFsRXJyb3IiLCJrVXJsIiwia1Jlc2V0Iiwia0NsaWVudCIsImtSdW5uaW5nIiwia1BlbmRpbmciLCJrUXVldWUiLCJrUGVuZGluZ0lkeCIsImtSdW5uaW5nSWR4Iiwia0Vycm9yIiwia1NvY2tldCIsImtTdHJpY3RDb250ZW50TGVuZ3RoIiwia09uRXJyb3IiLCJrTWF4Q29uY3VycmVudFN0cmVhbXMiLCJrSFRUUDJTZXNzaW9uIiwia1Jlc3VtZSIsImtPcGVuU3RyZWFtcyIsIlN5bWJvbCIsImgyRXhwZXJpbWVudGFsV2FybmVkIiwiaHR0cDIiLCJjb25zdGFudHMiLCJIVFRQMl9IRUFERVJfQVVUSE9SSVRZIiwiSFRUUDJfSEVBREVSX01FVEhPRCIsIkhUVFAyX0hFQURFUl9QQVRIIiwiSFRUUDJfSEVBREVSX1NDSEVNRSIsIkhUVFAyX0hFQURFUl9DT05URU5UX0xFTkdUSCIsIkhUVFAyX0hFQURFUl9FWFBFQ1QiLCJIVFRQMl9IRUFERVJfU1RBVFVTIiwicGFyc2VIMkhlYWRlcnMiLCJoZWFkZXJzIiwicmVzdWx0IiwibmFtZSIsInZhbHVlIiwiT2JqZWN0IiwiZW50cmllcyIsIkFycmF5IiwiaXNBcnJheSIsInN1YnZhbHVlIiwicHVzaCIsIkJ1ZmZlciIsImZyb20iLCJjb25uZWN0SDIiLCJjbGllbnQiLCJzb2NrZXQiLCJwcm9jZXNzIiwiZW1pdFdhcm5pbmciLCJjb2RlIiwic2Vzc2lvbiIsImNvbm5lY3QiLCJjcmVhdGVDb25uZWN0aW9uIiwicGVlck1heENvbmN1cnJlbnRTdHJlYW1zIiwiYWRkTGlzdGVuZXIiLCJvbkh0dHAyU2Vzc2lvbkVycm9yIiwib25IdHRwMkZyYW1lRXJyb3IiLCJvbkh0dHAyU2Vzc2lvbkVuZCIsIm9uSFRUUDJHb0F3YXkiLCJlcnIiLCJnZXRTb2NrZXRJbmZvIiwiZGVzdHJveWVkIiwicmVxdWVzdHMiLCJzcGxpY2UiLCJpIiwibGVuZ3RoIiwicmVxdWVzdCIsImVycm9yUmVxdWVzdCIsInVucmVmIiwiZGVzdHJveSIsImVtaXQiLCJjbG9zZWQiLCJvbiIsInZlcnNpb24iLCJkZWZhdWx0UGlwZWxpbmluZyIsIkluZmluaXR5Iiwid3JpdGUiLCJhcmdzIiwid3JpdGVIMiIsInJlc3VtZSIsImNhbGxiYWNrIiwicXVldWVNaWNyb3Rhc2siLCJidXN5IiwidHlwZSIsImlkIiwic2hvdWxkU2VuZENvbnRlbnRMZW5ndGgiLCJtZXRob2QiLCJib2R5IiwicGF0aCIsImhvc3QiLCJ1cGdyYWRlIiwiZXhwZWN0Q29udGludWUiLCJzaWduYWwiLCJyZXFIZWFkZXJzIiwiRXJyb3IiLCJhYm9ydGVkIiwibiIsImtleSIsInZhbCIsInN0cmVhbSIsImhvc3RuYW1lIiwicG9ydCIsImFib3J0IiwiY29tcGxldGVkIiwib25Db25uZWN0IiwicmVmIiwiZW5kU3RyZWFtIiwicGVuZGluZyIsIm9uVXBncmFkZSIsIm9uY2UiLCJleHBlY3RzUGF5bG9hZCIsInJlYWQiLCJjb250ZW50TGVuZ3RoIiwiYm9keUxlbmd0aCIsInNob3VsZEVuZFN0cmVhbSIsIndyaXRlQm9keUgyIiwic3RhdHVzQ29kZSIsInJlYWxIZWFkZXJzIiwib25SZXNwb25zZVN0YXJ0ZWQiLCJvbkhlYWRlcnMiLCJOdW1iZXIiLCJiaW5kIiwicGF1c2UiLCJjaHVuayIsIm9uRGF0YSIsInN0YXRlIiwib25Db21wbGV0ZSIsIndyaXRlQnVmZmVyIiwiaXNCdWZmZXIiLCJpc0Jsb2JMaWtlIiwid3JpdGVJdGVyYWJsZSIsIndyaXRlQmxvYiIsImlzU3RyZWFtIiwid3JpdGVTdHJlYW0iLCJpc0l0ZXJhYmxlIiwiaDJzdHJlYW0iLCJieXRlTGVuZ3RoIiwiY29yayIsInVuY29yayIsImVuZCIsIm9uQm9keVNlbnQiLCJvblJlcXVlc3RTZW50IiwiZXJyb3IiLCJwaXBlIiwicmVtb3ZlQWxsTGlzdGVuZXJzIiwib25QaXBlRGF0YSIsInNpemUiLCJidWZmZXIiLCJhcnJheUJ1ZmZlciIsIm9uRHJhaW4iLCJjYiIsIndhaXRGb3JEcmFpbiIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwicmVzIiwib2ZmIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/dispatcher/client-h2.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/dispatcher/client.js":
/*!******************************************************!*\
  !*** ./node_modules/undici/lib/dispatcher/client.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// @ts-check\n\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\");\nconst net = __webpack_require__(/*! node:net */ \"node:net\");\nconst http = __webpack_require__(/*! node:http */ \"node:http\");\nconst util = __webpack_require__(/*! ../core/util.js */ \"(ssr)/./node_modules/undici/lib/core/util.js\");\nconst { channels } = __webpack_require__(/*! ../core/diagnostics.js */ \"(ssr)/./node_modules/undici/lib/core/diagnostics.js\");\nconst Request = __webpack_require__(/*! ../core/request.js */ \"(ssr)/./node_modules/undici/lib/core/request.js\");\nconst DispatcherBase = __webpack_require__(/*! ./dispatcher-base */ \"(ssr)/./node_modules/undici/lib/dispatcher/dispatcher-base.js\");\nconst { InvalidArgumentError, InformationalError, ClientDestroyedError } = __webpack_require__(/*! ../core/errors.js */ \"(ssr)/./node_modules/undici/lib/core/errors.js\");\nconst buildConnector = __webpack_require__(/*! ../core/connect.js */ \"(ssr)/./node_modules/undici/lib/core/connect.js\");\nconst { kUrl, kServerName, kClient, kBusy, kConnect, kResuming, kRunning, kPending, kSize, kQueue, kConnected, kConnecting, kNeedDrain, kKeepAliveDefaultTimeout, kHostHeader, kPendingIdx, kRunningIdx, kError, kPipelining, kKeepAliveTimeoutValue, kMaxHeadersSize, kKeepAliveMaxTimeout, kKeepAliveTimeoutThreshold, kHeadersTimeout, kBodyTimeout, kStrictContentLength, kConnector, kMaxRedirections, kMaxRequests, kCounter, kClose, kDestroy, kDispatch, kInterceptors, kLocalAddress, kMaxResponseSize, kOnError, kHTTPContext, kMaxConcurrentStreams, kResume } = __webpack_require__(/*! ../core/symbols.js */ \"(ssr)/./node_modules/undici/lib/core/symbols.js\");\nconst connectH1 = __webpack_require__(/*! ./client-h1.js */ \"(ssr)/./node_modules/undici/lib/dispatcher/client-h1.js\");\nconst connectH2 = __webpack_require__(/*! ./client-h2.js */ \"(ssr)/./node_modules/undici/lib/dispatcher/client-h2.js\");\nlet deprecatedInterceptorWarned = false;\nconst kClosedResolve = Symbol(\"kClosedResolve\");\nfunction getPipelining(client) {\n    return client[kPipelining] ?? client[kHTTPContext]?.defaultPipelining ?? 1;\n}\n/**\n * @type {import('../../types/client.js').default}\n */ class Client extends DispatcherBase {\n    /**\n   *\n   * @param {string|URL} url\n   * @param {import('../../types/client.js').Client.Options} options\n   */ constructor(url, { interceptors, maxHeaderSize, headersTimeout, socketTimeout, requestTimeout, connectTimeout, bodyTimeout, idleTimeout, keepAlive, keepAliveTimeout, maxKeepAliveTimeout, keepAliveMaxTimeout, keepAliveTimeoutThreshold, socketPath, pipelining, tls, strictContentLength, maxCachedSessions, maxRedirections, connect, maxRequestsPerClient, localAddress, maxResponseSize, autoSelectFamily, autoSelectFamilyAttemptTimeout, // h2\n    maxConcurrentStreams, allowH2 } = {}){\n        super();\n        if (keepAlive !== undefined) {\n            throw new InvalidArgumentError(\"unsupported keepAlive, use pipelining=0 instead\");\n        }\n        if (socketTimeout !== undefined) {\n            throw new InvalidArgumentError(\"unsupported socketTimeout, use headersTimeout & bodyTimeout instead\");\n        }\n        if (requestTimeout !== undefined) {\n            throw new InvalidArgumentError(\"unsupported requestTimeout, use headersTimeout & bodyTimeout instead\");\n        }\n        if (idleTimeout !== undefined) {\n            throw new InvalidArgumentError(\"unsupported idleTimeout, use keepAliveTimeout instead\");\n        }\n        if (maxKeepAliveTimeout !== undefined) {\n            throw new InvalidArgumentError(\"unsupported maxKeepAliveTimeout, use keepAliveMaxTimeout instead\");\n        }\n        if (maxHeaderSize != null && !Number.isFinite(maxHeaderSize)) {\n            throw new InvalidArgumentError(\"invalid maxHeaderSize\");\n        }\n        if (socketPath != null && typeof socketPath !== \"string\") {\n            throw new InvalidArgumentError(\"invalid socketPath\");\n        }\n        if (connectTimeout != null && (!Number.isFinite(connectTimeout) || connectTimeout < 0)) {\n            throw new InvalidArgumentError(\"invalid connectTimeout\");\n        }\n        if (keepAliveTimeout != null && (!Number.isFinite(keepAliveTimeout) || keepAliveTimeout <= 0)) {\n            throw new InvalidArgumentError(\"invalid keepAliveTimeout\");\n        }\n        if (keepAliveMaxTimeout != null && (!Number.isFinite(keepAliveMaxTimeout) || keepAliveMaxTimeout <= 0)) {\n            throw new InvalidArgumentError(\"invalid keepAliveMaxTimeout\");\n        }\n        if (keepAliveTimeoutThreshold != null && !Number.isFinite(keepAliveTimeoutThreshold)) {\n            throw new InvalidArgumentError(\"invalid keepAliveTimeoutThreshold\");\n        }\n        if (headersTimeout != null && (!Number.isInteger(headersTimeout) || headersTimeout < 0)) {\n            throw new InvalidArgumentError(\"headersTimeout must be a positive integer or zero\");\n        }\n        if (bodyTimeout != null && (!Number.isInteger(bodyTimeout) || bodyTimeout < 0)) {\n            throw new InvalidArgumentError(\"bodyTimeout must be a positive integer or zero\");\n        }\n        if (connect != null && typeof connect !== \"function\" && typeof connect !== \"object\") {\n            throw new InvalidArgumentError(\"connect must be a function or an object\");\n        }\n        if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {\n            throw new InvalidArgumentError(\"maxRedirections must be a positive number\");\n        }\n        if (maxRequestsPerClient != null && (!Number.isInteger(maxRequestsPerClient) || maxRequestsPerClient < 0)) {\n            throw new InvalidArgumentError(\"maxRequestsPerClient must be a positive number\");\n        }\n        if (localAddress != null && (typeof localAddress !== \"string\" || net.isIP(localAddress) === 0)) {\n            throw new InvalidArgumentError(\"localAddress must be valid string IP address\");\n        }\n        if (maxResponseSize != null && (!Number.isInteger(maxResponseSize) || maxResponseSize < -1)) {\n            throw new InvalidArgumentError(\"maxResponseSize must be a positive number\");\n        }\n        if (autoSelectFamilyAttemptTimeout != null && (!Number.isInteger(autoSelectFamilyAttemptTimeout) || autoSelectFamilyAttemptTimeout < -1)) {\n            throw new InvalidArgumentError(\"autoSelectFamilyAttemptTimeout must be a positive number\");\n        }\n        // h2\n        if (allowH2 != null && typeof allowH2 !== \"boolean\") {\n            throw new InvalidArgumentError(\"allowH2 must be a valid boolean value\");\n        }\n        if (maxConcurrentStreams != null && (typeof maxConcurrentStreams !== \"number\" || maxConcurrentStreams < 1)) {\n            throw new InvalidArgumentError(\"maxConcurrentStreams must be a positive integer, greater than 0\");\n        }\n        if (typeof connect !== \"function\") {\n            connect = buildConnector({\n                ...tls,\n                maxCachedSessions,\n                allowH2,\n                socketPath,\n                timeout: connectTimeout,\n                ...autoSelectFamily ? {\n                    autoSelectFamily,\n                    autoSelectFamilyAttemptTimeout\n                } : undefined,\n                ...connect\n            });\n        }\n        if (interceptors?.Client && Array.isArray(interceptors.Client)) {\n            this[kInterceptors] = interceptors.Client;\n            if (!deprecatedInterceptorWarned) {\n                deprecatedInterceptorWarned = true;\n                process.emitWarning(\"Client.Options#interceptor is deprecated. Use Dispatcher#compose instead.\", {\n                    code: \"UNDICI-CLIENT-INTERCEPTOR-DEPRECATED\"\n                });\n            }\n        } else {\n            this[kInterceptors] = [\n                createRedirectInterceptor({\n                    maxRedirections\n                })\n            ];\n        }\n        this[kUrl] = util.parseOrigin(url);\n        this[kConnector] = connect;\n        this[kPipelining] = pipelining != null ? pipelining : 1;\n        this[kMaxHeadersSize] = maxHeaderSize || http.maxHeaderSize;\n        this[kKeepAliveDefaultTimeout] = keepAliveTimeout == null ? 4e3 : keepAliveTimeout;\n        this[kKeepAliveMaxTimeout] = keepAliveMaxTimeout == null ? 600e3 : keepAliveMaxTimeout;\n        this[kKeepAliveTimeoutThreshold] = keepAliveTimeoutThreshold == null ? 2e3 : keepAliveTimeoutThreshold;\n        this[kKeepAliveTimeoutValue] = this[kKeepAliveDefaultTimeout];\n        this[kServerName] = null;\n        this[kLocalAddress] = localAddress != null ? localAddress : null;\n        this[kResuming] = 0; // 0, idle, 1, scheduled, 2 resuming\n        this[kNeedDrain] = 0; // 0, idle, 1, scheduled, 2 resuming\n        this[kHostHeader] = `host: ${this[kUrl].hostname}${this[kUrl].port ? `:${this[kUrl].port}` : \"\"}\\r\\n`;\n        this[kBodyTimeout] = bodyTimeout != null ? bodyTimeout : 300e3;\n        this[kHeadersTimeout] = headersTimeout != null ? headersTimeout : 300e3;\n        this[kStrictContentLength] = strictContentLength == null ? true : strictContentLength;\n        this[kMaxRedirections] = maxRedirections;\n        this[kMaxRequests] = maxRequestsPerClient;\n        this[kClosedResolve] = null;\n        this[kMaxResponseSize] = maxResponseSize > -1 ? maxResponseSize : -1;\n        this[kMaxConcurrentStreams] = maxConcurrentStreams != null ? maxConcurrentStreams : 100; // Max peerConcurrentStreams for a Node h2 server\n        this[kHTTPContext] = null;\n        // kQueue is built up of 3 sections separated by\n        // the kRunningIdx and kPendingIdx indices.\n        // |   complete   |   running   |   pending   |\n        //                ^ kRunningIdx ^ kPendingIdx ^ kQueue.length\n        // kRunningIdx points to the first running element.\n        // kPendingIdx points to the first pending element.\n        // This implements a fast queue with an amortized\n        // time of O(1).\n        this[kQueue] = [];\n        this[kRunningIdx] = 0;\n        this[kPendingIdx] = 0;\n        this[kResume] = (sync)=>resume(this, sync);\n        this[kOnError] = (err)=>onError(this, err);\n    }\n    get pipelining() {\n        return this[kPipelining];\n    }\n    set pipelining(value) {\n        this[kPipelining] = value;\n        this[kResume](true);\n    }\n    get [kPending]() {\n        return this[kQueue].length - this[kPendingIdx];\n    }\n    get [kRunning]() {\n        return this[kPendingIdx] - this[kRunningIdx];\n    }\n    get [kSize]() {\n        return this[kQueue].length - this[kRunningIdx];\n    }\n    get [kConnected]() {\n        return !!this[kHTTPContext] && !this[kConnecting] && !this[kHTTPContext].destroyed;\n    }\n    get [kBusy]() {\n        return Boolean(this[kHTTPContext]?.busy(null) || this[kSize] >= (getPipelining(this) || 1) || this[kPending] > 0);\n    }\n    /* istanbul ignore: only used for test */ [kConnect](cb) {\n        connect(this);\n        this.once(\"connect\", cb);\n    }\n    [kDispatch](opts, handler) {\n        const origin = opts.origin || this[kUrl].origin;\n        const request = new Request(origin, opts, handler);\n        this[kQueue].push(request);\n        if (this[kResuming]) {\n        // Do nothing.\n        } else if (util.bodyLength(request.body) == null && util.isIterable(request.body)) {\n            // Wait a tick in case stream/iterator is ended in the same tick.\n            this[kResuming] = 1;\n            queueMicrotask(()=>resume(this));\n        } else {\n            this[kResume](true);\n        }\n        if (this[kResuming] && this[kNeedDrain] !== 2 && this[kBusy]) {\n            this[kNeedDrain] = 2;\n        }\n        return this[kNeedDrain] < 2;\n    }\n    async [kClose]() {\n        // TODO: for H2 we need to gracefully flush the remaining enqueued\n        // request and close each stream.\n        return new Promise((resolve)=>{\n            if (this[kSize]) {\n                this[kClosedResolve] = resolve;\n            } else {\n                resolve(null);\n            }\n        });\n    }\n    async [kDestroy](err) {\n        return new Promise((resolve)=>{\n            const requests = this[kQueue].splice(this[kPendingIdx]);\n            for(let i = 0; i < requests.length; i++){\n                const request = requests[i];\n                util.errorRequest(this, request, err);\n            }\n            const callback = ()=>{\n                if (this[kClosedResolve]) {\n                    // TODO (fix): Should we error here with ClientDestroyedError?\n                    this[kClosedResolve]();\n                    this[kClosedResolve] = null;\n                }\n                resolve(null);\n            };\n            if (this[kHTTPContext]) {\n                this[kHTTPContext].destroy(err, callback);\n                this[kHTTPContext] = null;\n            } else {\n                queueMicrotask(callback);\n            }\n            this[kResume]();\n        });\n    }\n}\nconst createRedirectInterceptor = __webpack_require__(/*! ../interceptor/redirect-interceptor.js */ \"(ssr)/./node_modules/undici/lib/interceptor/redirect-interceptor.js\");\nfunction onError(client, err) {\n    if (client[kRunning] === 0 && err.code !== \"UND_ERR_INFO\" && err.code !== \"UND_ERR_SOCKET\") {\n        // Error is not caused by running request and not a recoverable\n        // socket error.\n        assert(client[kPendingIdx] === client[kRunningIdx]);\n        const requests = client[kQueue].splice(client[kRunningIdx]);\n        for(let i = 0; i < requests.length; i++){\n            const request = requests[i];\n            util.errorRequest(client, request, err);\n        }\n        assert(client[kSize] === 0);\n    }\n}\nasync function connect(client) {\n    assert(!client[kConnecting]);\n    assert(!client[kHTTPContext]);\n    let { host, hostname, protocol, port } = client[kUrl];\n    // Resolve ipv6\n    if (hostname[0] === \"[\") {\n        const idx = hostname.indexOf(\"]\");\n        assert(idx !== -1);\n        const ip = hostname.substring(1, idx);\n        assert(net.isIP(ip));\n        hostname = ip;\n    }\n    client[kConnecting] = true;\n    if (channels.beforeConnect.hasSubscribers) {\n        channels.beforeConnect.publish({\n            connectParams: {\n                host,\n                hostname,\n                protocol,\n                port,\n                version: client[kHTTPContext]?.version,\n                servername: client[kServerName],\n                localAddress: client[kLocalAddress]\n            },\n            connector: client[kConnector]\n        });\n    }\n    try {\n        const socket = await new Promise((resolve, reject)=>{\n            client[kConnector]({\n                host,\n                hostname,\n                protocol,\n                port,\n                servername: client[kServerName],\n                localAddress: client[kLocalAddress]\n            }, (err, socket)=>{\n                if (err) {\n                    reject(err);\n                } else {\n                    resolve(socket);\n                }\n            });\n        });\n        if (client.destroyed) {\n            util.destroy(socket.on(\"error\", ()=>{}), new ClientDestroyedError());\n            return;\n        }\n        assert(socket);\n        try {\n            client[kHTTPContext] = socket.alpnProtocol === \"h2\" ? await connectH2(client, socket) : await connectH1(client, socket);\n        } catch (err) {\n            socket.destroy().on(\"error\", ()=>{});\n            throw err;\n        }\n        client[kConnecting] = false;\n        socket[kCounter] = 0;\n        socket[kMaxRequests] = client[kMaxRequests];\n        socket[kClient] = client;\n        socket[kError] = null;\n        if (channels.connected.hasSubscribers) {\n            channels.connected.publish({\n                connectParams: {\n                    host,\n                    hostname,\n                    protocol,\n                    port,\n                    version: client[kHTTPContext]?.version,\n                    servername: client[kServerName],\n                    localAddress: client[kLocalAddress]\n                },\n                connector: client[kConnector],\n                socket\n            });\n        }\n        client.emit(\"connect\", client[kUrl], [\n            client\n        ]);\n    } catch (err) {\n        if (client.destroyed) {\n            return;\n        }\n        client[kConnecting] = false;\n        if (channels.connectError.hasSubscribers) {\n            channels.connectError.publish({\n                connectParams: {\n                    host,\n                    hostname,\n                    protocol,\n                    port,\n                    version: client[kHTTPContext]?.version,\n                    servername: client[kServerName],\n                    localAddress: client[kLocalAddress]\n                },\n                connector: client[kConnector],\n                error: err\n            });\n        }\n        if (err.code === \"ERR_TLS_CERT_ALTNAME_INVALID\") {\n            assert(client[kRunning] === 0);\n            while(client[kPending] > 0 && client[kQueue][client[kPendingIdx]].servername === client[kServerName]){\n                const request = client[kQueue][client[kPendingIdx]++];\n                util.errorRequest(client, request, err);\n            }\n        } else {\n            onError(client, err);\n        }\n        client.emit(\"connectionError\", client[kUrl], [\n            client\n        ], err);\n    }\n    client[kResume]();\n}\nfunction emitDrain(client) {\n    client[kNeedDrain] = 0;\n    client.emit(\"drain\", client[kUrl], [\n        client\n    ]);\n}\nfunction resume(client, sync) {\n    if (client[kResuming] === 2) {\n        return;\n    }\n    client[kResuming] = 2;\n    _resume(client, sync);\n    client[kResuming] = 0;\n    if (client[kRunningIdx] > 256) {\n        client[kQueue].splice(0, client[kRunningIdx]);\n        client[kPendingIdx] -= client[kRunningIdx];\n        client[kRunningIdx] = 0;\n    }\n}\nfunction _resume(client, sync) {\n    while(true){\n        if (client.destroyed) {\n            assert(client[kPending] === 0);\n            return;\n        }\n        if (client[kClosedResolve] && !client[kSize]) {\n            client[kClosedResolve]();\n            client[kClosedResolve] = null;\n            return;\n        }\n        if (client[kHTTPContext]) {\n            client[kHTTPContext].resume();\n        }\n        if (client[kBusy]) {\n            client[kNeedDrain] = 2;\n        } else if (client[kNeedDrain] === 2) {\n            if (sync) {\n                client[kNeedDrain] = 1;\n                queueMicrotask(()=>emitDrain(client));\n            } else {\n                emitDrain(client);\n            }\n            continue;\n        }\n        if (client[kPending] === 0) {\n            return;\n        }\n        if (client[kRunning] >= (getPipelining(client) || 1)) {\n            return;\n        }\n        const request = client[kQueue][client[kPendingIdx]];\n        if (client[kUrl].protocol === \"https:\" && client[kServerName] !== request.servername) {\n            if (client[kRunning] > 0) {\n                return;\n            }\n            client[kServerName] = request.servername;\n            client[kHTTPContext]?.destroy(new InformationalError(\"servername changed\"), ()=>{\n                client[kHTTPContext] = null;\n                resume(client);\n            });\n        }\n        if (client[kConnecting]) {\n            return;\n        }\n        if (!client[kHTTPContext]) {\n            connect(client);\n            return;\n        }\n        if (client[kHTTPContext].destroyed) {\n            return;\n        }\n        if (client[kHTTPContext].busy(request)) {\n            return;\n        }\n        if (!request.aborted && client[kHTTPContext].write(request)) {\n            client[kPendingIdx]++;\n        } else {\n            client[kQueue].splice(client[kPendingIdx], 1);\n        }\n    }\n}\nmodule.exports = Client;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9kaXNwYXRjaGVyL2NsaWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBO0FBRUEsTUFBTUEsU0FBU0MsbUJBQU9BLENBQUM7QUFDdkIsTUFBTUMsTUFBTUQsbUJBQU9BLENBQUM7QUFDcEIsTUFBTUUsT0FBT0YsbUJBQU9BLENBQUM7QUFDckIsTUFBTUcsT0FBT0gsbUJBQU9BLENBQUM7QUFDckIsTUFBTSxFQUFFSSxRQUFBQSxFQUFVLEdBQUdKLG1CQUFPQSxDQUFDO0FBQzdCLE1BQU1LLFVBQVVMLG1CQUFPQSxDQUFDO0FBQ3hCLE1BQU1NLGlCQUFpQk4sbUJBQU9BLENBQUM7QUFDL0IsTUFBTSxFQUNKTyxvQkFBb0IsRUFDcEJDLGtCQUFrQixFQUNsQkMsb0JBQUFBLEVBQ0QsR0FBR1QsbUJBQU9BLENBQUM7QUFDWixNQUFNVSxpQkFBaUJWLG1CQUFPQSxDQUFDO0FBQy9CLE1BQU0sRUFDSlcsSUFBSSxFQUNKQyxXQUFXLEVBQ1hDLE9BQU8sRUFDUEMsS0FBSyxFQUNMQyxRQUFRLEVBQ1JDLFNBQVMsRUFDVEMsUUFBUSxFQUNSQyxRQUFRLEVBQ1JDLEtBQUssRUFDTEMsTUFBTSxFQUNOQyxVQUFVLEVBQ1ZDLFdBQVcsRUFDWEMsVUFBVSxFQUNWQyx3QkFBd0IsRUFDeEJDLFdBQVcsRUFDWEMsV0FBVyxFQUNYQyxXQUFXLEVBQ1hDLE1BQU0sRUFDTkMsV0FBVyxFQUNYQyxzQkFBc0IsRUFDdEJDLGVBQWUsRUFDZkMsb0JBQW9CLEVBQ3BCQywwQkFBMEIsRUFDMUJDLGVBQWUsRUFDZkMsWUFBWSxFQUNaQyxvQkFBb0IsRUFDcEJDLFVBQVUsRUFDVkMsZ0JBQWdCLEVBQ2hCQyxZQUFZLEVBQ1pDLFFBQVEsRUFDUkMsTUFBTSxFQUNOQyxRQUFRLEVBQ1JDLFNBQVMsRUFDVEMsYUFBYSxFQUNiQyxhQUFhLEVBQ2JDLGdCQUFnQixFQUNoQkMsUUFBUSxFQUNSQyxZQUFZLEVBQ1pDLHFCQUFxQixFQUNyQkMsT0FBQUEsRUFDRCxHQUFHbEQsbUJBQU9BLENBQUM7QUFDWixNQUFNbUQsWUFBWW5ELG1CQUFPQSxDQUFDO0FBQzFCLE1BQU1vRCxZQUFZcEQsbUJBQU9BLENBQUM7QUFDMUIsSUFBSXFELDhCQUE4QjtBQUVsQyxNQUFNQyxpQkFBaUJDLE9BQU87QUFFOUIsU0FBU0MsY0FBZUMsTUFBTTtJQUM1QixPQUFPQSxNQUFNLENBQUM1QixZQUFZLElBQUk0QixNQUFNLENBQUNULGFBQWEsRUFBRVUscUJBQXFCO0FBQzNFO0FBRUE7O0NBRUEsR0FDQSxNQUFNQyxlQUFlckQ7SUFDbkI7Ozs7R0FJRixHQUNFc0QsWUFBYUMsR0FBRyxFQUFFLEVBQ2hCQyxZQUFZLEVBQ1pDLGFBQWEsRUFDYkMsY0FBYyxFQUNkQyxhQUFhLEVBQ2JDLGNBQWMsRUFDZEMsY0FBYyxFQUNkQyxXQUFXLEVBQ1hDLFdBQVcsRUFDWEMsU0FBUyxFQUNUQyxnQkFBZ0IsRUFDaEJDLG1CQUFtQixFQUNuQkMsbUJBQW1CLEVBQ25CQyx5QkFBeUIsRUFDekJDLFVBQVUsRUFDVkMsVUFBVSxFQUNWQyxHQUFHLEVBQ0hDLG1CQUFtQixFQUNuQkMsaUJBQWlCLEVBQ2pCQyxlQUFlLEVBQ2ZDLE9BQU8sRUFDUEMsb0JBQW9CLEVBQ3BCQyxZQUFZLEVBQ1pDLGVBQWUsRUFDZkMsZ0JBQWdCLEVBQ2hCQyw4QkFBOEIsRUFDOUI7SUFDQUMsb0JBQW9CLEVBQ3BCQyxPQUFBQSxFQUNELEdBQUcsQ0FBQyxDQUFDLENBQUU7UUFDTixLQUFLO1FBRUwsSUFBSWxCLGNBQWNtQixXQUFXO1lBQzNCLE1BQU0sSUFBSWxGLHFCQUFxQjtRQUNqQztRQUVBLElBQUkwRCxrQkFBa0J3QixXQUFXO1lBQy9CLE1BQU0sSUFBSWxGLHFCQUFxQjtRQUNqQztRQUVBLElBQUkyRCxtQkFBbUJ1QixXQUFXO1lBQ2hDLE1BQU0sSUFBSWxGLHFCQUFxQjtRQUNqQztRQUVBLElBQUk4RCxnQkFBZ0JvQixXQUFXO1lBQzdCLE1BQU0sSUFBSWxGLHFCQUFxQjtRQUNqQztRQUVBLElBQUlpRSx3QkFBd0JpQixXQUFXO1lBQ3JDLE1BQU0sSUFBSWxGLHFCQUFxQjtRQUNqQztRQUVBLElBQUl3RCxpQkFBaUIsUUFBUSxDQUFDMkIsT0FBT0MsUUFBUSxDQUFDNUIsZ0JBQWdCO1lBQzVELE1BQU0sSUFBSXhELHFCQUFxQjtRQUNqQztRQUVBLElBQUlvRSxjQUFjLFFBQVEsT0FBT0EsZUFBZSxVQUFVO1lBQ3hELE1BQU0sSUFBSXBFLHFCQUFxQjtRQUNqQztRQUVBLElBQUk0RCxrQkFBa0IsUUFBUyxFQUFDdUIsT0FBT0MsUUFBUSxDQUFDeEIsbUJBQW1CQSxpQkFBaUIsSUFBSTtZQUN0RixNQUFNLElBQUk1RCxxQkFBcUI7UUFDakM7UUFFQSxJQUFJZ0Usb0JBQW9CLFFBQVMsRUFBQ21CLE9BQU9DLFFBQVEsQ0FBQ3BCLHFCQUFxQkEsb0JBQW9CLElBQUk7WUFDN0YsTUFBTSxJQUFJaEUscUJBQXFCO1FBQ2pDO1FBRUEsSUFBSWtFLHVCQUF1QixRQUFTLEVBQUNpQixPQUFPQyxRQUFRLENBQUNsQix3QkFBd0JBLHVCQUF1QixJQUFJO1lBQ3RHLE1BQU0sSUFBSWxFLHFCQUFxQjtRQUNqQztRQUVBLElBQUltRSw2QkFBNkIsUUFBUSxDQUFDZ0IsT0FBT0MsUUFBUSxDQUFDakIsNEJBQTRCO1lBQ3BGLE1BQU0sSUFBSW5FLHFCQUFxQjtRQUNqQztRQUVBLElBQUl5RCxrQkFBa0IsUUFBUyxFQUFDMEIsT0FBT0UsU0FBUyxDQUFDNUIsbUJBQW1CQSxpQkFBaUIsSUFBSTtZQUN2RixNQUFNLElBQUl6RCxxQkFBcUI7UUFDakM7UUFFQSxJQUFJNkQsZUFBZSxRQUFTLEVBQUNzQixPQUFPRSxTQUFTLENBQUN4QixnQkFBZ0JBLGNBQWMsSUFBSTtZQUM5RSxNQUFNLElBQUk3RCxxQkFBcUI7UUFDakM7UUFFQSxJQUFJMEUsV0FBVyxRQUFRLE9BQU9BLFlBQVksY0FBYyxPQUFPQSxZQUFZLFVBQVU7WUFDbkYsTUFBTSxJQUFJMUUscUJBQXFCO1FBQ2pDO1FBRUEsSUFBSXlFLG1CQUFtQixRQUFTLEVBQUNVLE9BQU9FLFNBQVMsQ0FBQ1osb0JBQW9CQSxrQkFBa0IsSUFBSTtZQUMxRixNQUFNLElBQUl6RSxxQkFBcUI7UUFDakM7UUFFQSxJQUFJMkUsd0JBQXdCLFFBQVMsRUFBQ1EsT0FBT0UsU0FBUyxDQUFDVix5QkFBeUJBLHVCQUF1QixJQUFJO1lBQ3pHLE1BQU0sSUFBSTNFLHFCQUFxQjtRQUNqQztRQUVBLElBQUk0RSxnQkFBZ0IsUUFBUyxRQUFPQSxpQkFBaUIsWUFBWWxGLElBQUk0RixJQUFJLENBQUNWLGtCQUFrQixJQUFJO1lBQzlGLE1BQU0sSUFBSTVFLHFCQUFxQjtRQUNqQztRQUVBLElBQUk2RSxtQkFBbUIsUUFBUyxFQUFDTSxPQUFPRSxTQUFTLENBQUNSLG9CQUFvQkEsa0JBQWtCLENBQUMsSUFBSTtZQUMzRixNQUFNLElBQUk3RSxxQkFBcUI7UUFDakM7UUFFQSxJQUNFK0Usa0NBQWtDLFFBQ2pDLEVBQUNJLE9BQU9FLFNBQVMsQ0FBQ04sbUNBQW1DQSxpQ0FBaUMsQ0FBQyxJQUN4RjtZQUNBLE1BQU0sSUFBSS9FLHFCQUFxQjtRQUNqQztRQUVBO1FBQ0EsSUFBSWlGLFdBQVcsUUFBUSxPQUFPQSxZQUFZLFdBQVc7WUFDbkQsTUFBTSxJQUFJakYscUJBQXFCO1FBQ2pDO1FBRUEsSUFBSWdGLHdCQUF3QixRQUFTLFFBQU9BLHlCQUF5QixZQUFZQSx1QkFBdUIsSUFBSTtZQUMxRyxNQUFNLElBQUloRixxQkFBcUI7UUFDakM7UUFFQSxJQUFJLE9BQU8wRSxZQUFZLFlBQVk7WUFDakNBLFVBQVV2RSxlQUFlO2dCQUN2QixHQUFHbUUsR0FBRztnQkFDTkU7Z0JBQ0FTO2dCQUNBYjtnQkFDQW1CLFNBQVMzQjtnQkFDVCxHQUFJa0IsbUJBQW1CO29CQUFFQTtvQkFBa0JDO2dCQUErQixJQUFJRyxTQUFTO2dCQUN2RixHQUFHUixPQUFBQTtZQUNMO1FBQ0Y7UUFFQSxJQUFJbkIsY0FBY0gsVUFBVW9DLE1BQU1DLE9BQU8sQ0FBQ2xDLGFBQWFILE1BQU0sR0FBRztZQUM5RCxJQUFJLENBQUNmLGNBQWMsR0FBR2tCLGFBQWFILE1BQU07WUFDekMsSUFBSSxDQUFDTiw2QkFBNkI7Z0JBQ2hDQSw4QkFBOEI7Z0JBQzlCNEMsUUFBUUMsV0FBVyxDQUFDLDZFQUE2RTtvQkFDL0ZDLE1BQU07Z0JBQ1I7WUFDRjtRQUNGLE9BQU87WUFDTCxJQUFJLENBQUN2RCxjQUFjLEdBQUc7Z0JBQUN3RCwwQkFBMEI7b0JBQUVwQjtnQkFBZ0I7YUFBRztRQUN4RTtRQUVBLElBQUksQ0FBQ3JFLEtBQUssR0FBR1IsS0FBS2tHLFdBQVcsQ0FBQ3hDO1FBQzlCLElBQUksQ0FBQ3hCLFdBQVcsR0FBRzRDO1FBQ25CLElBQUksQ0FBQ3BELFlBQVksR0FBRytDLGNBQWMsT0FBT0EsYUFBYTtRQUN0RCxJQUFJLENBQUM3QyxnQkFBZ0IsR0FBR2dDLGlCQUFpQjdELEtBQUs2RCxhQUFhO1FBQzNELElBQUksQ0FBQ3ZDLHlCQUF5QixHQUFHK0Msb0JBQW9CLE9BQU8sTUFBTUE7UUFDbEUsSUFBSSxDQUFDdkMscUJBQXFCLEdBQUd5Qyx1QkFBdUIsT0FBTyxRQUFRQTtRQUNuRSxJQUFJLENBQUN4QywyQkFBMkIsR0FBR3lDLDZCQUE2QixPQUFPLE1BQU1BO1FBQzdFLElBQUksQ0FBQzVDLHVCQUF1QixHQUFHLElBQUksQ0FBQ04seUJBQXlCO1FBQzdELElBQUksQ0FBQ1osWUFBWSxHQUFHO1FBQ3BCLElBQUksQ0FBQ2lDLGNBQWMsR0FBR3NDLGdCQUFnQixPQUFPQSxlQUFlO1FBQzVELElBQUksQ0FBQ25FLFVBQVUsR0FBRyxHQUFFO1FBQ3BCLElBQUksQ0FBQ08sV0FBVyxHQUFHLEdBQUU7UUFDckIsSUFBSSxDQUFDRSxZQUFZLEdBQUcsU0FBUyxJQUFJLENBQUNkLEtBQUssQ0FBQzJGLFFBQVEsR0FBRyxJQUFJLENBQUMzRixLQUFLLENBQUM0RixJQUFJLEdBQUcsSUFBSSxJQUFJLENBQUM1RixLQUFLLENBQUM0RixJQUFJLEVBQUUsR0FBRyxHQUFFLEtBQU07UUFDckcsSUFBSSxDQUFDcEUsYUFBYSxHQUFHaUMsZUFBZSxPQUFPQSxjQUFjO1FBQ3pELElBQUksQ0FBQ2xDLGdCQUFnQixHQUFHOEIsa0JBQWtCLE9BQU9BLGlCQUFpQjtRQUNsRSxJQUFJLENBQUM1QixxQkFBcUIsR0FBRzBDLHVCQUF1QixPQUFPLE9BQU9BO1FBQ2xFLElBQUksQ0FBQ3hDLGlCQUFpQixHQUFHMEM7UUFDekIsSUFBSSxDQUFDekMsYUFBYSxHQUFHMkM7UUFDckIsSUFBSSxDQUFDNUIsZUFBZSxHQUFHO1FBQ3ZCLElBQUksQ0FBQ1IsaUJBQWlCLEdBQUdzQyxrQkFBa0IsQ0FBQyxJQUFJQSxrQkFBa0IsQ0FBQztRQUNuRSxJQUFJLENBQUNuQyxzQkFBc0IsR0FBR3NDLHdCQUF3QixPQUFPQSx1QkFBdUIsS0FBSTtRQUN4RixJQUFJLENBQUN2QyxhQUFhLEdBQUc7UUFFckI7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUVBLElBQUksQ0FBQzVCLE9BQU8sR0FBRyxFQUFFO1FBQ2pCLElBQUksQ0FBQ08sWUFBWSxHQUFHO1FBQ3BCLElBQUksQ0FBQ0QsWUFBWSxHQUFHO1FBRXBCLElBQUksQ0FBQ3dCLFFBQVEsR0FBSXNELENBQUFBLE9BQVNDLE9BQU8sSUFBSSxFQUFFRDtRQUN2QyxJQUFJLENBQUN6RCxTQUFTLEdBQUkyRCxDQUFBQSxNQUFRQyxRQUFRLElBQUksRUFBRUQ7SUFDMUM7SUFFQSxJQUFJOUIsYUFBYztRQUNoQixPQUFPLElBQUksQ0FBQy9DLFlBQVk7SUFDMUI7SUFFQSxJQUFJK0MsV0FBWWdDLEtBQUssRUFBRTtRQUNyQixJQUFJLENBQUMvRSxZQUFZLEdBQUcrRTtRQUNwQixJQUFJLENBQUMxRCxRQUFRLENBQUM7SUFDaEI7SUFFQSxLQUFLaEMsU0FBUSxHQUFLO1FBQ2hCLE9BQU8sSUFBSSxDQUFDRSxPQUFPLENBQUN5RixNQUFNLEdBQUcsSUFBSSxDQUFDbkYsWUFBWTtJQUNoRDtJQUVBLEtBQUtULFNBQVEsR0FBSztRQUNoQixPQUFPLElBQUksQ0FBQ1MsWUFBWSxHQUFHLElBQUksQ0FBQ0MsWUFBWTtJQUM5QztJQUVBLEtBQUtSLE1BQUssR0FBSztRQUNiLE9BQU8sSUFBSSxDQUFDQyxPQUFPLENBQUN5RixNQUFNLEdBQUcsSUFBSSxDQUFDbEYsWUFBWTtJQUNoRDtJQUVBLEtBQUtOLFdBQVUsR0FBSztRQUNsQixPQUFPLENBQUMsQ0FBQyxJQUFJLENBQUMyQixhQUFhLElBQUksQ0FBQyxJQUFJLENBQUMxQixZQUFZLElBQUksQ0FBQyxJQUFJLENBQUMwQixhQUFhLENBQUM4RCxTQUFTO0lBQ3BGO0lBRUEsS0FBS2hHLE1BQUssR0FBSztRQUNiLE9BQU9pRyxRQUNMLElBQUksQ0FBQy9ELGFBQWEsRUFBRWdFLEtBQUssU0FDeEIsSUFBSSxDQUFDN0YsTUFBTSxJQUFLcUMsQ0FBQUEsY0FBYyxJQUFJLEtBQUssTUFDeEMsSUFBSSxDQUFDdEMsU0FBUyxHQUFHO0lBRXJCO0lBRUEsMENBQ0EsQ0FBQ0gsU0FBUSxDQUFHa0csRUFBRSxFQUFFO1FBQ2RoQyxRQUFRLElBQUk7UUFDWixJQUFJLENBQUNpQyxJQUFJLENBQUMsV0FBV0Q7SUFDdkI7SUFFQSxDQUFDdEUsVUFBUyxDQUFHd0UsSUFBSSxFQUFFQyxPQUFPLEVBQUU7UUFDMUIsTUFBTUMsU0FBU0YsS0FBS0UsTUFBTSxJQUFJLElBQUksQ0FBQzFHLEtBQUssQ0FBQzBHLE1BQU07UUFDL0MsTUFBTUMsVUFBVSxJQUFJakgsUUFBUWdILFFBQVFGLE1BQU1DO1FBRTFDLElBQUksQ0FBQ2hHLE9BQU8sQ0FBQ21HLElBQUksQ0FBQ0Q7UUFDbEIsSUFBSSxJQUFJLENBQUN0RyxVQUFVLEVBQUU7UUFDbkI7UUFBQSxPQUNLLElBQUliLEtBQUtxSCxVQUFVLENBQUNGLFFBQVFHLElBQUksS0FBSyxRQUFRdEgsS0FBS3VILFVBQVUsQ0FBQ0osUUFBUUcsSUFBSSxHQUFHO1lBQ2pGO1lBQ0EsSUFBSSxDQUFDekcsVUFBVSxHQUFHO1lBQ2xCMkcsZUFBZSxJQUFNbEIsT0FBTyxJQUFJO1FBQ2xDLE9BQU87WUFDTCxJQUFJLENBQUN2RCxRQUFRLENBQUM7UUFDaEI7UUFFQSxJQUFJLElBQUksQ0FBQ2xDLFVBQVUsSUFBSSxJQUFJLENBQUNPLFdBQVcsS0FBSyxLQUFLLElBQUksQ0FBQ1QsTUFBTSxFQUFFO1lBQzVELElBQUksQ0FBQ1MsV0FBVyxHQUFHO1FBQ3JCO1FBRUEsT0FBTyxJQUFJLENBQUNBLFdBQVcsR0FBRztJQUM1QjtJQUVBLE9BQU9rQixPQUFNLEdBQUs7UUFDaEI7UUFDQTtRQUNBLE9BQU8sSUFBSW1GLFFBQVNDLENBQUFBO1lBQ2xCLElBQUksSUFBSSxDQUFDMUcsTUFBTSxFQUFFO2dCQUNmLElBQUksQ0FBQ21DLGVBQWUsR0FBR3VFO1lBQ3pCLE9BQU87Z0JBQ0xBLFFBQVE7WUFDVjtRQUNGO0lBQ0Y7SUFFQSxPQUFPbkYsU0FBUSxDQUFHZ0UsR0FBRyxFQUFFO1FBQ3JCLE9BQU8sSUFBSWtCLFFBQVNDLENBQUFBO1lBQ2xCLE1BQU1DLFdBQVcsSUFBSSxDQUFDMUcsT0FBTyxDQUFDMkcsTUFBTSxDQUFDLElBQUksQ0FBQ3JHLFlBQVk7WUFDdEQsSUFBSyxJQUFJc0csSUFBSSxHQUFHQSxJQUFJRixTQUFTakIsTUFBTSxFQUFFbUIsSUFBSztnQkFDeEMsTUFBTVYsVUFBVVEsUUFBUSxDQUFDRSxFQUFFO2dCQUMzQjdILEtBQUs4SCxZQUFZLENBQUMsSUFBSSxFQUFFWCxTQUFTWjtZQUNuQztZQUVBLE1BQU13QixXQUFXQTtnQkFDZixJQUFJLElBQUksQ0FBQzVFLGVBQWUsRUFBRTtvQkFDeEI7b0JBQ0EsSUFBSSxDQUFDQSxlQUFlO29CQUNwQixJQUFJLENBQUNBLGVBQWUsR0FBRztnQkFDekI7Z0JBQ0F1RSxRQUFRO1lBQ1Y7WUFFQSxJQUFJLElBQUksQ0FBQzdFLGFBQWEsRUFBRTtnQkFDdEIsSUFBSSxDQUFDQSxhQUFhLENBQUNtRixPQUFPLENBQUN6QixLQUFLd0I7Z0JBQ2hDLElBQUksQ0FBQ2xGLGFBQWEsR0FBRztZQUN2QixPQUFPO2dCQUNMMkUsZUFBZU87WUFDakI7WUFFQSxJQUFJLENBQUNoRixRQUFRO1FBQ2Y7SUFDRjtBQUNGO0FBRUEsTUFBTWtELDRCQUE0QnBHLG1CQUFPQSxDQUFDO0FBRTFDLFNBQVMyRyxRQUFTbEQsTUFBTSxFQUFFaUQsR0FBRztJQUMzQixJQUNFakQsTUFBTSxDQUFDeEMsU0FBUyxLQUFLLEtBQ3JCeUYsSUFBSVAsSUFBSSxLQUFLLGtCQUNiTyxJQUFJUCxJQUFJLEtBQUssa0JBQ2I7UUFDQTtRQUNBO1FBRUFwRyxPQUFPMEQsTUFBTSxDQUFDL0IsWUFBWSxLQUFLK0IsTUFBTSxDQUFDOUIsWUFBWTtRQUVsRCxNQUFNbUcsV0FBV3JFLE1BQU0sQ0FBQ3JDLE9BQU8sQ0FBQzJHLE1BQU0sQ0FBQ3RFLE1BQU0sQ0FBQzlCLFlBQVk7UUFFMUQsSUFBSyxJQUFJcUcsSUFBSSxHQUFHQSxJQUFJRixTQUFTakIsTUFBTSxFQUFFbUIsSUFBSztZQUN4QyxNQUFNVixVQUFVUSxRQUFRLENBQUNFLEVBQUU7WUFDM0I3SCxLQUFLOEgsWUFBWSxDQUFDeEUsUUFBUTZELFNBQVNaO1FBQ3JDO1FBQ0EzRyxPQUFPMEQsTUFBTSxDQUFDdEMsTUFBTSxLQUFLO0lBQzNCO0FBQ0Y7QUFFQSxlQUFlOEQsUUFBU3hCLE1BQU07SUFDNUIxRCxPQUFPLENBQUMwRCxNQUFNLENBQUNuQyxZQUFZO0lBQzNCdkIsT0FBTyxDQUFDMEQsTUFBTSxDQUFDVCxhQUFhO0lBRTVCLElBQUksRUFBRW9GLElBQUksRUFBRTlCLFFBQVEsRUFBRStCLFFBQVEsRUFBRTlCLElBQUFBLEVBQU0sR0FBRzlDLE1BQU0sQ0FBQzlDLEtBQUs7SUFFckQ7SUFDQSxJQUFJMkYsUUFBUSxDQUFDLEVBQUUsS0FBSyxLQUFLO1FBQ3ZCLE1BQU1nQyxNQUFNaEMsU0FBU2lDLE9BQU8sQ0FBQztRQUU3QnhJLE9BQU91SSxRQUFRLENBQUM7UUFDaEIsTUFBTUUsS0FBS2xDLFNBQVNtQyxTQUFTLENBQUMsR0FBR0g7UUFFakN2SSxPQUFPRSxJQUFJNEYsSUFBSSxDQUFDMkM7UUFDaEJsQyxXQUFXa0M7SUFDYjtJQUVBL0UsTUFBTSxDQUFDbkMsWUFBWSxHQUFHO0lBRXRCLElBQUlsQixTQUFTc0ksYUFBYSxDQUFDQyxjQUFjLEVBQUU7UUFDekN2SSxTQUFTc0ksYUFBYSxDQUFDRSxPQUFPLENBQUM7WUFDN0JDLGVBQWU7Z0JBQ2JUO2dCQUNBOUI7Z0JBQ0ErQjtnQkFDQTlCO2dCQUNBdUMsU0FBU3JGLE1BQU0sQ0FBQ1QsYUFBYSxFQUFFOEY7Z0JBQy9CQyxZQUFZdEYsTUFBTSxDQUFDN0MsWUFBWTtnQkFDL0J1RSxjQUFjMUIsTUFBTSxDQUFDWixjQUFhO1lBQ3BDO1lBQ0FtRyxXQUFXdkYsTUFBTSxDQUFDcEIsV0FBVTtRQUM5QjtJQUNGO0lBRUEsSUFBSTtRQUNGLE1BQU00RyxTQUFTLE1BQU0sSUFBSXJCLFFBQVEsQ0FBQ0MsU0FBU3FCO1lBQ3pDekYsTUFBTSxDQUFDcEIsV0FBVyxDQUFDO2dCQUNqQitGO2dCQUNBOUI7Z0JBQ0ErQjtnQkFDQTlCO2dCQUNBd0MsWUFBWXRGLE1BQU0sQ0FBQzdDLFlBQVk7Z0JBQy9CdUUsY0FBYzFCLE1BQU0sQ0FBQ1osY0FBYTtZQUNwQyxHQUFHLENBQUM2RCxLQUFLdUM7Z0JBQ1AsSUFBSXZDLEtBQUs7b0JBQ1B3QyxPQUFPeEM7Z0JBQ1QsT0FBTztvQkFDTG1CLFFBQVFvQjtnQkFDVjtZQUNGO1FBQ0Y7UUFFQSxJQUFJeEYsT0FBT3FELFNBQVMsRUFBRTtZQUNwQjNHLEtBQUtnSSxPQUFPLENBQUNjLE9BQU9FLEVBQUUsQ0FBQyxTQUFTLEtBQU8sSUFBSSxJQUFJMUk7WUFDL0M7UUFDRjtRQUVBVixPQUFPa0o7UUFFUCxJQUFJO1lBQ0Z4RixNQUFNLENBQUNULGFBQWEsR0FBR2lHLE9BQU9HLFlBQVksS0FBSyxPQUMzQyxNQUFNaEcsVUFBVUssUUFBUXdGLFVBQ3hCLE1BQU05RixVQUFVTSxRQUFRd0Y7UUFDOUIsRUFBRSxPQUFPdkMsS0FBSztZQUNadUMsT0FBT2QsT0FBTyxHQUFHZ0IsRUFBRSxDQUFDLFNBQVMsS0FBTztZQUNwQyxNQUFNekM7UUFDUjtRQUVBakQsTUFBTSxDQUFDbkMsWUFBWSxHQUFHO1FBRXRCMkgsTUFBTSxDQUFDekcsU0FBUyxHQUFHO1FBQ25CeUcsTUFBTSxDQUFDMUcsYUFBYSxHQUFHa0IsTUFBTSxDQUFDbEIsYUFBYTtRQUMzQzBHLE1BQU0sQ0FBQ3BJLFFBQVEsR0FBRzRDO1FBQ2xCd0YsTUFBTSxDQUFDckgsT0FBTyxHQUFHO1FBRWpCLElBQUl4QixTQUFTaUosU0FBUyxDQUFDVixjQUFjLEVBQUU7WUFDckN2SSxTQUFTaUosU0FBUyxDQUFDVCxPQUFPLENBQUM7Z0JBQ3pCQyxlQUFlO29CQUNiVDtvQkFDQTlCO29CQUNBK0I7b0JBQ0E5QjtvQkFDQXVDLFNBQVNyRixNQUFNLENBQUNULGFBQWEsRUFBRThGO29CQUMvQkMsWUFBWXRGLE1BQU0sQ0FBQzdDLFlBQVk7b0JBQy9CdUUsY0FBYzFCLE1BQU0sQ0FBQ1osY0FBYTtnQkFDcEM7Z0JBQ0FtRyxXQUFXdkYsTUFBTSxDQUFDcEIsV0FBVztnQkFDN0I0RztZQUNGO1FBQ0Y7UUFDQXhGLE9BQU82RixJQUFJLENBQUMsV0FBVzdGLE1BQU0sQ0FBQzlDLEtBQUssRUFBRTtZQUFDOEM7U0FBTztJQUMvQyxFQUFFLE9BQU9pRCxLQUFLO1FBQ1osSUFBSWpELE9BQU9xRCxTQUFTLEVBQUU7WUFDcEI7UUFDRjtRQUVBckQsTUFBTSxDQUFDbkMsWUFBWSxHQUFHO1FBRXRCLElBQUlsQixTQUFTbUosWUFBWSxDQUFDWixjQUFjLEVBQUU7WUFDeEN2SSxTQUFTbUosWUFBWSxDQUFDWCxPQUFPLENBQUM7Z0JBQzVCQyxlQUFlO29CQUNiVDtvQkFDQTlCO29CQUNBK0I7b0JBQ0E5QjtvQkFDQXVDLFNBQVNyRixNQUFNLENBQUNULGFBQWEsRUFBRThGO29CQUMvQkMsWUFBWXRGLE1BQU0sQ0FBQzdDLFlBQVk7b0JBQy9CdUUsY0FBYzFCLE1BQU0sQ0FBQ1osY0FBYTtnQkFDcEM7Z0JBQ0FtRyxXQUFXdkYsTUFBTSxDQUFDcEIsV0FBVztnQkFDN0JtSCxPQUFPOUM7WUFDVDtRQUNGO1FBRUEsSUFBSUEsSUFBSVAsSUFBSSxLQUFLLGdDQUFnQztZQUMvQ3BHLE9BQU8wRCxNQUFNLENBQUN4QyxTQUFTLEtBQUs7WUFDNUIsTUFBT3dDLE1BQU0sQ0FBQ3ZDLFNBQVMsR0FBRyxLQUFLdUMsTUFBTSxDQUFDckMsT0FBTyxDQUFDcUMsTUFBTSxDQUFDL0IsWUFBWSxDQUFDLENBQUNxSCxVQUFVLEtBQUt0RixNQUFNLENBQUM3QyxZQUFZLENBQUU7Z0JBQ3JHLE1BQU0wRyxVQUFVN0QsTUFBTSxDQUFDckMsT0FBTyxDQUFDcUMsTUFBTSxDQUFDL0IsWUFBWSxHQUFHO2dCQUNyRHZCLEtBQUs4SCxZQUFZLENBQUN4RSxRQUFRNkQsU0FBU1o7WUFDckM7UUFDRixPQUFPO1lBQ0xDLFFBQVFsRCxRQUFRaUQ7UUFDbEI7UUFFQWpELE9BQU82RixJQUFJLENBQUMsbUJBQW1CN0YsTUFBTSxDQUFDOUMsS0FBSyxFQUFFO1lBQUM4QztTQUFPLEVBQUVpRDtJQUN6RDtJQUVBakQsTUFBTSxDQUFDUCxRQUFRO0FBQ2pCO0FBRUEsU0FBU3VHLFVBQVdoRyxNQUFNO0lBQ3hCQSxNQUFNLENBQUNsQyxXQUFXLEdBQUc7SUFDckJrQyxPQUFPNkYsSUFBSSxDQUFDLFNBQVM3RixNQUFNLENBQUM5QyxLQUFLLEVBQUU7UUFBQzhDO0tBQU87QUFDN0M7QUFFQSxTQUFTZ0QsT0FBUWhELE1BQU0sRUFBRStDLElBQUk7SUFDM0IsSUFBSS9DLE1BQU0sQ0FBQ3pDLFVBQVUsS0FBSyxHQUFHO1FBQzNCO0lBQ0Y7SUFFQXlDLE1BQU0sQ0FBQ3pDLFVBQVUsR0FBRztJQUVwQjBJLFFBQVFqRyxRQUFRK0M7SUFDaEIvQyxNQUFNLENBQUN6QyxVQUFVLEdBQUc7SUFFcEIsSUFBSXlDLE1BQU0sQ0FBQzlCLFlBQVksR0FBRyxLQUFLO1FBQzdCOEIsTUFBTSxDQUFDckMsT0FBTyxDQUFDMkcsTUFBTSxDQUFDLEdBQUd0RSxNQUFNLENBQUM5QixZQUFZO1FBQzVDOEIsTUFBTSxDQUFDL0IsWUFBWSxJQUFJK0IsTUFBTSxDQUFDOUIsWUFBWTtRQUMxQzhCLE1BQU0sQ0FBQzlCLFlBQVksR0FBRztJQUN4QjtBQUNGO0FBRUEsU0FBUytILFFBQVNqRyxNQUFNLEVBQUUrQyxJQUFJO0lBQzVCLE1BQU8sS0FBTTtRQUNYLElBQUkvQyxPQUFPcUQsU0FBUyxFQUFFO1lBQ3BCL0csT0FBTzBELE1BQU0sQ0FBQ3ZDLFNBQVMsS0FBSztZQUM1QjtRQUNGO1FBRUEsSUFBSXVDLE1BQU0sQ0FBQ0gsZUFBZSxJQUFJLENBQUNHLE1BQU0sQ0FBQ3RDLE1BQU0sRUFBRTtZQUM1Q3NDLE1BQU0sQ0FBQ0gsZUFBZTtZQUN0QkcsTUFBTSxDQUFDSCxlQUFlLEdBQUc7WUFDekI7UUFDRjtRQUVBLElBQUlHLE1BQU0sQ0FBQ1QsYUFBYSxFQUFFO1lBQ3hCUyxNQUFNLENBQUNULGFBQWEsQ0FBQ3lELE1BQU07UUFDN0I7UUFFQSxJQUFJaEQsTUFBTSxDQUFDM0MsTUFBTSxFQUFFO1lBQ2pCMkMsTUFBTSxDQUFDbEMsV0FBVyxHQUFHO1FBQ3ZCLE9BQU8sSUFBSWtDLE1BQU0sQ0FBQ2xDLFdBQVcsS0FBSyxHQUFHO1lBQ25DLElBQUlpRixNQUFNO2dCQUNSL0MsTUFBTSxDQUFDbEMsV0FBVyxHQUFHO2dCQUNyQm9HLGVBQWUsSUFBTThCLFVBQVVoRztZQUNqQyxPQUFPO2dCQUNMZ0csVUFBVWhHO1lBQ1o7WUFDQTtRQUNGO1FBRUEsSUFBSUEsTUFBTSxDQUFDdkMsU0FBUyxLQUFLLEdBQUc7WUFDMUI7UUFDRjtRQUVBLElBQUl1QyxNQUFNLENBQUN4QyxTQUFTLElBQUt1QyxDQUFBQSxjQUFjQyxXQUFXLElBQUk7WUFDcEQ7UUFDRjtRQUVBLE1BQU02RCxVQUFVN0QsTUFBTSxDQUFDckMsT0FBTyxDQUFDcUMsTUFBTSxDQUFDL0IsWUFBWSxDQUFDO1FBRW5ELElBQUkrQixNQUFNLENBQUM5QyxLQUFLLENBQUMwSCxRQUFRLEtBQUssWUFBWTVFLE1BQU0sQ0FBQzdDLFlBQVksS0FBSzBHLFFBQVF5QixVQUFVLEVBQUU7WUFDcEYsSUFBSXRGLE1BQU0sQ0FBQ3hDLFNBQVMsR0FBRyxHQUFHO2dCQUN4QjtZQUNGO1lBRUF3QyxNQUFNLENBQUM3QyxZQUFZLEdBQUcwRyxRQUFReUIsVUFBVTtZQUN4Q3RGLE1BQU0sQ0FBQ1QsYUFBYSxFQUFFbUYsUUFBUSxJQUFJM0gsbUJBQW1CLHVCQUF1QjtnQkFDMUVpRCxNQUFNLENBQUNULGFBQWEsR0FBRztnQkFDdkJ5RCxPQUFPaEQ7WUFDVDtRQUNGO1FBRUEsSUFBSUEsTUFBTSxDQUFDbkMsWUFBWSxFQUFFO1lBQ3ZCO1FBQ0Y7UUFFQSxJQUFJLENBQUNtQyxNQUFNLENBQUNULGFBQWEsRUFBRTtZQUN6QmlDLFFBQVF4QjtZQUNSO1FBQ0Y7UUFFQSxJQUFJQSxNQUFNLENBQUNULGFBQWEsQ0FBQzhELFNBQVMsRUFBRTtZQUNsQztRQUNGO1FBRUEsSUFBSXJELE1BQU0sQ0FBQ1QsYUFBYSxDQUFDZ0UsSUFBSSxDQUFDTSxVQUFVO1lBQ3RDO1FBQ0Y7UUFFQSxJQUFJLENBQUNBLFFBQVFxQyxPQUFPLElBQUlsRyxNQUFNLENBQUNULGFBQWEsQ0FBQzRHLEtBQUssQ0FBQ3RDLFVBQVU7WUFDM0Q3RCxNQUFNLENBQUMvQixZQUFZO1FBQ3JCLE9BQU87WUFDTCtCLE1BQU0sQ0FBQ3JDLE9BQU8sQ0FBQzJHLE1BQU0sQ0FBQ3RFLE1BQU0sQ0FBQy9CLFlBQVksRUFBRTtRQUM3QztJQUNGO0FBQ0Y7QUFFQW1JLE9BQU9DLE9BQU8sR0FBR25HIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbW9ja3VwZmxvdy8uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2Rpc3BhdGNoZXIvY2xpZW50LmpzPzU0YzciLCJ3ZWJwYWNrOi8vbW9ja3VwZmxvdy8uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2Rpc3BhdGNoZXIvY2xpZW50LmpzPzU0YzcqIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEB0cy1jaGVja1xuXG4ndXNlIHN0cmljdCdcblxuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZSgnbm9kZTphc3NlcnQnKVxuY29uc3QgbmV0ID0gcmVxdWlyZSgnbm9kZTpuZXQnKVxuY29uc3QgaHR0cCA9IHJlcXVpcmUoJ25vZGU6aHR0cCcpXG5jb25zdCB1dGlsID0gcmVxdWlyZSgnLi4vY29yZS91dGlsLmpzJylcbmNvbnN0IHsgY2hhbm5lbHMgfSA9IHJlcXVpcmUoJy4uL2NvcmUvZGlhZ25vc3RpY3MuanMnKVxuY29uc3QgUmVxdWVzdCA9IHJlcXVpcmUoJy4uL2NvcmUvcmVxdWVzdC5qcycpXG5jb25zdCBEaXNwYXRjaGVyQmFzZSA9IHJlcXVpcmUoJy4vZGlzcGF0Y2hlci1iYXNlJylcbmNvbnN0IHtcbiAgSW52YWxpZEFyZ3VtZW50RXJyb3IsXG4gIEluZm9ybWF0aW9uYWxFcnJvcixcbiAgQ2xpZW50RGVzdHJveWVkRXJyb3Jcbn0gPSByZXF1aXJlKCcuLi9jb3JlL2Vycm9ycy5qcycpXG5jb25zdCBidWlsZENvbm5lY3RvciA9IHJlcXVpcmUoJy4uL2NvcmUvY29ubmVjdC5qcycpXG5jb25zdCB7XG4gIGtVcmwsXG4gIGtTZXJ2ZXJOYW1lLFxuICBrQ2xpZW50LFxuICBrQnVzeSxcbiAga0Nvbm5lY3QsXG4gIGtSZXN1bWluZyxcbiAga1J1bm5pbmcsXG4gIGtQZW5kaW5nLFxuICBrU2l6ZSxcbiAga1F1ZXVlLFxuICBrQ29ubmVjdGVkLFxuICBrQ29ubmVjdGluZyxcbiAga05lZWREcmFpbixcbiAga0tlZXBBbGl2ZURlZmF1bHRUaW1lb3V0LFxuICBrSG9zdEhlYWRlcixcbiAga1BlbmRpbmdJZHgsXG4gIGtSdW5uaW5nSWR4LFxuICBrRXJyb3IsXG4gIGtQaXBlbGluaW5nLFxuICBrS2VlcEFsaXZlVGltZW91dFZhbHVlLFxuICBrTWF4SGVhZGVyc1NpemUsXG4gIGtLZWVwQWxpdmVNYXhUaW1lb3V0LFxuICBrS2VlcEFsaXZlVGltZW91dFRocmVzaG9sZCxcbiAga0hlYWRlcnNUaW1lb3V0LFxuICBrQm9keVRpbWVvdXQsXG4gIGtTdHJpY3RDb250ZW50TGVuZ3RoLFxuICBrQ29ubmVjdG9yLFxuICBrTWF4UmVkaXJlY3Rpb25zLFxuICBrTWF4UmVxdWVzdHMsXG4gIGtDb3VudGVyLFxuICBrQ2xvc2UsXG4gIGtEZXN0cm95LFxuICBrRGlzcGF0Y2gsXG4gIGtJbnRlcmNlcHRvcnMsXG4gIGtMb2NhbEFkZHJlc3MsXG4gIGtNYXhSZXNwb25zZVNpemUsXG4gIGtPbkVycm9yLFxuICBrSFRUUENvbnRleHQsXG4gIGtNYXhDb25jdXJyZW50U3RyZWFtcyxcbiAga1Jlc3VtZVxufSA9IHJlcXVpcmUoJy4uL2NvcmUvc3ltYm9scy5qcycpXG5jb25zdCBjb25uZWN0SDEgPSByZXF1aXJlKCcuL2NsaWVudC1oMS5qcycpXG5jb25zdCBjb25uZWN0SDIgPSByZXF1aXJlKCcuL2NsaWVudC1oMi5qcycpXG5sZXQgZGVwcmVjYXRlZEludGVyY2VwdG9yV2FybmVkID0gZmFsc2VcblxuY29uc3Qga0Nsb3NlZFJlc29sdmUgPSBTeW1ib2woJ2tDbG9zZWRSZXNvbHZlJylcblxuZnVuY3Rpb24gZ2V0UGlwZWxpbmluZyAoY2xpZW50KSB7XG4gIHJldHVybiBjbGllbnRba1BpcGVsaW5pbmddID8/IGNsaWVudFtrSFRUUENvbnRleHRdPy5kZWZhdWx0UGlwZWxpbmluZyA/PyAxXG59XG5cbi8qKlxuICogQHR5cGUge2ltcG9ydCgnLi4vLi4vdHlwZXMvY2xpZW50LmpzJykuZGVmYXVsdH1cbiAqL1xuY2xhc3MgQ2xpZW50IGV4dGVuZHMgRGlzcGF0Y2hlckJhc2Uge1xuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd8VVJMfSB1cmxcbiAgICogQHBhcmFtIHtpbXBvcnQoJy4uLy4uL3R5cGVzL2NsaWVudC5qcycpLkNsaWVudC5PcHRpb25zfSBvcHRpb25zXG4gICAqL1xuICBjb25zdHJ1Y3RvciAodXJsLCB7XG4gICAgaW50ZXJjZXB0b3JzLFxuICAgIG1heEhlYWRlclNpemUsXG4gICAgaGVhZGVyc1RpbWVvdXQsXG4gICAgc29ja2V0VGltZW91dCxcbiAgICByZXF1ZXN0VGltZW91dCxcbiAgICBjb25uZWN0VGltZW91dCxcbiAgICBib2R5VGltZW91dCxcbiAgICBpZGxlVGltZW91dCxcbiAgICBrZWVwQWxpdmUsXG4gICAga2VlcEFsaXZlVGltZW91dCxcbiAgICBtYXhLZWVwQWxpdmVUaW1lb3V0LFxuICAgIGtlZXBBbGl2ZU1heFRpbWVvdXQsXG4gICAga2VlcEFsaXZlVGltZW91dFRocmVzaG9sZCxcbiAgICBzb2NrZXRQYXRoLFxuICAgIHBpcGVsaW5pbmcsXG4gICAgdGxzLFxuICAgIHN0cmljdENvbnRlbnRMZW5ndGgsXG4gICAgbWF4Q2FjaGVkU2Vzc2lvbnMsXG4gICAgbWF4UmVkaXJlY3Rpb25zLFxuICAgIGNvbm5lY3QsXG4gICAgbWF4UmVxdWVzdHNQZXJDbGllbnQsXG4gICAgbG9jYWxBZGRyZXNzLFxuICAgIG1heFJlc3BvbnNlU2l6ZSxcbiAgICBhdXRvU2VsZWN0RmFtaWx5LFxuICAgIGF1dG9TZWxlY3RGYW1pbHlBdHRlbXB0VGltZW91dCxcbiAgICAvLyBoMlxuICAgIG1heENvbmN1cnJlbnRTdHJlYW1zLFxuICAgIGFsbG93SDJcbiAgfSA9IHt9KSB7XG4gICAgc3VwZXIoKVxuXG4gICAgaWYgKGtlZXBBbGl2ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ3Vuc3VwcG9ydGVkIGtlZXBBbGl2ZSwgdXNlIHBpcGVsaW5pbmc9MCBpbnN0ZWFkJylcbiAgICB9XG5cbiAgICBpZiAoc29ja2V0VGltZW91dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ3Vuc3VwcG9ydGVkIHNvY2tldFRpbWVvdXQsIHVzZSBoZWFkZXJzVGltZW91dCAmIGJvZHlUaW1lb3V0IGluc3RlYWQnKVxuICAgIH1cblxuICAgIGlmIChyZXF1ZXN0VGltZW91dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ3Vuc3VwcG9ydGVkIHJlcXVlc3RUaW1lb3V0LCB1c2UgaGVhZGVyc1RpbWVvdXQgJiBib2R5VGltZW91dCBpbnN0ZWFkJylcbiAgICB9XG5cbiAgICBpZiAoaWRsZVRpbWVvdXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCd1bnN1cHBvcnRlZCBpZGxlVGltZW91dCwgdXNlIGtlZXBBbGl2ZVRpbWVvdXQgaW5zdGVhZCcpXG4gICAgfVxuXG4gICAgaWYgKG1heEtlZXBBbGl2ZVRpbWVvdXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCd1bnN1cHBvcnRlZCBtYXhLZWVwQWxpdmVUaW1lb3V0LCB1c2Uga2VlcEFsaXZlTWF4VGltZW91dCBpbnN0ZWFkJylcbiAgICB9XG5cbiAgICBpZiAobWF4SGVhZGVyU2l6ZSAhPSBudWxsICYmICFOdW1iZXIuaXNGaW5pdGUobWF4SGVhZGVyU2l6ZSkpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBtYXhIZWFkZXJTaXplJylcbiAgICB9XG5cbiAgICBpZiAoc29ja2V0UGF0aCAhPSBudWxsICYmIHR5cGVvZiBzb2NrZXRQYXRoICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIHNvY2tldFBhdGgnKVxuICAgIH1cblxuICAgIGlmIChjb25uZWN0VGltZW91dCAhPSBudWxsICYmICghTnVtYmVyLmlzRmluaXRlKGNvbm5lY3RUaW1lb3V0KSB8fCBjb25uZWN0VGltZW91dCA8IDApKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgY29ubmVjdFRpbWVvdXQnKVxuICAgIH1cblxuICAgIGlmIChrZWVwQWxpdmVUaW1lb3V0ICE9IG51bGwgJiYgKCFOdW1iZXIuaXNGaW5pdGUoa2VlcEFsaXZlVGltZW91dCkgfHwga2VlcEFsaXZlVGltZW91dCA8PSAwKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIGtlZXBBbGl2ZVRpbWVvdXQnKVxuICAgIH1cblxuICAgIGlmIChrZWVwQWxpdmVNYXhUaW1lb3V0ICE9IG51bGwgJiYgKCFOdW1iZXIuaXNGaW5pdGUoa2VlcEFsaXZlTWF4VGltZW91dCkgfHwga2VlcEFsaXZlTWF4VGltZW91dCA8PSAwKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIGtlZXBBbGl2ZU1heFRpbWVvdXQnKVxuICAgIH1cblxuICAgIGlmIChrZWVwQWxpdmVUaW1lb3V0VGhyZXNob2xkICE9IG51bGwgJiYgIU51bWJlci5pc0Zpbml0ZShrZWVwQWxpdmVUaW1lb3V0VGhyZXNob2xkKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIGtlZXBBbGl2ZVRpbWVvdXRUaHJlc2hvbGQnKVxuICAgIH1cblxuICAgIGlmIChoZWFkZXJzVGltZW91dCAhPSBudWxsICYmICghTnVtYmVyLmlzSW50ZWdlcihoZWFkZXJzVGltZW91dCkgfHwgaGVhZGVyc1RpbWVvdXQgPCAwKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdoZWFkZXJzVGltZW91dCBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlciBvciB6ZXJvJylcbiAgICB9XG5cbiAgICBpZiAoYm9keVRpbWVvdXQgIT0gbnVsbCAmJiAoIU51bWJlci5pc0ludGVnZXIoYm9keVRpbWVvdXQpIHx8IGJvZHlUaW1lb3V0IDwgMCkpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignYm9keVRpbWVvdXQgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIgb3IgemVybycpXG4gICAgfVxuXG4gICAgaWYgKGNvbm5lY3QgIT0gbnVsbCAmJiB0eXBlb2YgY29ubmVjdCAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgY29ubmVjdCAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignY29ubmVjdCBtdXN0IGJlIGEgZnVuY3Rpb24gb3IgYW4gb2JqZWN0JylcbiAgICB9XG5cbiAgICBpZiAobWF4UmVkaXJlY3Rpb25zICE9IG51bGwgJiYgKCFOdW1iZXIuaXNJbnRlZ2VyKG1heFJlZGlyZWN0aW9ucykgfHwgbWF4UmVkaXJlY3Rpb25zIDwgMCkpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignbWF4UmVkaXJlY3Rpb25zIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInKVxuICAgIH1cblxuICAgIGlmIChtYXhSZXF1ZXN0c1BlckNsaWVudCAhPSBudWxsICYmICghTnVtYmVyLmlzSW50ZWdlcihtYXhSZXF1ZXN0c1BlckNsaWVudCkgfHwgbWF4UmVxdWVzdHNQZXJDbGllbnQgPCAwKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdtYXhSZXF1ZXN0c1BlckNsaWVudCBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJylcbiAgICB9XG5cbiAgICBpZiAobG9jYWxBZGRyZXNzICE9IG51bGwgJiYgKHR5cGVvZiBsb2NhbEFkZHJlc3MgIT09ICdzdHJpbmcnIHx8IG5ldC5pc0lQKGxvY2FsQWRkcmVzcykgPT09IDApKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2xvY2FsQWRkcmVzcyBtdXN0IGJlIHZhbGlkIHN0cmluZyBJUCBhZGRyZXNzJylcbiAgICB9XG5cbiAgICBpZiAobWF4UmVzcG9uc2VTaXplICE9IG51bGwgJiYgKCFOdW1iZXIuaXNJbnRlZ2VyKG1heFJlc3BvbnNlU2l6ZSkgfHwgbWF4UmVzcG9uc2VTaXplIDwgLTEpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ21heFJlc3BvbnNlU2l6ZSBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJylcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICBhdXRvU2VsZWN0RmFtaWx5QXR0ZW1wdFRpbWVvdXQgIT0gbnVsbCAmJlxuICAgICAgKCFOdW1iZXIuaXNJbnRlZ2VyKGF1dG9TZWxlY3RGYW1pbHlBdHRlbXB0VGltZW91dCkgfHwgYXV0b1NlbGVjdEZhbWlseUF0dGVtcHRUaW1lb3V0IDwgLTEpXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2F1dG9TZWxlY3RGYW1pbHlBdHRlbXB0VGltZW91dCBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJylcbiAgICB9XG5cbiAgICAvLyBoMlxuICAgIGlmIChhbGxvd0gyICE9IG51bGwgJiYgdHlwZW9mIGFsbG93SDIgIT09ICdib29sZWFuJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdhbGxvd0gyIG11c3QgYmUgYSB2YWxpZCBib29sZWFuIHZhbHVlJylcbiAgICB9XG5cbiAgICBpZiAobWF4Q29uY3VycmVudFN0cmVhbXMgIT0gbnVsbCAmJiAodHlwZW9mIG1heENvbmN1cnJlbnRTdHJlYW1zICE9PSAnbnVtYmVyJyB8fCBtYXhDb25jdXJyZW50U3RyZWFtcyA8IDEpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ21heENvbmN1cnJlbnRTdHJlYW1zIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyLCBncmVhdGVyIHRoYW4gMCcpXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBjb25uZWN0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb25uZWN0ID0gYnVpbGRDb25uZWN0b3Ioe1xuICAgICAgICAuLi50bHMsXG4gICAgICAgIG1heENhY2hlZFNlc3Npb25zLFxuICAgICAgICBhbGxvd0gyLFxuICAgICAgICBzb2NrZXRQYXRoLFxuICAgICAgICB0aW1lb3V0OiBjb25uZWN0VGltZW91dCxcbiAgICAgICAgLi4uKGF1dG9TZWxlY3RGYW1pbHkgPyB7IGF1dG9TZWxlY3RGYW1pbHksIGF1dG9TZWxlY3RGYW1pbHlBdHRlbXB0VGltZW91dCB9IDogdW5kZWZpbmVkKSxcbiAgICAgICAgLi4uY29ubmVjdFxuICAgICAgfSlcbiAgICB9XG5cbiAgICBpZiAoaW50ZXJjZXB0b3JzPy5DbGllbnQgJiYgQXJyYXkuaXNBcnJheShpbnRlcmNlcHRvcnMuQ2xpZW50KSkge1xuICAgICAgdGhpc1trSW50ZXJjZXB0b3JzXSA9IGludGVyY2VwdG9ycy5DbGllbnRcbiAgICAgIGlmICghZGVwcmVjYXRlZEludGVyY2VwdG9yV2FybmVkKSB7XG4gICAgICAgIGRlcHJlY2F0ZWRJbnRlcmNlcHRvcldhcm5lZCA9IHRydWVcbiAgICAgICAgcHJvY2Vzcy5lbWl0V2FybmluZygnQ2xpZW50Lk9wdGlvbnMjaW50ZXJjZXB0b3IgaXMgZGVwcmVjYXRlZC4gVXNlIERpc3BhdGNoZXIjY29tcG9zZSBpbnN0ZWFkLicsIHtcbiAgICAgICAgICBjb2RlOiAnVU5ESUNJLUNMSUVOVC1JTlRFUkNFUFRPUi1ERVBSRUNBVEVEJ1xuICAgICAgICB9KVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzW2tJbnRlcmNlcHRvcnNdID0gW2NyZWF0ZVJlZGlyZWN0SW50ZXJjZXB0b3IoeyBtYXhSZWRpcmVjdGlvbnMgfSldXG4gICAgfVxuXG4gICAgdGhpc1trVXJsXSA9IHV0aWwucGFyc2VPcmlnaW4odXJsKVxuICAgIHRoaXNba0Nvbm5lY3Rvcl0gPSBjb25uZWN0XG4gICAgdGhpc1trUGlwZWxpbmluZ10gPSBwaXBlbGluaW5nICE9IG51bGwgPyBwaXBlbGluaW5nIDogMVxuICAgIHRoaXNba01heEhlYWRlcnNTaXplXSA9IG1heEhlYWRlclNpemUgfHwgaHR0cC5tYXhIZWFkZXJTaXplXG4gICAgdGhpc1trS2VlcEFsaXZlRGVmYXVsdFRpbWVvdXRdID0ga2VlcEFsaXZlVGltZW91dCA9PSBudWxsID8gNGUzIDoga2VlcEFsaXZlVGltZW91dFxuICAgIHRoaXNba0tlZXBBbGl2ZU1heFRpbWVvdXRdID0ga2VlcEFsaXZlTWF4VGltZW91dCA9PSBudWxsID8gNjAwZTMgOiBrZWVwQWxpdmVNYXhUaW1lb3V0XG4gICAgdGhpc1trS2VlcEFsaXZlVGltZW91dFRocmVzaG9sZF0gPSBrZWVwQWxpdmVUaW1lb3V0VGhyZXNob2xkID09IG51bGwgPyAyZTMgOiBrZWVwQWxpdmVUaW1lb3V0VGhyZXNob2xkXG4gICAgdGhpc1trS2VlcEFsaXZlVGltZW91dFZhbHVlXSA9IHRoaXNba0tlZXBBbGl2ZURlZmF1bHRUaW1lb3V0XVxuICAgIHRoaXNba1NlcnZlck5hbWVdID0gbnVsbFxuICAgIHRoaXNba0xvY2FsQWRkcmVzc10gPSBsb2NhbEFkZHJlc3MgIT0gbnVsbCA/IGxvY2FsQWRkcmVzcyA6IG51bGxcbiAgICB0aGlzW2tSZXN1bWluZ10gPSAwIC8vIDAsIGlkbGUsIDEsIHNjaGVkdWxlZCwgMiByZXN1bWluZ1xuICAgIHRoaXNba05lZWREcmFpbl0gPSAwIC8vIDAsIGlkbGUsIDEsIHNjaGVkdWxlZCwgMiByZXN1bWluZ1xuICAgIHRoaXNba0hvc3RIZWFkZXJdID0gYGhvc3Q6ICR7dGhpc1trVXJsXS5ob3N0bmFtZX0ke3RoaXNba1VybF0ucG9ydCA/IGA6JHt0aGlzW2tVcmxdLnBvcnR9YCA6ICcnfVxcclxcbmBcbiAgICB0aGlzW2tCb2R5VGltZW91dF0gPSBib2R5VGltZW91dCAhPSBudWxsID8gYm9keVRpbWVvdXQgOiAzMDBlM1xuICAgIHRoaXNba0hlYWRlcnNUaW1lb3V0XSA9IGhlYWRlcnNUaW1lb3V0ICE9IG51bGwgPyBoZWFkZXJzVGltZW91dCA6IDMwMGUzXG4gICAgdGhpc1trU3RyaWN0Q29udGVudExlbmd0aF0gPSBzdHJpY3RDb250ZW50TGVuZ3RoID09IG51bGwgPyB0cnVlIDogc3RyaWN0Q29udGVudExlbmd0aFxuICAgIHRoaXNba01heFJlZGlyZWN0aW9uc10gPSBtYXhSZWRpcmVjdGlvbnNcbiAgICB0aGlzW2tNYXhSZXF1ZXN0c10gPSBtYXhSZXF1ZXN0c1BlckNsaWVudFxuICAgIHRoaXNba0Nsb3NlZFJlc29sdmVdID0gbnVsbFxuICAgIHRoaXNba01heFJlc3BvbnNlU2l6ZV0gPSBtYXhSZXNwb25zZVNpemUgPiAtMSA/IG1heFJlc3BvbnNlU2l6ZSA6IC0xXG4gICAgdGhpc1trTWF4Q29uY3VycmVudFN0cmVhbXNdID0gbWF4Q29uY3VycmVudFN0cmVhbXMgIT0gbnVsbCA/IG1heENvbmN1cnJlbnRTdHJlYW1zIDogMTAwIC8vIE1heCBwZWVyQ29uY3VycmVudFN0cmVhbXMgZm9yIGEgTm9kZSBoMiBzZXJ2ZXJcbiAgICB0aGlzW2tIVFRQQ29udGV4dF0gPSBudWxsXG5cbiAgICAvLyBrUXVldWUgaXMgYnVpbHQgdXAgb2YgMyBzZWN0aW9ucyBzZXBhcmF0ZWQgYnlcbiAgICAvLyB0aGUga1J1bm5pbmdJZHggYW5kIGtQZW5kaW5nSWR4IGluZGljZXMuXG4gICAgLy8gfCAgIGNvbXBsZXRlICAgfCAgIHJ1bm5pbmcgICB8ICAgcGVuZGluZyAgIHxcbiAgICAvLyAgICAgICAgICAgICAgICBeIGtSdW5uaW5nSWR4IF4ga1BlbmRpbmdJZHggXiBrUXVldWUubGVuZ3RoXG4gICAgLy8ga1J1bm5pbmdJZHggcG9pbnRzIHRvIHRoZSBmaXJzdCBydW5uaW5nIGVsZW1lbnQuXG4gICAgLy8ga1BlbmRpbmdJZHggcG9pbnRzIHRvIHRoZSBmaXJzdCBwZW5kaW5nIGVsZW1lbnQuXG4gICAgLy8gVGhpcyBpbXBsZW1lbnRzIGEgZmFzdCBxdWV1ZSB3aXRoIGFuIGFtb3J0aXplZFxuICAgIC8vIHRpbWUgb2YgTygxKS5cblxuICAgIHRoaXNba1F1ZXVlXSA9IFtdXG4gICAgdGhpc1trUnVubmluZ0lkeF0gPSAwXG4gICAgdGhpc1trUGVuZGluZ0lkeF0gPSAwXG5cbiAgICB0aGlzW2tSZXN1bWVdID0gKHN5bmMpID0+IHJlc3VtZSh0aGlzLCBzeW5jKVxuICAgIHRoaXNba09uRXJyb3JdID0gKGVycikgPT4gb25FcnJvcih0aGlzLCBlcnIpXG4gIH1cblxuICBnZXQgcGlwZWxpbmluZyAoKSB7XG4gICAgcmV0dXJuIHRoaXNba1BpcGVsaW5pbmddXG4gIH1cblxuICBzZXQgcGlwZWxpbmluZyAodmFsdWUpIHtcbiAgICB0aGlzW2tQaXBlbGluaW5nXSA9IHZhbHVlXG4gICAgdGhpc1trUmVzdW1lXSh0cnVlKVxuICB9XG5cbiAgZ2V0IFtrUGVuZGluZ10gKCkge1xuICAgIHJldHVybiB0aGlzW2tRdWV1ZV0ubGVuZ3RoIC0gdGhpc1trUGVuZGluZ0lkeF1cbiAgfVxuXG4gIGdldCBba1J1bm5pbmddICgpIHtcbiAgICByZXR1cm4gdGhpc1trUGVuZGluZ0lkeF0gLSB0aGlzW2tSdW5uaW5nSWR4XVxuICB9XG5cbiAgZ2V0IFtrU2l6ZV0gKCkge1xuICAgIHJldHVybiB0aGlzW2tRdWV1ZV0ubGVuZ3RoIC0gdGhpc1trUnVubmluZ0lkeF1cbiAgfVxuXG4gIGdldCBba0Nvbm5lY3RlZF0gKCkge1xuICAgIHJldHVybiAhIXRoaXNba0hUVFBDb250ZXh0XSAmJiAhdGhpc1trQ29ubmVjdGluZ10gJiYgIXRoaXNba0hUVFBDb250ZXh0XS5kZXN0cm95ZWRcbiAgfVxuXG4gIGdldCBba0J1c3ldICgpIHtcbiAgICByZXR1cm4gQm9vbGVhbihcbiAgICAgIHRoaXNba0hUVFBDb250ZXh0XT8uYnVzeShudWxsKSB8fFxuICAgICAgKHRoaXNba1NpemVdID49IChnZXRQaXBlbGluaW5nKHRoaXMpIHx8IDEpKSB8fFxuICAgICAgdGhpc1trUGVuZGluZ10gPiAwXG4gICAgKVxuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlOiBvbmx5IHVzZWQgZm9yIHRlc3QgKi9cbiAgW2tDb25uZWN0XSAoY2IpIHtcbiAgICBjb25uZWN0KHRoaXMpXG4gICAgdGhpcy5vbmNlKCdjb25uZWN0JywgY2IpXG4gIH1cblxuICBba0Rpc3BhdGNoXSAob3B0cywgaGFuZGxlcikge1xuICAgIGNvbnN0IG9yaWdpbiA9IG9wdHMub3JpZ2luIHx8IHRoaXNba1VybF0ub3JpZ2luXG4gICAgY29uc3QgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KG9yaWdpbiwgb3B0cywgaGFuZGxlcilcblxuICAgIHRoaXNba1F1ZXVlXS5wdXNoKHJlcXVlc3QpXG4gICAgaWYgKHRoaXNba1Jlc3VtaW5nXSkge1xuICAgICAgLy8gRG8gbm90aGluZy5cbiAgICB9IGVsc2UgaWYgKHV0aWwuYm9keUxlbmd0aChyZXF1ZXN0LmJvZHkpID09IG51bGwgJiYgdXRpbC5pc0l0ZXJhYmxlKHJlcXVlc3QuYm9keSkpIHtcbiAgICAgIC8vIFdhaXQgYSB0aWNrIGluIGNhc2Ugc3RyZWFtL2l0ZXJhdG9yIGlzIGVuZGVkIGluIHRoZSBzYW1lIHRpY2suXG4gICAgICB0aGlzW2tSZXN1bWluZ10gPSAxXG4gICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiByZXN1bWUodGhpcykpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXNba1Jlc3VtZV0odHJ1ZSlcbiAgICB9XG5cbiAgICBpZiAodGhpc1trUmVzdW1pbmddICYmIHRoaXNba05lZWREcmFpbl0gIT09IDIgJiYgdGhpc1trQnVzeV0pIHtcbiAgICAgIHRoaXNba05lZWREcmFpbl0gPSAyXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXNba05lZWREcmFpbl0gPCAyXG4gIH1cblxuICBhc3luYyBba0Nsb3NlXSAoKSB7XG4gICAgLy8gVE9ETzogZm9yIEgyIHdlIG5lZWQgdG8gZ3JhY2VmdWxseSBmbHVzaCB0aGUgcmVtYWluaW5nIGVucXVldWVkXG4gICAgLy8gcmVxdWVzdCBhbmQgY2xvc2UgZWFjaCBzdHJlYW0uXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICBpZiAodGhpc1trU2l6ZV0pIHtcbiAgICAgICAgdGhpc1trQ2xvc2VkUmVzb2x2ZV0gPSByZXNvbHZlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNvbHZlKG51bGwpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIGFzeW5jIFtrRGVzdHJveV0gKGVycikge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgY29uc3QgcmVxdWVzdHMgPSB0aGlzW2tRdWV1ZV0uc3BsaWNlKHRoaXNba1BlbmRpbmdJZHhdKVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXF1ZXN0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0gcmVxdWVzdHNbaV1cbiAgICAgICAgdXRpbC5lcnJvclJlcXVlc3QodGhpcywgcmVxdWVzdCwgZXJyKVxuICAgICAgfVxuXG4gICAgICBjb25zdCBjYWxsYmFjayA9ICgpID0+IHtcbiAgICAgICAgaWYgKHRoaXNba0Nsb3NlZFJlc29sdmVdKSB7XG4gICAgICAgICAgLy8gVE9ETyAoZml4KTogU2hvdWxkIHdlIGVycm9yIGhlcmUgd2l0aCBDbGllbnREZXN0cm95ZWRFcnJvcj9cbiAgICAgICAgICB0aGlzW2tDbG9zZWRSZXNvbHZlXSgpXG4gICAgICAgICAgdGhpc1trQ2xvc2VkUmVzb2x2ZV0gPSBudWxsXG4gICAgICAgIH1cbiAgICAgICAgcmVzb2x2ZShudWxsKVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpc1trSFRUUENvbnRleHRdKSB7XG4gICAgICAgIHRoaXNba0hUVFBDb250ZXh0XS5kZXN0cm95KGVyciwgY2FsbGJhY2spXG4gICAgICAgIHRoaXNba0hUVFBDb250ZXh0XSA9IG51bGxcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlTWljcm90YXNrKGNhbGxiYWNrKVxuICAgICAgfVxuXG4gICAgICB0aGlzW2tSZXN1bWVdKClcbiAgICB9KVxuICB9XG59XG5cbmNvbnN0IGNyZWF0ZVJlZGlyZWN0SW50ZXJjZXB0b3IgPSByZXF1aXJlKCcuLi9pbnRlcmNlcHRvci9yZWRpcmVjdC1pbnRlcmNlcHRvci5qcycpXG5cbmZ1bmN0aW9uIG9uRXJyb3IgKGNsaWVudCwgZXJyKSB7XG4gIGlmIChcbiAgICBjbGllbnRba1J1bm5pbmddID09PSAwICYmXG4gICAgZXJyLmNvZGUgIT09ICdVTkRfRVJSX0lORk8nICYmXG4gICAgZXJyLmNvZGUgIT09ICdVTkRfRVJSX1NPQ0tFVCdcbiAgKSB7XG4gICAgLy8gRXJyb3IgaXMgbm90IGNhdXNlZCBieSBydW5uaW5nIHJlcXVlc3QgYW5kIG5vdCBhIHJlY292ZXJhYmxlXG4gICAgLy8gc29ja2V0IGVycm9yLlxuXG4gICAgYXNzZXJ0KGNsaWVudFtrUGVuZGluZ0lkeF0gPT09IGNsaWVudFtrUnVubmluZ0lkeF0pXG5cbiAgICBjb25zdCByZXF1ZXN0cyA9IGNsaWVudFtrUXVldWVdLnNwbGljZShjbGllbnRba1J1bm5pbmdJZHhdKVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXF1ZXN0cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgcmVxdWVzdCA9IHJlcXVlc3RzW2ldXG4gICAgICB1dGlsLmVycm9yUmVxdWVzdChjbGllbnQsIHJlcXVlc3QsIGVycilcbiAgICB9XG4gICAgYXNzZXJ0KGNsaWVudFtrU2l6ZV0gPT09IDApXG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gY29ubmVjdCAoY2xpZW50KSB7XG4gIGFzc2VydCghY2xpZW50W2tDb25uZWN0aW5nXSlcbiAgYXNzZXJ0KCFjbGllbnRba0hUVFBDb250ZXh0XSlcblxuICBsZXQgeyBob3N0LCBob3N0bmFtZSwgcHJvdG9jb2wsIHBvcnQgfSA9IGNsaWVudFtrVXJsXVxuXG4gIC8vIFJlc29sdmUgaXB2NlxuICBpZiAoaG9zdG5hbWVbMF0gPT09ICdbJykge1xuICAgIGNvbnN0IGlkeCA9IGhvc3RuYW1lLmluZGV4T2YoJ10nKVxuXG4gICAgYXNzZXJ0KGlkeCAhPT0gLTEpXG4gICAgY29uc3QgaXAgPSBob3N0bmFtZS5zdWJzdHJpbmcoMSwgaWR4KVxuXG4gICAgYXNzZXJ0KG5ldC5pc0lQKGlwKSlcbiAgICBob3N0bmFtZSA9IGlwXG4gIH1cblxuICBjbGllbnRba0Nvbm5lY3RpbmddID0gdHJ1ZVxuXG4gIGlmIChjaGFubmVscy5iZWZvcmVDb25uZWN0Lmhhc1N1YnNjcmliZXJzKSB7XG4gICAgY2hhbm5lbHMuYmVmb3JlQ29ubmVjdC5wdWJsaXNoKHtcbiAgICAgIGNvbm5lY3RQYXJhbXM6IHtcbiAgICAgICAgaG9zdCxcbiAgICAgICAgaG9zdG5hbWUsXG4gICAgICAgIHByb3RvY29sLFxuICAgICAgICBwb3J0LFxuICAgICAgICB2ZXJzaW9uOiBjbGllbnRba0hUVFBDb250ZXh0XT8udmVyc2lvbixcbiAgICAgICAgc2VydmVybmFtZTogY2xpZW50W2tTZXJ2ZXJOYW1lXSxcbiAgICAgICAgbG9jYWxBZGRyZXNzOiBjbGllbnRba0xvY2FsQWRkcmVzc11cbiAgICAgIH0sXG4gICAgICBjb25uZWN0b3I6IGNsaWVudFtrQ29ubmVjdG9yXVxuICAgIH0pXG4gIH1cblxuICB0cnkge1xuICAgIGNvbnN0IHNvY2tldCA9IGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNsaWVudFtrQ29ubmVjdG9yXSh7XG4gICAgICAgIGhvc3QsXG4gICAgICAgIGhvc3RuYW1lLFxuICAgICAgICBwcm90b2NvbCxcbiAgICAgICAgcG9ydCxcbiAgICAgICAgc2VydmVybmFtZTogY2xpZW50W2tTZXJ2ZXJOYW1lXSxcbiAgICAgICAgbG9jYWxBZGRyZXNzOiBjbGllbnRba0xvY2FsQWRkcmVzc11cbiAgICAgIH0sIChlcnIsIHNvY2tldCkgPT4ge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgcmVqZWN0KGVycilcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXNvbHZlKHNvY2tldClcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9KVxuXG4gICAgaWYgKGNsaWVudC5kZXN0cm95ZWQpIHtcbiAgICAgIHV0aWwuZGVzdHJveShzb2NrZXQub24oJ2Vycm9yJywgKCkgPT4ge30pLCBuZXcgQ2xpZW50RGVzdHJveWVkRXJyb3IoKSlcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGFzc2VydChzb2NrZXQpXG5cbiAgICB0cnkge1xuICAgICAgY2xpZW50W2tIVFRQQ29udGV4dF0gPSBzb2NrZXQuYWxwblByb3RvY29sID09PSAnaDInXG4gICAgICAgID8gYXdhaXQgY29ubmVjdEgyKGNsaWVudCwgc29ja2V0KVxuICAgICAgICA6IGF3YWl0IGNvbm5lY3RIMShjbGllbnQsIHNvY2tldClcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHNvY2tldC5kZXN0cm95KCkub24oJ2Vycm9yJywgKCkgPT4ge30pXG4gICAgICB0aHJvdyBlcnJcbiAgICB9XG5cbiAgICBjbGllbnRba0Nvbm5lY3RpbmddID0gZmFsc2VcblxuICAgIHNvY2tldFtrQ291bnRlcl0gPSAwXG4gICAgc29ja2V0W2tNYXhSZXF1ZXN0c10gPSBjbGllbnRba01heFJlcXVlc3RzXVxuICAgIHNvY2tldFtrQ2xpZW50XSA9IGNsaWVudFxuICAgIHNvY2tldFtrRXJyb3JdID0gbnVsbFxuXG4gICAgaWYgKGNoYW5uZWxzLmNvbm5lY3RlZC5oYXNTdWJzY3JpYmVycykge1xuICAgICAgY2hhbm5lbHMuY29ubmVjdGVkLnB1Ymxpc2goe1xuICAgICAgICBjb25uZWN0UGFyYW1zOiB7XG4gICAgICAgICAgaG9zdCxcbiAgICAgICAgICBob3N0bmFtZSxcbiAgICAgICAgICBwcm90b2NvbCxcbiAgICAgICAgICBwb3J0LFxuICAgICAgICAgIHZlcnNpb246IGNsaWVudFtrSFRUUENvbnRleHRdPy52ZXJzaW9uLFxuICAgICAgICAgIHNlcnZlcm5hbWU6IGNsaWVudFtrU2VydmVyTmFtZV0sXG4gICAgICAgICAgbG9jYWxBZGRyZXNzOiBjbGllbnRba0xvY2FsQWRkcmVzc11cbiAgICAgICAgfSxcbiAgICAgICAgY29ubmVjdG9yOiBjbGllbnRba0Nvbm5lY3Rvcl0sXG4gICAgICAgIHNvY2tldFxuICAgICAgfSlcbiAgICB9XG4gICAgY2xpZW50LmVtaXQoJ2Nvbm5lY3QnLCBjbGllbnRba1VybF0sIFtjbGllbnRdKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpZiAoY2xpZW50LmRlc3Ryb3llZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY2xpZW50W2tDb25uZWN0aW5nXSA9IGZhbHNlXG5cbiAgICBpZiAoY2hhbm5lbHMuY29ubmVjdEVycm9yLmhhc1N1YnNjcmliZXJzKSB7XG4gICAgICBjaGFubmVscy5jb25uZWN0RXJyb3IucHVibGlzaCh7XG4gICAgICAgIGNvbm5lY3RQYXJhbXM6IHtcbiAgICAgICAgICBob3N0LFxuICAgICAgICAgIGhvc3RuYW1lLFxuICAgICAgICAgIHByb3RvY29sLFxuICAgICAgICAgIHBvcnQsXG4gICAgICAgICAgdmVyc2lvbjogY2xpZW50W2tIVFRQQ29udGV4dF0/LnZlcnNpb24sXG4gICAgICAgICAgc2VydmVybmFtZTogY2xpZW50W2tTZXJ2ZXJOYW1lXSxcbiAgICAgICAgICBsb2NhbEFkZHJlc3M6IGNsaWVudFtrTG9jYWxBZGRyZXNzXVxuICAgICAgICB9LFxuICAgICAgICBjb25uZWN0b3I6IGNsaWVudFtrQ29ubmVjdG9yXSxcbiAgICAgICAgZXJyb3I6IGVyclxuICAgICAgfSlcbiAgICB9XG5cbiAgICBpZiAoZXJyLmNvZGUgPT09ICdFUlJfVExTX0NFUlRfQUxUTkFNRV9JTlZBTElEJykge1xuICAgICAgYXNzZXJ0KGNsaWVudFtrUnVubmluZ10gPT09IDApXG4gICAgICB3aGlsZSAoY2xpZW50W2tQZW5kaW5nXSA+IDAgJiYgY2xpZW50W2tRdWV1ZV1bY2xpZW50W2tQZW5kaW5nSWR4XV0uc2VydmVybmFtZSA9PT0gY2xpZW50W2tTZXJ2ZXJOYW1lXSkge1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0gY2xpZW50W2tRdWV1ZV1bY2xpZW50W2tQZW5kaW5nSWR4XSsrXVxuICAgICAgICB1dGlsLmVycm9yUmVxdWVzdChjbGllbnQsIHJlcXVlc3QsIGVycilcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgb25FcnJvcihjbGllbnQsIGVycilcbiAgICB9XG5cbiAgICBjbGllbnQuZW1pdCgnY29ubmVjdGlvbkVycm9yJywgY2xpZW50W2tVcmxdLCBbY2xpZW50XSwgZXJyKVxuICB9XG5cbiAgY2xpZW50W2tSZXN1bWVdKClcbn1cblxuZnVuY3Rpb24gZW1pdERyYWluIChjbGllbnQpIHtcbiAgY2xpZW50W2tOZWVkRHJhaW5dID0gMFxuICBjbGllbnQuZW1pdCgnZHJhaW4nLCBjbGllbnRba1VybF0sIFtjbGllbnRdKVxufVxuXG5mdW5jdGlvbiByZXN1bWUgKGNsaWVudCwgc3luYykge1xuICBpZiAoY2xpZW50W2tSZXN1bWluZ10gPT09IDIpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGNsaWVudFtrUmVzdW1pbmddID0gMlxuXG4gIF9yZXN1bWUoY2xpZW50LCBzeW5jKVxuICBjbGllbnRba1Jlc3VtaW5nXSA9IDBcblxuICBpZiAoY2xpZW50W2tSdW5uaW5nSWR4XSA+IDI1Nikge1xuICAgIGNsaWVudFtrUXVldWVdLnNwbGljZSgwLCBjbGllbnRba1J1bm5pbmdJZHhdKVxuICAgIGNsaWVudFtrUGVuZGluZ0lkeF0gLT0gY2xpZW50W2tSdW5uaW5nSWR4XVxuICAgIGNsaWVudFtrUnVubmluZ0lkeF0gPSAwXG4gIH1cbn1cblxuZnVuY3Rpb24gX3Jlc3VtZSAoY2xpZW50LCBzeW5jKSB7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgaWYgKGNsaWVudC5kZXN0cm95ZWQpIHtcbiAgICAgIGFzc2VydChjbGllbnRba1BlbmRpbmddID09PSAwKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKGNsaWVudFtrQ2xvc2VkUmVzb2x2ZV0gJiYgIWNsaWVudFtrU2l6ZV0pIHtcbiAgICAgIGNsaWVudFtrQ2xvc2VkUmVzb2x2ZV0oKVxuICAgICAgY2xpZW50W2tDbG9zZWRSZXNvbHZlXSA9IG51bGxcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChjbGllbnRba0hUVFBDb250ZXh0XSkge1xuICAgICAgY2xpZW50W2tIVFRQQ29udGV4dF0ucmVzdW1lKClcbiAgICB9XG5cbiAgICBpZiAoY2xpZW50W2tCdXN5XSkge1xuICAgICAgY2xpZW50W2tOZWVkRHJhaW5dID0gMlxuICAgIH0gZWxzZSBpZiAoY2xpZW50W2tOZWVkRHJhaW5dID09PSAyKSB7XG4gICAgICBpZiAoc3luYykge1xuICAgICAgICBjbGllbnRba05lZWREcmFpbl0gPSAxXG4gICAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IGVtaXREcmFpbihjbGllbnQpKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW1pdERyYWluKGNsaWVudClcbiAgICAgIH1cbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgaWYgKGNsaWVudFtrUGVuZGluZ10gPT09IDApIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChjbGllbnRba1J1bm5pbmddID49IChnZXRQaXBlbGluaW5nKGNsaWVudCkgfHwgMSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IHJlcXVlc3QgPSBjbGllbnRba1F1ZXVlXVtjbGllbnRba1BlbmRpbmdJZHhdXVxuXG4gICAgaWYgKGNsaWVudFtrVXJsXS5wcm90b2NvbCA9PT0gJ2h0dHBzOicgJiYgY2xpZW50W2tTZXJ2ZXJOYW1lXSAhPT0gcmVxdWVzdC5zZXJ2ZXJuYW1lKSB7XG4gICAgICBpZiAoY2xpZW50W2tSdW5uaW5nXSA+IDApIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGNsaWVudFtrU2VydmVyTmFtZV0gPSByZXF1ZXN0LnNlcnZlcm5hbWVcbiAgICAgIGNsaWVudFtrSFRUUENvbnRleHRdPy5kZXN0cm95KG5ldyBJbmZvcm1hdGlvbmFsRXJyb3IoJ3NlcnZlcm5hbWUgY2hhbmdlZCcpLCAoKSA9PiB7XG4gICAgICAgIGNsaWVudFtrSFRUUENvbnRleHRdID0gbnVsbFxuICAgICAgICByZXN1bWUoY2xpZW50KVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBpZiAoY2xpZW50W2tDb25uZWN0aW5nXSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKCFjbGllbnRba0hUVFBDb250ZXh0XSkge1xuICAgICAgY29ubmVjdChjbGllbnQpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoY2xpZW50W2tIVFRQQ29udGV4dF0uZGVzdHJveWVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoY2xpZW50W2tIVFRQQ29udGV4dF0uYnVzeShyZXF1ZXN0KSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKCFyZXF1ZXN0LmFib3J0ZWQgJiYgY2xpZW50W2tIVFRQQ29udGV4dF0ud3JpdGUocmVxdWVzdCkpIHtcbiAgICAgIGNsaWVudFtrUGVuZGluZ0lkeF0rK1xuICAgIH0gZWxzZSB7XG4gICAgICBjbGllbnRba1F1ZXVlXS5zcGxpY2UoY2xpZW50W2tQZW5kaW5nSWR4XSwgMSlcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBDbGllbnRcbiJdLCJuYW1lcyI6WyJhc3NlcnQiLCJyZXF1aXJlIiwibmV0IiwiaHR0cCIsInV0aWwiLCJjaGFubmVscyIsIlJlcXVlc3QiLCJEaXNwYXRjaGVyQmFzZSIsIkludmFsaWRBcmd1bWVudEVycm9yIiwiSW5mb3JtYXRpb25hbEVycm9yIiwiQ2xpZW50RGVzdHJveWVkRXJyb3IiLCJidWlsZENvbm5lY3RvciIsImtVcmwiLCJrU2VydmVyTmFtZSIsImtDbGllbnQiLCJrQnVzeSIsImtDb25uZWN0Iiwia1Jlc3VtaW5nIiwia1J1bm5pbmciLCJrUGVuZGluZyIsImtTaXplIiwia1F1ZXVlIiwia0Nvbm5lY3RlZCIsImtDb25uZWN0aW5nIiwia05lZWREcmFpbiIsImtLZWVwQWxpdmVEZWZhdWx0VGltZW91dCIsImtIb3N0SGVhZGVyIiwia1BlbmRpbmdJZHgiLCJrUnVubmluZ0lkeCIsImtFcnJvciIsImtQaXBlbGluaW5nIiwia0tlZXBBbGl2ZVRpbWVvdXRWYWx1ZSIsImtNYXhIZWFkZXJzU2l6ZSIsImtLZWVwQWxpdmVNYXhUaW1lb3V0Iiwia0tlZXBBbGl2ZVRpbWVvdXRUaHJlc2hvbGQiLCJrSGVhZGVyc1RpbWVvdXQiLCJrQm9keVRpbWVvdXQiLCJrU3RyaWN0Q29udGVudExlbmd0aCIsImtDb25uZWN0b3IiLCJrTWF4UmVkaXJlY3Rpb25zIiwia01heFJlcXVlc3RzIiwia0NvdW50ZXIiLCJrQ2xvc2UiLCJrRGVzdHJveSIsImtEaXNwYXRjaCIsImtJbnRlcmNlcHRvcnMiLCJrTG9jYWxBZGRyZXNzIiwia01heFJlc3BvbnNlU2l6ZSIsImtPbkVycm9yIiwia0hUVFBDb250ZXh0Iiwia01heENvbmN1cnJlbnRTdHJlYW1zIiwia1Jlc3VtZSIsImNvbm5lY3RIMSIsImNvbm5lY3RIMiIsImRlcHJlY2F0ZWRJbnRlcmNlcHRvcldhcm5lZCIsImtDbG9zZWRSZXNvbHZlIiwiU3ltYm9sIiwiZ2V0UGlwZWxpbmluZyIsImNsaWVudCIsImRlZmF1bHRQaXBlbGluaW5nIiwiQ2xpZW50IiwiY29uc3RydWN0b3IiLCJ1cmwiLCJpbnRlcmNlcHRvcnMiLCJtYXhIZWFkZXJTaXplIiwiaGVhZGVyc1RpbWVvdXQiLCJzb2NrZXRUaW1lb3V0IiwicmVxdWVzdFRpbWVvdXQiLCJjb25uZWN0VGltZW91dCIsImJvZHlUaW1lb3V0IiwiaWRsZVRpbWVvdXQiLCJrZWVwQWxpdmUiLCJrZWVwQWxpdmVUaW1lb3V0IiwibWF4S2VlcEFsaXZlVGltZW91dCIsImtlZXBBbGl2ZU1heFRpbWVvdXQiLCJrZWVwQWxpdmVUaW1lb3V0VGhyZXNob2xkIiwic29ja2V0UGF0aCIsInBpcGVsaW5pbmciLCJ0bHMiLCJzdHJpY3RDb250ZW50TGVuZ3RoIiwibWF4Q2FjaGVkU2Vzc2lvbnMiLCJtYXhSZWRpcmVjdGlvbnMiLCJjb25uZWN0IiwibWF4UmVxdWVzdHNQZXJDbGllbnQiLCJsb2NhbEFkZHJlc3MiLCJtYXhSZXNwb25zZVNpemUiLCJhdXRvU2VsZWN0RmFtaWx5IiwiYXV0b1NlbGVjdEZhbWlseUF0dGVtcHRUaW1lb3V0IiwibWF4Q29uY3VycmVudFN0cmVhbXMiLCJhbGxvd0gyIiwidW5kZWZpbmVkIiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJpc0ludGVnZXIiLCJpc0lQIiwidGltZW91dCIsIkFycmF5IiwiaXNBcnJheSIsInByb2Nlc3MiLCJlbWl0V2FybmluZyIsImNvZGUiLCJjcmVhdGVSZWRpcmVjdEludGVyY2VwdG9yIiwicGFyc2VPcmlnaW4iLCJob3N0bmFtZSIsInBvcnQiLCJzeW5jIiwicmVzdW1lIiwiZXJyIiwib25FcnJvciIsInZhbHVlIiwibGVuZ3RoIiwiZGVzdHJveWVkIiwiQm9vbGVhbiIsImJ1c3kiLCJjYiIsIm9uY2UiLCJvcHRzIiwiaGFuZGxlciIsIm9yaWdpbiIsInJlcXVlc3QiLCJwdXNoIiwiYm9keUxlbmd0aCIsImJvZHkiLCJpc0l0ZXJhYmxlIiwicXVldWVNaWNyb3Rhc2siLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlcXVlc3RzIiwic3BsaWNlIiwiaSIsImVycm9yUmVxdWVzdCIsImNhbGxiYWNrIiwiZGVzdHJveSIsImhvc3QiLCJwcm90b2NvbCIsImlkeCIsImluZGV4T2YiLCJpcCIsInN1YnN0cmluZyIsImJlZm9yZUNvbm5lY3QiLCJoYXNTdWJzY3JpYmVycyIsInB1Ymxpc2giLCJjb25uZWN0UGFyYW1zIiwidmVyc2lvbiIsInNlcnZlcm5hbWUiLCJjb25uZWN0b3IiLCJzb2NrZXQiLCJyZWplY3QiLCJvbiIsImFscG5Qcm90b2NvbCIsImNvbm5lY3RlZCIsImVtaXQiLCJjb25uZWN0RXJyb3IiLCJlcnJvciIsImVtaXREcmFpbiIsIl9yZXN1bWUiLCJhYm9ydGVkIiwid3JpdGUiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/dispatcher/client.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/dispatcher/dispatcher-base.js":
/*!***************************************************************!*\
  !*** ./node_modules/undici/lib/dispatcher/dispatcher-base.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst Dispatcher = __webpack_require__(/*! ./dispatcher */ \"(ssr)/./node_modules/undici/lib/dispatcher/dispatcher.js\");\nconst { ClientDestroyedError, ClientClosedError, InvalidArgumentError } = __webpack_require__(/*! ../core/errors */ \"(ssr)/./node_modules/undici/lib/core/errors.js\");\nconst { kDestroy, kClose, kClosed, kDestroyed, kDispatch, kInterceptors } = __webpack_require__(/*! ../core/symbols */ \"(ssr)/./node_modules/undici/lib/core/symbols.js\");\nconst kOnDestroyed = Symbol(\"onDestroyed\");\nconst kOnClosed = Symbol(\"onClosed\");\nconst kInterceptedDispatch = Symbol(\"Intercepted Dispatch\");\nclass DispatcherBase extends Dispatcher {\n    constructor(){\n        super();\n        this[kDestroyed] = false;\n        this[kOnDestroyed] = null;\n        this[kClosed] = false;\n        this[kOnClosed] = [];\n    }\n    get destroyed() {\n        return this[kDestroyed];\n    }\n    get closed() {\n        return this[kClosed];\n    }\n    get interceptors() {\n        return this[kInterceptors];\n    }\n    set interceptors(newInterceptors) {\n        if (newInterceptors) {\n            for(let i = newInterceptors.length - 1; i >= 0; i--){\n                const interceptor = this[kInterceptors][i];\n                if (typeof interceptor !== \"function\") {\n                    throw new InvalidArgumentError(\"interceptor must be an function\");\n                }\n            }\n        }\n        this[kInterceptors] = newInterceptors;\n    }\n    close(callback) {\n        if (callback === undefined) {\n            return new Promise((resolve, reject)=>{\n                this.close((err, data)=>{\n                    return err ? reject(err) : resolve(data);\n                });\n            });\n        }\n        if (typeof callback !== \"function\") {\n            throw new InvalidArgumentError(\"invalid callback\");\n        }\n        if (this[kDestroyed]) {\n            queueMicrotask(()=>callback(new ClientDestroyedError(), null));\n            return;\n        }\n        if (this[kClosed]) {\n            if (this[kOnClosed]) {\n                this[kOnClosed].push(callback);\n            } else {\n                queueMicrotask(()=>callback(null, null));\n            }\n            return;\n        }\n        this[kClosed] = true;\n        this[kOnClosed].push(callback);\n        const onClosed = ()=>{\n            const callbacks = this[kOnClosed];\n            this[kOnClosed] = null;\n            for(let i = 0; i < callbacks.length; i++){\n                callbacks[i](null, null);\n            }\n        };\n        // Should not error.\n        this[kClose]().then(()=>this.destroy()).then(()=>{\n            queueMicrotask(onClosed);\n        });\n    }\n    destroy(err, callback) {\n        if (typeof err === \"function\") {\n            callback = err;\n            err = null;\n        }\n        if (callback === undefined) {\n            return new Promise((resolve, reject)=>{\n                this.destroy(err, (err, data)=>{\n                    return err ? /* istanbul ignore next: should never error */ reject(err) : resolve(data);\n                });\n            });\n        }\n        if (typeof callback !== \"function\") {\n            throw new InvalidArgumentError(\"invalid callback\");\n        }\n        if (this[kDestroyed]) {\n            if (this[kOnDestroyed]) {\n                this[kOnDestroyed].push(callback);\n            } else {\n                queueMicrotask(()=>callback(null, null));\n            }\n            return;\n        }\n        if (!err) {\n            err = new ClientDestroyedError();\n        }\n        this[kDestroyed] = true;\n        this[kOnDestroyed] = this[kOnDestroyed] || [];\n        this[kOnDestroyed].push(callback);\n        const onDestroyed = ()=>{\n            const callbacks = this[kOnDestroyed];\n            this[kOnDestroyed] = null;\n            for(let i = 0; i < callbacks.length; i++){\n                callbacks[i](null, null);\n            }\n        };\n        // Should not error.\n        this[kDestroy](err).then(()=>{\n            queueMicrotask(onDestroyed);\n        });\n    }\n    [kInterceptedDispatch](opts, handler) {\n        if (!this[kInterceptors] || this[kInterceptors].length === 0) {\n            this[kInterceptedDispatch] = this[kDispatch];\n            return this[kDispatch](opts, handler);\n        }\n        let dispatch = this[kDispatch].bind(this);\n        for(let i = this[kInterceptors].length - 1; i >= 0; i--){\n            dispatch = this[kInterceptors][i](dispatch);\n        }\n        this[kInterceptedDispatch] = dispatch;\n        return dispatch(opts, handler);\n    }\n    dispatch(opts, handler) {\n        if (!handler || typeof handler !== \"object\") {\n            throw new InvalidArgumentError(\"handler must be an object\");\n        }\n        try {\n            if (!opts || typeof opts !== \"object\") {\n                throw new InvalidArgumentError(\"opts must be an object.\");\n            }\n            if (this[kDestroyed] || this[kOnDestroyed]) {\n                throw new ClientDestroyedError();\n            }\n            if (this[kClosed]) {\n                throw new ClientClosedError();\n            }\n            return this[kInterceptedDispatch](opts, handler);\n        } catch (err) {\n            if (typeof handler.onError !== \"function\") {\n                throw new InvalidArgumentError(\"invalid onError method\");\n            }\n            handler.onError(err);\n            return false;\n        }\n    }\n}\nmodule.exports = DispatcherBase;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9kaXNwYXRjaGVyL2Rpc3BhdGNoZXItYmFzZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU1BLGFBQWFDLG1CQUFPQSxDQUFDO0FBQzNCLE1BQU0sRUFDSkMsb0JBQW9CLEVBQ3BCQyxpQkFBaUIsRUFDakJDLG9CQUFBQSxFQUNELEdBQUdILG1CQUFPQSxDQUFDO0FBQ1osTUFBTSxFQUFFSSxRQUFRLEVBQUVDLE1BQU0sRUFBRUMsT0FBTyxFQUFFQyxVQUFVLEVBQUVDLFNBQVMsRUFBRUMsYUFBQUEsRUFBZSxHQUFHVCxtQkFBT0EsQ0FBQztBQUVwRixNQUFNVSxlQUFlQyxPQUFPO0FBQzVCLE1BQU1DLFlBQVlELE9BQU87QUFDekIsTUFBTUUsdUJBQXVCRixPQUFPO0FBRXBDLE1BQU1HLHVCQUF1QmY7SUFDM0JnQixhQUFlO1FBQ2IsS0FBSztRQUVMLElBQUksQ0FBQ1IsV0FBVyxHQUFHO1FBQ25CLElBQUksQ0FBQ0csYUFBYSxHQUFHO1FBQ3JCLElBQUksQ0FBQ0osUUFBUSxHQUFHO1FBQ2hCLElBQUksQ0FBQ00sVUFBVSxHQUFHLEVBQUU7SUFDdEI7SUFFQSxJQUFJSSxZQUFhO1FBQ2YsT0FBTyxJQUFJLENBQUNULFdBQVc7SUFDekI7SUFFQSxJQUFJVSxTQUFVO1FBQ1osT0FBTyxJQUFJLENBQUNYLFFBQVE7SUFDdEI7SUFFQSxJQUFJWSxlQUFnQjtRQUNsQixPQUFPLElBQUksQ0FBQ1QsY0FBYztJQUM1QjtJQUVBLElBQUlTLGFBQWNDLGVBQWUsRUFBRTtRQUNqQyxJQUFJQSxpQkFBaUI7WUFDbkIsSUFBSyxJQUFJQyxJQUFJRCxnQkFBZ0JFLE1BQU0sR0FBRyxHQUFHRCxLQUFLLEdBQUdBLElBQUs7Z0JBQ3BELE1BQU1FLGNBQWMsSUFBSSxDQUFDYixjQUFjLENBQUNXLEVBQUU7Z0JBQzFDLElBQUksT0FBT0UsZ0JBQWdCLFlBQVk7b0JBQ3JDLE1BQU0sSUFBSW5CLHFCQUFxQjtnQkFDakM7WUFDRjtRQUNGO1FBRUEsSUFBSSxDQUFDTSxjQUFjLEdBQUdVO0lBQ3hCO0lBRUFJLE1BQU9DLFFBQVEsRUFBRTtRQUNmLElBQUlBLGFBQWFDLFdBQVc7WUFDMUIsT0FBTyxJQUFJQyxRQUFRLENBQUNDLFNBQVNDO2dCQUMzQixJQUFJLENBQUNMLEtBQUssQ0FBQyxDQUFDTSxLQUFLQztvQkFDZixPQUFPRCxNQUFNRCxPQUFPQyxPQUFPRixRQUFRRztnQkFDckM7WUFDRjtRQUNGO1FBRUEsSUFBSSxPQUFPTixhQUFhLFlBQVk7WUFDbEMsTUFBTSxJQUFJckIscUJBQXFCO1FBQ2pDO1FBRUEsSUFBSSxJQUFJLENBQUNJLFdBQVcsRUFBRTtZQUNwQndCLGVBQWUsSUFBTVAsU0FBUyxJQUFJdkIsd0JBQXdCO1lBQzFEO1FBQ0Y7UUFFQSxJQUFJLElBQUksQ0FBQ0ssUUFBUSxFQUFFO1lBQ2pCLElBQUksSUFBSSxDQUFDTSxVQUFVLEVBQUU7Z0JBQ25CLElBQUksQ0FBQ0EsVUFBVSxDQUFDb0IsSUFBSSxDQUFDUjtZQUN2QixPQUFPO2dCQUNMTyxlQUFlLElBQU1QLFNBQVMsTUFBTTtZQUN0QztZQUNBO1FBQ0Y7UUFFQSxJQUFJLENBQUNsQixRQUFRLEdBQUc7UUFDaEIsSUFBSSxDQUFDTSxVQUFVLENBQUNvQixJQUFJLENBQUNSO1FBRXJCLE1BQU1TLFdBQVdBO1lBQ2YsTUFBTUMsWUFBWSxJQUFJLENBQUN0QixVQUFVO1lBQ2pDLElBQUksQ0FBQ0EsVUFBVSxHQUFHO1lBQ2xCLElBQUssSUFBSVEsSUFBSSxHQUFHQSxJQUFJYyxVQUFVYixNQUFNLEVBQUVELElBQUs7Z0JBQ3pDYyxTQUFTLENBQUNkLEVBQUUsQ0FBQyxNQUFNO1lBQ3JCO1FBQ0Y7UUFFQTtRQUNBLElBQUksQ0FBQ2YsT0FBTyxHQUNUOEIsSUFBSSxDQUFDLElBQU0sSUFBSSxDQUFDQyxPQUFPLElBQ3ZCRCxJQUFJLENBQUM7WUFDSkosZUFBZUU7UUFDakI7SUFDSjtJQUVBRyxRQUFTUCxHQUFHLEVBQUVMLFFBQVEsRUFBRTtRQUN0QixJQUFJLE9BQU9LLFFBQVEsWUFBWTtZQUM3QkwsV0FBV0s7WUFDWEEsTUFBTTtRQUNSO1FBRUEsSUFBSUwsYUFBYUMsV0FBVztZQUMxQixPQUFPLElBQUlDLFFBQVEsQ0FBQ0MsU0FBU0M7Z0JBQzNCLElBQUksQ0FBQ1EsT0FBTyxDQUFDUCxLQUFLLENBQUNBLEtBQUtDO29CQUN0QixPQUFPRCxNQUFNLCtDQUErQ0QsT0FBT0MsT0FBT0YsUUFBUUc7Z0JBQ3BGO1lBQ0Y7UUFDRjtRQUVBLElBQUksT0FBT04sYUFBYSxZQUFZO1lBQ2xDLE1BQU0sSUFBSXJCLHFCQUFxQjtRQUNqQztRQUVBLElBQUksSUFBSSxDQUFDSSxXQUFXLEVBQUU7WUFDcEIsSUFBSSxJQUFJLENBQUNHLGFBQWEsRUFBRTtnQkFDdEIsSUFBSSxDQUFDQSxhQUFhLENBQUNzQixJQUFJLENBQUNSO1lBQzFCLE9BQU87Z0JBQ0xPLGVBQWUsSUFBTVAsU0FBUyxNQUFNO1lBQ3RDO1lBQ0E7UUFDRjtRQUVBLElBQUksQ0FBQ0ssS0FBSztZQUNSQSxNQUFNLElBQUk1QjtRQUNaO1FBRUEsSUFBSSxDQUFDTSxXQUFXLEdBQUc7UUFDbkIsSUFBSSxDQUFDRyxhQUFhLEdBQUcsSUFBSSxDQUFDQSxhQUFhLElBQUksRUFBRTtRQUM3QyxJQUFJLENBQUNBLGFBQWEsQ0FBQ3NCLElBQUksQ0FBQ1I7UUFFeEIsTUFBTWEsY0FBY0E7WUFDbEIsTUFBTUgsWUFBWSxJQUFJLENBQUN4QixhQUFhO1lBQ3BDLElBQUksQ0FBQ0EsYUFBYSxHQUFHO1lBQ3JCLElBQUssSUFBSVUsSUFBSSxHQUFHQSxJQUFJYyxVQUFVYixNQUFNLEVBQUVELElBQUs7Z0JBQ3pDYyxTQUFTLENBQUNkLEVBQUUsQ0FBQyxNQUFNO1lBQ3JCO1FBQ0Y7UUFFQTtRQUNBLElBQUksQ0FBQ2hCLFNBQVMsQ0FBQ3lCLEtBQUtNLElBQUksQ0FBQztZQUN2QkosZUFBZU07UUFDakI7SUFDRjtJQUVBLENBQUN4QixxQkFBb0IsQ0FBR3lCLElBQUksRUFBRUMsT0FBTyxFQUFFO1FBQ3JDLElBQUksQ0FBQyxJQUFJLENBQUM5QixjQUFjLElBQUksSUFBSSxDQUFDQSxjQUFjLENBQUNZLE1BQU0sS0FBSyxHQUFHO1lBQzVELElBQUksQ0FBQ1IscUJBQXFCLEdBQUcsSUFBSSxDQUFDTCxVQUFVO1lBQzVDLE9BQU8sSUFBSSxDQUFDQSxVQUFVLENBQUM4QixNQUFNQztRQUMvQjtRQUVBLElBQUlDLFdBQVcsSUFBSSxDQUFDaEMsVUFBVSxDQUFDaUMsSUFBSSxDQUFDLElBQUk7UUFDeEMsSUFBSyxJQUFJckIsSUFBSSxJQUFJLENBQUNYLGNBQWMsQ0FBQ1ksTUFBTSxHQUFHLEdBQUdELEtBQUssR0FBR0EsSUFBSztZQUN4RG9CLFdBQVcsSUFBSSxDQUFDL0IsY0FBYyxDQUFDVyxFQUFFLENBQUNvQjtRQUNwQztRQUNBLElBQUksQ0FBQzNCLHFCQUFxQixHQUFHMkI7UUFDN0IsT0FBT0EsU0FBU0YsTUFBTUM7SUFDeEI7SUFFQUMsU0FBVUYsSUFBSSxFQUFFQyxPQUFPLEVBQUU7UUFDdkIsSUFBSSxDQUFDQSxXQUFXLE9BQU9BLFlBQVksVUFBVTtZQUMzQyxNQUFNLElBQUlwQyxxQkFBcUI7UUFDakM7UUFFQSxJQUFJO1lBQ0YsSUFBSSxDQUFDbUMsUUFBUSxPQUFPQSxTQUFTLFVBQVU7Z0JBQ3JDLE1BQU0sSUFBSW5DLHFCQUFxQjtZQUNqQztZQUVBLElBQUksSUFBSSxDQUFDSSxXQUFXLElBQUksSUFBSSxDQUFDRyxhQUFhLEVBQUU7Z0JBQzFDLE1BQU0sSUFBSVQ7WUFDWjtZQUVBLElBQUksSUFBSSxDQUFDSyxRQUFRLEVBQUU7Z0JBQ2pCLE1BQU0sSUFBSUo7WUFDWjtZQUVBLE9BQU8sSUFBSSxDQUFDVyxxQkFBcUIsQ0FBQ3lCLE1BQU1DO1FBQzFDLEVBQUUsT0FBT1YsS0FBSztZQUNaLElBQUksT0FBT1UsUUFBUUcsT0FBTyxLQUFLLFlBQVk7Z0JBQ3pDLE1BQU0sSUFBSXZDLHFCQUFxQjtZQUNqQztZQUVBb0MsUUFBUUcsT0FBTyxDQUFDYjtZQUVoQixPQUFPO1FBQ1Q7SUFDRjtBQUNGO0FBRUFjLE9BQU9DLE9BQU8sR0FBRzlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbW9ja3VwZmxvdy8uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2Rpc3BhdGNoZXIvZGlzcGF0Y2hlci1iYXNlLmpzPzI5YTciLCJ3ZWJwYWNrOi8vbW9ja3VwZmxvdy8uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2Rpc3BhdGNoZXIvZGlzcGF0Y2hlci1iYXNlLmpzPzI5YTcqIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBEaXNwYXRjaGVyID0gcmVxdWlyZSgnLi9kaXNwYXRjaGVyJylcbmNvbnN0IHtcbiAgQ2xpZW50RGVzdHJveWVkRXJyb3IsXG4gIENsaWVudENsb3NlZEVycm9yLFxuICBJbnZhbGlkQXJndW1lbnRFcnJvclxufSA9IHJlcXVpcmUoJy4uL2NvcmUvZXJyb3JzJylcbmNvbnN0IHsga0Rlc3Ryb3ksIGtDbG9zZSwga0Nsb3NlZCwga0Rlc3Ryb3llZCwga0Rpc3BhdGNoLCBrSW50ZXJjZXB0b3JzIH0gPSByZXF1aXJlKCcuLi9jb3JlL3N5bWJvbHMnKVxuXG5jb25zdCBrT25EZXN0cm95ZWQgPSBTeW1ib2woJ29uRGVzdHJveWVkJylcbmNvbnN0IGtPbkNsb3NlZCA9IFN5bWJvbCgnb25DbG9zZWQnKVxuY29uc3Qga0ludGVyY2VwdGVkRGlzcGF0Y2ggPSBTeW1ib2woJ0ludGVyY2VwdGVkIERpc3BhdGNoJylcblxuY2xhc3MgRGlzcGF0Y2hlckJhc2UgZXh0ZW5kcyBEaXNwYXRjaGVyIHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHN1cGVyKClcblxuICAgIHRoaXNba0Rlc3Ryb3llZF0gPSBmYWxzZVxuICAgIHRoaXNba09uRGVzdHJveWVkXSA9IG51bGxcbiAgICB0aGlzW2tDbG9zZWRdID0gZmFsc2VcbiAgICB0aGlzW2tPbkNsb3NlZF0gPSBbXVxuICB9XG5cbiAgZ2V0IGRlc3Ryb3llZCAoKSB7XG4gICAgcmV0dXJuIHRoaXNba0Rlc3Ryb3llZF1cbiAgfVxuXG4gIGdldCBjbG9zZWQgKCkge1xuICAgIHJldHVybiB0aGlzW2tDbG9zZWRdXG4gIH1cblxuICBnZXQgaW50ZXJjZXB0b3JzICgpIHtcbiAgICByZXR1cm4gdGhpc1trSW50ZXJjZXB0b3JzXVxuICB9XG5cbiAgc2V0IGludGVyY2VwdG9ycyAobmV3SW50ZXJjZXB0b3JzKSB7XG4gICAgaWYgKG5ld0ludGVyY2VwdG9ycykge1xuICAgICAgZm9yIChsZXQgaSA9IG5ld0ludGVyY2VwdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBjb25zdCBpbnRlcmNlcHRvciA9IHRoaXNba0ludGVyY2VwdG9yc11baV1cbiAgICAgICAgaWYgKHR5cGVvZiBpbnRlcmNlcHRvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW50ZXJjZXB0b3IgbXVzdCBiZSBhbiBmdW5jdGlvbicpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzW2tJbnRlcmNlcHRvcnNdID0gbmV3SW50ZXJjZXB0b3JzXG4gIH1cblxuICBjbG9zZSAoY2FsbGJhY2spIHtcbiAgICBpZiAoY2FsbGJhY2sgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgdGhpcy5jbG9zZSgoZXJyLCBkYXRhKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIGVyciA/IHJlamVjdChlcnIpIDogcmVzb2x2ZShkYXRhKVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgY2FsbGJhY2snKVxuICAgIH1cblxuICAgIGlmICh0aGlzW2tEZXN0cm95ZWRdKSB7XG4gICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiBjYWxsYmFjayhuZXcgQ2xpZW50RGVzdHJveWVkRXJyb3IoKSwgbnVsbCkpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAodGhpc1trQ2xvc2VkXSkge1xuICAgICAgaWYgKHRoaXNba09uQ2xvc2VkXSkge1xuICAgICAgICB0aGlzW2tPbkNsb3NlZF0ucHVzaChjYWxsYmFjaylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IGNhbGxiYWNrKG51bGwsIG51bGwpKVxuICAgICAgfVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpc1trQ2xvc2VkXSA9IHRydWVcbiAgICB0aGlzW2tPbkNsb3NlZF0ucHVzaChjYWxsYmFjaylcblxuICAgIGNvbnN0IG9uQ2xvc2VkID0gKCkgPT4ge1xuICAgICAgY29uc3QgY2FsbGJhY2tzID0gdGhpc1trT25DbG9zZWRdXG4gICAgICB0aGlzW2tPbkNsb3NlZF0gPSBudWxsXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjYWxsYmFja3NbaV0obnVsbCwgbnVsbClcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTaG91bGQgbm90IGVycm9yLlxuICAgIHRoaXNba0Nsb3NlXSgpXG4gICAgICAudGhlbigoKSA9PiB0aGlzLmRlc3Ryb3koKSlcbiAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgcXVldWVNaWNyb3Rhc2sob25DbG9zZWQpXG4gICAgICB9KVxuICB9XG5cbiAgZGVzdHJveSAoZXJyLCBjYWxsYmFjaykge1xuICAgIGlmICh0eXBlb2YgZXJyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYWxsYmFjayA9IGVyclxuICAgICAgZXJyID0gbnVsbFxuICAgIH1cblxuICAgIGlmIChjYWxsYmFjayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICB0aGlzLmRlc3Ryb3koZXJyLCAoZXJyLCBkYXRhKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIGVyciA/IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBzaG91bGQgbmV2ZXIgZXJyb3IgKi8gcmVqZWN0KGVycikgOiByZXNvbHZlKGRhdGEpXG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBjYWxsYmFjaycpXG4gICAgfVxuXG4gICAgaWYgKHRoaXNba0Rlc3Ryb3llZF0pIHtcbiAgICAgIGlmICh0aGlzW2tPbkRlc3Ryb3llZF0pIHtcbiAgICAgICAgdGhpc1trT25EZXN0cm95ZWRdLnB1c2goY2FsbGJhY2spXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiBjYWxsYmFjayhudWxsLCBudWxsKSlcbiAgICAgIH1cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmICghZXJyKSB7XG4gICAgICBlcnIgPSBuZXcgQ2xpZW50RGVzdHJveWVkRXJyb3IoKVxuICAgIH1cblxuICAgIHRoaXNba0Rlc3Ryb3llZF0gPSB0cnVlXG4gICAgdGhpc1trT25EZXN0cm95ZWRdID0gdGhpc1trT25EZXN0cm95ZWRdIHx8IFtdXG4gICAgdGhpc1trT25EZXN0cm95ZWRdLnB1c2goY2FsbGJhY2spXG5cbiAgICBjb25zdCBvbkRlc3Ryb3llZCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGNhbGxiYWNrcyA9IHRoaXNba09uRGVzdHJveWVkXVxuICAgICAgdGhpc1trT25EZXN0cm95ZWRdID0gbnVsbFxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2FsbGJhY2tzW2ldKG51bGwsIG51bGwpXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gU2hvdWxkIG5vdCBlcnJvci5cbiAgICB0aGlzW2tEZXN0cm95XShlcnIpLnRoZW4oKCkgPT4ge1xuICAgICAgcXVldWVNaWNyb3Rhc2sob25EZXN0cm95ZWQpXG4gICAgfSlcbiAgfVxuXG4gIFtrSW50ZXJjZXB0ZWREaXNwYXRjaF0gKG9wdHMsIGhhbmRsZXIpIHtcbiAgICBpZiAoIXRoaXNba0ludGVyY2VwdG9yc10gfHwgdGhpc1trSW50ZXJjZXB0b3JzXS5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXNba0ludGVyY2VwdGVkRGlzcGF0Y2hdID0gdGhpc1trRGlzcGF0Y2hdXG4gICAgICByZXR1cm4gdGhpc1trRGlzcGF0Y2hdKG9wdHMsIGhhbmRsZXIpXG4gICAgfVxuXG4gICAgbGV0IGRpc3BhdGNoID0gdGhpc1trRGlzcGF0Y2hdLmJpbmQodGhpcylcbiAgICBmb3IgKGxldCBpID0gdGhpc1trSW50ZXJjZXB0b3JzXS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgZGlzcGF0Y2ggPSB0aGlzW2tJbnRlcmNlcHRvcnNdW2ldKGRpc3BhdGNoKVxuICAgIH1cbiAgICB0aGlzW2tJbnRlcmNlcHRlZERpc3BhdGNoXSA9IGRpc3BhdGNoXG4gICAgcmV0dXJuIGRpc3BhdGNoKG9wdHMsIGhhbmRsZXIpXG4gIH1cblxuICBkaXNwYXRjaCAob3B0cywgaGFuZGxlcikge1xuICAgIGlmICghaGFuZGxlciB8fCB0eXBlb2YgaGFuZGxlciAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaGFuZGxlciBtdXN0IGJlIGFuIG9iamVjdCcpXG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGlmICghb3B0cyB8fCB0eXBlb2Ygb3B0cyAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdvcHRzIG11c3QgYmUgYW4gb2JqZWN0LicpXG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzW2tEZXN0cm95ZWRdIHx8IHRoaXNba09uRGVzdHJveWVkXSkge1xuICAgICAgICB0aHJvdyBuZXcgQ2xpZW50RGVzdHJveWVkRXJyb3IoKVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpc1trQ2xvc2VkXSkge1xuICAgICAgICB0aHJvdyBuZXcgQ2xpZW50Q2xvc2VkRXJyb3IoKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpc1trSW50ZXJjZXB0ZWREaXNwYXRjaF0ob3B0cywgaGFuZGxlcilcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmICh0eXBlb2YgaGFuZGxlci5vbkVycm9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBvbkVycm9yIG1ldGhvZCcpXG4gICAgICB9XG5cbiAgICAgIGhhbmRsZXIub25FcnJvcihlcnIpXG5cbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IERpc3BhdGNoZXJCYXNlXG4iXSwibmFtZXMiOlsiRGlzcGF0Y2hlciIsInJlcXVpcmUiLCJDbGllbnREZXN0cm95ZWRFcnJvciIsIkNsaWVudENsb3NlZEVycm9yIiwiSW52YWxpZEFyZ3VtZW50RXJyb3IiLCJrRGVzdHJveSIsImtDbG9zZSIsImtDbG9zZWQiLCJrRGVzdHJveWVkIiwia0Rpc3BhdGNoIiwia0ludGVyY2VwdG9ycyIsImtPbkRlc3Ryb3llZCIsIlN5bWJvbCIsImtPbkNsb3NlZCIsImtJbnRlcmNlcHRlZERpc3BhdGNoIiwiRGlzcGF0Y2hlckJhc2UiLCJjb25zdHJ1Y3RvciIsImRlc3Ryb3llZCIsImNsb3NlZCIsImludGVyY2VwdG9ycyIsIm5ld0ludGVyY2VwdG9ycyIsImkiLCJsZW5ndGgiLCJpbnRlcmNlcHRvciIsImNsb3NlIiwiY2FsbGJhY2siLCJ1bmRlZmluZWQiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsImVyciIsImRhdGEiLCJxdWV1ZU1pY3JvdGFzayIsInB1c2giLCJvbkNsb3NlZCIsImNhbGxiYWNrcyIsInRoZW4iLCJkZXN0cm95Iiwib25EZXN0cm95ZWQiLCJvcHRzIiwiaGFuZGxlciIsImRpc3BhdGNoIiwiYmluZCIsIm9uRXJyb3IiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/dispatcher/dispatcher-base.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/dispatcher/dispatcher.js":
/*!**********************************************************!*\
  !*** ./node_modules/undici/lib/dispatcher/dispatcher.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst EventEmitter = __webpack_require__(/*! node:events */ \"node:events\");\nclass Dispatcher extends EventEmitter {\n    dispatch() {\n        throw new Error(\"not implemented\");\n    }\n    close() {\n        throw new Error(\"not implemented\");\n    }\n    destroy() {\n        throw new Error(\"not implemented\");\n    }\n    compose(...args) {\n        // So we handle [interceptor1, interceptor2] or interceptor1, interceptor2, ...\n        const interceptors = Array.isArray(args[0]) ? args[0] : args;\n        let dispatch = this.dispatch.bind(this);\n        for (const interceptor of interceptors){\n            if (interceptor == null) {\n                continue;\n            }\n            if (typeof interceptor !== \"function\") {\n                throw new TypeError(`invalid interceptor, expected function received ${typeof interceptor}`);\n            }\n            dispatch = interceptor(dispatch);\n            if (dispatch == null || typeof dispatch !== \"function\" || dispatch.length !== 2) {\n                throw new TypeError(\"invalid interceptor\");\n            }\n        }\n        return new ComposedDispatcher(this, dispatch);\n    }\n}\nclass ComposedDispatcher extends Dispatcher {\n    #dispatcher;\n    #dispatch;\n    constructor(dispatcher, dispatch){\n        super();\n        this.#dispatcher = null;\n        this.#dispatch = null;\n        this.#dispatcher = dispatcher;\n        this.#dispatch = dispatch;\n    }\n    dispatch(...args) {\n        this.#dispatch(...args);\n    }\n    close(...args) {\n        return this.#dispatcher.close(...args);\n    }\n    destroy(...args) {\n        return this.#dispatcher.destroy(...args);\n    }\n}\nmodule.exports = Dispatcher;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9kaXNwYXRjaGVyL2Rpc3BhdGNoZXIuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxNQUFNQSxlQUFlQyxtQkFBT0EsQ0FBQztBQUU3QixNQUFNQyxtQkFBbUJGO0lBQ3ZCRyxXQUFZO1FBQ1YsTUFBTSxJQUFJQyxNQUFNO0lBQ2xCO0lBRUFDLFFBQVM7UUFDUCxNQUFNLElBQUlELE1BQU07SUFDbEI7SUFFQUUsVUFBVztRQUNULE1BQU0sSUFBSUYsTUFBTTtJQUNsQjtJQUVBRyxRQUFTLEdBQUdDLElBQUksRUFBRTtRQUNoQjtRQUNBLE1BQU1DLGVBQWVDLE1BQU1DLE9BQU8sQ0FBQ0gsSUFBSSxDQUFDLEVBQUUsSUFBSUEsSUFBSSxDQUFDLEVBQUUsR0FBR0E7UUFDeEQsSUFBSUwsV0FBVyxJQUFJLENBQUNBLFFBQVEsQ0FBQ1MsSUFBSSxDQUFDLElBQUk7UUFFdEMsS0FBSyxNQUFNQyxlQUFlSixhQUFjO1lBQ3RDLElBQUlJLGVBQWUsTUFBTTtnQkFDdkI7WUFDRjtZQUVBLElBQUksT0FBT0EsZ0JBQWdCLFlBQVk7Z0JBQ3JDLE1BQU0sSUFBSUMsVUFBVSxtREFBbUQsT0FBT0QsWUFBVyxDQUFFO1lBQzdGO1lBRUFWLFdBQVdVLFlBQVlWO1lBRXZCLElBQUlBLFlBQVksUUFBUSxPQUFPQSxhQUFhLGNBQWNBLFNBQVNZLE1BQU0sS0FBSyxHQUFHO2dCQUMvRSxNQUFNLElBQUlELFVBQVU7WUFDdEI7UUFDRjtRQUVBLE9BQU8sSUFBSUUsbUJBQW1CLElBQUksRUFBRWI7SUFDdEM7QUFDRjtBQUVBLE1BQU1hLDJCQUEyQmQ7SUFDL0IsQ0FBQ2UsVUFBVSxDQUFPO0lBQ2xCLENBQUNkLFFBQVEsQ0FBTztJQUVoQmUsWUFBYUQsVUFBVSxFQUFFZCxRQUFRLENBQUU7UUFDakMsS0FBSzthQUpQLENBQUNjLFVBQVUsR0FBRzthQUNkLENBQUNkLFFBQVEsR0FBRztRQUlWLElBQUksQ0FBQyxDQUFDYyxVQUFVLEdBQUdBO1FBQ25CLElBQUksQ0FBQyxDQUFDZCxRQUFRLEdBQUdBO0lBQ25CO0lBRUFBLFNBQVUsR0FBR0ssSUFBSSxFQUFFO1FBQ2pCLElBQUksQ0FBQyxDQUFDTCxRQUFRLElBQUlLO0lBQ3BCO0lBRUFILE1BQU8sR0FBR0csSUFBSSxFQUFFO1FBQ2QsT0FBTyxJQUFJLENBQUMsQ0FBQ1MsVUFBVSxDQUFDWixLQUFLLElBQUlHO0lBQ25DO0lBRUFGLFFBQVMsR0FBR0UsSUFBSSxFQUFFO1FBQ2hCLE9BQU8sSUFBSSxDQUFDLENBQUNTLFVBQVUsQ0FBQ1gsT0FBTyxJQUFJRTtJQUNyQztBQUNGO0FBRUFXLE9BQU9DLE9BQU8sR0FBR2xCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbW9ja3VwZmxvdy8uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2Rpc3BhdGNoZXIvZGlzcGF0Y2hlci5qcz84MDQyIiwid2VicGFjazovL21vY2t1cGZsb3cvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9kaXNwYXRjaGVyL2Rpc3BhdGNoZXIuanM/ODA0MioiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5jb25zdCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdub2RlOmV2ZW50cycpXG5cbmNsYXNzIERpc3BhdGNoZXIgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBkaXNwYXRjaCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKVxuICB9XG5cbiAgY2xvc2UgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJylcbiAgfVxuXG4gIGRlc3Ryb3kgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJylcbiAgfVxuXG4gIGNvbXBvc2UgKC4uLmFyZ3MpIHtcbiAgICAvLyBTbyB3ZSBoYW5kbGUgW2ludGVyY2VwdG9yMSwgaW50ZXJjZXB0b3IyXSBvciBpbnRlcmNlcHRvcjEsIGludGVyY2VwdG9yMiwgLi4uXG4gICAgY29uc3QgaW50ZXJjZXB0b3JzID0gQXJyYXkuaXNBcnJheShhcmdzWzBdKSA/IGFyZ3NbMF0gOiBhcmdzXG4gICAgbGV0IGRpc3BhdGNoID0gdGhpcy5kaXNwYXRjaC5iaW5kKHRoaXMpXG5cbiAgICBmb3IgKGNvbnN0IGludGVyY2VwdG9yIG9mIGludGVyY2VwdG9ycykge1xuICAgICAgaWYgKGludGVyY2VwdG9yID09IG51bGwpIHtcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBpbnRlcmNlcHRvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBpbnZhbGlkIGludGVyY2VwdG9yLCBleHBlY3RlZCBmdW5jdGlvbiByZWNlaXZlZCAke3R5cGVvZiBpbnRlcmNlcHRvcn1gKVxuICAgICAgfVxuXG4gICAgICBkaXNwYXRjaCA9IGludGVyY2VwdG9yKGRpc3BhdGNoKVxuXG4gICAgICBpZiAoZGlzcGF0Y2ggPT0gbnVsbCB8fCB0eXBlb2YgZGlzcGF0Y2ggIT09ICdmdW5jdGlvbicgfHwgZGlzcGF0Y2gubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgaW50ZXJjZXB0b3InKVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBuZXcgQ29tcG9zZWREaXNwYXRjaGVyKHRoaXMsIGRpc3BhdGNoKVxuICB9XG59XG5cbmNsYXNzIENvbXBvc2VkRGlzcGF0Y2hlciBleHRlbmRzIERpc3BhdGNoZXIge1xuICAjZGlzcGF0Y2hlciA9IG51bGxcbiAgI2Rpc3BhdGNoID0gbnVsbFxuXG4gIGNvbnN0cnVjdG9yIChkaXNwYXRjaGVyLCBkaXNwYXRjaCkge1xuICAgIHN1cGVyKClcbiAgICB0aGlzLiNkaXNwYXRjaGVyID0gZGlzcGF0Y2hlclxuICAgIHRoaXMuI2Rpc3BhdGNoID0gZGlzcGF0Y2hcbiAgfVxuXG4gIGRpc3BhdGNoICguLi5hcmdzKSB7XG4gICAgdGhpcy4jZGlzcGF0Y2goLi4uYXJncylcbiAgfVxuXG4gIGNsb3NlICguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuI2Rpc3BhdGNoZXIuY2xvc2UoLi4uYXJncylcbiAgfVxuXG4gIGRlc3Ryb3kgKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy4jZGlzcGF0Y2hlci5kZXN0cm95KC4uLmFyZ3MpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBEaXNwYXRjaGVyXG4iXSwibmFtZXMiOlsiRXZlbnRFbWl0dGVyIiwicmVxdWlyZSIsIkRpc3BhdGNoZXIiLCJkaXNwYXRjaCIsIkVycm9yIiwiY2xvc2UiLCJkZXN0cm95IiwiY29tcG9zZSIsImFyZ3MiLCJpbnRlcmNlcHRvcnMiLCJBcnJheSIsImlzQXJyYXkiLCJiaW5kIiwiaW50ZXJjZXB0b3IiLCJUeXBlRXJyb3IiLCJsZW5ndGgiLCJDb21wb3NlZERpc3BhdGNoZXIiLCJkaXNwYXRjaGVyIiwiY29uc3RydWN0b3IiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/dispatcher/dispatcher.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/dispatcher/env-http-proxy-agent.js":
/*!********************************************************************!*\
  !*** ./node_modules/undici/lib/dispatcher/env-http-proxy-agent.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst DispatcherBase = __webpack_require__(/*! ./dispatcher-base */ \"(ssr)/./node_modules/undici/lib/dispatcher/dispatcher-base.js\");\nconst { kClose, kDestroy, kClosed, kDestroyed, kDispatch, kNoProxyAgent, kHttpProxyAgent, kHttpsProxyAgent } = __webpack_require__(/*! ../core/symbols */ \"(ssr)/./node_modules/undici/lib/core/symbols.js\");\nconst ProxyAgent = __webpack_require__(/*! ./proxy-agent */ \"(ssr)/./node_modules/undici/lib/dispatcher/proxy-agent.js\");\nconst Agent = __webpack_require__(/*! ./agent */ \"(ssr)/./node_modules/undici/lib/dispatcher/agent.js\");\nconst DEFAULT_PORTS = {\n    \"http:\": 80,\n    \"https:\": 443\n};\nlet experimentalWarned = false;\nclass EnvHttpProxyAgent extends DispatcherBase {\n    #noProxyValue;\n    #noProxyEntries;\n    #opts;\n    constructor(opts = {}){\n        super();\n        this.#noProxyValue = null;\n        this.#noProxyEntries = null;\n        this.#opts = null;\n        this.#opts = opts;\n        if (!experimentalWarned) {\n            experimentalWarned = true;\n            process.emitWarning(\"EnvHttpProxyAgent is experimental, expect them to change at any time.\", {\n                code: \"UNDICI-EHPA\"\n            });\n        }\n        const { httpProxy, httpsProxy, noProxy, ...agentOpts } = opts;\n        this[kNoProxyAgent] = new Agent(agentOpts);\n        const HTTP_PROXY = httpProxy ?? process.env.http_proxy ?? process.env.HTTP_PROXY;\n        if (HTTP_PROXY) {\n            this[kHttpProxyAgent] = new ProxyAgent({\n                ...agentOpts,\n                uri: HTTP_PROXY\n            });\n        } else {\n            this[kHttpProxyAgent] = this[kNoProxyAgent];\n        }\n        const HTTPS_PROXY = httpsProxy ?? process.env.https_proxy ?? process.env.HTTPS_PROXY;\n        if (HTTPS_PROXY) {\n            this[kHttpsProxyAgent] = new ProxyAgent({\n                ...agentOpts,\n                uri: HTTPS_PROXY\n            });\n        } else {\n            this[kHttpsProxyAgent] = this[kHttpProxyAgent];\n        }\n        this.#parseNoProxy();\n    }\n    [kDispatch](opts, handler) {\n        const url = new URL(opts.origin);\n        const agent = this.#getProxyAgentForUrl(url);\n        return agent.dispatch(opts, handler);\n    }\n    async [kClose]() {\n        await this[kNoProxyAgent].close();\n        if (!this[kHttpProxyAgent][kClosed]) {\n            await this[kHttpProxyAgent].close();\n        }\n        if (!this[kHttpsProxyAgent][kClosed]) {\n            await this[kHttpsProxyAgent].close();\n        }\n    }\n    async [kDestroy](err) {\n        await this[kNoProxyAgent].destroy(err);\n        if (!this[kHttpProxyAgent][kDestroyed]) {\n            await this[kHttpProxyAgent].destroy(err);\n        }\n        if (!this[kHttpsProxyAgent][kDestroyed]) {\n            await this[kHttpsProxyAgent].destroy(err);\n        }\n    }\n    #getProxyAgentForUrl(url) {\n        let { protocol, host: hostname, port } = url;\n        // Stripping ports in this way instead of using parsedUrl.hostname to make\n        // sure that the brackets around IPv6 addresses are kept.\n        hostname = hostname.replace(/:\\d*$/, \"\").toLowerCase();\n        port = Number.parseInt(port, 10) || DEFAULT_PORTS[protocol] || 0;\n        if (!this.#shouldProxy(hostname, port)) {\n            return this[kNoProxyAgent];\n        }\n        if (protocol === \"https:\") {\n            return this[kHttpsProxyAgent];\n        }\n        return this[kHttpProxyAgent];\n    }\n    #shouldProxy(hostname, port) {\n        if (this.#noProxyChanged) {\n            this.#parseNoProxy();\n        }\n        if (this.#noProxyEntries.length === 0) {\n            return true; // Always proxy if NO_PROXY is not set or empty.\n        }\n        if (this.#noProxyValue === \"*\") {\n            return false; // Never proxy if wildcard is set.\n        }\n        for(let i = 0; i < this.#noProxyEntries.length; i++){\n            const entry = this.#noProxyEntries[i];\n            if (entry.port && entry.port !== port) {\n                continue; // Skip if ports don't match.\n            }\n            if (!/^[.*]/.test(entry.hostname)) {\n                // No wildcards, so don't proxy only if there is not an exact match.\n                if (hostname === entry.hostname) {\n                    return false;\n                }\n            } else {\n                // Don't proxy if the hostname ends with the no_proxy host.\n                if (hostname.endsWith(entry.hostname.replace(/^\\*/, \"\"))) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    #parseNoProxy() {\n        const noProxyValue = this.#opts.noProxy ?? this.#noProxyEnv;\n        const noProxySplit = noProxyValue.split(/[,\\s]/);\n        const noProxyEntries = [];\n        for(let i = 0; i < noProxySplit.length; i++){\n            const entry = noProxySplit[i];\n            if (!entry) {\n                continue;\n            }\n            const parsed = entry.match(/^(.+):(\\d+)$/);\n            noProxyEntries.push({\n                hostname: (parsed ? parsed[1] : entry).toLowerCase(),\n                port: parsed ? Number.parseInt(parsed[2], 10) : 0\n            });\n        }\n        this.#noProxyValue = noProxyValue;\n        this.#noProxyEntries = noProxyEntries;\n    }\n    get #noProxyChanged() {\n        if (this.#opts.noProxy !== undefined) {\n            return false;\n        }\n        return this.#noProxyValue !== this.#noProxyEnv;\n    }\n    get #noProxyEnv() {\n        return process.env.no_proxy ?? process.env.NO_PROXY ?? \"\";\n    }\n}\nmodule.exports = EnvHttpProxyAgent;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9kaXNwYXRjaGVyL2Vudi1odHRwLXByb3h5LWFnZW50LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTUEsaUJBQWlCQyxtQkFBT0EsQ0FBQztBQUMvQixNQUFNLEVBQUVDLE1BQU0sRUFBRUMsUUFBUSxFQUFFQyxPQUFPLEVBQUVDLFVBQVUsRUFBRUMsU0FBUyxFQUFFQyxhQUFhLEVBQUVDLGVBQWUsRUFBRUMsZ0JBQUFBLEVBQWtCLEdBQUdSLG1CQUFPQSxDQUFDO0FBQ3ZILE1BQU1TLGFBQWFULG1CQUFPQSxDQUFDO0FBQzNCLE1BQU1VLFFBQVFWLG1CQUFPQSxDQUFDO0FBRXRCLE1BQU1XLGdCQUFnQjtJQUNwQixTQUFTO0lBQ1QsVUFBVTtBQUNaO0FBRUEsSUFBSUMscUJBQXFCO0FBRXpCLE1BQU1DLDBCQUEwQmQ7SUFDOUIsQ0FBQ2UsWUFBWSxDQUFPO0lBQ3BCLENBQUNDLGNBQWMsQ0FBTztJQUN0QixDQUFDQyxJQUFJLENBQU87SUFFWkMsWUFBYUQsT0FBTyxDQUFDLENBQUMsQ0FBRTtRQUN0QixLQUFLO2FBTFAsQ0FBQ0YsWUFBWSxHQUFHO2FBQ2hCLENBQUNDLGNBQWMsR0FBRzthQUNsQixDQUFDQyxJQUFJLEdBQUc7UUFJTixJQUFJLENBQUMsQ0FBQ0EsSUFBSSxHQUFHQTtRQUViLElBQUksQ0FBQ0osb0JBQW9CO1lBQ3ZCQSxxQkFBcUI7WUFDckJNLFFBQVFDLFdBQVcsQ0FBQyx5RUFBeUU7Z0JBQzNGQyxNQUFNO1lBQ1I7UUFDRjtRQUVBLE1BQU0sRUFBRUMsU0FBUyxFQUFFQyxVQUFVLEVBQUVDLE9BQU8sRUFBRSxHQUFHQyxXQUFXLEdBQUdSO1FBRXpELElBQUksQ0FBQ1YsY0FBYyxHQUFHLElBQUlJLE1BQU1jO1FBRWhDLE1BQU1DLGFBQWFKLGFBQWFILFFBQVFRLEdBQUcsQ0FBQ0MsVUFBVSxJQUFJVCxRQUFRUSxHQUFHLENBQUNELFVBQVU7UUFDaEYsSUFBSUEsWUFBWTtZQUNk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QUdBO1FBQ3JCLElBQUksQ0FBQyxDQUFDQyxjQUFjLEdBQUdBO0lBQ3pCO0lBRUEsSUFBSSxDQUFDc0MsY0FBY2E7UUFDakIsSUFBSSxJQUFJLENBQUMsQ0FBQ2xELElBQUksQ0FBQ08sT0FBTyxLQUFLNEMsV0FBVztZQUNwQyxPQUFPO1FBQ1Q7UUFDQSxPQUFPLElBQUksQ0FBQyxDQUFDckQsWUFBWSxLQUFLLElBQUksQ0FBQyxDQUFDOEMsVUFBVTtJQUNoRDtJQUVBLElBQUksQ0FBQ0EsVUFBVVE7UUFDYixPQUFPbEQsUUFBUVEsR0FBRyxDQUFDMkMsUUFBUSxJQUFJbkQsUUFBUVEsR0FBRyxDQUFDNEMsUUFBUSxJQUFJO0lBQ3pEO0FBQ0Y7QUFFQUMsT0FBT0MsT0FBTyxHQUFHM0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tb2NrdXBmbG93Ly4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvZGlzcGF0Y2hlci9lbnYtaHR0cC1wcm94eS1hZ2VudC5qcz82NTgzIiwid2VicGFjazovL21vY2t1cGZsb3cvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9kaXNwYXRjaGVyL2Vudi1odHRwLXByb3h5LWFnZW50LmpzPzY1ODMqIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBEaXNwYXRjaGVyQmFzZSA9IHJlcXVpcmUoJy4vZGlzcGF0Y2hlci1iYXNlJylcbmNvbnN0IHsga0Nsb3NlLCBrRGVzdHJveSwga0Nsb3NlZCwga0Rlc3Ryb3llZCwga0Rpc3BhdGNoLCBrTm9Qcm94eUFnZW50LCBrSHR0cFByb3h5QWdlbnQsIGtIdHRwc1Byb3h5QWdlbnQgfSA9IHJlcXVpcmUoJy4uL2NvcmUvc3ltYm9scycpXG5jb25zdCBQcm94eUFnZW50ID0gcmVxdWlyZSgnLi9wcm94eS1hZ2VudCcpXG5jb25zdCBBZ2VudCA9IHJlcXVpcmUoJy4vYWdlbnQnKVxuXG5jb25zdCBERUZBVUxUX1BPUlRTID0ge1xuICAnaHR0cDonOiA4MCxcbiAgJ2h0dHBzOic6IDQ0M1xufVxuXG5sZXQgZXhwZXJpbWVudGFsV2FybmVkID0gZmFsc2VcblxuY2xhc3MgRW52SHR0cFByb3h5QWdlbnQgZXh0ZW5kcyBEaXNwYXRjaGVyQmFzZSB7XG4gICNub1Byb3h5VmFsdWUgPSBudWxsXG4gICNub1Byb3h5RW50cmllcyA9IG51bGxcbiAgI29wdHMgPSBudWxsXG5cbiAgY29uc3RydWN0b3IgKG9wdHMgPSB7fSkge1xuICAgIHN1cGVyKClcbiAgICB0aGlzLiNvcHRzID0gb3B0c1xuXG4gICAgaWYgKCFleHBlcmltZW50YWxXYXJuZWQpIHtcbiAgICAgIGV4cGVyaW1lbnRhbFdhcm5lZCA9IHRydWVcbiAgICAgIHByb2Nlc3MuZW1pdFdhcm5pbmcoJ0Vudkh0dHBQcm94eUFnZW50IGlzIGV4cGVyaW1lbnRhbCwgZXhwZWN0IHRoZW0gdG8gY2hhbmdlIGF0IGFueSB0aW1lLicsIHtcbiAgICAgICAgY29kZTogJ1VORElDSS1FSFBBJ1xuICAgICAgfSlcbiAgICB9XG5cbiAgICBjb25zdCB7IGh0dHBQcm94eSwgaHR0cHNQcm94eSwgbm9Qcm94eSwgLi4uYWdlbnRPcHRzIH0gPSBvcHRzXG5cbiAgICB0aGlzW2tOb1Byb3h5QWdlbnRdID0gbmV3IEFnZW50KGFnZW50T3B0cylcblxuICAgIGNvbnN0IEhUVFBfUFJPWFkgPSBodHRwUHJveHkgPz8gcHJvY2Vzcy5lbnYuaHR0cF9wcm94eSA/PyBwcm9jZXNzLmVudi5IVFRQX1BST1hZXG4gICAgaWYgKEhUVFBfUFJPWFkpIHtcbiAgICAgIHRoaXNba0h0dHBQcm94eUFnZW50XSA9IG5ldyBQcm94eUFnZW50KHsgLi4uYWdlbnRPcHRzLCB1cmk6IEhUVFBfUFJPWFkgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpc1trSHR0cFByb3h5QWdlbnRdID0gdGhpc1trTm9Qcm94eUFnZW50XVxuICAgIH1cblxuICAgIGNvbnN0IEhUVFBTX1BST1hZID0gaHR0cHNQcm94eSA/PyBwcm9jZXNzLmVudi5odHRwc19wcm94eSA/PyBwcm9jZXNzLmVudi5IVFRQU19QUk9YWVxuICAgIGlmIChIVFRQU19QUk9YWSkge1xuICAgICAgdGhpc1trSHR0cHNQcm94eUFnZW50XSA9IG5ldyBQcm94eUFnZW50KHsgLi4uYWdlbnRPcHRzLCB1cmk6IEhUVFBTX1BST1hZIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXNba0h0dHBzUHJveHlBZ2VudF0gPSB0aGlzW2tIdHRwUHJveHlBZ2VudF1cbiAgICB9XG5cbiAgICB0aGlzLiNwYXJzZU5vUHJveHkoKVxuICB9XG5cbiAgW2tEaXNwYXRjaF0gKG9wdHMsIGhhbmRsZXIpIHtcbiAgICBjb25zdCB1cmwgPSBuZXcgVVJMKG9wdHMub3JpZ2luKVxuICAgIGNvbnN0IGFnZW50ID0gdGhpcy4jZ2V0UHJveHlBZ2VudEZvclVybCh1cmwpXG4gICAgcmV0dXJuIGFnZW50LmRpc3BhdGNoKG9wdHMsIGhhbmRsZXIpXG4gIH1cblxuICBhc3luYyBba0Nsb3NlXSAoKSB7XG4gICAgYXdhaXQgdGhpc1trTm9Qcm94eUFnZW50XS5jbG9zZSgpXG4gICAgaWYgKCF0aGlzW2tIdHRwUHJveHlBZ2VudF1ba0Nsb3NlZF0pIHtcbiAgICAgIGF3YWl0IHRoaXNba0h0dHBQcm94eUFnZW50XS5jbG9zZSgpXG4gICAgfVxuICAgIGlmICghdGhpc1trSHR0cHNQcm94eUFnZW50XVtrQ2xvc2VkXSkge1xuICAgICAgYXdhaXQgdGhpc1trSHR0cHNQcm94eUFnZW50XS5jbG9zZSgpXG4gICAgfVxuICB9XG5cbiAgYXN5bmMgW2tEZXN0cm95XSAoZXJyKSB7XG4gICAgYXdhaXQgdGhpc1trTm9Qcm94eUFnZW50XS5kZXN0cm95KGVycilcbiAgICBpZiAoIXRoaXNba0h0dHBQcm94eUFnZW50XVtrRGVzdHJveWVkXSkge1xuICAgICAgYXdhaXQgdGhpc1trSHR0cFByb3h5QWdlbnRdLmRlc3Ryb3koZXJyKVxuICAgIH1cbiAgICBpZiAoIXRoaXNba0h0dHBzUHJveHlBZ2VudF1ba0Rlc3Ryb3llZF0pIHtcbiAgICAgIGF3YWl0IHRoaXNba0h0dHBzUHJveHlBZ2VudF0uZGVzdHJveShlcnIpXG4gICAgfVxuICB9XG5cbiAgI2dldFByb3h5QWdlbnRGb3JVcmwgKHVybCkge1xuICAgIGxldCB7IHByb3RvY29sLCBob3N0OiBob3N0bmFtZSwgcG9ydCB9ID0gdXJsXG5cbiAgICAvLyBTdHJpcHBpbmcgcG9ydHMgaW4gdGhpcyB3YXkgaW5zdGVhZCBvZiB1c2luZyBwYXJzZWRVcmwuaG9zdG5hbWUgdG8gbWFrZVxuICAgIC8vIHN1cmUgdGhhdCB0aGUgYnJhY2tldHMgYXJvdW5kIElQdjYgYWRkcmVzc2VzIGFyZSBrZXB0LlxuICAgIGhvc3RuYW1lID0gaG9zdG5hbWUucmVwbGFjZSgvOlxcZCokLywgJycpLnRvTG93ZXJDYXNlKClcbiAgICBwb3J0ID0gTnVtYmVyLnBhcnNlSW50KHBvcnQsIDEwKSB8fCBERUZBVUxUX1BPUlRTW3Byb3RvY29sXSB8fCAwXG4gICAgaWYgKCF0aGlzLiNzaG91bGRQcm94eShob3N0bmFtZSwgcG9ydCkpIHtcbiAgICAgIHJldHVybiB0aGlzW2tOb1Byb3h5QWdlbnRdXG4gICAgfVxuICAgIGlmIChwcm90b2NvbCA9PT0gJ2h0dHBzOicpIHtcbiAgICAgIHJldHVybiB0aGlzW2tIdHRwc1Byb3h5QWdlbnRdXG4gICAgfVxuICAgIHJldHVybiB0aGlzW2tIdHRwUHJveHlBZ2VudF1cbiAgfVxuXG4gICNzaG91bGRQcm94eSAoaG9zdG5hbWUsIHBvcnQpIHtcbiAgICBpZiAodGhpcy4jbm9Qcm94eUNoYW5nZWQpIHtcbiAgICAgIHRoaXMuI3BhcnNlTm9Qcm94eSgpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuI25vUHJveHlFbnRyaWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRydWUgLy8gQWx3YXlzIHByb3h5IGlmIE5PX1BST1hZIGlzIG5vdCBzZXQgb3IgZW1wdHkuXG4gICAgfVxuICAgIGlmICh0aGlzLiNub1Byb3h5VmFsdWUgPT09ICcqJykge1xuICAgICAgcmV0dXJuIGZhbHNlIC8vIE5ldmVyIHByb3h5IGlmIHdpbGRjYXJkIGlzIHNldC5cbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuI25vUHJveHlFbnRyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBlbnRyeSA9IHRoaXMuI25vUHJveHlFbnRyaWVzW2ldXG4gICAgICBpZiAoZW50cnkucG9ydCAmJiBlbnRyeS5wb3J0ICE9PSBwb3J0KSB7XG4gICAgICAgIGNvbnRpbnVlIC8vIFNraXAgaWYgcG9ydHMgZG9uJ3QgbWF0Y2guXG4gICAgICB9XG4gICAgICBpZiAoIS9eWy4qXS8udGVzdChlbnRyeS5ob3N0bmFtZSkpIHtcbiAgICAgICAgLy8gTm8gd2lsZGNhcmRzLCBzbyBkb24ndCBwcm94eSBvbmx5IGlmIHRoZXJlIGlzIG5vdCBhbiBleGFjdCBtYXRjaC5cbiAgICAgICAgaWYgKGhvc3RuYW1lID09PSBlbnRyeS5ob3N0bmFtZSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBEb24ndCBwcm94eSBpZiB0aGUgaG9zdG5hbWUgZW5kcyB3aXRoIHRoZSBub19wcm94eSBob3N0LlxuICAgICAgICBpZiAoaG9zdG5hbWUuZW5kc1dpdGgoZW50cnkuaG9zdG5hbWUucmVwbGFjZSgvXlxcKi8sICcnKSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAjcGFyc2VOb1Byb3h5ICgpIHtcbiAgICBjb25zdCBub1Byb3h5VmFsdWUgPSB0aGlzLiNvcHRzLm5vUHJveHkgPz8gdGhpcy4jbm9Qcm94eUVudlxuICAgIGNvbnN0IG5vUHJveHlTcGxpdCA9IG5vUHJveHlWYWx1ZS5zcGxpdCgvWyxcXHNdLylcbiAgICBjb25zdCBub1Byb3h5RW50cmllcyA9IFtdXG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vUHJveHlTcGxpdC5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgZW50cnkgPSBub1Byb3h5U3BsaXRbaV1cbiAgICAgIGlmICghZW50cnkpIHtcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBhcnNlZCA9IGVudHJ5Lm1hdGNoKC9eKC4rKTooXFxkKykkLylcbiAgICAgIG5vUHJveHlFbnRyaWVzLnB1c2goe1xuICAgICAgICBob3N0bmFtZTogKHBhcnNlZCA/IHBhcnNlZFsxXSA6IGVudHJ5KS50b0xvd2VyQ2FzZSgpLFxuICAgICAgICBwb3J0OiBwYXJzZWQgPyBOdW1iZXIucGFyc2VJbnQocGFyc2VkWzJdLCAxMCkgOiAwXG4gICAgICB9KVxuICAgIH1cblxuICAgIHRoaXMuI25vUHJveHlWYWx1ZSA9IG5vUHJveHlWYWx1ZVxuICAgIHRoaXMuI25vUHJveHlFbnRyaWVzID0gbm9Qcm94eUVudHJpZXNcbiAgfVxuXG4gIGdldCAjbm9Qcm94eUNoYW5nZWQgKCkge1xuICAgIGlmICh0aGlzLiNvcHRzLm5vUHJveHkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIHJldHVybiB0aGlzLiNub1Byb3h5VmFsdWUgIT09IHRoaXMuI25vUHJveHlFbnZcbiAgfVxuXG4gIGdldCAjbm9Qcm94eUVudiAoKSB7XG4gICAgcmV0dXJuIHByb2Nlc3MuZW52Lm5vX3Byb3h5ID8/IHByb2Nlc3MuZW52Lk5PX1BST1hZID8/ICcnXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBFbnZIdHRwUHJveHlBZ2VudFxuIl0sIm5hbWVzIjpbIkRpc3BhdGNoZXJCYXNlIiwicmVxdWlyZSIsImtDbG9zZSIsImtEZXN0cm95Iiwia0Nsb3NlZCIsImtEZXN0cm95ZWQiLCJrRGlzcGF0Y2giLCJrTm9Qcm94eUFnZW50Iiwia0h0dHBQcm94eUFnZW50Iiwia0h0dHBzUHJveHlBZ2VudCIsIlByb3h5QWdlbnQiLCJBZ2VudCIsIkRFRkFVTFRfUE9SVFMiLCJleHBlcmltZW50YWxXYXJuZWQiLCJFbnZIdHRwUHJveHlBZ2VudCIsIm5vUHJveHlWYWx1ZSIsIm5vUHJveHlFbnRyaWVzIiwib3B0cyIsImNvbnN0cnVjdG9yIiwicHJvY2VzcyIsImVtaXRXYXJuaW5nIiwiY29kZSIsImh0dHBQcm94eSIsImh0dHBzUHJveHkiLCJub1Byb3h5IiwiYWdlbnRPcHRzIiwiSFRUUF9QUk9YWSIsImVudiIsImh0dHBfcHJveHkiLCJ1cmkiLCJIVFRQU19QUk9YWSIsImh0dHBzX3Byb3h5IiwicGFyc2VOb1Byb3h5IiwiaGFuZGxlciIsInVybCIsIlVSTCIsIm9yaWdpbiIsImFnZW50IiwiZ2V0UHJveHlBZ2VudEZvclVybCIsImRpc3BhdGNoIiwiY2xvc2UiLCJlcnIiLCJkZXN0cm95IiwiI2dldFByb3h5QWdlbnRGb3JVcmwiLCJwcm90b2NvbCIsImhvc3QiLCJob3N0bmFtZSIsInBvcnQiLCJyZXBsYWNlIiwidG9Mb3dlckNhc2UiLCJOdW1iZXIiLCJwYXJzZUludCIsInNob3VsZFByb3h5IiwiI3Nob3VsZFByb3h5Iiwibm9Qcm94eUNoYW5nZWQiLCJsZW5ndGgiLCJpIiwiZW50cnkiLCJ0ZXN0IiwiZW5kc1dpdGgiLCIjcGFyc2VOb1Byb3h5Iiwibm9Qcm94eUVudiIsIm5vUHJveHlTcGxpdCIsInNwbGl0IiwicGFyc2VkIiwibWF0Y2giLCJwdXNoIiwiI25vUHJveHlDaGFuZ2VkIiwidW5kZWZpbmVkIiwiI25vUHJveHlFbnYiLCJub19wcm94eSIsIk5PX1BST1hZIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/dispatcher/env-http-proxy-agent.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/dispatcher/fixed-queue.js":
/*!***********************************************************!*\
  !*** ./node_modules/undici/lib/dispatcher/fixed-queue.js ***!
  \***********************************************************/
/***/ ((module) => {

eval("/* eslint-disable */ \n// Extracted from node/lib/internal/fixed_queue.js\n// Currently optimal queue size, tested on V8 6.0 - 6.6. Must be power of two.\nconst kSize = 2048;\nconst kMask = kSize - 1;\n// The FixedQueue is implemented as a singly-linked list of fixed-size\n// circular buffers. It looks something like this:\n//\n//  head                                                       tail\n//    |                                                          |\n//    v                                                          v\n// +-----------+ <-----\\       +-----------+ <------\\         +-----------+\n// |  [null]   |        \\----- |   next    |         \\------- |   next    |\n// +-----------+               +-----------+                  +-----------+\n// |   item    | <-- bottom    |   item    | <-- bottom       |  [empty]  |\n// |   item    |               |   item    |                  |  [empty]  |\n// |   item    |               |   item    |                  |  [empty]  |\n// |   item    |               |   item    |                  |  [empty]  |\n// |   item    |               |   item    |       bottom --> |   item    |\n// |   item    |               |   item    |                  |   item    |\n// |    ...    |               |    ...    |                  |    ...    |\n// |   item    |               |   item    |                  |   item    |\n// |   item    |               |   item    |                  |   item    |\n// |  [empty]  | <-- top       |   item    |                  |   item    |\n// |  [empty]  |               |   item    |                  |   item    |\n// |  [empty]  |               |  [empty]  | <-- top  top --> |  [empty]  |\n// +-----------+               +-----------+                  +-----------+\n//\n// Or, if there is only one circular buffer, it looks something\n// like either of these:\n//\n//  head   tail                                 head   tail\n//    |     |                                     |     |\n//    v     v                                     v     v\n// +-----------+                               +-----------+\n// |  [null]   |                               |  [null]   |\n// +-----------+                               +-----------+\n// |  [empty]  |                               |   item    |\n// |  [empty]  |                               |   item    |\n// |   item    | <-- bottom            top --> |  [empty]  |\n// |   item    |                               |  [empty]  |\n// |  [empty]  | <-- top            bottom --> |   item    |\n// |  [empty]  |                               |   item    |\n// +-----------+                               +-----------+\n//\n// Adding a value means moving `top` forward by one, removing means\n// moving `bottom` forward by one. After reaching the end, the queue\n// wraps around.\n//\n// When `top === bottom` the current queue is empty and when\n// `top + 1 === bottom` it's full. This wastes a single space of storage\n// but allows much quicker checks.\nclass FixedCircularBuffer {\n    constructor(){\n        this.bottom = 0;\n        this.top = 0;\n        this.list = new Array(kSize);\n        this.next = null;\n    }\n    isEmpty() {\n        return this.top === this.bottom;\n    }\n    isFull() {\n        return (this.top + 1 & kMask) === this.bottom;\n    }\n    push(data) {\n        this.list[this.top] = data;\n        this.top = this.top + 1 & kMask;\n    }\n    shift() {\n        const nextItem = this.list[this.bottom];\n        if (nextItem === undefined) return null;\n        this.list[this.bottom] = undefined;\n        this.bottom = this.bottom + 1 & kMask;\n        return nextItem;\n    }\n}\nmodule.exports = class FixedQueue {\n    constructor(){\n        this.head = this.tail = new FixedCircularBuffer();\n    }\n    isEmpty() {\n        return this.head.isEmpty();\n    }\n    push(data) {\n        if (this.head.isFull()) {\n            // Head is full: Creates a new queue, sets the old queue's `.next` to it,\n            // and sets it as the new main queue.\n            this.head = this.head.next = new FixedCircularBuffer();\n        }\n        this.head.push(data);\n    }\n    shift() {\n        const tail = this.tail;\n        const next = tail.shift();\n        if (tail.isEmpty() && tail.next !== null) {\n            // If there is another queue, it forms the new tail.\n            this.tail = tail.next;\n        }\n        return next;\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9kaXNwYXRjaGVyL2ZpeGVkLXF1ZXVlLmpzIiwibWFwcGluZ3MiOiJBQUFBLHFCQUVBO0FBRUE7QUFFQTtBQUNBLE1BQU1BLFFBQVE7QUFDZCxNQUFNQyxRQUFRRCxRQUFRO0FBRXRCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQSxNQUFNRTtJQUNKQyxhQUFjO1FBQ1osSUFBSSxDQUFDQyxNQUFNLEdBQUc7UUFDZCxJQUFJLENBQUNDLEdBQUcsR0FBRztRQUNYLElBQUksQ0FBQ0MsSUFBSSxHQUFHLElBQUlDLE1BQU1QO1FBQ3RCLElBQUksQ0FBQ1EsSUFBSSxHQUFHO0lBQ2Q7SUFFQUMsVUFBVTtRQUNSLE9BQU8sSUFBSSxDQUFDSixHQUFHLEtBQUssSUFBSSxDQUFDRCxNQUFNO0lBQ2pDO0lBRUFNLFNBQVM7UUFDUCxPQUFPLENBQUUsSUFBSSxDQUFDTCxHQUFHLEdBQUcsSUFBS0osS0FBQUEsTUFBVyxJQUFJLENBQUNHLE1BQU07SUFDakQ7SUFFQU8sS0FBS0MsSUFBSSxFQUFFO1FBQ1QsSUFBSSxDQUFDTixJQUFJLENBQUMsSUFBSSxDQUFDRCxHQUFHLENBQUMsR0FBR087UUFDdEIsSUFBSSxDQUFDUCxHQUFHLEdBQUksSUFBSSxDQUFDQSxHQUFHLEdBQUcsSUFBS0o7SUFDOUI7SUFFQVksUUFBUTtRQUNOLE1BQU1DLFdBQVcsSUFBSSxDQUFDUixJQUFJLENBQUMsSUFBSSxDQUFDRixNQUFNLENBQUM7UUFDdkMsSUFBSVUsYUFBYUMsV0FDZixPQUFPO1FBQ1QsSUFBSSxDQUFDVCxJQUFJLENBQUMsSUFBSSxDQUFDRixNQUFNLENBQUMsR0FBR1c7UUFDekIsSUFBSSxDQUFDWCxNQUFNLEdBQUksSUFBSSxDQUFDQSxNQUFNLEdBQUcsSUFBS0g7UUFDbEMsT0FBT2E7SUFDVDtBQUNGO0FBRUFFLE9BQU9DLE9BQU8sR0FBRyxNQUFNQztJQUNyQmYsYUFBYztRQUNaLElBQUksQ0FBQ2dCLElBQUksR0FBRyxJQUFJLENBQUNDLElBQUksR0FBRyxJQUFJbEI7SUFDOUI7SUFFQU8sVUFBVTtRQUNSLE9BQU8sSUFBSSxDQUFDVSxJQUFJLENBQUNWLE9BQU87SUFDMUI7SUFFQUUsS0FBS0MsSUFBSSxFQUFFO1FBQ1QsSUFBSSxJQUFJLENBQUNPLElBQUksQ0FBQ1QsTUFBTSxJQUFJO1lBQ3RCO1lBQ0E7WUFDQSxJQUFJLENBQUNTLElBQUksR0FBRyxJQUFJLENBQUNBLElBQUksQ0FBQ1gsSUFBSSxHQUFHLElBQUlOO1FBQ25DO1FBQ0EsSUFBSSxDQUFDaUIsSUFBSSxDQUFDUixJQUFJLENBQUNDO0lBQ2pCO0lBRUFDLFFBQVE7UUFDTixNQUFNTyxPQUFPLElBQUksQ0FBQ0EsSUFBSTtRQUN0QixNQUFNWixPQUFPWSxLQUFLUCxLQUFLO1FBQ3ZCLElBQUlPLEtBQUtYLE9BQU8sTUFBTVcsS0FBS1osSUFBSSxLQUFLLE1BQU07WUFDeEM7WUFDQSxJQUFJLENBQUNZLElBQUksR0FBR0EsS0FBS1osSUFBSTtRQUN2QjtRQUNBLE9BQU9BO0lBQ1Q7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL21vY2t1cGZsb3cvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9kaXNwYXRjaGVyL2ZpeGVkLXF1ZXVlLmpzPzZkMjkiLCJ3ZWJwYWNrOi8vbW9ja3VwZmxvdy8uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2Rpc3BhdGNoZXIvZml4ZWQtcXVldWUuanM/NmQyOSoiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgKi9cblxuJ3VzZSBzdHJpY3QnXG5cbi8vIEV4dHJhY3RlZCBmcm9tIG5vZGUvbGliL2ludGVybmFsL2ZpeGVkX3F1ZXVlLmpzXG5cbi8vIEN1cnJlbnRseSBvcHRpbWFsIHF1ZXVlIHNpemUsIHRlc3RlZCBvbiBWOCA2LjAgLSA2LjYuIE11c3QgYmUgcG93ZXIgb2YgdHdvLlxuY29uc3Qga1NpemUgPSAyMDQ4O1xuY29uc3Qga01hc2sgPSBrU2l6ZSAtIDE7XG5cbi8vIFRoZSBGaXhlZFF1ZXVlIGlzIGltcGxlbWVudGVkIGFzIGEgc2luZ2x5LWxpbmtlZCBsaXN0IG9mIGZpeGVkLXNpemVcbi8vIGNpcmN1bGFyIGJ1ZmZlcnMuIEl0IGxvb2tzIHNvbWV0aGluZyBsaWtlIHRoaXM6XG4vL1xuLy8gIGhlYWQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFpbFxuLy8gICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4vLyAgICB2ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZcbi8vICstLS0tLS0tLS0tLSsgPC0tLS0tXFwgICAgICAgKy0tLS0tLS0tLS0tKyA8LS0tLS0tXFwgICAgICAgICArLS0tLS0tLS0tLS0rXG4vLyB8ICBbbnVsbF0gICB8ICAgICAgICBcXC0tLS0tIHwgICBuZXh0ICAgIHwgICAgICAgICBcXC0tLS0tLS0gfCAgIG5leHQgICAgfFxuLy8gKy0tLS0tLS0tLS0tKyAgICAgICAgICAgICAgICstLS0tLS0tLS0tLSsgICAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0rXG4vLyB8ICAgaXRlbSAgICB8IDwtLSBib3R0b20gICAgfCAgIGl0ZW0gICAgfCA8LS0gYm90dG9tICAgICAgIHwgIFtlbXB0eV0gIHxcbi8vIHwgICBpdGVtICAgIHwgICAgICAgICAgICAgICB8ICAgaXRlbSAgICB8ICAgICAgICAgICAgICAgICAgfCAgW2VtcHR5XSAgfFxuLy8gfCAgIGl0ZW0gICAgfCAgICAgICAgICAgICAgIHwgICBpdGVtICAgIHwgICAgICAgICAgICAgICAgICB8ICBbZW1wdHldICB8XG4vLyB8ICAgaXRlbSAgICB8ICAgICAgICAgICAgICAgfCAgIGl0ZW0gICAgfCAgICAgICAgICAgICAgICAgIHwgIFtlbXB0eV0gIHxcbi8vIHwgICBpdGVtICAgIHwgICAgICAgICAgICAgICB8ICAgaXRlbSAgICB8ICAgICAgIGJvdHRvbSAtLT4gfCAgIGl0ZW0gICAgfFxuLy8gfCAgIGl0ZW0gICAgfCAgICAgICAgICAgICAgIHwgICBpdGVtICAgIHwgICAgICAgICAgICAgICAgICB8ICAgaXRlbSAgICB8XG4vLyB8ICAgIC4uLiAgICB8ICAgICAgICAgICAgICAgfCAgICAuLi4gICAgfCAgICAgICAgICAgICAgICAgIHwgICAgLi4uICAgIHxcbi8vIHwgICBpdGVtICAgIHwgICAgICAgICAgICAgICB8ICAgaXRlbSAgICB8ICAgICAgICAgICAgICAgICAgfCAgIGl0ZW0gICAgfFxuLy8gfCAgIGl0ZW0gICAgfCAgICAgICAgICAgICAgIHwgICBpdGVtICAgIHwgICAgICAgICAgICAgICAgICB8ICAgaXRlbSAgICB8XG4vLyB8ICBbZW1wdHldICB8IDwtLSB0b3AgICAgICAgfCAgIGl0ZW0gICAgfCAgICAgICAgICAgICAgICAgIHwgICBpdGVtICAgIHxcbi8vIHwgIFtlbXB0eV0gIHwgICAgICAgICAgICAgICB8ICAgaXRlbSAgICB8ICAgICAgICAgICAgICAgICAgfCAgIGl0ZW0gICAgfFxuLy8gfCAgW2VtcHR5XSAgfCAgICAgICAgICAgICAgIHwgIFtlbXB0eV0gIHwgPC0tIHRvcCAgdG9wIC0tPiB8ICBbZW1wdHldICB8XG4vLyArLS0tLS0tLS0tLS0rICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tKyAgICAgICAgICAgICAgICAgICstLS0tLS0tLS0tLStcbi8vXG4vLyBPciwgaWYgdGhlcmUgaXMgb25seSBvbmUgY2lyY3VsYXIgYnVmZmVyLCBpdCBsb29rcyBzb21ldGhpbmdcbi8vIGxpa2UgZWl0aGVyIG9mIHRoZXNlOlxuLy9cbi8vICBoZWFkICAgdGFpbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWQgICB0YWlsXG4vLyAgICB8ICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHxcbi8vICAgIHYgICAgIHYgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdiAgICAgdlxuLy8gKy0tLS0tLS0tLS0tKyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0rXG4vLyB8ICBbbnVsbF0gICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgIFtudWxsXSAgIHxcbi8vICstLS0tLS0tLS0tLSsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tK1xuLy8gfCAgW2VtcHR5XSAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgaXRlbSAgICB8XG4vLyB8ICBbZW1wdHldICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICBpdGVtICAgIHxcbi8vIHwgICBpdGVtICAgIHwgPC0tIGJvdHRvbSAgICAgICAgICAgIHRvcCAtLT4gfCAgW2VtcHR5XSAgfFxuLy8gfCAgIGl0ZW0gICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICBbZW1wdHldICB8XG4vLyB8ICBbZW1wdHldICB8IDwtLSB0b3AgICAgICAgICAgICBib3R0b20gLS0+IHwgICBpdGVtICAgIHxcbi8vIHwgIFtlbXB0eV0gIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgIGl0ZW0gICAgfFxuLy8gKy0tLS0tLS0tLS0tKyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0rXG4vL1xuLy8gQWRkaW5nIGEgdmFsdWUgbWVhbnMgbW92aW5nIGB0b3BgIGZvcndhcmQgYnkgb25lLCByZW1vdmluZyBtZWFuc1xuLy8gbW92aW5nIGBib3R0b21gIGZvcndhcmQgYnkgb25lLiBBZnRlciByZWFjaGluZyB0aGUgZW5kLCB0aGUgcXVldWVcbi8vIHdyYXBzIGFyb3VuZC5cbi8vXG4vLyBXaGVuIGB0b3AgPT09IGJvdHRvbWAgdGhlIGN1cnJlbnQgcXVldWUgaXMgZW1wdHkgYW5kIHdoZW5cbi8vIGB0b3AgKyAxID09PSBib3R0b21gIGl0J3MgZnVsbC4gVGhpcyB3YXN0ZXMgYSBzaW5nbGUgc3BhY2Ugb2Ygc3RvcmFnZVxuLy8gYnV0IGFsbG93cyBtdWNoIHF1aWNrZXIgY2hlY2tzLlxuXG5jbGFzcyBGaXhlZENpcmN1bGFyQnVmZmVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5ib3R0b20gPSAwO1xuICAgIHRoaXMudG9wID0gMDtcbiAgICB0aGlzLmxpc3QgPSBuZXcgQXJyYXkoa1NpemUpO1xuICAgIHRoaXMubmV4dCA9IG51bGw7XG4gIH1cblxuICBpc0VtcHR5KCkge1xuICAgIHJldHVybiB0aGlzLnRvcCA9PT0gdGhpcy5ib3R0b207XG4gIH1cblxuICBpc0Z1bGwoKSB7XG4gICAgcmV0dXJuICgodGhpcy50b3AgKyAxKSAmIGtNYXNrKSA9PT0gdGhpcy5ib3R0b207XG4gIH1cblxuICBwdXNoKGRhdGEpIHtcbiAgICB0aGlzLmxpc3RbdGhpcy50b3BdID0gZGF0YTtcbiAgICB0aGlzLnRvcCA9ICh0aGlzLnRvcCArIDEpICYga01hc2s7XG4gIH1cblxuICBzaGlmdCgpIHtcbiAgICBjb25zdCBuZXh0SXRlbSA9IHRoaXMubGlzdFt0aGlzLmJvdHRvbV07XG4gICAgaWYgKG5leHRJdGVtID09PSB1bmRlZmluZWQpXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB0aGlzLmxpc3RbdGhpcy5ib3R0b21dID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuYm90dG9tID0gKHRoaXMuYm90dG9tICsgMSkgJiBrTWFzaztcbiAgICByZXR1cm4gbmV4dEl0ZW07XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBGaXhlZFF1ZXVlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbmV3IEZpeGVkQ2lyY3VsYXJCdWZmZXIoKTtcbiAgfVxuXG4gIGlzRW1wdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGVhZC5pc0VtcHR5KCk7XG4gIH1cblxuICBwdXNoKGRhdGEpIHtcbiAgICBpZiAodGhpcy5oZWFkLmlzRnVsbCgpKSB7XG4gICAgICAvLyBIZWFkIGlzIGZ1bGw6IENyZWF0ZXMgYSBuZXcgcXVldWUsIHNldHMgdGhlIG9sZCBxdWV1ZSdzIGAubmV4dGAgdG8gaXQsXG4gICAgICAvLyBhbmQgc2V0cyBpdCBhcyB0aGUgbmV3IG1haW4gcXVldWUuXG4gICAgICB0aGlzLmhlYWQgPSB0aGlzLmhlYWQubmV4dCA9IG5ldyBGaXhlZENpcmN1bGFyQnVmZmVyKCk7XG4gICAgfVxuICAgIHRoaXMuaGVhZC5wdXNoKGRhdGEpO1xuICB9XG5cbiAgc2hpZnQoKSB7XG4gICAgY29uc3QgdGFpbCA9IHRoaXMudGFpbDtcbiAgICBjb25zdCBuZXh0ID0gdGFpbC5zaGlmdCgpO1xuICAgIGlmICh0YWlsLmlzRW1wdHkoKSAmJiB0YWlsLm5leHQgIT09IG51bGwpIHtcbiAgICAgIC8vIElmIHRoZXJlIGlzIGFub3RoZXIgcXVldWUsIGl0IGZvcm1zIHRoZSBuZXcgdGFpbC5cbiAgICAgIHRoaXMudGFpbCA9IHRhaWwubmV4dDtcbiAgICB9XG4gICAgcmV0dXJuIG5leHQ7XG4gIH1cbn07XG4iXSwibmFtZXMiOlsia1NpemUiLCJrTWFzayIsIkZpeGVkQ2lyY3VsYXJCdWZmZXIiLCJjb25zdHJ1Y3RvciIsImJvdHRvbSIsInRvcCIsImxpc3QiLCJBcnJheSIsIm5leHQiLCJpc0VtcHR5IiwiaXNGdWxsIiwicHVzaCIsImRhdGEiLCJzaGlmdCIsIm5leHRJdGVtIiwidW5kZWZpbmVkIiwibW9kdWxlIiwiZXhwb3J0cyIsIkZpeGVkUXVldWUiLCJoZWFkIiwidGFpbCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/dispatcher/fixed-queue.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/dispatcher/pool-base.js":
/*!*********************************************************!*\
  !*** ./node_modules/undici/lib/dispatcher/pool-base.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst DispatcherBase = __webpack_require__(/*! ./dispatcher-base */ \"(ssr)/./node_modules/undici/lib/dispatcher/dispatcher-base.js\");\nconst FixedQueue = __webpack_require__(/*! ./fixed-queue */ \"(ssr)/./node_modules/undici/lib/dispatcher/fixed-queue.js\");\nconst { kConnected, kSize, kRunning, kPending, kQueued, kBusy, kFree, kUrl, kClose, kDestroy, kDispatch } = __webpack_require__(/*! ../core/symbols */ \"(ssr)/./node_modules/undici/lib/core/symbols.js\");\nconst PoolStats = __webpack_require__(/*! ./pool-stats */ \"(ssr)/./node_modules/undici/lib/dispatcher/pool-stats.js\");\nconst kClients = Symbol(\"clients\");\nconst kNeedDrain = Symbol(\"needDrain\");\nconst kQueue = Symbol(\"queue\");\nconst kClosedResolve = Symbol(\"closed resolve\");\nconst kOnDrain = Symbol(\"onDrain\");\nconst kOnConnect = Symbol(\"onConnect\");\nconst kOnDisconnect = Symbol(\"onDisconnect\");\nconst kOnConnectionError = Symbol(\"onConnectionError\");\nconst kGetDispatcher = Symbol(\"get dispatcher\");\nconst kAddClient = Symbol(\"add client\");\nconst kRemoveClient = Symbol(\"remove client\");\nconst kStats = Symbol(\"stats\");\nclass PoolBase extends DispatcherBase {\n    constructor(){\n        super();\n        this[kQueue] = new FixedQueue();\n        this[kClients] = [];\n        this[kQueued] = 0;\n        const pool = this;\n        this[kOnDrain] = function onDrain(origin, targets) {\n            const queue = pool[kQueue];\n            let needDrain = false;\n            while(!needDrain){\n                const item = queue.shift();\n                if (!item) {\n                    break;\n                }\n                pool[kQueued]--;\n                needDrain = !this.dispatch(item.opts, item.handler);\n            }\n            this[kNeedDrain] = needDrain;\n            if (!this[kNeedDrain] && pool[kNeedDrain]) {\n                pool[kNeedDrain] = false;\n                pool.emit(\"drain\", origin, [\n                    pool,\n                    ...targets\n                ]);\n            }\n            if (pool[kClosedResolve] && queue.isEmpty()) {\n                Promise.all(pool[kClients].map((c)=>c.close())).then(pool[kClosedResolve]);\n            }\n        };\n        this[kOnConnect] = (origin, targets)=>{\n            pool.emit(\"connect\", origin, [\n                pool,\n                ...targets\n            ]);\n        };\n        this[kOnDisconnect] = (origin, targets, err)=>{\n            pool.emit(\"disconnect\", origin, [\n                pool,\n                ...targets\n            ], err);\n        };\n        this[kOnConnectionError] = (origin, targets, err)=>{\n            pool.emit(\"connectionError\", origin, [\n                pool,\n                ...targets\n            ], err);\n        };\n        this[kStats] = new PoolStats(this);\n    }\n    get [kBusy]() {\n        return this[kNeedDrain];\n    }\n    get [kConnected]() {\n        return this[kClients].filter((client)=>client[kConnected]).length;\n    }\n    get [kFree]() {\n        return this[kClients].filter((client)=>client[kConnected] && !client[kNeedDrain]).length;\n    }\n    get [kPending]() {\n        let ret = this[kQueued];\n        for (const { [kPending]: pending } of this[kClients]){\n            ret += pending;\n        }\n        return ret;\n    }\n    get [kRunning]() {\n        let ret = 0;\n        for (const { [kRunning]: running } of this[kClients]){\n            ret += running;\n        }\n        return ret;\n    }\n    get [kSize]() {\n        let ret = this[kQueued];\n        for (const { [kSize]: size } of this[kClients]){\n            ret += size;\n        }\n        return ret;\n    }\n    get stats() {\n        return this[kStats];\n    }\n    async [kClose]() {\n        if (this[kQueue].isEmpty()) {\n            return Promise.all(this[kClients].map((c)=>c.close()));\n        } else {\n            return new Promise((resolve)=>{\n                this[kClosedResolve] = resolve;\n            });\n        }\n    }\n    async [kDestroy](err) {\n        while(true){\n            const item = this[kQueue].shift();\n            if (!item) {\n                break;\n            }\n            item.handler.onError(err);\n        }\n        return Promise.all(this[kClients].map((c)=>c.destroy(err)));\n    }\n    [kDispatch](opts, handler) {\n        const dispatcher = this[kGetDispatcher]();\n        if (!dispatcher) {\n            this[kNeedDrain] = true;\n            this[kQueue].push({\n                opts,\n                handler\n            });\n            this[kQueued]++;\n        } else if (!dispatcher.dispatch(opts, handler)) {\n            dispatcher[kNeedDrain] = true;\n            this[kNeedDrain] = !this[kGetDispatcher]();\n        }\n        return !this[kNeedDrain];\n    }\n    [kAddClient](client) {\n        client.on(\"drain\", this[kOnDrain]).on(\"connect\", this[kOnConnect]).on(\"disconnect\", this[kOnDisconnect]).on(\"connectionError\", this[kOnConnectionError]);\n        this[kClients].push(client);\n        if (this[kNeedDrain]) {\n            queueMicrotask(()=>{\n                if (this[kNeedDrain]) {\n                    this[kOnDrain](client[kUrl], [\n                        this,\n                        client\n                    ]);\n                }\n            });\n        }\n        return this;\n    }\n    [kRemoveClient](client) {\n        client.close(()=>{\n            const idx = this[kClients].indexOf(client);\n            if (idx !== -1) {\n                this[kClients].splice(idx, 1);\n            }\n        });\n        this[kNeedDrain] = this[kClients].some((dispatcher)=>!dispatcher[kNeedDrain] && dispatcher.closed !== true && dispatcher.destroyed !== true);\n    }\n}\nmodule.exports = {\n    PoolBase,\n    kClients,\n    kNeedDrain,\n    kAddClient,\n    kRemoveClient,\n    kGetDispatcher\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9kaXNwYXRjaGVyL3Bvb2wtYmFzZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU1BLGlCQUFpQkMsbUJBQU9BLENBQUM7QUFDL0IsTUFBTUMsYUFBYUQsbUJBQU9BLENBQUM7QUFDM0IsTUFBTSxFQUFFRSxVQUFVLEVBQUVDLEtBQUssRUFBRUMsUUFBUSxFQUFFQyxRQUFRLEVBQUVDLE9BQU8sRUFBRUMsS0FBSyxFQUFFQyxLQUFLLEVBQUVDLElBQUksRUFBRUMsTUFBTSxFQUFFQyxRQUFRLEVBQUVDLFNBQUFBLEVBQVcsR0FBR1osbUJBQU9BLENBQUM7QUFDcEgsTUFBTWEsWUFBWWIsbUJBQU9BLENBQUM7QUFFMUIsTUFBTWMsV0FBV0MsT0FBTztBQUN4QixNQUFNQyxhQUFhRCxPQUFPO0FBQzFCLE1BQU1FLFNBQVNGLE9BQU87QUFDdEIsTUFBTUcsaUJBQWlCSCxPQUFPO0FBQzlCLE1BQU1JLFdBQVdKLE9BQU87QUFDeEIsTUFBTUssYUFBYUwsT0FBTztBQUMxQixNQUFNTSxnQkFBZ0JOLE9BQU87QUFDN0IsTUFBTU8scUJBQXFCUCxPQUFPO0FBQ2xDLE1BQU1RLGlCQUFpQlIsT0FBTztBQUM5QixNQUFNUyxhQUFhVCxPQUFPO0FBQzFCLE1BQU1VLGdCQUFnQlYsT0FBTztBQUM3QixNQUFNVyxTQUFTWCxPQUFPO0FBRXRCLE1BQU1ZLGlCQUFpQjVCO0lBQ3JCNkIsYUFBZTtRQUNiLEtBQUs7UUFFTCxJQUFJLENBQUNYLE9BQU8sR0FBRyxJQUFJaEI7UUFDbkIsSUFBSSxDQUFDYSxTQUFTLEdBQUcsRUFBRTtRQUNuQixJQUFJLENBQUNSLFFBQVEsR0FBRztRQUVoQixNQUFNdUIsT0FBTyxJQUFJO1FBRWpCLElBQUksQ0FBQ1YsU0FBUyxHQUFHLFNBQVNXLFFBQVNDLE1BQU0sRUFBRUMsT0FBTztZQUNoRCxNQUFNQyxRQUFRSixJQUFJLENBQUNaLE9BQU87WUFFMUIsSUFBSWlCLFlBQVk7WUFFaEIsTUFBTyxDQUFDQSxVQUFXO2dCQUNqQixNQUFNQyxPQUFPRixNQUFNRyxLQUFLO2dCQUN4QixJQUFJLENBQUNELE1BQU07b0JBQ1Q7Z0JBQ0Y7Z0JBQ0FOLElBQUksQ0FBQ3ZCLFFBQVE7Z0JBQ2I0QixZQUFZLENBQUMsSUFBSSxDQUFDRyxRQUFRLENBQUNGLEtBQUtHLElBQUksRUFBRUgsS0FBS0ksT0FBTztZQUNwRDtZQUVBLElBQUksQ0FBQ3ZCLFdBQVcsR0FBR2tCO1lBRW5CLElBQUksQ0FBQyxJQUFJLENBQUNsQixXQUFXLElBQUlhLElBQUksQ0FBQ2IsV0FBVyxFQUFFO2dCQUN6Q2EsSUFBSSxDQUFDYixXQUFXLEdBQUc7Z0JBQ25CYSxLQUFLVyxJQUFJLENBQUMsU0FBU1QsUUFBUTtvQkFBQ0Y7dUJBQVNHO2lCQUFRO1lBQy9DO1lBRUEsSUFBSUgsSUFBSSxDQUFDWCxlQUFlLElBQUllLE1BQU1RLE9BQU8sSUFBSTtnQkFDM0NDLFFBQ0dDLEdBQUcsQ0FBQ2QsSUFBSSxDQUFDZixTQUFTLENBQUM4QixHQUFHLENBQUNDLENBQUFBLElBQUtBLEVBQUVDLEtBQUssS0FDbkNDLElBQUksQ0FBQ2xCLElBQUksQ0FBQ1gsZUFBZTtZQUM5QjtRQUNGO1FBRUEsSUFBSSxDQUFDRSxXQUFXLEdBQUcsQ0FBQ1csUUFBUUM7WUFDMUJILEtBQUtXLElBQUksQ0FBQyxXQUFXVCxRQUFRO2dCQUFDRjttQkFBU0c7YUFBUTtRQUNqRDtRQUVBLElBQUksQ0FBQ1gsY0FBYyxHQUFHLENBQUNVLFFBQVFDLFNBQVNnQjtZQUN0Q25CLEtBQUtXLElBQUksQ0FBQyxjQUFjVCxRQUFRO2dCQUFDRjttQkFBU0c7YUFBUSxFQUFFZ0I7UUFDdEQ7UUFFQSxJQUFJLENBQUMxQixtQkFBbUIsR0FBRyxDQUFDUyxRQUFRQyxTQUFTZ0I7WUFDM0NuQixLQUFLVyxJQUFJLENBQUMsbUJBQW1CVCxRQUFRO2dCQUFDRjttQkFBU0c7YUFBUSxFQUFFZ0I7UUFDM0Q7UUFFQSxJQUFJLENBQUN0QixPQUFPLEdBQUcsSUFBSWIsVUFBVSxJQUFJO0lBQ25DO0lBRUEsS0FBS04sTUFBSyxHQUFLO1FBQ2IsT0FBTyxJQUFJLENBQUNTLFdBQVc7SUFDekI7SUFFQSxLQUFLZCxXQUFVLEdBQUs7UUFDbEIsT0FBTyxJQUFJLENBQUNZLFNBQVMsQ0FBQ21DLE1BQU0sQ0FBQ0MsQ0FBQUEsU0FBVUEsTUFBTSxDQUFDaEQsV0FBVyxFQUFFaUQsTUFBTTtJQUNuRTtJQUVBLEtBQUszQyxNQUFLLEdBQUs7UUFDYixPQUFPLElBQUksQ0FBQ00sU0FBUyxDQUFDbUMsTUFBTSxDQUFDQyxDQUFBQSxTQUFVQSxNQUFNLENBQUNoRCxXQUFXLElBQUksQ0FBQ2dELE1BQU0sQ0FBQ2xDLFdBQVcsRUFBRW1DLE1BQU07SUFDMUY7SUFFQSxLQUFLOUMsU0FBUSxHQUFLO1FBQ2hCLElBQUkrQyxNQUFNLElBQUksQ0FBQzlDLFFBQVE7UUFDdkIsS0FBSyxNQUFNLEVBQUUsQ0FBQ0QsU0FBUSxFQUFHZ0QsT0FBQUEsRUFBUyxJQUFJLElBQUksQ0FBQ3ZDLFNBQVMsQ0FBRTtZQUNwRHNDLE9BQU9DO1FBQ1Q7UUFDQSxPQUFPRDtJQUNUO0lBRUEsS0FBS2hELFNBQVEsR0FBSztRQUNoQixJQUFJZ0QsTUFBTTtRQUNWLEtBQUssTUFBTSxFQUFFLENBQUNoRCxTQUFRLEVBQUdrRCxPQUFBQSxFQUFTLElBQUksSUFBSSxDQUFDeEMsU0FBUyxDQUFFO1lBQ3BEc0MsT0FBT0U7UUFDVDtRQUNBLE9BQU9GO0lBQ1Q7SUFFQSxLQUFLakQsTUFBSyxHQUFLO1FBQ2IsSUFBSWlELE1BQU0sSUFBSSxDQUFDOUMsUUFBUTtRQUN2QixLQUFLLE1BQU0sRUFBRSxDQUFDSCxNQUFLLEVBQUdvRCxJQUFBQSxFQUFNLElBQUksSUFBSSxDQUFDekMsU0FBUyxDQUFFO1lBQzlDc0MsT0FBT0c7UUFDVDtRQUNBLE9BQU9IO0lBQ1Q7SUFFQSxJQUFJSSxRQUFTO1FBQ1gsT0FBTyxJQUFJLENBQUM5QixPQUFPO0lBQ3JCO0lBRUEsT0FBT2hCLE9BQU0sR0FBSztRQUNoQixJQUFJLElBQUksQ0FBQ08sT0FBTyxDQUFDd0IsT0FBTyxJQUFJO1lBQzFCLE9BQU9DLFFBQVFDLEdBQUcsQ0FBQyxJQUFJLENBQUM3QixTQUFTLENBQUM4QixHQUFHLENBQUNDLENBQUFBLElBQUtBLEVBQUVDLEtBQUs7UUFDcEQsT0FBTztZQUNMLE9BQU8sSUFBSUosUUFBU2UsQ0FBQUE7Z0JBQ2xCLElBQUksQ0FBQ3ZDLGVBQWUsR0FBR3VDO1lBQ3pCO1FBQ0Y7SUFDRjtJQUVBLE9BQU85QyxTQUFRLENBQUdxQyxHQUFHLEVBQUU7UUFDckIsTUFBTyxLQUFNO1lBQ1gsTUFBTWIsT0FBTyxJQUFJLENBQUNsQixPQUFPLENBQUNtQixLQUFLO1lBQy9CLElBQUksQ0FBQ0QsTUFBTTtnQkFDVDtZQUNGO1lBQ0FBLEtBQUtJLE9BQU8sQ0FBQ21CLE9BQU8sQ0FBQ1Y7UUFDdkI7UUFFQSxPQUFPTixRQUFRQyxHQUFHLENBQUMsSUFBSSxDQUFDN0IsU0FBUyxDQUFDOEIsR0FBRyxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFYyxPQUFPLENBQUNYO0lBQ3ZEO0lBRUEsQ0FBQ3BDLFVBQVMsQ0FBRzBCLElBQUksRUFBRUMsT0FBTyxFQUFFO1FBQzFCLE1BQU1xQixhQUFhLElBQUksQ0FBQ3JDLGVBQWU7UUFFdkMsSUFBSSxDQUFDcUMsWUFBWTtZQUNmLElBQUksQ0FBQzVDLFdBQVcsR0FBRztZQUNuQixJQUFJLENBQUNDLE9BQU8sQ0FBQzRDLElBQUksQ0FBQztnQkFBRXZCO2dCQUFNQztZQUFRO1lBQ2xDLElBQUksQ0FBQ2pDLFFBQVE7UUFDZixPQUFPLElBQUksQ0FBQ3NELFdBQVd2QixRQUFRLENBQUNDLE1BQU1DLFVBQVU7WUFDOUNxQixVQUFVLENBQUM1QyxXQUFXLEdBQUc7WUFDekIsSUFBSSxDQUFDQSxXQUFXLEdBQUcsQ0FBQyxJQUFJLENBQUNPLGVBQWU7UUFDMUM7UUFFQSxPQUFPLENBQUMsSUFBSSxDQUFDUCxXQUFXO0lBQzFCO0lBRUEsQ0FBQ1EsV0FBVSxDQUFHMEIsTUFBTSxFQUFFO1FBQ3BCQSxPQUNHWSxFQUFFLENBQUMsU0FBUyxJQUFJLENBQUMzQyxTQUFTLEVBQzFCMkMsRUFBRSxDQUFDLFdBQVcsSUFBSSxDQUFDMUMsV0FBVyxFQUM5QjBDLEVBQUUsQ0FBQyxjQUFjLElBQUksQ0FBQ3pDLGNBQWMsRUFDcEN5QyxFQUFFLENBQUMsbUJBQW1CLElBQUksQ0FBQ3hDLG1CQUFtQjtRQUVqRCxJQUFJLENBQUNSLFNBQVMsQ0FBQytDLElBQUksQ0FBQ1g7UUFFcEIsSUFBSSxJQUFJLENBQUNsQyxXQUFXLEVBQUU7WUFDcEIrQyxlQUFlO2dCQUNiLElBQUksSUFBSSxDQUFDL0MsV0FBVyxFQUFFO29CQUNwQixJQUFJLENBQUNHLFNBQVMsQ0FBQytCLE1BQU0sQ0FBQ3pDLEtBQUssRUFBRTt3QkFBQyxJQUFJO3dCQUFFeUM7cUJBQU87Z0JBQzdDO1lBQ0Y7UUFDRjtRQUVBLE9BQU8sSUFBSTtJQUNiO0lBRUEsQ0FBQ3pCLGNBQWEsQ0FBR3lCLE1BQU0sRUFBRTtRQUN2QkEsT0FBT0osS0FBSyxDQUFDO1lBQ1gsTUFBTWtCLE1BQU0sSUFBSSxDQUFDbEQsU0FBUyxDQUFDbUQsT0FBTyxDQUFDZjtZQUNuQyxJQUFJYyxRQUFRLENBQUMsR0FBRztnQkFDZCxJQUFJLENBQUNsRCxTQUFTLENBQUNvRCxNQUFNLENBQUNGLEtBQUs7WUFDN0I7UUFDRjtRQUVBLElBQUksQ0FBQ2hELFdBQVcsR0FBRyxJQUFJLENBQUNGLFNBQVMsQ0FBQ3FELElBQUksQ0FBQ1AsQ0FBQUEsYUFDckMsQ0FBQ0EsVUFBVSxDQUFDNUMsV0FBVyxJQUN2QjRDLFdBQVdRLE1BQU0sS0FBSyxRQUN0QlIsV0FBV1MsU0FBUyxLQUFLO0lBRTdCO0FBQ0Y7QUFFQUMsT0FBT0MsT0FBTyxHQUFHO0lBQ2Y1QztJQUNBYjtJQUNBRTtJQUNBUTtJQUNBQztJQUNBRjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbW9ja3VwZmxvdy8uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2Rpc3BhdGNoZXIvcG9vbC1iYXNlLmpzPzkzMzQiLCJ3ZWJwYWNrOi8vbW9ja3VwZmxvdy8uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2Rpc3BhdGNoZXIvcG9vbC1iYXNlLmpzPzkzMzQqIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBEaXNwYXRjaGVyQmFzZSA9IHJlcXVpcmUoJy4vZGlzcGF0Y2hlci1iYXNlJylcbmNvbnN0IEZpeGVkUXVldWUgPSByZXF1aXJlKCcuL2ZpeGVkLXF1ZXVlJylcbmNvbnN0IHsga0Nvbm5lY3RlZCwga1NpemUsIGtSdW5uaW5nLCBrUGVuZGluZywga1F1ZXVlZCwga0J1c3ksIGtGcmVlLCBrVXJsLCBrQ2xvc2UsIGtEZXN0cm95LCBrRGlzcGF0Y2ggfSA9IHJlcXVpcmUoJy4uL2NvcmUvc3ltYm9scycpXG5jb25zdCBQb29sU3RhdHMgPSByZXF1aXJlKCcuL3Bvb2wtc3RhdHMnKVxuXG5jb25zdCBrQ2xpZW50cyA9IFN5bWJvbCgnY2xpZW50cycpXG5jb25zdCBrTmVlZERyYWluID0gU3ltYm9sKCduZWVkRHJhaW4nKVxuY29uc3Qga1F1ZXVlID0gU3ltYm9sKCdxdWV1ZScpXG5jb25zdCBrQ2xvc2VkUmVzb2x2ZSA9IFN5bWJvbCgnY2xvc2VkIHJlc29sdmUnKVxuY29uc3Qga09uRHJhaW4gPSBTeW1ib2woJ29uRHJhaW4nKVxuY29uc3Qga09uQ29ubmVjdCA9IFN5bWJvbCgnb25Db25uZWN0JylcbmNvbnN0IGtPbkRpc2Nvbm5lY3QgPSBTeW1ib2woJ29uRGlzY29ubmVjdCcpXG5jb25zdCBrT25Db25uZWN0aW9uRXJyb3IgPSBTeW1ib2woJ29uQ29ubmVjdGlvbkVycm9yJylcbmNvbnN0IGtHZXREaXNwYXRjaGVyID0gU3ltYm9sKCdnZXQgZGlzcGF0Y2hlcicpXG5jb25zdCBrQWRkQ2xpZW50ID0gU3ltYm9sKCdhZGQgY2xpZW50JylcbmNvbnN0IGtSZW1vdmVDbGllbnQgPSBTeW1ib2woJ3JlbW92ZSBjbGllbnQnKVxuY29uc3Qga1N0YXRzID0gU3ltYm9sKCdzdGF0cycpXG5cbmNsYXNzIFBvb2xCYXNlIGV4dGVuZHMgRGlzcGF0Y2hlckJhc2Uge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgc3VwZXIoKVxuXG4gICAgdGhpc1trUXVldWVdID0gbmV3IEZpeGVkUXVldWUoKVxuICAgIHRoaXNba0NsaWVudHNdID0gW11cbiAgICB0aGlzW2tRdWV1ZWRdID0gMFxuXG4gICAgY29uc3QgcG9vbCA9IHRoaXNcblxuICAgIHRoaXNba09uRHJhaW5dID0gZnVuY3Rpb24gb25EcmFpbiAob3JpZ2luLCB0YXJnZXRzKSB7XG4gICAgICBjb25zdCBxdWV1ZSA9IHBvb2xba1F1ZXVlXVxuXG4gICAgICBsZXQgbmVlZERyYWluID0gZmFsc2VcblxuICAgICAgd2hpbGUgKCFuZWVkRHJhaW4pIHtcbiAgICAgICAgY29uc3QgaXRlbSA9IHF1ZXVlLnNoaWZ0KClcbiAgICAgICAgaWYgKCFpdGVtKSB7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBwb29sW2tRdWV1ZWRdLS1cbiAgICAgICAgbmVlZERyYWluID0gIXRoaXMuZGlzcGF0Y2goaXRlbS5vcHRzLCBpdGVtLmhhbmRsZXIpXG4gICAgICB9XG5cbiAgICAgIHRoaXNba05lZWREcmFpbl0gPSBuZWVkRHJhaW5cblxuICAgICAgaWYgKCF0aGlzW2tOZWVkRHJhaW5dICYmIHBvb2xba05lZWREcmFpbl0pIHtcbiAgICAgICAgcG9vbFtrTmVlZERyYWluXSA9IGZhbHNlXG4gICAgICAgIHBvb2wuZW1pdCgnZHJhaW4nLCBvcmlnaW4sIFtwb29sLCAuLi50YXJnZXRzXSlcbiAgICAgIH1cblxuICAgICAgaWYgKHBvb2xba0Nsb3NlZFJlc29sdmVdICYmIHF1ZXVlLmlzRW1wdHkoKSkge1xuICAgICAgICBQcm9taXNlXG4gICAgICAgICAgLmFsbChwb29sW2tDbGllbnRzXS5tYXAoYyA9PiBjLmNsb3NlKCkpKVxuICAgICAgICAgIC50aGVuKHBvb2xba0Nsb3NlZFJlc29sdmVdKVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXNba09uQ29ubmVjdF0gPSAob3JpZ2luLCB0YXJnZXRzKSA9PiB7XG4gICAgICBwb29sLmVtaXQoJ2Nvbm5lY3QnLCBvcmlnaW4sIFtwb29sLCAuLi50YXJnZXRzXSlcbiAgICB9XG5cbiAgICB0aGlzW2tPbkRpc2Nvbm5lY3RdID0gKG9yaWdpbiwgdGFyZ2V0cywgZXJyKSA9PiB7XG4gICAgICBwb29sLmVtaXQoJ2Rpc2Nvbm5lY3QnLCBvcmlnaW4sIFtwb29sLCAuLi50YXJnZXRzXSwgZXJyKVxuICAgIH1cblxuICAgIHRoaXNba09uQ29ubmVjdGlvbkVycm9yXSA9IChvcmlnaW4sIHRhcmdldHMsIGVycikgPT4ge1xuICAgICAgcG9vbC5lbWl0KCdjb25uZWN0aW9uRXJyb3InLCBvcmlnaW4sIFtwb29sLCAuLi50YXJnZXRzXSwgZXJyKVxuICAgIH1cblxuICAgIHRoaXNba1N0YXRzXSA9IG5ldyBQb29sU3RhdHModGhpcylcbiAgfVxuXG4gIGdldCBba0J1c3ldICgpIHtcbiAgICByZXR1cm4gdGhpc1trTmVlZERyYWluXVxuICB9XG5cbiAgZ2V0IFtrQ29ubmVjdGVkXSAoKSB7XG4gICAgcmV0dXJuIHRoaXNba0NsaWVudHNdLmZpbHRlcihjbGllbnQgPT4gY2xpZW50W2tDb25uZWN0ZWRdKS5sZW5ndGhcbiAgfVxuXG4gIGdldCBba0ZyZWVdICgpIHtcbiAgICByZXR1cm4gdGhpc1trQ2xpZW50c10uZmlsdGVyKGNsaWVudCA9PiBjbGllbnRba0Nvbm5lY3RlZF0gJiYgIWNsaWVudFtrTmVlZERyYWluXSkubGVuZ3RoXG4gIH1cblxuICBnZXQgW2tQZW5kaW5nXSAoKSB7XG4gICAgbGV0IHJldCA9IHRoaXNba1F1ZXVlZF1cbiAgICBmb3IgKGNvbnN0IHsgW2tQZW5kaW5nXTogcGVuZGluZyB9IG9mIHRoaXNba0NsaWVudHNdKSB7XG4gICAgICByZXQgKz0gcGVuZGluZ1xuICAgIH1cbiAgICByZXR1cm4gcmV0XG4gIH1cblxuICBnZXQgW2tSdW5uaW5nXSAoKSB7XG4gICAgbGV0IHJldCA9IDBcbiAgICBmb3IgKGNvbnN0IHsgW2tSdW5uaW5nXTogcnVubmluZyB9IG9mIHRoaXNba0NsaWVudHNdKSB7XG4gICAgICByZXQgKz0gcnVubmluZ1xuICAgIH1cbiAgICByZXR1cm4gcmV0XG4gIH1cblxuICBnZXQgW2tTaXplXSAoKSB7XG4gICAgbGV0IHJldCA9IHRoaXNba1F1ZXVlZF1cbiAgICBmb3IgKGNvbnN0IHsgW2tTaXplXTogc2l6ZSB9IG9mIHRoaXNba0NsaWVudHNdKSB7XG4gICAgICByZXQgKz0gc2l6ZVxuICAgIH1cbiAgICByZXR1cm4gcmV0XG4gIH1cblxuICBnZXQgc3RhdHMgKCkge1xuICAgIHJldHVybiB0aGlzW2tTdGF0c11cbiAgfVxuXG4gIGFzeW5jIFtrQ2xvc2VdICgpIHtcbiAgICBpZiAodGhpc1trUXVldWVdLmlzRW1wdHkoKSkge1xuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHRoaXNba0NsaWVudHNdLm1hcChjID0+IGMuY2xvc2UoKSkpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICB0aGlzW2tDbG9zZWRSZXNvbHZlXSA9IHJlc29sdmVcbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgYXN5bmMgW2tEZXN0cm95XSAoZXJyKSB7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGNvbnN0IGl0ZW0gPSB0aGlzW2tRdWV1ZV0uc2hpZnQoKVxuICAgICAgaWYgKCFpdGVtKSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBpdGVtLmhhbmRsZXIub25FcnJvcihlcnIpXG4gICAgfVxuXG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHRoaXNba0NsaWVudHNdLm1hcChjID0+IGMuZGVzdHJveShlcnIpKSlcbiAgfVxuXG4gIFtrRGlzcGF0Y2hdIChvcHRzLCBoYW5kbGVyKSB7XG4gICAgY29uc3QgZGlzcGF0Y2hlciA9IHRoaXNba0dldERpc3BhdGNoZXJdKClcblxuICAgIGlmICghZGlzcGF0Y2hlcikge1xuICAgICAgdGhpc1trTmVlZERyYWluXSA9IHRydWVcbiAgICAgIHRoaXNba1F1ZXVlXS5wdXNoKHsgb3B0cywgaGFuZGxlciB9KVxuICAgICAgdGhpc1trUXVldWVkXSsrXG4gICAgfSBlbHNlIGlmICghZGlzcGF0Y2hlci5kaXNwYXRjaChvcHRzLCBoYW5kbGVyKSkge1xuICAgICAgZGlzcGF0Y2hlcltrTmVlZERyYWluXSA9IHRydWVcbiAgICAgIHRoaXNba05lZWREcmFpbl0gPSAhdGhpc1trR2V0RGlzcGF0Y2hlcl0oKVxuICAgIH1cblxuICAgIHJldHVybiAhdGhpc1trTmVlZERyYWluXVxuICB9XG5cbiAgW2tBZGRDbGllbnRdIChjbGllbnQpIHtcbiAgICBjbGllbnRcbiAgICAgIC5vbignZHJhaW4nLCB0aGlzW2tPbkRyYWluXSlcbiAgICAgIC5vbignY29ubmVjdCcsIHRoaXNba09uQ29ubmVjdF0pXG4gICAgICAub24oJ2Rpc2Nvbm5lY3QnLCB0aGlzW2tPbkRpc2Nvbm5lY3RdKVxuICAgICAgLm9uKCdjb25uZWN0aW9uRXJyb3InLCB0aGlzW2tPbkNvbm5lY3Rpb25FcnJvcl0pXG5cbiAgICB0aGlzW2tDbGllbnRzXS5wdXNoKGNsaWVudClcblxuICAgIGlmICh0aGlzW2tOZWVkRHJhaW5dKSB7XG4gICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzW2tOZWVkRHJhaW5dKSB7XG4gICAgICAgICAgdGhpc1trT25EcmFpbl0oY2xpZW50W2tVcmxdLCBbdGhpcywgY2xpZW50XSlcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgW2tSZW1vdmVDbGllbnRdIChjbGllbnQpIHtcbiAgICBjbGllbnQuY2xvc2UoKCkgPT4ge1xuICAgICAgY29uc3QgaWR4ID0gdGhpc1trQ2xpZW50c10uaW5kZXhPZihjbGllbnQpXG4gICAgICBpZiAoaWR4ICE9PSAtMSkge1xuICAgICAgICB0aGlzW2tDbGllbnRzXS5zcGxpY2UoaWR4LCAxKVxuICAgICAgfVxuICAgIH0pXG5cbiAgICB0aGlzW2tOZWVkRHJhaW5dID0gdGhpc1trQ2xpZW50c10uc29tZShkaXNwYXRjaGVyID0+IChcbiAgICAgICFkaXNwYXRjaGVyW2tOZWVkRHJhaW5dICYmXG4gICAgICBkaXNwYXRjaGVyLmNsb3NlZCAhPT0gdHJ1ZSAmJlxuICAgICAgZGlzcGF0Y2hlci5kZXN0cm95ZWQgIT09IHRydWVcbiAgICApKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBQb29sQmFzZSxcbiAga0NsaWVudHMsXG4gIGtOZWVkRHJhaW4sXG4gIGtBZGRDbGllbnQsXG4gIGtSZW1vdmVDbGllbnQsXG4gIGtHZXREaXNwYXRjaGVyXG59XG4iXSwibmFtZXMiOlsiRGlzcGF0Y2hlckJhc2UiLCJyZXF1aXJlIiwiRml4ZWRRdWV1ZSIsImtDb25uZWN0ZWQiLCJrU2l6ZSIsImtSdW5uaW5nIiwia1BlbmRpbmciLCJrUXVldWVkIiwia0J1c3kiLCJrRnJlZSIsImtVcmwiLCJrQ2xvc2UiLCJrRGVzdHJveSIsImtEaXNwYXRjaCIsIlBvb2xTdGF0cyIsImtDbGllbnRzIiwiU3ltYm9sIiwia05lZWREcmFpbiIsImtRdWV1ZSIsImtDbG9zZWRSZXNvbHZlIiwia09uRHJhaW4iLCJrT25Db25uZWN0Iiwia09uRGlzY29ubmVjdCIsImtPbkNvbm5lY3Rpb25FcnJvciIsImtHZXREaXNwYXRjaGVyIiwia0FkZENsaWVudCIsImtSZW1vdmVDbGllbnQiLCJrU3RhdHMiLCJQb29sQmFzZSIsImNvbnN0cnVjdG9yIiwicG9vbCIsIm9uRHJhaW4iLCJvcmlnaW4iLCJ0YXJnZXRzIiwicXVldWUiLCJuZWVkRHJhaW4iLCJpdGVtIiwic2hpZnQiLCJkaXNwYXRjaCIsIm9wdHMiLCJoYW5kbGVyIiwiZW1pdCIsImlzRW1wdHkiLCJQcm9taXNlIiwiYWxsIiwibWFwIiwiYyIsImNsb3NlIiwidGhlbiIsImVyciIsImZpbHRlciIsImNsaWVudCIsImxlbmd0aCIsInJldCIsInBlbmRpbmciLCJydW5uaW5nIiwic2l6ZSIsInN0YXRzIiwicmVzb2x2ZSIsIm9uRXJyb3IiLCJkZXN0cm95IiwiZGlzcGF0Y2hlciIsInB1c2giLCJvbiIsInF1ZXVlTWljcm90YXNrIiwiaWR4IiwiaW5kZXhPZiIsInNwbGljZSIsInNvbWUiLCJjbG9zZWQiLCJkZXN0cm95ZWQiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/dispatcher/pool-base.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/dispatcher/pool-stats.js":
/*!**********************************************************!*\
  !*** ./node_modules/undici/lib/dispatcher/pool-stats.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { kFree, kConnected, kPending, kQueued, kRunning, kSize } = __webpack_require__(/*! ../core/symbols */ \"(ssr)/./node_modules/undici/lib/core/symbols.js\");\nconst kPool = Symbol(\"pool\");\nclass PoolStats {\n    constructor(pool){\n        this[kPool] = pool;\n    }\n    get connected() {\n        return this[kPool][kConnected];\n    }\n    get free() {\n        return this[kPool][kFree];\n    }\n    get pending() {\n        return this[kPool][kPending];\n    }\n    get queued() {\n        return this[kPool][kQueued];\n    }\n    get running() {\n        return this[kPool][kRunning];\n    }\n    get size() {\n        return this[kPool][kSize];\n    }\n}\nmodule.exports = PoolStats;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9kaXNwYXRjaGVyL3Bvb2wtc3RhdHMuanMiLCJtYXBwaW5ncyI6IjtBQUFBLE1BQU0sRUFBRUEsS0FBSyxFQUFFQyxVQUFVLEVBQUVDLFFBQVEsRUFBRUMsT0FBTyxFQUFFQyxRQUFRLEVBQUVDLEtBQUFBLEVBQU8sR0FBR0MsbUJBQU9BLENBQUM7QUFDMUUsTUFBTUMsUUFBUUMsT0FBTztBQUVyQixNQUFNQztJQUNKQyxZQUFhQyxJQUFJLENBQUU7UUFDakIsSUFBSSxDQUFDSixNQUFNLEdBQUdJO0lBQ2hCO0lBRUEsSUFBSUMsWUFBYTtRQUNmLE9BQU8sSUFBSSxDQUFDTCxNQUFNLENBQUNOLFdBQVc7SUFDaEM7SUFFQSxJQUFJWSxPQUFRO1FBQ1YsT0FBTyxJQUFJLENBQUNOLE1BQU0sQ0FBQ1AsTUFBTTtJQUMzQjtJQUVBLElBQUljLFVBQVc7UUFDYixPQUFPLElBQUksQ0FBQ1AsTUFBTSxDQUFDTCxTQUFTO0lBQzlCO0lBRUEsSUFBSWEsU0FBVTtRQUNaLE9BQU8sSUFBSSxDQUFDUixNQUFNLENBQUNKLFFBQVE7SUFDN0I7SUFFQSxJQUFJYSxVQUFXO1FBQ2IsT0FBTyxJQUFJLENBQUNULE1BQU0sQ0FBQ0gsU0FBUztJQUM5QjtJQUVBLElBQUlhLE9BQVE7UUFDVixPQUFPLElBQUksQ0FBQ1YsTUFBTSxDQUFDRixNQUFNO0lBQzNCO0FBQ0Y7QUFFQWEsT0FBT0MsT0FBTyxHQUFHViIsInNvdXJjZXMiOlsid2VicGFjazovL21vY2t1cGZsb3cvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9kaXNwYXRjaGVyL3Bvb2wtc3RhdHMuanM/Y2NkNCIsIndlYnBhY2s6Ly9tb2NrdXBmbG93Ly4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvZGlzcGF0Y2hlci9wb29sLXN0YXRzLmpzP2NjZDQqIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHsga0ZyZWUsIGtDb25uZWN0ZWQsIGtQZW5kaW5nLCBrUXVldWVkLCBrUnVubmluZywga1NpemUgfSA9IHJlcXVpcmUoJy4uL2NvcmUvc3ltYm9scycpXG5jb25zdCBrUG9vbCA9IFN5bWJvbCgncG9vbCcpXG5cbmNsYXNzIFBvb2xTdGF0cyB7XG4gIGNvbnN0cnVjdG9yIChwb29sKSB7XG4gICAgdGhpc1trUG9vbF0gPSBwb29sXG4gIH1cblxuICBnZXQgY29ubmVjdGVkICgpIHtcbiAgICByZXR1cm4gdGhpc1trUG9vbF1ba0Nvbm5lY3RlZF1cbiAgfVxuXG4gIGdldCBmcmVlICgpIHtcbiAgICByZXR1cm4gdGhpc1trUG9vbF1ba0ZyZWVdXG4gIH1cblxuICBnZXQgcGVuZGluZyAoKSB7XG4gICAgcmV0dXJuIHRoaXNba1Bvb2xdW2tQZW5kaW5nXVxuICB9XG5cbiAgZ2V0IHF1ZXVlZCAoKSB7XG4gICAgcmV0dXJuIHRoaXNba1Bvb2xdW2tRdWV1ZWRdXG4gIH1cblxuICBnZXQgcnVubmluZyAoKSB7XG4gICAgcmV0dXJuIHRoaXNba1Bvb2xdW2tSdW5uaW5nXVxuICB9XG5cbiAgZ2V0IHNpemUgKCkge1xuICAgIHJldHVybiB0aGlzW2tQb29sXVtrU2l6ZV1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFBvb2xTdGF0c1xuIl0sIm5hbWVzIjpbImtGcmVlIiwia0Nvbm5lY3RlZCIsImtQZW5kaW5nIiwia1F1ZXVlZCIsImtSdW5uaW5nIiwia1NpemUiLCJyZXF1aXJlIiwia1Bvb2wiLCJTeW1ib2wiLCJQb29sU3RhdHMiLCJjb25zdHJ1Y3RvciIsInBvb2wiLCJjb25uZWN0ZWQiLCJmcmVlIiwicGVuZGluZyIsInF1ZXVlZCIsInJ1bm5pbmciLCJzaXplIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/dispatcher/pool-stats.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/dispatcher/pool.js":
/*!****************************************************!*\
  !*** ./node_modules/undici/lib/dispatcher/pool.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { PoolBase, kClients, kNeedDrain, kAddClient, kGetDispatcher } = __webpack_require__(/*! ./pool-base */ \"(ssr)/./node_modules/undici/lib/dispatcher/pool-base.js\");\nconst Client = __webpack_require__(/*! ./client */ \"(ssr)/./node_modules/undici/lib/dispatcher/client.js\");\nconst { InvalidArgumentError } = __webpack_require__(/*! ../core/errors */ \"(ssr)/./node_modules/undici/lib/core/errors.js\");\nconst util = __webpack_require__(/*! ../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\");\nconst { kUrl, kInterceptors } = __webpack_require__(/*! ../core/symbols */ \"(ssr)/./node_modules/undici/lib/core/symbols.js\");\nconst buildConnector = __webpack_require__(/*! ../core/connect */ \"(ssr)/./node_modules/undici/lib/core/connect.js\");\nconst kOptions = Symbol(\"options\");\nconst kConnections = Symbol(\"connections\");\nconst kFactory = Symbol(\"factory\");\nfunction defaultFactory(origin, opts) {\n    return new Client(origin, opts);\n}\nclass Pool extends PoolBase {\n    constructor(origin, { connections, factory = defaultFactory, connect, connectTimeout, tls, maxCachedSessions, socketPath, autoSelectFamily, autoSelectFamilyAttemptTimeout, allowH2, ...options } = {}){\n        super();\n        if (connections != null && (!Number.isFinite(connections) || connections < 0)) {\n            throw new InvalidArgumentError(\"invalid connections\");\n        }\n        if (typeof factory !== \"function\") {\n            throw new InvalidArgumentError(\"factory must be a function.\");\n        }\n        if (connect != null && typeof connect !== \"function\" && typeof connect !== \"object\") {\n            throw new InvalidArgumentError(\"connect must be a function or an object\");\n        }\n        if (typeof connect !== \"function\") {\n            connect = buildConnector({\n                ...tls,\n                maxCachedSessions,\n                allowH2,\n                socketPath,\n                timeout: connectTimeout,\n                ...autoSelectFamily ? {\n                    autoSelectFamily,\n                    autoSelectFamilyAttemptTimeout\n                } : undefined,\n                ...connect\n            });\n        }\n        this[kInterceptors] = options.interceptors?.Pool && Array.isArray(options.interceptors.Pool) ? options.interceptors.Pool : [];\n        this[kConnections] = connections || null;\n        this[kUrl] = util.parseOrigin(origin);\n        this[kOptions] = {\n            ...util.deepClone(options),\n            connect,\n            allowH2\n        };\n        this[kOptions].interceptors = options.interceptors ? {\n            ...options.interceptors\n        } : undefined;\n        this[kFactory] = factory;\n    }\n    [kGetDispatcher]() {\n        for (const client of this[kClients]){\n            if (!client[kNeedDrain]) {\n                return client;\n            }\n        }\n        if (!this[kConnections] || this[kClients].length < this[kConnections]) {\n            const dispatcher = this[kFactory](this[kUrl], this[kOptions]);\n            this[kAddClient](dispatcher);\n            return dispatcher;\n        }\n    }\n}\nmodule.exports = Pool;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9kaXNwYXRjaGVyL3Bvb2wuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNLEVBQ0pBLFFBQVEsRUFDUkMsUUFBUSxFQUNSQyxVQUFVLEVBQ1ZDLFVBQVUsRUFDVkMsY0FBQUEsRUFDRCxHQUFHQyxtQkFBT0EsQ0FBQztBQUNaLE1BQU1DLFNBQVNELG1CQUFPQSxDQUFDO0FBQ3ZCLE1BQU0sRUFDSkUsb0JBQUFBLEVBQ0QsR0FBR0YsbUJBQU9BLENBQUM7QUFDWixNQUFNRyxPQUFPSCxtQkFBT0EsQ0FBQztBQUNyQixNQUFNLEVBQUVJLElBQUksRUFBRUMsYUFBQUEsRUFBZSxHQUFHTCxtQkFBT0EsQ0FBQztBQUN4QyxNQUFNTSxpQkFBaUJOLG1CQUFPQSxDQUFDO0FBRS9CLE1BQU1PLFdBQVdDLE9BQU87QUFDeEIsTUFBTUMsZUFBZUQsT0FBTztBQUM1QixNQUFNRSxXQUFXRixPQUFPO0FBRXhCLFNBQVNHLGVBQWdCQyxNQUFNLEVBQUVDLElBQUk7SUFDbkMsT0FBTyxJQUFJWixPQUFPVyxRQUFRQztBQUM1QjtBQUVBLE1BQU1DLGFBQWFuQjtJQUNqQm9CLFlBQWFILE1BQU0sRUFBRSxFQUNuQkksV0FBVyxFQUNYQyxVQUFVTixjQUFjLEVBQ3hCTyxPQUFPLEVBQ1BDLGNBQWMsRUFDZEMsR0FBRyxFQUNIQyxpQkFBaUIsRUFDakJDLFVBQVUsRUFDVkMsZ0JBQWdCLEVBQ2hCQyw4QkFBOEIsRUFDOUJDLE9BQU8sRUFDUCxHQUFHQyxTQUNKLEdBQUcsQ0FBQyxDQUFDLENBQUU7UUFDTixLQUFLO1FBRUwsSUFBSVYsZUFBZSxRQUFTLEVBQUNXLE9BQU9DLFFBQVEsQ0FBQ1osZ0JBQWdCQSxjQUFjLElBQUk7WUFDN0UsTUFBTSxJQUFJZCxxQkFBcUI7UUFDakM7UUFFQSxJQUFJLE9BQU9lLFlBQVksWUFBWTtZQUNqQyxNQUFNLElBQUlmLHFCQUFxQjtRQUNqQztRQUVBLElBQUlnQixXQUFXLFFBQVEsT0FBT0EsWUFBWSxjQUFjLE9BQU9BLFlBQVksVUFBVTtZQUNuRixNQUFNLElBQUloQixxQkFBcUI7UUFDakM7UUFFQSxJQUFJLE9BQU9nQixZQUFZLFlBQVk7WUFDakNBLFVBQVVaLGVBQWU7Z0JBQ3ZCLEdBQUdjLEdBQUc7Z0JBQ05DO2dCQUNBSTtnQkFDQUg7Z0JBQ0FPLFNBQVNWO2dCQUNULEdBQUlJLG1CQUFtQjtvQkFBRUE7b0JBQWtCQztnQkFBK0IsSUFBSU0sU0FBUztnQkFDdkYsR0FBR1osT0FBQUE7WUFDTDtRQUNGO1FBRUEsSUFBSSxDQUFDYixjQUFjLEdBQUdxQixRQUFRSyxZQUFZLEVBQUVqQixRQUFRa0IsTUFBTUMsT0FBTyxDQUFDUCxRQUFRSyxZQUFZLENBQUNqQixJQUFJLElBQ3ZGWSxRQUFRSyxZQUFZLENBQUNqQixJQUFJLEdBQ3pCLEVBQUU7UUFDTixJQUFJLENBQUNMLGFBQWEsR0FBR08sZUFBZTtRQUNwQyxJQUFJLENBQUNaLEtBQUssR0FBR0QsS0FBSytCLFdBQVcsQ0FBQ3RCO1FBQzlCLElBQUksQ0FBQ0wsU0FBUyxHQUFHO1lBQUUsR0FBR0osS0FBS2dDLFNBQVMsQ0FBQ1QsUUFBUTtZQUFFUjtZQUFTTztRQUFRO1FBQ2hFLElBQUksQ0FBQ2xCLFNBQVMsQ0FBQ3dCLFlBQVksR0FBR0wsUUFBUUssWUFBWSxHQUM5QztZQUFFLEdBQUdMLFFBQVFLLFlBQUFBO1FBQWEsSUFDMUJEO1FBQ0osSUFBSSxDQUFDcEIsU0FBUyxHQUFHTztJQUNuQjtJQUVBLENBQUNsQixlQUFjLEdBQUs7UUFDbEIsS0FBSyxNQUFNcUMsVUFBVSxJQUFJLENBQUN4QyxTQUFTLENBQUU7WUFDbkMsSUFBSSxDQUFDd0MsTUFBTSxDQUFDdkMsV0FBVyxFQUFFO2dCQUN2QixPQUFPdUM7WUFDVDtRQUNGO1FBRUEsSUFBSSxDQUFDLElBQUksQ0FBQzNCLGFBQWEsSUFBSSxJQUFJLENBQUNiLFNBQVMsQ0FBQ3lDLE1BQU0sR0FBRyxJQUFJLENBQUM1QixhQUFhLEVBQUU7WUFDckUsTUFBTTZCLGFBQWEsSUFBSSxDQUFDNUIsU0FBUyxDQUFDLElBQUksQ0FBQ04sS0FBSyxFQUFFLElBQUksQ0FBQ0csU0FBUztZQUM1RCxJQUFJLENBQUNULFdBQVcsQ0FBQ3dDO1lBQ2pCLE9BQU9BO1FBQ1Q7SUFDRjtBQUNGO0FBRUFDLE9BQU9DLE9BQU8sR0FBRzFCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbW9ja3VwZmxvdy8uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2Rpc3BhdGNoZXIvcG9vbC5qcz8yZTdkIiwid2VicGFjazovL21vY2t1cGZsb3cvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9kaXNwYXRjaGVyL3Bvb2wuanM/MmU3ZCoiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHtcbiAgUG9vbEJhc2UsXG4gIGtDbGllbnRzLFxuICBrTmVlZERyYWluLFxuICBrQWRkQ2xpZW50LFxuICBrR2V0RGlzcGF0Y2hlclxufSA9IHJlcXVpcmUoJy4vcG9vbC1iYXNlJylcbmNvbnN0IENsaWVudCA9IHJlcXVpcmUoJy4vY2xpZW50JylcbmNvbnN0IHtcbiAgSW52YWxpZEFyZ3VtZW50RXJyb3Jcbn0gPSByZXF1aXJlKCcuLi9jb3JlL2Vycm9ycycpXG5jb25zdCB1dGlsID0gcmVxdWlyZSgnLi4vY29yZS91dGlsJylcbmNvbnN0IHsga1VybCwga0ludGVyY2VwdG9ycyB9ID0gcmVxdWlyZSgnLi4vY29yZS9zeW1ib2xzJylcbmNvbnN0IGJ1aWxkQ29ubmVjdG9yID0gcmVxdWlyZSgnLi4vY29yZS9jb25uZWN0JylcblxuY29uc3Qga09wdGlvbnMgPSBTeW1ib2woJ29wdGlvbnMnKVxuY29uc3Qga0Nvbm5lY3Rpb25zID0gU3ltYm9sKCdjb25uZWN0aW9ucycpXG5jb25zdCBrRmFjdG9yeSA9IFN5bWJvbCgnZmFjdG9yeScpXG5cbmZ1bmN0aW9uIGRlZmF1bHRGYWN0b3J5IChvcmlnaW4sIG9wdHMpIHtcbiAgcmV0dXJuIG5ldyBDbGllbnQob3JpZ2luLCBvcHRzKVxufVxuXG5jbGFzcyBQb29sIGV4dGVuZHMgUG9vbEJhc2Uge1xuICBjb25zdHJ1Y3RvciAob3JpZ2luLCB7XG4gICAgY29ubmVjdGlvbnMsXG4gICAgZmFjdG9yeSA9IGRlZmF1bHRGYWN0b3J5LFxuICAgIGNvbm5lY3QsXG4gICAgY29ubmVjdFRpbWVvdXQsXG4gICAgdGxzLFxuICAgIG1heENhY2hlZFNlc3Npb25zLFxuICAgIHNvY2tldFBhdGgsXG4gICAgYXV0b1NlbGVjdEZhbWlseSxcbiAgICBhdXRvU2VsZWN0RmFtaWx5QXR0ZW1wdFRpbWVvdXQsXG4gICAgYWxsb3dIMixcbiAgICAuLi5vcHRpb25zXG4gIH0gPSB7fSkge1xuICAgIHN1cGVyKClcblxuICAgIGlmIChjb25uZWN0aW9ucyAhPSBudWxsICYmICghTnVtYmVyLmlzRmluaXRlKGNvbm5lY3Rpb25zKSB8fCBjb25uZWN0aW9ucyA8IDApKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgY29ubmVjdGlvbnMnKVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZmFjdG9yeSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdmYWN0b3J5IG11c3QgYmUgYSBmdW5jdGlvbi4nKVxuICAgIH1cblxuICAgIGlmIChjb25uZWN0ICE9IG51bGwgJiYgdHlwZW9mIGNvbm5lY3QgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGNvbm5lY3QgIT09ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2Nvbm5lY3QgbXVzdCBiZSBhIGZ1bmN0aW9uIG9yIGFuIG9iamVjdCcpXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBjb25uZWN0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb25uZWN0ID0gYnVpbGRDb25uZWN0b3Ioe1xuICAgICAgICAuLi50bHMsXG4gICAgICAgIG1heENhY2hlZFNlc3Npb25zLFxuICAgICAgICBhbGxvd0gyLFxuICAgICAgICBzb2NrZXRQYXRoLFxuICAgICAgICB0aW1lb3V0OiBjb25uZWN0VGltZW91dCxcbiAgICAgICAgLi4uKGF1dG9TZWxlY3RGYW1pbHkgPyB7IGF1dG9TZWxlY3RGYW1pbHksIGF1dG9TZWxlY3RGYW1pbHlBdHRlbXB0VGltZW91dCB9IDogdW5kZWZpbmVkKSxcbiAgICAgICAgLi4uY29ubmVjdFxuICAgICAgfSlcbiAgICB9XG5cbiAgICB0aGlzW2tJbnRlcmNlcHRvcnNdID0gb3B0aW9ucy5pbnRlcmNlcHRvcnM/LlBvb2wgJiYgQXJyYXkuaXNBcnJheShvcHRpb25zLmludGVyY2VwdG9ycy5Qb29sKVxuICAgICAgPyBvcHRpb25zLmludGVyY2VwdG9ycy5Qb29sXG4gICAgICA6IFtdXG4gICAgdGhpc1trQ29ubmVjdGlvbnNdID0gY29ubmVjdGlvbnMgfHwgbnVsbFxuICAgIHRoaXNba1VybF0gPSB1dGlsLnBhcnNlT3JpZ2luKG9yaWdpbilcbiAgICB0aGlzW2tPcHRpb25zXSA9IHsgLi4udXRpbC5kZWVwQ2xvbmUob3B0aW9ucyksIGNvbm5lY3QsIGFsbG93SDIgfVxuICAgIHRoaXNba09wdGlvbnNdLmludGVyY2VwdG9ycyA9IG9wdGlvbnMuaW50ZXJjZXB0b3JzXG4gICAgICA/IHsgLi4ub3B0aW9ucy5pbnRlcmNlcHRvcnMgfVxuICAgICAgOiB1bmRlZmluZWRcbiAgICB0aGlzW2tGYWN0b3J5XSA9IGZhY3RvcnlcbiAgfVxuXG4gIFtrR2V0RGlzcGF0Y2hlcl0gKCkge1xuICAgIGZvciAoY29uc3QgY2xpZW50IG9mIHRoaXNba0NsaWVudHNdKSB7XG4gICAgICBpZiAoIWNsaWVudFtrTmVlZERyYWluXSkge1xuICAgICAgICByZXR1cm4gY2xpZW50XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzW2tDb25uZWN0aW9uc10gfHwgdGhpc1trQ2xpZW50c10ubGVuZ3RoIDwgdGhpc1trQ29ubmVjdGlvbnNdKSB7XG4gICAgICBjb25zdCBkaXNwYXRjaGVyID0gdGhpc1trRmFjdG9yeV0odGhpc1trVXJsXSwgdGhpc1trT3B0aW9uc10pXG4gICAgICB0aGlzW2tBZGRDbGllbnRdKGRpc3BhdGNoZXIpXG4gICAgICByZXR1cm4gZGlzcGF0Y2hlclxuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFBvb2xcbiJdLCJuYW1lcyI6WyJQb29sQmFzZSIsImtDbGllbnRzIiwia05lZWREcmFpbiIsImtBZGRDbGllbnQiLCJrR2V0RGlzcGF0Y2hlciIsInJlcXVpcmUiLCJDbGllbnQiLCJJbnZhbGlkQXJndW1lbnRFcnJvciIsInV0aWwiLCJrVXJsIiwia0ludGVyY2VwdG9ycyIsImJ1aWxkQ29ubmVjdG9yIiwia09wdGlvbnMiLCJTeW1ib2wiLCJrQ29ubmVjdGlvbnMiLCJrRmFjdG9yeSIsImRlZmF1bHRGYWN0b3J5Iiwib3JpZ2luIiwib3B0cyIsIlBvb2wiLCJjb25zdHJ1Y3RvciIsImNvbm5lY3Rpb25zIiwiZmFjdG9yeSIsImNvbm5lY3QiLCJjb25uZWN0VGltZW91dCIsInRscyIsIm1heENhY2hlZFNlc3Npb25zIiwic29ja2V0UGF0aCIsImF1dG9TZWxlY3RGYW1pbHkiLCJhdXRvU2VsZWN0RmFtaWx5QXR0ZW1wdFRpbWVvdXQiLCJhbGxvd0gyIiwib3B0aW9ucyIsIk51bWJlciIsImlzRmluaXRlIiwidGltZW91dCIsInVuZGVmaW5lZCIsImludGVyY2VwdG9ycyIsIkFycmF5IiwiaXNBcnJheSIsInBhcnNlT3JpZ2luIiwiZGVlcENsb25lIiwiY2xpZW50IiwibGVuZ3RoIiwiZGlzcGF0Y2hlciIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/dispatcher/pool.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/dispatcher/proxy-agent.js":
/*!***********************************************************!*\
  !*** ./node_modules/undici/lib/dispatcher/proxy-agent.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { kProxy, kClose, kDestroy, kInterceptors } = __webpack_require__(/*! ../core/symbols */ \"(ssr)/./node_modules/undici/lib/core/symbols.js\");\nconst { URL } = __webpack_require__(/*! node:url */ \"node:url\");\nconst Agent = __webpack_require__(/*! ./agent */ \"(ssr)/./node_modules/undici/lib/dispatcher/agent.js\");\nconst Pool = __webpack_require__(/*! ./pool */ \"(ssr)/./node_modules/undici/lib/dispatcher/pool.js\");\nconst DispatcherBase = __webpack_require__(/*! ./dispatcher-base */ \"(ssr)/./node_modules/undici/lib/dispatcher/dispatcher-base.js\");\nconst { InvalidArgumentError, RequestAbortedError, SecureProxyConnectionError } = __webpack_require__(/*! ../core/errors */ \"(ssr)/./node_modules/undici/lib/core/errors.js\");\nconst buildConnector = __webpack_require__(/*! ../core/connect */ \"(ssr)/./node_modules/undici/lib/core/connect.js\");\nconst kAgent = Symbol(\"proxy agent\");\nconst kClient = Symbol(\"proxy client\");\nconst kProxyHeaders = Symbol(\"proxy headers\");\nconst kRequestTls = Symbol(\"request tls settings\");\nconst kProxyTls = Symbol(\"proxy tls settings\");\nconst kConnectEndpoint = Symbol(\"connect endpoint function\");\nfunction defaultProtocolPort(protocol) {\n    return protocol === \"https:\" ? 443 : 80;\n}\nfunction defaultFactory(origin, opts) {\n    return new Pool(origin, opts);\n}\nclass ProxyAgent extends DispatcherBase {\n    constructor(opts){\n        super();\n        if (!opts || typeof opts === \"object\" && !(opts instanceof URL) && !opts.uri) {\n            throw new InvalidArgumentError(\"Proxy uri is mandatory\");\n        }\n        const { clientFactory = defaultFactory } = opts;\n        if (typeof clientFactory !== \"function\") {\n            throw new InvalidArgumentError(\"Proxy opts.clientFactory must be a function.\");\n        }\n        const url = this.#getUrl(opts);\n        const { href, origin, port, protocol, username, password, hostname: proxyHostname } = url;\n        this[kProxy] = {\n            uri: href,\n            protocol\n        };\n        this[kInterceptors] = opts.interceptors?.ProxyAgent && Array.isArray(opts.interceptors.ProxyAgent) ? opts.interceptors.ProxyAgent : [];\n        this[kRequestTls] = opts.requestTls;\n        this[kProxyTls] = opts.proxyTls;\n        this[kProxyHeaders] = opts.headers || {};\n        if (opts.auth && opts.token) {\n            throw new InvalidArgumentError(\"opts.auth cannot be used in combination with opts.token\");\n        } else if (opts.auth) {\n            /* @deprecated in favour of opts.token */ this[kProxyHeaders][\"proxy-authorization\"] = `Basic ${opts.auth}`;\n        } else if (opts.token) {\n            this[kProxyHeaders][\"proxy-authorization\"] = opts.token;\n        } else if (username && password) {\n            this[kProxyHeaders][\"proxy-authorization\"] = `Basic ${Buffer.from(`${decodeURIComponent(username)}:${decodeURIComponent(password)}`).toString(\"base64\")}`;\n        }\n        const connect = buildConnector({\n            ...opts.proxyTls\n        });\n        this[kConnectEndpoint] = buildConnector({\n            ...opts.requestTls\n        });\n        this[kClient] = clientFactory(url, {\n            connect\n        });\n        this[kAgent] = new Agent({\n            ...opts,\n            connect: async (opts, callback)=>{\n                let requestedPath = opts.host;\n                if (!opts.port) {\n                    requestedPath += `:${defaultProtocolPort(opts.protocol)}`;\n                }\n                try {\n                    const { socket, statusCode } = await this[kClient].connect({\n                        origin,\n                        port,\n                        path: requestedPath,\n                        signal: opts.signal,\n                        headers: {\n                            ...this[kProxyHeaders],\n                            host: opts.host\n                        },\n                        servername: this[kProxyTls]?.servername || proxyHostname\n                    });\n                    if (statusCode !== 200) {\n                        socket.on(\"error\", ()=>{}).destroy();\n                        callback(new RequestAbortedError(`Proxy response (${statusCode}) !== 200 when HTTP Tunneling`));\n                    }\n                    if (opts.protocol !== \"https:\") {\n                        callback(null, socket);\n                        return;\n                    }\n                    let servername;\n                    if (this[kRequestTls]) {\n                        servername = this[kRequestTls].servername;\n                    } else {\n                        servername = opts.servername;\n                    }\n                    this[kConnectEndpoint]({\n                        ...opts,\n                        servername,\n                        httpSocket: socket\n                    }, callback);\n                } catch (err) {\n                    if (err.code === \"ERR_TLS_CERT_ALTNAME_INVALID\") {\n                        // Throw a custom error to avoid loop in client.js#connect\n                        callback(new SecureProxyConnectionError(err));\n                    } else {\n                        callback(err);\n                    }\n                }\n            }\n        });\n    }\n    dispatch(opts, handler) {\n        const headers = buildHeaders(opts.headers);\n        throwIfProxyAuthIsSent(headers);\n        if (headers && !(\"host\" in headers) && !(\"Host\" in headers)) {\n            const { host } = new URL(opts.origin);\n            headers.host = host;\n        }\n        return this[kAgent].dispatch({\n            ...opts,\n            headers\n        }, handler);\n    }\n    /**\n   * @param {import('../types/proxy-agent').ProxyAgent.Options | string | URL} opts\n   * @returns {URL}\n   */ #getUrl(opts) {\n        if (typeof opts === \"string\") {\n            return new URL(opts);\n        } else if (opts instanceof URL) {\n            return opts;\n        } else {\n            return new URL(opts.uri);\n        }\n    }\n    async [kClose]() {\n        await this[kAgent].close();\n        await this[kClient].close();\n    }\n    async [kDestroy]() {\n        await this[kAgent].destroy();\n        await this[kClient].destroy();\n    }\n}\n/**\n * @param {string[] | Record<string, string>} headers\n * @returns {Record<string, string>}\n */ function buildHeaders(headers) {\n    // When using undici.fetch, the headers list is stored\n    // as an array.\n    if (Array.isArray(headers)) {\n        /** @type {Record<string, string>} */ const headersPair = {};\n        for(let i = 0; i < headers.length; i += 2){\n            headersPair[headers[i]] = headers[i + 1];\n        }\n        return headersPair;\n    }\n    return headers;\n}\n/**\n * @param {Record<string, string>} headers\n *\n * Previous versions of ProxyAgent suggests the Proxy-Authorization in request headers\n * Nevertheless, it was changed and to avoid a security vulnerability by end users\n * this check was created.\n * It should be removed in the next major version for performance reasons\n */ function throwIfProxyAuthIsSent(headers) {\n    const existProxyAuth = headers && Object.keys(headers).find((key)=>key.toLowerCase() === \"proxy-authorization\");\n    if (existProxyAuth) {\n        throw new InvalidArgumentError(\"Proxy-Authorization should be sent in ProxyAgent constructor\");\n    }\n}\nmodule.exports = ProxyAgent;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9kaXNwYXRjaGVyL3Byb3h5LWFnZW50LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTSxFQUFFQSxNQUFNLEVBQUVDLE1BQU0sRUFBRUMsUUFBUSxFQUFFQyxhQUFBQSxFQUFlLEdBQUdDLG1CQUFPQSxDQUFDO0FBQzVELE1BQU0sRUFBRUMsR0FBQUEsRUFBSyxHQUFHRCxtQkFBT0EsQ0FBQztBQUN4QixNQUFNRSxRQUFRRixtQkFBT0EsQ0FBQztBQUN0QixNQUFNRyxPQUFPSCxtQkFBT0EsQ0FBQztBQUNyQixNQUFNSSxpQkFBaUJKLG1CQUFPQSxDQUFDO0FBQy9CLE1BQU0sRUFBRUssb0JBQW9CLEVBQUVDLG1CQUFtQixFQUFFQywwQkFBQUEsRUFBNEIsR0FBR1AsbUJBQU9BLENBQUM7QUFDMUYsTUFBTVEsaUJBQWlCUixtQkFBT0EsQ0FBQztBQUUvQixNQUFNUyxTQUFTQyxPQUFPO0FBQ3RCLE1BQU1DLFVBQVVELE9BQU87QUFDdkIsTUFBTUUsZ0JBQWdCRixPQUFPO0FBQzdCLE1BQU1HLGNBQWNILE9BQU87QUFDM0IsTUFBTUksWUFBWUosT0FBTztBQUN6QixNQUFNSyxtQkFBbUJMLE9BQU87QUFFaEMsU0FBU00sb0JBQXFCQyxRQUFRO0lBQ3BDLE9BQU9BLGFBQWEsV0FBVyxNQUFNO0FBQ3ZDO0FBRUEsU0FBU0MsZUFBZ0JDLE1BQU0sRUFBRUMsSUFBSTtJQUNuQyxPQUFPLElBQUlqQixLQUFLZ0IsUUFBUUM7QUFDMUI7QUFFQSxNQUFNQyxtQkFBbUJqQjtJQUN2QmtCLFlBQWFGLElBQUksQ0FBRTtRQUNqQixLQUFLO1FBRUwsSUFBSSxDQUFDQSxRQUFTLE9BQU9BLFNBQVMsWUFBWSxDQUFFQSxDQUFBQSxnQkFBZ0JuQixHQUFBQSxLQUFRLENBQUNtQixLQUFLRyxHQUFJLEVBQUU7WUFDOUUsTUFBTSxJQUFJbEIscUJBQXFCO1FBQ2pDO1FBRUEsTUFBTSxFQUFFbUIsZ0JBQWdCTixjQUFBQSxF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MUIsT0FBTSxHQUFLO1FBQ2hCLE1BQU0sSUFBSSxDQUFDWSxPQUFPLENBQUN1RCxLQUFLO1FBQ3hCLE1BQU0sSUFBSSxDQUFDckQsUUFBUSxDQUFDcUQsS0FBSztJQUMzQjtJQUVBLE9BQU9sRSxTQUFRLEdBQUs7UUFDbEIsTUFBTSxJQUFJLENBQUNXLE9BQU8sQ0FBQzhDLE9BQU87UUFDMUIsTUFBTSxJQUFJLENBQUM1QyxRQUFRLENBQUM0QyxPQUFPO0lBQzdCO0FBQ0Y7QUFFQTs7O0NBR0EsR0FDQSxTQUFTTSxhQUFjdkIsT0FBTztJQUM1QjtJQUNBO0lBQ0EsSUFBSUosTUFBTUMsT0FBTyxDQUFDRyxVQUFVO1FBQzFCLHNDQUNBLE1BQU0yQixjQUFjLENBQUM7UUFFckIsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUk1QixRQUFRNkIsTUFBTSxFQUFFRCxLQUFLLEVBQUc7WUFDMUNELFdBQVcsQ0FBQzNCLE9BQU8sQ0FBQzRCLEVBQUUsQ0FBQyxHQUFHNUIsT0FBTyxDQUFDNEIsSUFBSSxFQUFFO1FBQzFDO1FBRUEsT0FBT0Q7SUFDVDtJQUVBLE9BQU8zQjtBQUNUO0FBRUE7Ozs7Ozs7Q0FPQSxHQUNBLFNBQVN3Qix1QkFBd0J4QixPQUFPO0lBQ3RDLE1BQU04QixpQkFBaUI5QixXQUFXK0IsT0FBT0MsSUFBSSxDQUFDaEMsU0FDM0NpQyxJQUFJLENBQUVDLENBQUFBLE1BQVFBLElBQUlDLFdBQVcsT0FBTztJQUN2QyxJQUFJTCxnQkFBZ0I7UUFDbEIsTUFBTSxJQUFJL0QscUJBQXFCO0lBQ2pDO0FBQ0Y7QUFFQXFFLE9BQU9DLE9BQU8sR0FBR3REIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbW9ja3VwZmxvdy8uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2Rpc3BhdGNoZXIvcHJveHktYWdlbnQuanM/OTdmZiIsIndlYnBhY2s6Ly9tb2NrdXBmbG93Ly4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvZGlzcGF0Y2hlci9wcm94eS1hZ2VudC5qcz85N2ZmKiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyBrUHJveHksIGtDbG9zZSwga0Rlc3Ryb3ksIGtJbnRlcmNlcHRvcnMgfSA9IHJlcXVpcmUoJy4uL2NvcmUvc3ltYm9scycpXG5jb25zdCB7IFVSTCB9ID0gcmVxdWlyZSgnbm9kZTp1cmwnKVxuY29uc3QgQWdlbnQgPSByZXF1aXJlKCcuL2FnZW50JylcbmNvbnN0IFBvb2wgPSByZXF1aXJlKCcuL3Bvb2wnKVxuY29uc3QgRGlzcGF0Y2hlckJhc2UgPSByZXF1aXJlKCcuL2Rpc3BhdGNoZXItYmFzZScpXG5jb25zdCB7IEludmFsaWRBcmd1bWVudEVycm9yLCBSZXF1ZXN0QWJvcnRlZEVycm9yLCBTZWN1cmVQcm94eUNvbm5lY3Rpb25FcnJvciB9ID0gcmVxdWlyZSgnLi4vY29yZS9lcnJvcnMnKVxuY29uc3QgYnVpbGRDb25uZWN0b3IgPSByZXF1aXJlKCcuLi9jb3JlL2Nvbm5lY3QnKVxuXG5jb25zdCBrQWdlbnQgPSBTeW1ib2woJ3Byb3h5IGFnZW50JylcbmNvbnN0IGtDbGllbnQgPSBTeW1ib2woJ3Byb3h5IGNsaWVudCcpXG5jb25zdCBrUHJveHlIZWFkZXJzID0gU3ltYm9sKCdwcm94eSBoZWFkZXJzJylcbmNvbnN0IGtSZXF1ZXN0VGxzID0gU3ltYm9sKCdyZXF1ZXN0IHRscyBzZXR0aW5ncycpXG5jb25zdCBrUHJveHlUbHMgPSBTeW1ib2woJ3Byb3h5IHRscyBzZXR0aW5ncycpXG5jb25zdCBrQ29ubmVjdEVuZHBvaW50ID0gU3ltYm9sKCdjb25uZWN0IGVuZHBvaW50IGZ1bmN0aW9uJylcblxuZnVuY3Rpb24gZGVmYXVsdFByb3RvY29sUG9ydCAocHJvdG9jb2wpIHtcbiAgcmV0dXJuIHByb3RvY29sID09PSAnaHR0cHM6JyA/IDQ0MyA6IDgwXG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRGYWN0b3J5IChvcmlnaW4sIG9wdHMpIHtcbiAgcmV0dXJuIG5ldyBQb29sKG9yaWdpbiwgb3B0cylcbn1cblxuY2xhc3MgUHJveHlBZ2VudCBleHRlbmRzIERpc3BhdGNoZXJCYXNlIHtcbiAgY29uc3RydWN0b3IgKG9wdHMpIHtcbiAgICBzdXBlcigpXG5cbiAgICBpZiAoIW9wdHMgfHwgKHR5cGVvZiBvcHRzID09PSAnb2JqZWN0JyAmJiAhKG9wdHMgaW5zdGFuY2VvZiBVUkwpICYmICFvcHRzLnVyaSkpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignUHJveHkgdXJpIGlzIG1hbmRhdG9yeScpXG4gICAgfVxuXG4gICAgY29uc3QgeyBjbGllbnRGYWN0b3J5ID0gZGVmYXVsdEZhY3RvcnkgfSA9IG9wdHNcbiAgICBpZiAodHlwZW9mIGNsaWVudEZhY3RvcnkgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignUHJveHkgb3B0cy5jbGllbnRGYWN0b3J5IG11c3QgYmUgYSBmdW5jdGlvbi4nKVxuICAgIH1cblxuICAgIGNvbnN0IHVybCA9IHRoaXMuI2dldFVybChvcHRzKVxuICAgIGNvbnN0IHsgaHJlZiwgb3JpZ2luLCBwb3J0LCBwcm90b2NvbCwgdXNlcm5hbWUsIHBhc3N3b3JkLCBob3N0bmFtZTogcHJveHlIb3N0bmFtZSB9ID0gdXJsXG5cbiAgICB0aGlzW2tQcm94eV0gPSB7IHVyaTogaHJlZiwgcHJvdG9jb2wgfVxuICAgIHRoaXNba0ludGVyY2VwdG9yc10gPSBvcHRzLmludGVyY2VwdG9ycz8uUHJveHlBZ2VudCAmJiBBcnJheS5pc0FycmF5KG9wdHMuaW50ZXJjZXB0b3JzLlByb3h5QWdlbnQpXG4gICAgICA/IG9wdHMuaW50ZXJjZXB0b3JzLlByb3h5QWdlbnRcbiAgICAgIDogW11cbiAgICB0aGlzW2tSZXF1ZXN0VGxzXSA9IG9wdHMucmVxdWVzdFRsc1xuICAgIHRoaXNba1Byb3h5VGxzXSA9IG9wdHMucHJveHlUbHNcbiAgICB0aGlzW2tQcm94eUhlYWRlcnNdID0gb3B0cy5oZWFkZXJzIHx8IHt9XG5cbiAgICBpZiAob3B0cy5hdXRoICYmIG9wdHMudG9rZW4pIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignb3B0cy5hdXRoIGNhbm5vdCBiZSB1c2VkIGluIGNvbWJpbmF0aW9uIHdpdGggb3B0cy50b2tlbicpXG4gICAgfSBlbHNlIGlmIChvcHRzLmF1dGgpIHtcbiAgICAgIC8qIEBkZXByZWNhdGVkIGluIGZhdm91ciBvZiBvcHRzLnRva2VuICovXG4gICAgICB0aGlzW2tQcm94eUhlYWRlcnNdWydwcm94eS1hdXRob3JpemF0aW9uJ10gPSBgQmFzaWMgJHtvcHRzLmF1dGh9YFxuICAgIH0gZWxzZSBpZiAob3B0cy50b2tlbikge1xuICAgICAgdGhpc1trUHJveHlIZWFkZXJzXVsncHJveHktYXV0aG9yaXphdGlvbiddID0gb3B0cy50b2tlblxuICAgIH0gZWxzZSBpZiAodXNlcm5hbWUgJiYgcGFzc3dvcmQpIHtcbiAgICAgIHRoaXNba1Byb3h5SGVhZGVyc11bJ3Byb3h5LWF1dGhvcml6YXRpb24nXSA9IGBCYXNpYyAke0J1ZmZlci5mcm9tKGAke2RlY29kZVVSSUNvbXBvbmVudCh1c2VybmFtZSl9OiR7ZGVjb2RlVVJJQ29tcG9uZW50KHBhc3N3b3JkKX1gKS50b1N0cmluZygnYmFzZTY0Jyl9YFxuICAgIH1cblxuICAgIGNvbnN0IGNvbm5lY3QgPSBidWlsZENvbm5lY3Rvcih7IC4uLm9wdHMucHJveHlUbHMgfSlcbiAgICB0aGlzW2tDb25uZWN0RW5kcG9pbnRdID0gYnVpbGRDb25uZWN0b3IoeyAuLi5vcHRzLnJlcXVlc3RUbHMgfSlcbiAgICB0aGlzW2tDbGllbnRdID0gY2xpZW50RmFjdG9yeSh1cmwsIHsgY29ubmVjdCB9KVxuICAgIHRoaXNba0FnZW50XSA9IG5ldyBBZ2VudCh7XG4gICAgICAuLi5vcHRzLFxuICAgICAgY29ubmVjdDogYXN5bmMgKG9wdHMsIGNhbGxiYWNrKSA9PiB7XG4gICAgICAgIGxldCByZXF1ZXN0ZWRQYXRoID0gb3B0cy5ob3N0XG4gICAgICAgIGlmICghb3B0cy5wb3J0KSB7XG4gICAgICAgICAgcmVxdWVzdGVkUGF0aCArPSBgOiR7ZGVmYXVsdFByb3RvY29sUG9ydChvcHRzLnByb3RvY29sKX1gXG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCB7IHNvY2tldCwgc3RhdHVzQ29kZSB9ID0gYXdhaXQgdGhpc1trQ2xpZW50XS5jb25uZWN0KHtcbiAgICAgICAgICAgIG9yaWdpbixcbiAgICAgICAgICAgIHBvcnQsXG4gICAgICAgICAgICBwYXRoOiByZXF1ZXN0ZWRQYXRoLFxuICAgICAgICAgICAgc2lnbmFsOiBvcHRzLnNpZ25hbCxcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgLi4udGhpc1trUHJveHlIZWFkZXJzXSxcbiAgICAgICAgICAgICAgaG9zdDogb3B0cy5ob3N0XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2VydmVybmFtZTogdGhpc1trUHJveHlUbHNdPy5zZXJ2ZXJuYW1lIHx8IHByb3h5SG9zdG5hbWVcbiAgICAgICAgICB9KVxuICAgICAgICAgIGlmIChzdGF0dXNDb2RlICE9PSAyMDApIHtcbiAgICAgICAgICAgIHNvY2tldC5vbignZXJyb3InLCAoKSA9PiB7fSkuZGVzdHJveSgpXG4gICAgICAgICAgICBjYWxsYmFjayhuZXcgUmVxdWVzdEFib3J0ZWRFcnJvcihgUHJveHkgcmVzcG9uc2UgKCR7c3RhdHVzQ29kZX0pICE9PSAyMDAgd2hlbiBIVFRQIFR1bm5lbGluZ2ApKVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob3B0cy5wcm90b2NvbCAhPT0gJ2h0dHBzOicpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHNvY2tldClcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgc2VydmVybmFtZVxuICAgICAgICAgIGlmICh0aGlzW2tSZXF1ZXN0VGxzXSkge1xuICAgICAgICAgICAgc2VydmVybmFtZSA9IHRoaXNba1JlcXVlc3RUbHNdLnNlcnZlcm5hbWVcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VydmVybmFtZSA9IG9wdHMuc2VydmVybmFtZVxuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzW2tDb25uZWN0RW5kcG9pbnRdKHsgLi4ub3B0cywgc2VydmVybmFtZSwgaHR0cFNvY2tldDogc29ja2V0IH0sIGNhbGxiYWNrKVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBpZiAoZXJyLmNvZGUgPT09ICdFUlJfVExTX0NFUlRfQUxUTkFNRV9JTlZBTElEJykge1xuICAgICAgICAgICAgLy8gVGhyb3cgYSBjdXN0b20gZXJyb3IgdG8gYXZvaWQgbG9vcCBpbiBjbGllbnQuanMjY29ubmVjdFxuICAgICAgICAgICAgY2FsbGJhY2sobmV3IFNlY3VyZVByb3h5Q29ubmVjdGlvbkVycm9yKGVycikpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGVycilcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgZGlzcGF0Y2ggKG9wdHMsIGhhbmRsZXIpIHtcbiAgICBjb25zdCBoZWFkZXJzID0gYnVpbGRIZWFkZXJzKG9wdHMuaGVhZGVycylcbiAgICB0aHJvd0lmUHJveHlBdXRoSXNTZW50KGhlYWRlcnMpXG5cbiAgICBpZiAoaGVhZGVycyAmJiAhKCdob3N0JyBpbiBoZWFkZXJzKSAmJiAhKCdIb3N0JyBpbiBoZWFkZXJzKSkge1xuICAgICAgY29uc3QgeyBob3N0IH0gPSBuZXcgVVJMKG9wdHMub3JpZ2luKVxuICAgICAgaGVhZGVycy5ob3N0ID0gaG9zdFxuICAgIH1cblxuICAgIHJldHVybiB0aGlzW2tBZ2VudF0uZGlzcGF0Y2goXG4gICAgICB7XG4gICAgICAgIC4uLm9wdHMsXG4gICAgICAgIGhlYWRlcnNcbiAgICAgIH0sXG4gICAgICBoYW5kbGVyXG4gICAgKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KCcuLi90eXBlcy9wcm94eS1hZ2VudCcpLlByb3h5QWdlbnQuT3B0aW9ucyB8IHN0cmluZyB8IFVSTH0gb3B0c1xuICAgKiBAcmV0dXJucyB7VVJMfVxuICAgKi9cbiAgI2dldFVybCAob3B0cykge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBuZXcgVVJMKG9wdHMpXG4gICAgfSBlbHNlIGlmIChvcHRzIGluc3RhbmNlb2YgVVJMKSB7XG4gICAgICByZXR1cm4gb3B0c1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IFVSTChvcHRzLnVyaSlcbiAgICB9XG4gIH1cblxuICBhc3luYyBba0Nsb3NlXSAoKSB7XG4gICAgYXdhaXQgdGhpc1trQWdlbnRdLmNsb3NlKClcbiAgICBhd2FpdCB0aGlzW2tDbGllbnRdLmNsb3NlKClcbiAgfVxuXG4gIGFzeW5jIFtrRGVzdHJveV0gKCkge1xuICAgIGF3YWl0IHRoaXNba0FnZW50XS5kZXN0cm95KClcbiAgICBhd2FpdCB0aGlzW2tDbGllbnRdLmRlc3Ryb3koKVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmdbXSB8IFJlY29yZDxzdHJpbmcsIHN0cmluZz59IGhlYWRlcnNcbiAqIEByZXR1cm5zIHtSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+fVxuICovXG5mdW5jdGlvbiBidWlsZEhlYWRlcnMgKGhlYWRlcnMpIHtcbiAgLy8gV2hlbiB1c2luZyB1bmRpY2kuZmV0Y2gsIHRoZSBoZWFkZXJzIGxpc3QgaXMgc3RvcmVkXG4gIC8vIGFzIGFuIGFycmF5LlxuICBpZiAoQXJyYXkuaXNBcnJheShoZWFkZXJzKSkge1xuICAgIC8qKiBAdHlwZSB7UmVjb3JkPHN0cmluZywgc3RyaW5nPn0gKi9cbiAgICBjb25zdCBoZWFkZXJzUGFpciA9IHt9XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGhlYWRlcnMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgIGhlYWRlcnNQYWlyW2hlYWRlcnNbaV1dID0gaGVhZGVyc1tpICsgMV1cbiAgICB9XG5cbiAgICByZXR1cm4gaGVhZGVyc1BhaXJcbiAgfVxuXG4gIHJldHVybiBoZWFkZXJzXG59XG5cbi8qKlxuICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+fSBoZWFkZXJzXG4gKlxuICogUHJldmlvdXMgdmVyc2lvbnMgb2YgUHJveHlBZ2VudCBzdWdnZXN0cyB0aGUgUHJveHktQXV0aG9yaXphdGlvbiBpbiByZXF1ZXN0IGhlYWRlcnNcbiAqIE5ldmVydGhlbGVzcywgaXQgd2FzIGNoYW5nZWQgYW5kIHRvIGF2b2lkIGEgc2VjdXJpdHkgdnVsbmVyYWJpbGl0eSBieSBlbmQgdXNlcnNcbiAqIHRoaXMgY2hlY2sgd2FzIGNyZWF0ZWQuXG4gKiBJdCBzaG91bGQgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uIGZvciBwZXJmb3JtYW5jZSByZWFzb25zXG4gKi9cbmZ1bmN0aW9uIHRocm93SWZQcm94eUF1dGhJc1NlbnQgKGhlYWRlcnMpIHtcbiAgY29uc3QgZXhpc3RQcm94eUF1dGggPSBoZWFkZXJzICYmIE9iamVjdC5rZXlzKGhlYWRlcnMpXG4gICAgLmZpbmQoKGtleSkgPT4ga2V5LnRvTG93ZXJDYXNlKCkgPT09ICdwcm94eS1hdXRob3JpemF0aW9uJylcbiAgaWYgKGV4aXN0UHJveHlBdXRoKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdQcm94eS1BdXRob3JpemF0aW9uIHNob3VsZCBiZSBzZW50IGluIFByb3h5QWdlbnQgY29uc3RydWN0b3InKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUHJveHlBZ2VudFxuIl0sIm5hbWVzIjpbImtQcm94eSIsImtDbG9zZSIsImtEZXN0cm95Iiwia0ludGVyY2VwdG9ycyIsInJlcXVpcmUiLCJVUkwiLCJBZ2VudCIsIlBvb2wiLCJEaXNwYXRjaGVyQmFzZSIsIkludmFsaWRBcmd1bWVudEVycm9yIiwiUmVxdWVzdEFib3J0ZWRFcnJvciIsIlNlY3VyZVByb3h5Q29ubmVjdGlvbkVycm9yIiwiYnVpbGRDb25uZWN0b3IiLCJrQWdlbnQiLCJTeW1ib2wiLCJrQ2xpZW50Iiwia1Byb3h5SGVhZGVycyIsImtSZXF1ZXN0VGxzIiwia1Byb3h5VGxzIiwia0Nvbm5lY3RFbmRwb2ludCIsImRlZmF1bHRQcm90b2NvbFBvcnQiLCJwcm90b2NvbCIsImRlZmF1bHRGYWN0b3J5Iiwib3JpZ2luIiwib3B0cyIsIlByb3h5QWdlbnQiLCJjb25zdHJ1Y3RvciIsInVyaSIsImNsaWVudEZhY3RvcnkiLCJ1cmwiLCJnZXRVcmwiLCJocmVmIiwicG9ydCIsInVzZXJuYW1lIiwicGFzc3dvcmQiLCJob3N0bmFtZSIsInByb3h5SG9zdG5hbWUiLCJpbnRlcmNlcHRvcnMiLCJBcnJheSIsImlzQXJyYXkiLCJyZXF1ZXN0VGxzIiwicHJveHlUbHMiLCJoZWFkZXJzIiwiYXV0aCIsInRva2VuIiwiQnVmZmVyIiwiZnJvbSIsImRlY29kZVVSSUNvbXBvbmVudCIsInRvU3RyaW5nIiwiY29ubmVjdCIsImNhbGxiYWNrIiwicmVxdWVzdGVkUGF0aCIsImhvc3QiLCJzb2NrZXQiLCJzdGF0dXNDb2RlIiwicGF0aCIsInNpZ25hbCIsInNlcnZlcm5hbWUiLCJvbiIsImRlc3Ryb3kiLCJodHRwU29ja2V0IiwiZXJyIiwiY29kZSIsImRpc3BhdGNoIiwiaGFuZGxlciIsImJ1aWxkSGVhZGVycyIsInRocm93SWZQcm94eUF1dGhJc1NlbnQiLCIjZ2V0VXJsIiwiY2xvc2UiLCJoZWFkZXJzUGFpciIsImkiLCJsZW5ndGgiLCJleGlzdFByb3h5QXV0aCIsIk9iamVjdCIsImtleXMiLCJmaW5kIiwia2V5IiwidG9Mb3dlckNhc2UiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/dispatcher/proxy-agent.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/dispatcher/retry-agent.js":
/*!***********************************************************!*\
  !*** ./node_modules/undici/lib/dispatcher/retry-agent.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst Dispatcher = __webpack_require__(/*! ./dispatcher */ \"(ssr)/./node_modules/undici/lib/dispatcher/dispatcher.js\");\nconst RetryHandler = __webpack_require__(/*! ../handler/retry-handler */ \"(ssr)/./node_modules/undici/lib/handler/retry-handler.js\");\nclass RetryAgent extends Dispatcher {\n    #agent;\n    #options;\n    constructor(agent, options = {}){\n        super(options);\n        this.#agent = null;\n        this.#options = null;\n        this.#agent = agent;\n        this.#options = options;\n    }\n    dispatch(opts, handler) {\n        const retry = new RetryHandler({\n            ...opts,\n            retryOptions: this.#options\n        }, {\n            dispatch: this.#agent.dispatch.bind(this.#agent),\n            handler\n        });\n        return this.#agent.dispatch(opts, retry);\n    }\n    close() {\n        return this.#agent.close();\n    }\n    destroy() {\n        return this.#agent.destroy();\n    }\n}\nmodule.exports = RetryAgent;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9kaXNwYXRjaGVyL3JldHJ5LWFnZW50LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTUEsYUFBYUMsbUJBQU9BLENBQUM7QUFDM0IsTUFBTUMsZUFBZUQsbUJBQU9BLENBQUM7QUFFN0IsTUFBTUUsbUJBQW1CSDtJQUN2QixDQUFDSSxLQUFLLENBQU87SUFDYixDQUFDQyxPQUFPLENBQU87SUFDZkMsWUFBYUYsS0FBSyxFQUFFQyxVQUFVLENBQUMsQ0FBQyxDQUFFO1FBQ2hDLEtBQUssQ0FBQ0E7YUFIUixDQUFDRCxLQUFLLEdBQUc7YUFDVCxDQUFDQyxPQUFPLEdBQUc7UUFHVCxJQUFJLENBQUMsQ0FBQ0QsS0FBSyxHQUFHQTtRQUNkLElBQUksQ0FBQyxDQUFDQyxPQUFPLEdBQUdBO0lBQ2xCO0lBRUFFLFNBQVVDLElBQUksRUFBRUMsT0FBTyxFQUFFO1FBQ3ZCLE1BQU1DLFFBQVEsSUFBSVIsYUFBYTtZQUM3QixHQUFHTSxJQUFJO1lBQ1BHLGNBQWMsSUFBSSxDQUFDLENBQUNOLE9BQUFBO1FBQ3RCLEdBQUc7WUFDREUsVUFBVSxJQUFJLENBQUMsQ0FBQ0gsS0FBSyxDQUFDRyxRQUFRLENBQUNLLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQ1IsS0FBSztZQUMvQ0s7UUFDRjtRQUNBLE9BQU8sSUFBSSxDQUFDLENBQUNMLEtBQUssQ0FBQ0csUUFBUSxDQUFDQyxNQUFNRTtJQUNwQztJQUVBRyxRQUFTO1FBQ1AsT0FBTyxJQUFJLENBQUMsQ0FBQ1QsS0FBSyxDQUFDUyxLQUFLO0lBQzFCO0lBRUFDLFVBQVc7UUFDVCxPQUFPLElBQUksQ0FBQyxDQUFDVixLQUFLLENBQUNVLE9BQU87SUFDNUI7QUFDRjtBQUVBQyxPQUFPQyxPQUFPLEdBQUdiIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbW9ja3VwZmxvdy8uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2Rpc3BhdGNoZXIvcmV0cnktYWdlbnQuanM/NjRhOSIsIndlYnBhY2s6Ly9tb2NrdXBmbG93Ly4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvZGlzcGF0Y2hlci9yZXRyeS1hZ2VudC5qcz82NGE5KiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgRGlzcGF0Y2hlciA9IHJlcXVpcmUoJy4vZGlzcGF0Y2hlcicpXG5jb25zdCBSZXRyeUhhbmRsZXIgPSByZXF1aXJlKCcuLi9oYW5kbGVyL3JldHJ5LWhhbmRsZXInKVxuXG5jbGFzcyBSZXRyeUFnZW50IGV4dGVuZHMgRGlzcGF0Y2hlciB7XG4gICNhZ2VudCA9IG51bGxcbiAgI29wdGlvbnMgPSBudWxsXG4gIGNvbnN0cnVjdG9yIChhZ2VudCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIob3B0aW9ucylcbiAgICB0aGlzLiNhZ2VudCA9IGFnZW50XG4gICAgdGhpcy4jb3B0aW9ucyA9IG9wdGlvbnNcbiAgfVxuXG4gIGRpc3BhdGNoIChvcHRzLCBoYW5kbGVyKSB7XG4gICAgY29uc3QgcmV0cnkgPSBuZXcgUmV0cnlIYW5kbGVyKHtcbiAgICAgIC4uLm9wdHMsXG4gICAgICByZXRyeU9wdGlvbnM6IHRoaXMuI29wdGlvbnNcbiAgICB9LCB7XG4gICAgICBkaXNwYXRjaDogdGhpcy4jYWdlbnQuZGlzcGF0Y2guYmluZCh0aGlzLiNhZ2VudCksXG4gICAgICBoYW5kbGVyXG4gICAgfSlcbiAgICByZXR1cm4gdGhpcy4jYWdlbnQuZGlzcGF0Y2gob3B0cywgcmV0cnkpXG4gIH1cblxuICBjbG9zZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2FnZW50LmNsb3NlKClcbiAgfVxuXG4gIGRlc3Ryb3kgKCkge1xuICAgIHJldHVybiB0aGlzLiNhZ2VudC5kZXN0cm95KClcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJldHJ5QWdlbnRcbiJdLCJuYW1lcyI6WyJEaXNwYXRjaGVyIiwicmVxdWlyZSIsIlJldHJ5SGFuZGxlciIsIlJldHJ5QWdlbnQiLCJhZ2VudCIsIm9wdGlvbnMiLCJjb25zdHJ1Y3RvciIsImRpc3BhdGNoIiwib3B0cyIsImhhbmRsZXIiLCJyZXRyeSIsInJldHJ5T3B0aW9ucyIsImJpbmQiLCJjbG9zZSIsImRlc3Ryb3kiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/dispatcher/retry-agent.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/global.js":
/*!*******************************************!*\
  !*** ./node_modules/undici/lib/global.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n// We include a version number for the Dispatcher API. In case of breaking changes,\n// this version number must be increased to avoid conflicts.\nconst globalDispatcher = Symbol.for(\"undici.globalDispatcher.1\");\nconst { InvalidArgumentError } = __webpack_require__(/*! ./core/errors */ \"(ssr)/./node_modules/undici/lib/core/errors.js\");\nconst Agent = __webpack_require__(/*! ./dispatcher/agent */ \"(ssr)/./node_modules/undici/lib/dispatcher/agent.js\");\nif (getGlobalDispatcher() === undefined) {\n    setGlobalDispatcher(new Agent());\n}\nfunction setGlobalDispatcher(agent) {\n    if (!agent || typeof agent.dispatch !== \"function\") {\n        throw new InvalidArgumentError(\"Argument agent must implement Agent\");\n    }\n    Object.defineProperty(globalThis, globalDispatcher, {\n        value: agent,\n        writable: true,\n        enumerable: false,\n        configurable: false\n    });\n}\nfunction getGlobalDispatcher() {\n    return globalThis[globalDispatcher];\n}\nmodule.exports = {\n    setGlobalDispatcher,\n    getGlobalDispatcher\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9nbG9iYWwuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQTtBQUNBO0FBQ0EsTUFBTUEsbUJBQW1CQyxPQUFPQyxHQUFHLENBQUM7QUFDcEMsTUFBTSxFQUFFQyxvQkFBQUEsRUFBc0IsR0FBR0MsbUJBQU9BLENBQUM7QUFDekMsTUFBTUMsUUFBUUQsbUJBQU9BLENBQUM7QUFFdEIsSUFBSUUsMEJBQTBCQyxXQUFXO0lBQ3ZDQyxvQkFBb0IsSUFBSUg7QUFDMUI7QUFFQSxTQUFTRyxvQkFBcUJDLEtBQUs7SUFDakMsSUFBSSxDQUFDQSxTQUFTLE9BQU9BLE1BQU1DLFFBQVEsS0FBSyxZQUFZO1FBQ2xELE1BQU0sSUFBSVAscUJBQXFCO0lBQ2pDO0lBQ0FRLE9BQU9DLGNBQWMsQ0FBQ0MsWUFBWWIsa0JBQWtCO1FBQ2xEYyxPQUFPTDtRQUNQTSxVQUFVO1FBQ1ZDLFlBQVk7UUFDWkMsY0FBYztJQUNoQjtBQUNGO0FBRUEsU0FBU1g7SUFDUCxPQUFPTyxVQUFVLENBQUNiLGlCQUFpQjtBQUNyQztBQUVBa0IsT0FBT0MsT0FBTyxHQUFHO0lBQ2ZYO0lBQ0FGO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tb2NrdXBmbG93Ly4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvZ2xvYmFsLmpzP2RiOGEiLCJ3ZWJwYWNrOi8vbW9ja3VwZmxvdy8uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2dsb2JhbC5qcz9kYjhhKiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuLy8gV2UgaW5jbHVkZSBhIHZlcnNpb24gbnVtYmVyIGZvciB0aGUgRGlzcGF0Y2hlciBBUEkuIEluIGNhc2Ugb2YgYnJlYWtpbmcgY2hhbmdlcyxcbi8vIHRoaXMgdmVyc2lvbiBudW1iZXIgbXVzdCBiZSBpbmNyZWFzZWQgdG8gYXZvaWQgY29uZmxpY3RzLlxuY29uc3QgZ2xvYmFsRGlzcGF0Y2hlciA9IFN5bWJvbC5mb3IoJ3VuZGljaS5nbG9iYWxEaXNwYXRjaGVyLjEnKVxuY29uc3QgeyBJbnZhbGlkQXJndW1lbnRFcnJvciB9ID0gcmVxdWlyZSgnLi9jb3JlL2Vycm9ycycpXG5jb25zdCBBZ2VudCA9IHJlcXVpcmUoJy4vZGlzcGF0Y2hlci9hZ2VudCcpXG5cbmlmIChnZXRHbG9iYWxEaXNwYXRjaGVyKCkgPT09IHVuZGVmaW5lZCkge1xuICBzZXRHbG9iYWxEaXNwYXRjaGVyKG5ldyBBZ2VudCgpKVxufVxuXG5mdW5jdGlvbiBzZXRHbG9iYWxEaXNwYXRjaGVyIChhZ2VudCkge1xuICBpZiAoIWFnZW50IHx8IHR5cGVvZiBhZ2VudC5kaXNwYXRjaCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignQXJndW1lbnQgYWdlbnQgbXVzdCBpbXBsZW1lbnQgQWdlbnQnKVxuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShnbG9iYWxUaGlzLCBnbG9iYWxEaXNwYXRjaGVyLCB7XG4gICAgdmFsdWU6IGFnZW50LFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogZmFsc2VcbiAgfSlcbn1cblxuZnVuY3Rpb24gZ2V0R2xvYmFsRGlzcGF0Y2hlciAoKSB7XG4gIHJldHVybiBnbG9iYWxUaGlzW2dsb2JhbERpc3BhdGNoZXJdXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBzZXRHbG9iYWxEaXNwYXRjaGVyLFxuICBnZXRHbG9iYWxEaXNwYXRjaGVyXG59XG4iXSwibmFtZXMiOlsiZ2xvYmFsRGlzcGF0Y2hlciIsIlN5bWJvbCIsImZvciIsIkludmFsaWRBcmd1bWVudEVycm9yIiwicmVxdWlyZSIsIkFnZW50IiwiZ2V0R2xvYmFsRGlzcGF0Y2hlciIsInVuZGVmaW5lZCIsInNldEdsb2JhbERpc3BhdGNoZXIiLCJhZ2VudCIsImRpc3BhdGNoIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJnbG9iYWxUaGlzIiwidmFsdWUiLCJ3cml0YWJsZSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/global.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/handler/decorator-handler.js":
/*!**************************************************************!*\
  !*** ./node_modules/undici/lib/handler/decorator-handler.js ***!
  \**************************************************************/
/***/ ((module) => {

eval("\nmodule.exports = class DecoratorHandler {\n    #handler;\n    constructor(handler){\n        if (typeof handler !== \"object\" || handler === null) {\n            throw new TypeError(\"handler must be an object\");\n        }\n        this.#handler = handler;\n    }\n    onConnect(...args) {\n        return this.#handler.onConnect?.(...args);\n    }\n    onError(...args) {\n        return this.#handler.onError?.(...args);\n    }\n    onUpgrade(...args) {\n        return this.#handler.onUpgrade?.(...args);\n    }\n    onResponseStarted(...args) {\n        return this.#handler.onResponseStarted?.(...args);\n    }\n    onHeaders(...args) {\n        return this.#handler.onHeaders?.(...args);\n    }\n    onData(...args) {\n        return this.#handler.onData?.(...args);\n    }\n    onComplete(...args) {\n        return this.#handler.onComplete?.(...args);\n    }\n    onBodySent(...args) {\n        return this.#handler.onBodySent?.(...args);\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9oYW5kbGVyL2RlY29yYXRvci1oYW5kbGVyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUFBLE9BQU9DLE9BQU8sR0FBRyxNQUFNQztJQUNyQixDQUFDQyxPQUFPO0lBRVJDLFlBQWFELE9BQU8sQ0FBRTtRQUNwQixJQUFJLE9BQU9BLFlBQVksWUFBWUEsWUFBWSxNQUFNO1lBQ25ELE1BQU0sSUFBSUUsVUFBVTtRQUN0QjtRQUNBLElBQUksQ0FBQyxDQUFDRixPQUFPLEdBQUdBO0lBQ2xCO0lBRUFHLFVBQVcsR0FBR0MsSUFBSSxFQUFFO1FBQ2xCLE9BQU8sSUFBSSxDQUFDLENBQUNKLE9BQU8sQ0FBQ0csU0FBUyxNQUFNQztJQUN0QztJQUVBQyxRQUFTLEdBQUdELElBQUksRUFBRTtRQUNoQixPQUFPLElBQUksQ0FBQyxDQUFDSixPQUFPLENBQUNLLE9BQU8sTUFBTUQ7SUFDcEM7SUFFQUUsVUFBVyxHQUFHRixJQUFJLEVBQUU7UUFDbEIsT0FBTyxJQUFJLENBQUMsQ0FBQ0osT0FBTyxDQUFDTSxTQUFTLE1BQU1GO0lBQ3RDO0lBRUFHLGtCQUFtQixHQUFHSCxJQUFJLEVBQUU7UUFDMUIsT0FBTyxJQUFJLENBQUMsQ0FBQ0osT0FBTyxDQUFDTyxpQkFBaUIsTUFBTUg7SUFDOUM7SUFFQUksVUFBVyxHQUFHSixJQUFJLEVBQUU7UUFDbEIsT0FBTyxJQUFJLENBQUMsQ0FBQ0osT0FBTyxDQUFDUSxTQUFTLE1BQU1KO0lBQ3RDO0lBRUFLLE9BQVEsR0FBR0wsSUFBSSxFQUFFO1FBQ2YsT0FBTyxJQUFJLENBQUMsQ0FBQ0osT0FBTyxDQUFDUyxNQUFNLE1BQU1MO0lBQ25DO0lBRUFNLFdBQVksR0FBR04sSUFBSSxFQUFFO1FBQ25CLE9BQU8sSUFBSSxDQUFDLENBQUNKLE9BQU8sQ0FBQ1UsVUFBVSxNQUFNTjtJQUN2QztJQUVBTyxXQUFZLEdBQUdQLElBQUksRUFBRTtRQUNuQixPQUFPLElBQUksQ0FBQyxDQUFDSixPQUFPLENBQUNXLFVBQVUsTUFBTVA7SUFDdkM7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL21vY2t1cGZsb3cvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9oYW5kbGVyL2RlY29yYXRvci1oYW5kbGVyLmpzP2RlYTYiLCJ3ZWJwYWNrOi8vbW9ja3VwZmxvdy8uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2hhbmRsZXIvZGVjb3JhdG9yLWhhbmRsZXIuanM/ZGVhNioiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgRGVjb3JhdG9ySGFuZGxlciB7XG4gICNoYW5kbGVyXG5cbiAgY29uc3RydWN0b3IgKGhhbmRsZXIpIHtcbiAgICBpZiAodHlwZW9mIGhhbmRsZXIgIT09ICdvYmplY3QnIHx8IGhhbmRsZXIgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2hhbmRsZXIgbXVzdCBiZSBhbiBvYmplY3QnKVxuICAgIH1cbiAgICB0aGlzLiNoYW5kbGVyID0gaGFuZGxlclxuICB9XG5cbiAgb25Db25uZWN0ICguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuI2hhbmRsZXIub25Db25uZWN0Py4oLi4uYXJncylcbiAgfVxuXG4gIG9uRXJyb3IgKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy4jaGFuZGxlci5vbkVycm9yPy4oLi4uYXJncylcbiAgfVxuXG4gIG9uVXBncmFkZSAoLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLiNoYW5kbGVyLm9uVXBncmFkZT8uKC4uLmFyZ3MpXG4gIH1cblxuICBvblJlc3BvbnNlU3RhcnRlZCAoLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLiNoYW5kbGVyLm9uUmVzcG9uc2VTdGFydGVkPy4oLi4uYXJncylcbiAgfVxuXG4gIG9uSGVhZGVycyAoLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLiNoYW5kbGVyLm9uSGVhZGVycz8uKC4uLmFyZ3MpXG4gIH1cblxuICBvbkRhdGEgKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy4jaGFuZGxlci5vbkRhdGE/LiguLi5hcmdzKVxuICB9XG5cbiAgb25Db21wbGV0ZSAoLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLiNoYW5kbGVyLm9uQ29tcGxldGU/LiguLi5hcmdzKVxuICB9XG5cbiAgb25Cb2R5U2VudCAoLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLiNoYW5kbGVyLm9uQm9keVNlbnQ/LiguLi5hcmdzKVxuICB9XG59XG4iXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsIkRlY29yYXRvckhhbmRsZXIiLCJoYW5kbGVyIiwiY29uc3RydWN0b3IiLCJUeXBlRXJyb3IiLCJvbkNvbm5lY3QiLCJhcmdzIiwib25FcnJvciIsIm9uVXBncmFkZSIsIm9uUmVzcG9uc2VTdGFydGVkIiwib25IZWFkZXJzIiwib25EYXRhIiwib25Db21wbGV0ZSIsIm9uQm9keVNlbnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/handler/decorator-handler.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/handler/redirect-handler.js":
/*!*************************************************************!*\
  !*** ./node_modules/undici/lib/handler/redirect-handler.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst util = __webpack_require__(/*! ../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\");\nconst { kBodyUsed } = __webpack_require__(/*! ../core/symbols */ \"(ssr)/./node_modules/undici/lib/core/symbols.js\");\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\");\nconst { InvalidArgumentError } = __webpack_require__(/*! ../core/errors */ \"(ssr)/./node_modules/undici/lib/core/errors.js\");\nconst EE = __webpack_require__(/*! node:events */ \"node:events\");\nconst redirectableStatusCodes = [\n    300,\n    301,\n    302,\n    303,\n    307,\n    308\n];\nconst kBody = Symbol(\"body\");\nclass BodyAsyncIterable {\n    constructor(body){\n        this[kBody] = body;\n        this[kBodyUsed] = false;\n    }\n    async *[Symbol.asyncIterator]() {\n        assert(!this[kBodyUsed], \"disturbed\");\n        this[kBodyUsed] = true;\n        yield* this[kBody];\n    }\n}\nclass RedirectHandler {\n    constructor(dispatch, maxRedirections, opts, handler){\n        if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {\n            throw new InvalidArgumentError(\"maxRedirections must be a positive number\");\n        }\n        util.validateHandler(handler, opts.method, opts.upgrade);\n        this.dispatch = dispatch;\n        this.location = null;\n        this.abort = null;\n        this.opts = {\n            ...opts,\n            maxRedirections: 0\n        }; // opts must be a copy\n        this.maxRedirections = maxRedirections;\n        this.handler = handler;\n        this.history = [];\n        this.redirectionLimitReached = false;\n        if (util.isStream(this.opts.body)) {\n            // TODO (fix): Provide some way for the user to cache the file to e.g. /tmp\n            // so that it can be dispatched again?\n            // TODO (fix): Do we need 100-expect support to provide a way to do this properly?\n            if (util.bodyLength(this.opts.body) === 0) {\n                this.opts.body.on(\"data\", function() {\n                    assert(false);\n                });\n            }\n            if (typeof this.opts.body.readableDidRead !== \"boolean\") {\n                this.opts.body[kBodyUsed] = false;\n                EE.prototype.on.call(this.opts.body, \"data\", function() {\n                    this[kBodyUsed] = true;\n                });\n            }\n        } else if (this.opts.body && typeof this.opts.body.pipeTo === \"function\") {\n            // TODO (fix): We can't access ReadableStream internal state\n            // to determine whether or not it has been disturbed. This is just\n            // a workaround.\n            this.opts.body = new BodyAsyncIterable(this.opts.body);\n        } else if (this.opts.body && typeof this.opts.body !== \"string\" && !ArrayBuffer.isView(this.opts.body) && util.isIterable(this.opts.body)) {\n            // TODO: Should we allow re-using iterable if !this.opts.idempotent\n            // or through some other flag?\n            this.opts.body = new BodyAsyncIterable(this.opts.body);\n        }\n    }\n    onConnect(abort) {\n        this.abort = abort;\n        this.handler.onConnect(abort, {\n            history: this.history\n        });\n    }\n    onUpgrade(statusCode, headers, socket) {\n        this.handler.onUpgrade(statusCode, headers, socket);\n    }\n    onError(error) {\n        this.handler.onError(error);\n    }\n    onHeaders(statusCode, headers, resume, statusText) {\n        this.location = this.history.length >= this.maxRedirections || util.isDisturbed(this.opts.body) ? null : parseLocation(statusCode, headers);\n        if (this.opts.throwOnMaxRedirect && this.history.length >= this.maxRedirections) {\n            if (this.request) {\n                this.request.abort(new Error(\"max redirects\"));\n            }\n            this.redirectionLimitReached = true;\n            this.abort(new Error(\"max redirects\"));\n            return;\n        }\n        if (this.opts.origin) {\n            this.history.push(new URL(this.opts.path, this.opts.origin));\n        }\n        if (!this.location) {\n            return this.handler.onHeaders(statusCode, headers, resume, statusText);\n        }\n        const { origin, pathname, search } = util.parseURL(new URL(this.location, this.opts.origin && new URL(this.opts.path, this.opts.origin)));\n        const path = search ? `${pathname}${search}` : pathname;\n        // Remove headers referring to the original URL.\n        // By default it is Host only, unless it's a 303 (see below), which removes also all Content-* headers.\n        // https://tools.ietf.org/html/rfc7231#section-6.4\n        this.opts.headers = cleanRequestHeaders(this.opts.headers, statusCode === 303, this.opts.origin !== origin);\n        this.opts.path = path;\n        this.opts.origin = origin;\n        this.opts.maxRedirections = 0;\n        this.opts.query = null;\n        // https://tools.ietf.org/html/rfc7231#section-6.4.4\n        // In case of HTTP 303, always replace method to be either HEAD or GET\n        if (statusCode === 303 && this.opts.method !== \"HEAD\") {\n            this.opts.method = \"GET\";\n            this.opts.body = null;\n        }\n    }\n    onData(chunk) {\n        if (this.location) {\n        /*\n        https://tools.ietf.org/html/rfc7231#section-6.4\n         TLDR: undici always ignores 3xx response bodies.\n         Redirection is used to serve the requested resource from another URL, so it is assumes that\n        no body is generated (and thus can be ignored). Even though generating a body is not prohibited.\n         For status 301, 302, 303, 307 and 308 (the latter from RFC 7238), the specs mention that the body usually\n        (which means it's optional and not mandated) contain just an hyperlink to the value of\n        the Location response header, so the body can be ignored safely.\n         For status 300, which is \"Multiple Choices\", the spec mentions both generating a Location\n        response header AND a response body with the other possible location to follow.\n        Since the spec explicitly chooses not to specify a format for such body and leave it to\n        servers and browsers implementors, we ignore the body as there is no specified way to eventually parse it.\n      */ } else {\n            return this.handler.onData(chunk);\n        }\n    }\n    onComplete(trailers) {\n        if (this.location) {\n            /*\n        https://tools.ietf.org/html/rfc7231#section-6.4\n         TLDR: undici always ignores 3xx response trailers as they are not expected in case of redirections\n        and neither are useful if present.\n         See comment on onData method above for more detailed information.\n      */ this.location = null;\n            this.abort = null;\n            this.dispatch(this.opts, this);\n        } else {\n            this.handler.onComplete(trailers);\n        }\n    }\n    onBodySent(chunk) {\n        if (this.handler.onBodySent) {\n            this.handler.onBodySent(chunk);\n        }\n    }\n}\nfunction parseLocation(statusCode, headers) {\n    if (redirectableStatusCodes.indexOf(statusCode) === -1) {\n        return null;\n    }\n    for(let i = 0; i < headers.length; i += 2){\n        if (headers[i].length === 8 && util.headerNameToString(headers[i]) === \"location\") {\n            return headers[i + 1];\n        }\n    }\n}\n// https://tools.ietf.org/html/rfc7231#section-6.4.4\nfunction shouldRemoveHeader(header, removeContent, unknownOrigin) {\n    if (header.length === 4) {\n        return util.headerNameToString(header) === \"host\";\n    }\n    if (removeContent && util.headerNameToString(header).startsWith(\"content-\")) {\n        return true;\n    }\n    if (unknownOrigin && (header.length === 13 || header.length === 6 || header.length === 19)) {\n        const name = util.headerNameToString(header);\n        return name === \"authorization\" || name === \"cookie\" || name === \"proxy-authorization\";\n    }\n    return false;\n}\n// https://tools.ietf.org/html/rfc7231#section-6.4\nfunction cleanRequestHeaders(headers, removeContent, unknownOrigin) {\n    const ret = [];\n    if (Array.isArray(headers)) {\n        for(let i = 0; i < headers.length; i += 2){\n            if (!shouldRemoveHeader(headers[i], removeContent, unknownOrigin)) {\n                ret.push(headers[i], headers[i + 1]);\n            }\n        }\n    } else if (headers && typeof headers === \"object\") {\n        for (const key of Object.keys(headers)){\n            if (!shouldRemoveHeader(key, removeContent, unknownOrigin)) {\n                ret.push(key, headers[key]);\n            }\n        }\n    } else {\n        assert(headers == null, \"headers must be an object or an array\");\n    }\n    return ret;\n}\nmodule.exports = RedirectHandler;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9oYW5kbGVyL3JlZGlyZWN0LWhhbmRsZXIuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNQSxPQUFPQyxtQkFBT0EsQ0FBQztBQUNyQixNQUFNLEVBQUVDLFNBQUFBLEVBQVcsR0FBR0QsbUJBQU9BLENBQUM7QUFDOUIsTUFBTUUsU0FBU0YsbUJBQU9BLENBQUM7QUFDdkIsTUFBTSxFQUFFRyxvQkFBQUEsRUFBc0IsR0FBR0gsbUJBQU9BLENBQUM7QUFDekMsTUFBTUksS0FBS0osbUJBQU9BLENBQUM7QUFFbkIsTUFBTUssMEJBQTBCO0lBQUM7SUFBSztJQUFLO0lBQUs7SUFBSztJQUFLO0NBQUk7QUFFOUQsTUFBTUMsUUFBUUMsT0FBTztBQUVyQixNQUFNQztJQUNKQyxZQUFhQyxJQUFJLENBQUU7UUFDakIsSUFBSSxDQUFDSixNQUFNLEdBQUdJO1FBQ2QsSUFBSSxDQUFDVCxVQUFVLEdBQUc7SUFDcEI7SUFFQSxRQUFTTSxPQUFPSSxhQUFhLElBQUs7UUFDaENULE9BQU8sQ0FBQyxJQUFJLENBQUNELFVBQVUsRUFBRTtRQUN6QixJQUFJLENBQUNBLFVBQVUsR0FBRztRQUNsQixPQUFRLElBQUksQ0FBQ0ssTUFBTTtJQUNyQjtBQUNGO0FBRUEsTUFBTU07SUFDSkgsWUFBYUksUUFBUSxFQUFFQyxlQUFlLEVBQUVDLElBQUksRUFBRUMsT0FBTyxDQUFFO1FBQ3JELElBQUlGLG1CQUFtQixRQUFTLEVBQUNHLE9BQU9DLFNBQVMsQ0FBQ0osb0JBQW9CQSxrQkFBa0IsSUFBSTtZQUMxRixNQUFNLElBQUlYLHFCQUFxQjtRQUNqQztRQUVBSixLQUFLb0IsZUFBZSxDQUFDSCxTQUFTRCxLQUFLSyxNQUFNLEVBQUVMLEtBQUtNLE9BQU87UUFFdkQsSUFBSSxDQUFDUixRQUFRLEdBQUdBO1FBQ2hCLElBQUksQ0FBQ1MsUUFBUSxHQUFHO1FBQ2hCLElBQUksQ0FBQ0MsS0FBSyxHQUFHO1FBQ2IsSUFBSSxDQUFD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QUFNdUMsT0FBT0MsT0FBT0MsSUFBSSxDQUFDekMsU0FBVTtZQUN0QyxJQUFJLENBQUM4QixtQkFBbUJTLEtBQUtQLGVBQWVDLGdCQUFnQjtnQkFDMURHLElBQUl0QixJQUFJLENBQUN5QixLQUFLdkMsT0FBTyxDQUFDdUMsSUFBSTtZQUM1QjtRQUNGO0lBQ0YsT0FBTztRQUNMNUUsT0FBT3FDLFdBQVcsTUFBTTtJQUMxQjtJQUNBLE9BQU9vQztBQUNUO0FBRUFNLE9BQU9DLE9BQU8sR0FBR3RFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbW9ja3VwZmxvdy8uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2hhbmRsZXIvcmVkaXJlY3QtaGFuZGxlci5qcz81ZGRhIiwid2VicGFjazovL21vY2t1cGZsb3cvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9oYW5kbGVyL3JlZGlyZWN0LWhhbmRsZXIuanM/NWRkYSoiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHV0aWwgPSByZXF1aXJlKCcuLi9jb3JlL3V0aWwnKVxuY29uc3QgeyBrQm9keVVzZWQgfSA9IHJlcXVpcmUoJy4uL2NvcmUvc3ltYm9scycpXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdub2RlOmFzc2VydCcpXG5jb25zdCB7IEludmFsaWRBcmd1bWVudEVycm9yIH0gPSByZXF1aXJlKCcuLi9jb3JlL2Vycm9ycycpXG5jb25zdCBFRSA9IHJlcXVpcmUoJ25vZGU6ZXZlbnRzJylcblxuY29uc3QgcmVkaXJlY3RhYmxlU3RhdHVzQ29kZXMgPSBbMzAwLCAzMDEsIDMwMiwgMzAzLCAzMDcsIDMwOF1cblxuY29uc3Qga0JvZHkgPSBTeW1ib2woJ2JvZHknKVxuXG5jbGFzcyBCb2R5QXN5bmNJdGVyYWJsZSB7XG4gIGNvbnN0cnVjdG9yIChib2R5KSB7XG4gICAgdGhpc1trQm9keV0gPSBib2R5XG4gICAgdGhpc1trQm9keVVzZWRdID0gZmFsc2VcbiAgfVxuXG4gIGFzeW5jICogW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSAoKSB7XG4gICAgYXNzZXJ0KCF0aGlzW2tCb2R5VXNlZF0sICdkaXN0dXJiZWQnKVxuICAgIHRoaXNba0JvZHlVc2VkXSA9IHRydWVcbiAgICB5aWVsZCAqIHRoaXNba0JvZHldXG4gIH1cbn1cblxuY2xhc3MgUmVkaXJlY3RIYW5kbGVyIHtcbiAgY29uc3RydWN0b3IgKGRpc3BhdGNoLCBtYXhSZWRpcmVjdGlvbnMsIG9wdHMsIGhhbmRsZXIpIHtcbiAgICBpZiAobWF4UmVkaXJlY3Rpb25zICE9IG51bGwgJiYgKCFOdW1iZXIuaXNJbnRlZ2VyKG1heFJlZGlyZWN0aW9ucykgfHwgbWF4UmVkaXJlY3Rpb25zIDwgMCkpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignbWF4UmVkaXJlY3Rpb25zIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInKVxuICAgIH1cblxuICAgIHV0aWwudmFsaWRhdGVIYW5kbGVyKGhhbmRsZXIsIG9wdHMubWV0aG9kLCBvcHRzLnVwZ3JhZGUpXG5cbiAgICB0aGlzLmRpc3BhdGNoID0gZGlzcGF0Y2hcbiAgICB0aGlzLmxvY2F0aW9uID0gbnVsbFxuICAgIHRoaXMuYWJvcnQgPSBudWxsXG4gICAgdGhpcy5vcHRzID0geyAuLi5vcHRzLCBtYXhSZWRpcmVjdGlvbnM6IDAgfSAvLyBvcHRzIG11c3QgYmUgYSBjb3B5XG4gICAgdGhpcy5tYXhSZWRpcmVjdGlvbnMgPSBtYXhSZWRpcmVjdGlvbnNcbiAgICB0aGlzLmhhbmRsZXIgPSBoYW5kbGVyXG4gICAgdGhpcy5oaXN0b3J5ID0gW11cbiAgICB0aGlzLnJlZGlyZWN0aW9uTGltaXRSZWFjaGVkID0gZmFsc2VcblxuICAgIGlmICh1dGlsLmlzU3RyZWFtKHRoaXMub3B0cy5ib2R5KSkge1xuICAgICAgLy8gVE9ETyAoZml4KTogUHJvdmlkZSBzb21lIHdheSBmb3IgdGhlIHVzZXIgdG8gY2FjaGUgdGhlIGZpbGUgdG8gZS5nLiAvdG1wXG4gICAgICAvLyBzbyB0aGF0IGl0IGNhbiBiZSBkaXNwYXRjaGVkIGFnYWluP1xuICAgICAgLy8gVE9ETyAoZml4KTogRG8gd2UgbmVlZCAxMDAtZXhwZWN0IHN1cHBvcnQgdG8gcHJvdmlkZSBhIHdheSB0byBkbyB0aGlzIHByb3Blcmx5P1xuICAgICAgaWYgKHV0aWwuYm9keUxlbmd0aCh0aGlzLm9wdHMuYm9keSkgPT09IDApIHtcbiAgICAgICAgdGhpcy5vcHRzLmJvZHlcbiAgICAgICAgICAub24oJ2RhdGEnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBhc3NlcnQoZmFsc2UpXG4gICAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdHMuYm9keS5yZWFkYWJsZURpZFJlYWQgIT09ICdib29sZWFuJykge1xuICAgICAgICB0aGlzLm9wdHMuYm9keVtrQm9keVVzZWRdID0gZmFsc2VcbiAgICAgICAgRUUucHJvdG90eXBlLm9uLmNhbGwodGhpcy5vcHRzLmJvZHksICdkYXRhJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoaXNba0JvZHlVc2VkXSA9IHRydWVcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMub3B0cy5ib2R5ICYmIHR5cGVvZiB0aGlzLm9wdHMuYm9keS5waXBlVG8gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIFRPRE8gKGZpeCk6IFdlIGNhbid0IGFjY2VzcyBSZWFkYWJsZVN0cmVhbSBpbnRlcm5hbCBzdGF0ZVxuICAgICAgLy8gdG8gZGV0ZXJtaW5lIHdoZXRoZXIgb3Igbm90IGl0IGhhcyBiZWVuIGRpc3R1cmJlZC4gVGhpcyBpcyBqdXN0XG4gICAgICAvLyBhIHdvcmthcm91bmQuXG4gICAgICB0aGlzLm9wdHMuYm9keSA9IG5ldyBCb2R5QXN5bmNJdGVyYWJsZSh0aGlzLm9wdHMuYm9keSlcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgdGhpcy5vcHRzLmJvZHkgJiZcbiAgICAgIHR5cGVvZiB0aGlzLm9wdHMuYm9keSAhPT0gJ3N0cmluZycgJiZcbiAgICAgICFBcnJheUJ1ZmZlci5pc1ZpZXcodGhpcy5vcHRzLmJvZHkpICYmXG4gICAgICB1dGlsLmlzSXRlcmFibGUodGhpcy5vcHRzLmJvZHkpXG4gICAgKSB7XG4gICAgICAvLyBUT0RPOiBTaG91bGQgd2UgYWxsb3cgcmUtdXNpbmcgaXRlcmFibGUgaWYgIXRoaXMub3B0cy5pZGVtcG90ZW50XG4gICAgICAvLyBvciB0aHJvdWdoIHNvbWUgb3RoZXIgZmxhZz9cbiAgICAgIHRoaXMub3B0cy5ib2R5ID0gbmV3IEJvZHlBc3luY0l0ZXJhYmxlKHRoaXMub3B0cy5ib2R5KVxuICAgIH1cbiAgfVxuXG4gIG9uQ29ubmVjdCAoYWJvcnQpIHtcbiAgICB0aGlzLmFib3J0ID0gYWJvcnRcbiAgICB0aGlzLmhhbmRsZXIub25Db25uZWN0KGFib3J0LCB7IGhpc3Rvcnk6IHRoaXMuaGlzdG9yeSB9KVxuICB9XG5cbiAgb25VcGdyYWRlIChzdGF0dXNDb2RlLCBoZWFkZXJzLCBzb2NrZXQpIHtcbiAgICB0aGlzLmhhbmRsZXIub25VcGdyYWRlKHN0YXR1c0NvZGUsIGhlYWRlcnMsIHNvY2tldClcbiAgfVxuXG4gIG9uRXJyb3IgKGVycm9yKSB7XG4gICAgdGhpcy5oYW5kbGVyLm9uRXJyb3IoZXJyb3IpXG4gIH1cblxuICBvbkhlYWRlcnMgKHN0YXR1c0NvZGUsIGhlYWRlcnMsIHJlc3VtZSwgc3RhdHVzVGV4dCkge1xuICAgIHRoaXMubG9jYXRpb24gPSB0aGlzLmhpc3RvcnkubGVuZ3RoID49IHRoaXMubWF4UmVkaXJlY3Rpb25zIHx8IHV0aWwuaXNEaXN0dXJiZWQodGhpcy5vcHRzLmJvZHkpXG4gICAgICA/IG51bGxcbiAgICAgIDogcGFyc2VMb2NhdGlvbihzdGF0dXNDb2RlLCBoZWFkZXJzKVxuXG4gICAgaWYgKHRoaXMub3B0cy50aHJvd09uTWF4UmVkaXJlY3QgJiYgdGhpcy5oaXN0b3J5Lmxlbmd0aCA+PSB0aGlzLm1heFJlZGlyZWN0aW9ucykge1xuICAgICAgaWYgKHRoaXMucmVxdWVzdCkge1xuICAgICAgICB0aGlzLnJlcXVlc3QuYWJvcnQobmV3IEVycm9yKCdtYXggcmVkaXJlY3RzJykpXG4gICAgICB9XG5cbiAgICAgIHRoaXMucmVkaXJlY3Rpb25MaW1pdFJlYWNoZWQgPSB0cnVlXG4gICAgICB0aGlzLmFib3J0KG5ldyBFcnJvcignbWF4IHJlZGlyZWN0cycpKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0cy5vcmlnaW4pIHtcbiAgICAgIHRoaXMuaGlzdG9yeS5wdXNoKG5ldyBVUkwodGhpcy5vcHRzLnBhdGgsIHRoaXMub3B0cy5vcmlnaW4pKVxuICAgIH1cblxuICAgIGlmICghdGhpcy5sb2NhdGlvbikge1xuICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlci5vbkhlYWRlcnMoc3RhdHVzQ29kZSwgaGVhZGVycywgcmVzdW1lLCBzdGF0dXNUZXh0KVxuICAgIH1cblxuICAgIGNvbnN0IHsgb3JpZ2luLCBwYXRobmFtZSwgc2VhcmNoIH0gPSB1dGlsLnBhcnNlVVJMKG5ldyBVUkwodGhpcy5sb2NhdGlvbiwgdGhpcy5vcHRzLm9yaWdpbiAmJiBuZXcgVVJMKHRoaXMub3B0cy5wYXRoLCB0aGlzLm9wdHMub3JpZ2luKSkpXG4gICAgY29uc3QgcGF0aCA9IHNlYXJjaCA/IGAke3BhdGhuYW1lfSR7c2VhcmNofWAgOiBwYXRobmFtZVxuXG4gICAgLy8gUmVtb3ZlIGhlYWRlcnMgcmVmZXJyaW5nIHRvIHRoZSBvcmlnaW5hbCBVUkwuXG4gICAgLy8gQnkgZGVmYXVsdCBpdCBpcyBIb3N0IG9ubHksIHVubGVzcyBpdCdzIGEgMzAzIChzZWUgYmVsb3cpLCB3aGljaCByZW1vdmVzIGFsc28gYWxsIENvbnRlbnQtKiBoZWFkZXJzLlxuICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3MjMxI3NlY3Rpb24tNi40XG4gICAgdGhpcy5vcHRzLmhlYWRlcnMgPSBjbGVhblJlcXVlc3RIZWFkZXJzKHRoaXMub3B0cy5oZWFkZXJzLCBzdGF0dXNDb2RlID09PSAzMDMsIHRoaXMub3B0cy5vcmlnaW4gIT09IG9yaWdpbilcbiAgICB0aGlzLm9wdHMucGF0aCA9IHBhdGhcbiAgICB0aGlzLm9wdHMub3JpZ2luID0gb3JpZ2luXG4gICAgdGhpcy5vcHRzLm1heFJlZGlyZWN0aW9ucyA9IDBcbiAgICB0aGlzLm9wdHMucXVlcnkgPSBudWxsXG5cbiAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzIzMSNzZWN0aW9uLTYuNC40XG4gICAgLy8gSW4gY2FzZSBvZiBIVFRQIDMwMywgYWx3YXlzIHJlcGxhY2UgbWV0aG9kIHRvIGJlIGVpdGhlciBIRUFEIG9yIEdFVFxuICAgIGlmIChzdGF0dXNDb2RlID09PSAzMDMgJiYgdGhpcy5vcHRzLm1ldGhvZCAhPT0gJ0hFQUQnKSB7XG4gICAgICB0aGlzLm9wdHMubWV0aG9kID0gJ0dFVCdcbiAgICAgIHRoaXMub3B0cy5ib2R5ID0gbnVsbFxuICAgIH1cbiAgfVxuXG4gIG9uRGF0YSAoY2h1bmspIHtcbiAgICBpZiAodGhpcy5sb2NhdGlvbikge1xuICAgICAgLypcbiAgICAgICAgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzcyMzEjc2VjdGlvbi02LjRcblxuICAgICAgICBUTERSOiB1bmRpY2kgYWx3YXlzIGlnbm9yZXMgM3h4IHJlc3BvbnNlIGJvZGllcy5cblxuICAgICAgICBSZWRpcmVjdGlvbiBpcyB1c2VkIHRvIHNlcnZlIHRoZSByZXF1ZXN0ZWQgcmVzb3VyY2UgZnJvbSBhbm90aGVyIFVSTCwgc28gaXQgaXMgYXNzdW1lcyB0aGF0XG4gICAgICAgIG5vIGJvZHkgaXMgZ2VuZXJhdGVkIChhbmQgdGh1cyBjYW4gYmUgaWdub3JlZCkuIEV2ZW4gdGhvdWdoIGdlbmVyYXRpbmcgYSBib2R5IGlzIG5vdCBwcm9oaWJpdGVkLlxuXG4gICAgICAgIEZvciBzdGF0dXMgMzAxLCAzMDIsIDMwMywgMzA3IGFuZCAzMDggKHRoZSBsYXR0ZXIgZnJvbSBSRkMgNzIzOCksIHRoZSBzcGVjcyBtZW50aW9uIHRoYXQgdGhlIGJvZHkgdXN1YWxseVxuICAgICAgICAod2hpY2ggbWVhbnMgaXQncyBvcHRpb25hbCBhbmQgbm90IG1hbmRhdGVkKSBjb250YWluIGp1c3QgYW4gaHlwZXJsaW5rIHRvIHRoZSB2YWx1ZSBvZlxuICAgICAgICB0aGUgTG9jYXRpb24gcmVzcG9uc2UgaGVhZGVyLCBzbyB0aGUgYm9keSBjYW4gYmUgaWdub3JlZCBzYWZlbHkuXG5cbiAgICAgICAgRm9yIHN0YXR1cyAzMDAsIHdoaWNoIGlzIFwiTXVsdGlwbGUgQ2hvaWNlc1wiLCB0aGUgc3BlYyBtZW50aW9ucyBib3RoIGdlbmVyYXRpbmcgYSBMb2NhdGlvblxuICAgICAgICByZXNwb25zZSBoZWFkZXIgQU5EIGEgcmVzcG9uc2UgYm9keSB3aXRoIHRoZSBvdGhlciBwb3NzaWJsZSBsb2NhdGlvbiB0byBmb2xsb3cuXG4gICAgICAgIFNpbmNlIHRoZSBzcGVjIGV4cGxpY2l0bHkgY2hvb3NlcyBub3QgdG8gc3BlY2lmeSBhIGZvcm1hdCBmb3Igc3VjaCBib2R5IGFuZCBsZWF2ZSBpdCB0b1xuICAgICAgICBzZXJ2ZXJzIGFuZCBicm93c2VycyBpbXBsZW1lbnRvcnMsIHdlIGlnbm9yZSB0aGUgYm9keSBhcyB0aGVyZSBpcyBubyBzcGVjaWZpZWQgd2F5IHRvIGV2ZW50dWFsbHkgcGFyc2UgaXQuXG4gICAgICAqL1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5oYW5kbGVyLm9uRGF0YShjaHVuaylcbiAgICB9XG4gIH1cblxuICBvbkNvbXBsZXRlICh0cmFpbGVycykge1xuICAgIGlmICh0aGlzLmxvY2F0aW9uKSB7XG4gICAgICAvKlxuICAgICAgICBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzIzMSNzZWN0aW9uLTYuNFxuXG4gICAgICAgIFRMRFI6IHVuZGljaSBhbHdheXMgaWdub3JlcyAzeHggcmVzcG9uc2UgdHJhaWxlcnMgYXMgdGhleSBhcmUgbm90IGV4cGVjdGVkIGluIGNhc2Ugb2YgcmVkaXJlY3Rpb25zXG4gICAgICAgIGFuZCBuZWl0aGVyIGFyZSB1c2VmdWwgaWYgcHJlc2VudC5cblxuICAgICAgICBTZWUgY29tbWVudCBvbiBvbkRhdGEgbWV0aG9kIGFib3ZlIGZvciBtb3JlIGRldGFpbGVkIGluZm9ybWF0aW9uLlxuICAgICAgKi9cblxuICAgICAgdGhpcy5sb2NhdGlvbiA9IG51bGxcbiAgICAgIHRoaXMuYWJvcnQgPSBudWxsXG5cbiAgICAgIHRoaXMuZGlzcGF0Y2godGhpcy5vcHRzLCB0aGlzKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmhhbmRsZXIub25Db21wbGV0ZSh0cmFpbGVycylcbiAgICB9XG4gIH1cblxuICBvbkJvZHlTZW50IChjaHVuaykge1xuICAgIGlmICh0aGlzLmhhbmRsZXIub25Cb2R5U2VudCkge1xuICAgICAgdGhpcy5oYW5kbGVyLm9uQm9keVNlbnQoY2h1bmspXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHBhcnNlTG9jYXRpb24gKHN0YXR1c0NvZGUsIGhlYWRlcnMpIHtcbiAgaWYgKHJlZGlyZWN0YWJsZVN0YXR1c0NvZGVzLmluZGV4T2Yoc3RhdHVzQ29kZSkgPT09IC0xKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaGVhZGVycy5sZW5ndGg7IGkgKz0gMikge1xuICAgIGlmIChoZWFkZXJzW2ldLmxlbmd0aCA9PT0gOCAmJiB1dGlsLmhlYWRlck5hbWVUb1N0cmluZyhoZWFkZXJzW2ldKSA9PT0gJ2xvY2F0aW9uJykge1xuICAgICAgcmV0dXJuIGhlYWRlcnNbaSArIDFdXG4gICAgfVxuICB9XG59XG5cbi8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3MjMxI3NlY3Rpb24tNi40LjRcbmZ1bmN0aW9uIHNob3VsZFJlbW92ZUhlYWRlciAoaGVhZGVyLCByZW1vdmVDb250ZW50LCB1bmtub3duT3JpZ2luKSB7XG4gIGlmIChoZWFkZXIubGVuZ3RoID09PSA0KSB7XG4gICAgcmV0dXJuIHV0aWwuaGVhZGVyTmFtZVRvU3RyaW5nKGhlYWRlcikgPT09ICdob3N0J1xuICB9XG4gIGlmIChyZW1vdmVDb250ZW50ICYmIHV0aWwuaGVhZGVyTmFtZVRvU3RyaW5nKGhlYWRlcikuc3RhcnRzV2l0aCgnY29udGVudC0nKSkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgaWYgKHVua25vd25PcmlnaW4gJiYgKGhlYWRlci5sZW5ndGggPT09IDEzIHx8IGhlYWRlci5sZW5ndGggPT09IDYgfHwgaGVhZGVyLmxlbmd0aCA9PT0gMTkpKSB7XG4gICAgY29uc3QgbmFtZSA9IHV0aWwuaGVhZGVyTmFtZVRvU3RyaW5nKGhlYWRlcilcbiAgICByZXR1cm4gbmFtZSA9PT0gJ2F1dGhvcml6YXRpb24nIHx8IG5hbWUgPT09ICdjb29raWUnIHx8IG5hbWUgPT09ICdwcm94eS1hdXRob3JpemF0aW9uJ1xuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG4vLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzIzMSNzZWN0aW9uLTYuNFxuZnVuY3Rpb24gY2xlYW5SZXF1ZXN0SGVhZGVycyAoaGVhZGVycywgcmVtb3ZlQ29udGVudCwgdW5rbm93bk9yaWdpbikge1xuICBjb25zdCByZXQgPSBbXVxuICBpZiAoQXJyYXkuaXNBcnJheShoZWFkZXJzKSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaGVhZGVycy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgaWYgKCFzaG91bGRSZW1vdmVIZWFkZXIoaGVhZGVyc1tpXSwgcmVtb3ZlQ29udGVudCwgdW5rbm93bk9yaWdpbikpIHtcbiAgICAgICAgcmV0LnB1c2goaGVhZGVyc1tpXSwgaGVhZGVyc1tpICsgMV0pXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGhlYWRlcnMgJiYgdHlwZW9mIGhlYWRlcnMgPT09ICdvYmplY3QnKSB7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoaGVhZGVycykpIHtcbiAgICAgIGlmICghc2hvdWxkUmVtb3ZlSGVhZGVyKGtleSwgcmVtb3ZlQ29udGVudCwgdW5rbm93bk9yaWdpbikpIHtcbiAgICAgICAgcmV0LnB1c2goa2V5LCBoZWFkZXJzW2tleV0pXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGFzc2VydChoZWFkZXJzID09IG51bGwsICdoZWFkZXJzIG11c3QgYmUgYW4gb2JqZWN0IG9yIGFuIGFycmF5JylcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVkaXJlY3RIYW5kbGVyXG4iXSwibmFtZXMiOlsidXRpbCIsInJlcXVpcmUiLCJrQm9keVVzZWQiLCJhc3NlcnQiLCJJbnZhbGlkQXJndW1lbnRFcnJvciIsIkVFIiwicmVkaXJlY3RhYmxlU3RhdHVzQ29kZXMiLCJrQm9keSIsIlN5bWJvbCIsIkJvZHlBc3luY0l0ZXJhYmxlIiwiY29uc3RydWN0b3IiLCJib2R5IiwiYXN5bmNJdGVyYXRvciIsIlJlZGlyZWN0SGFuZGxlciIsImRpc3BhdGNoIiwibWF4UmVkaXJlY3Rpb25zIiwib3B0cyIsImhhbmRsZXIiLCJOdW1iZXIiLCJpc0ludGVnZXIiLCJ2YWxpZGF0ZUhhbmRsZXIiLCJtZXRob2QiLCJ1cGdyYWRlIiwibG9jYXRpb24iLCJhYm9ydCIsImhpc3RvcnkiLCJyZWRpcmVjdGlvbkxpbWl0UmVhY2hlZCIsImlzU3RyZWFtIiwiYm9keUxlbmd0aCIsIm9uIiwicmVhZGFibGVEaWRSZWFkIiwicHJvdG90eXBlIiwiY2FsbCIsInBpcGVUbyIsIkFycmF5QnVmZmVyIiwiaXNWaWV3IiwiaXNJdGVyYWJsZSIsIm9uQ29ubmVjdCIsIm9uVXBncmFkZSIsInN0YXR1c0NvZGUiLCJoZWFkZXJzIiwic29ja2V0Iiwib25FcnJvciIsImVycm9yIiwib25IZWFkZXJzIiwicmVzdW1lIiwic3RhdHVzVGV4dCIsImxlbmd0aCIsImlzRGlzdHVyYmVkIiwicGFyc2VMb2NhdGlvbiIsInRocm93T25NYXhSZWRpcmVjdCIsInJlcXVlc3QiLCJFcnJvciIsIm9yaWdpbiIsInB1c2giLCJVUkwiLCJwYXRoIiwicGF0aG5hbWUiLCJzZWFyY2giLCJwYXJzZVVSTCIsImNsZWFuUmVxdWVzdEhlYWRlcnMiLCJxdWVyeSIsIm9uRGF0YSIsImNodW5rIiwib25Db21wbGV0ZSIsInRyYWlsZXJzIiwib25Cb2R5U2VudCIsImluZGV4T2YiLCJpIiwiaGVhZGVyTmFtZVRvU3RyaW5nIiwic2hvdWxkUmVtb3ZlSGVhZGVyIiwiaGVhZGVyIiwicmVtb3ZlQ29udGVudCIsInVua25vd25PcmlnaW4iLCJzdGFydHNXaXRoIiwibmFtZSIsInJldCIsIkFycmF5IiwiaXNBcnJheSIsImtleSIsIk9iamVjdCIsImtleXMiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/handler/redirect-handler.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/handler/retry-handler.js":
/*!**********************************************************!*\
  !*** ./node_modules/undici/lib/handler/retry-handler.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\");\nconst { kRetryHandlerDefaultRetry } = __webpack_require__(/*! ../core/symbols */ \"(ssr)/./node_modules/undici/lib/core/symbols.js\");\nconst { RequestRetryError } = __webpack_require__(/*! ../core/errors */ \"(ssr)/./node_modules/undici/lib/core/errors.js\");\nconst { isDisturbed, parseHeaders, parseRangeHeader, wrapRequestBody } = __webpack_require__(/*! ../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\");\nfunction calculateRetryAfterHeader(retryAfter) {\n    const current = Date.now();\n    return new Date(retryAfter).getTime() - current;\n}\nclass RetryHandler {\n    constructor(opts, handlers){\n        const { retryOptions, ...dispatchOpts } = opts;\n        const { // Retry scoped\n        retry: retryFn, maxRetries, maxTimeout, minTimeout, timeoutFactor, // Response scoped\n        methods, errorCodes, retryAfter, statusCodes } = retryOptions ?? {};\n        this.dispatch = handlers.dispatch;\n        this.handler = handlers.handler;\n        this.opts = {\n            ...dispatchOpts,\n            body: wrapRequestBody(opts.body)\n        };\n        this.abort = null;\n        this.aborted = false;\n        this.retryOpts = {\n            retry: retryFn ?? RetryHandler[kRetryHandlerDefaultRetry],\n            retryAfter: retryAfter ?? true,\n            maxTimeout: maxTimeout ?? 30 * 1000,\n            // 30s,\n            minTimeout: minTimeout ?? 500,\n            // .5s\n            timeoutFactor: timeoutFactor ?? 2,\n            maxRetries: maxRetries ?? 5,\n            // What errors we should retry\n            methods: methods ?? [\n                \"GET\",\n                \"HEAD\",\n                \"OPTIONS\",\n                \"PUT\",\n                \"DELETE\",\n                \"TRACE\"\n            ],\n            // Indicates which errors to retry\n            statusCodes: statusCodes ?? [\n                500,\n                502,\n                503,\n                504,\n                429\n            ],\n            // List of errors to retry\n            errorCodes: errorCodes ?? [\n                \"ECONNRESET\",\n                \"ECONNREFUSED\",\n                \"ENOTFOUND\",\n                \"ENETDOWN\",\n                \"ENETUNREACH\",\n                \"EHOSTDOWN\",\n                \"EHOSTUNREACH\",\n                \"EPIPE\",\n                \"UND_ERR_SOCKET\"\n            ]\n        };\n        this.retryCount = 0;\n        this.retryCountCheckpoint = 0;\n        this.start = 0;\n        this.end = null;\n        this.etag = null;\n        this.resume = null;\n        // Handle possible onConnect duplication\n        this.handler.onConnect((reason)=>{\n            this.aborted = true;\n            if (this.abort) {\n                this.abort(reason);\n            } else {\n                this.reason = reason;\n            }\n        });\n    }\n    onRequestSent() {\n        if (this.handler.onRequestSent) {\n            this.handler.onRequestSent();\n        }\n    }\n    onUpgrade(statusCode, headers, socket) {\n        if (this.handler.onUpgrade) {\n            this.handler.onUpgrade(statusCode, headers, socket);\n        }\n    }\n    onConnect(abort) {\n        if (this.aborted) {\n            abort(this.reason);\n        } else {\n            this.abort = abort;\n        }\n    }\n    onBodySent(chunk) {\n        if (this.handler.onBodySent) return this.handler.onBodySent(chunk);\n    }\n    static [kRetryHandlerDefaultRetry](err, { state, opts }, cb) {\n        const { statusCode, code, headers } = err;\n        const { method, retryOptions } = opts;\n        const { maxRetries, minTimeout, maxTimeout, timeoutFactor, statusCodes, errorCodes, methods } = retryOptions;\n        const { counter } = state;\n        // Any code that is not a Undici's originated and allowed to retry\n        if (code && code !== \"UND_ERR_REQ_RETRY\" && !errorCodes.includes(code)) {\n            cb(err);\n            return;\n        }\n        // If a set of method are provided and the current method is not in the list\n        if (Array.isArray(methods) && !methods.includes(method)) {\n            cb(err);\n            return;\n        }\n        // If a set of status code are provided and the current status code is not in the list\n        if (statusCode != null && Array.isArray(statusCodes) && !statusCodes.includes(statusCode)) {\n            cb(err);\n            return;\n        }\n        // If we reached the max number of retries\n        if (counter > maxRetries) {\n            cb(err);\n            return;\n        }\n        let retryAfterHeader = headers?.[\"retry-after\"];\n        if (retryAfterHeader) {\n            retryAfterHeader = Number(retryAfterHeader);\n            retryAfterHeader = Number.isNaN(retryAfterHeader) ? calculateRetryAfterHeader(retryAfterHeader) : retryAfterHeader * 1e3; // Retry-After is in seconds\n        }\n        const retryTimeout = retryAfterHeader > 0 ? Math.min(retryAfterHeader, maxTimeout) : Math.min(minTimeout * timeoutFactor ** (counter - 1), maxTimeout);\n        setTimeout(()=>cb(null), retryTimeout);\n    }\n    onHeaders(statusCode, rawHeaders, resume, statusMessage) {\n        const headers = parseHeaders(rawHeaders);\n        this.retryCount += 1;\n        if (statusCode >= 300) {\n            if (this.retryOpts.statusCodes.includes(statusCode) === false) {\n                return this.handler.onHeaders(statusCode, rawHeaders, resume, statusMessage);\n            } else {\n                this.abort(new RequestRetryError(\"Request failed\", statusCode, {\n                    headers,\n                    data: {\n                        count: this.retryCount\n                    }\n                }));\n                return false;\n            }\n        }\n        // Checkpoint for resume from where we left it\n        if (this.resume != null) {\n            this.resume = null;\n            if (statusCode !== 206) {\n                return true;\n            }\n            const contentRange = parseRangeHeader(headers[\"content-range\"]);\n            // If no content range\n            if (!contentRange) {\n                this.abort(new RequestRetryError(\"Content-Range mismatch\", statusCode, {\n                    headers,\n                    data: {\n                        count: this.retryCount\n                    }\n                }));\n                return false;\n            }\n            // Let's start with a weak etag check\n            if (this.etag != null && this.etag !== headers.etag) {\n                this.abort(new RequestRetryError(\"ETag mismatch\", statusCode, {\n                    headers,\n                    data: {\n                        count: this.retryCount\n                    }\n                }));\n                return false;\n            }\n            const { start, size, end = size } = contentRange;\n            assert(this.start === start, \"content-range mismatch\");\n            assert(this.end == null || this.end === end, \"content-range mismatch\");\n            this.resume = resume;\n            return true;\n        }\n        if (this.end == null) {\n            if (statusCode === 206) {\n                // First time we receive 206\n                const range = parseRangeHeader(headers[\"content-range\"]);\n                if (range == null) {\n                    return this.handler.onHeaders(statusCode, rawHeaders, resume, statusMessage);\n                }\n                const { start, size, end = size } = range;\n                assert(start != null && Number.isFinite(start), \"content-range mismatch\");\n                assert(end != null && Number.isFinite(end), \"invalid content-length\");\n                this.start = start;\n                this.end = end;\n            }\n            // We make our best to checkpoint the body for further range headers\n            if (this.end == null) {\n                const contentLength = headers[\"content-length\"];\n                this.end = contentLength != null ? Number(contentLength) : null;\n            }\n            assert(Number.isFinite(this.start));\n            assert(this.end == null || Number.isFinite(this.end), \"invalid content-length\");\n            this.resume = resume;\n            this.etag = headers.etag != null ? headers.etag : null;\n            // Weak etags are not useful for comparison nor cache\n            // for instance not safe to assume if the response is byte-per-byte\n            // equal\n            if (this.etag != null && this.etag.startsWith(\"W/\")) {\n                this.etag = null;\n            }\n            return this.handler.onHeaders(statusCode, rawHeaders, resume, statusMessage);\n        }\n        const err = new RequestRetryError(\"Request failed\", statusCode, {\n            headers,\n            data: {\n                count: this.retryCount\n            }\n        });\n        this.abort(err);\n        return false;\n    }\n    onData(chunk) {\n        this.start += chunk.length;\n        return this.handler.onData(chunk);\n    }\n    onComplete(rawTrailers) {\n        this.retryCount = 0;\n        return this.handler.onComplete(rawTrailers);\n    }\n    onError(err) {\n        if (this.aborted || isDisturbed(this.opts.body)) {\n            return this.handler.onError(err);\n        }\n        // We reconcile in case of a mix between network errors\n        // and server error response\n        if (this.retryCount - this.retryCountCheckpoint > 0) {\n            // We count the difference between the last checkpoint and the current retry count\n            this.retryCount = this.retryCountCheckpoint + (this.retryCount - this.retryCountCheckpoint);\n        } else {\n            this.retryCount += 1;\n        }\n        this.retryOpts.retry(err, {\n            state: {\n                counter: this.retryCount\n            },\n            opts: {\n                retryOptions: this.retryOpts,\n                ...this.opts\n            }\n        }, onRetry.bind(this));\n        function onRetry(err) {\n            if (err != null || this.aborted || isDisturbed(this.opts.body)) {\n                return this.handler.onError(err);\n            }\n            if (this.start !== 0) {\n                const headers = {\n                    range: `bytes=${this.start}-${this.end ?? \"\"}`\n                };\n                // Weak etag check - weak etags will make comparison algorithms never match\n                if (this.etag != null) {\n                    headers[\"if-match\"] = this.etag;\n                }\n                this.opts = {\n                    ...this.opts,\n                    headers: {\n                        ...this.opts.headers,\n                        ...headers\n                    }\n                };\n            }\n            try {\n                this.retryCountCheckpoint = this.retryCount;\n                this.dispatch(this.opts, this);\n            } catch (err) {\n                this.handler.onError(err);\n            }\n        }\n    }\n}\nmodule.exports = RetryHandler;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9oYW5kbGVyL3JldHJ5LWhhbmRsZXIuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxNQUFNQSxTQUFTQyxtQkFBT0EsQ0FBQztBQUV2QixNQUFNLEVBQUVDLHlCQUFBQSxFQUEyQixHQUFHRCxtQkFBT0EsQ0FBQztBQUM5QyxNQUFNLEVBQUVFLGlCQUFBQSxFQUFtQixHQUFHRixtQkFBT0EsQ0FBQztBQUN0QyxNQUFNLEVBQ0pHLFdBQVcsRUFDWEMsWUFBWSxFQUNaQyxnQkFBZ0IsRUFDaEJDLGVBQUFBLEVBQ0QsR0FBR04sbUJBQU9BLENBQUM7QUFFWixTQUFTTywwQkFBMkJDLFVBQVU7SUFDNUMsTUFBTUMsVUFBVUMsS0FBS0MsR0FBRztJQUN4QixPQUFPLElBQUlELEtBQUtGLFlBQVlJLE9BQU8sS0FBS0g7QUFDMUM7QUFFQSxNQUFNSTtJQUNKQyxZQUFhQyxJQUFJLEVBQUVDLFFBQVEsQ0FBRTtRQUMzQixNQUFNLEVBQUVDLFlBQVksRUFBRSxHQUFHQyxjQUFjLEdBQUdIO1FBQzFDLE1BQU0sRUFDSjtRQUNBSSxPQUFPQyxPQUFPLEVBQ2RDLFVBQVUsRUFDVkMsVUFBVSxFQUNWQyxVQUFVLEVBQ1ZDLGFBQWEsRUFDYjtRQUNBQyxPQUFPLEVBQ1BDLFVBQVUsRUFDVmxCLFVBQVUsRUFDVm1CLFdBQUFBLEVBQ0QsR0FBR1YsZ0JBQWdCLENBQUM7UUFFckIsSUFBSSxDQUFDVyxRQUFRLEdBQUdaLFNBQVNZLFFBQVE7UUFDakMsSUFBSSxDQUFDQyxPQUFPLEdBQUdiLFNBQVNhLE9BQU87UUFDL0IsSUFBSSxDQUFDZCxJQUFJLEdBQUc7WUFBRSxHQUFHRyxZQUFZO1lBQUVZLE1BQU14QixnQkFBZ0JTLEtBQUtlLElBQUk7UUFBRTtRQUNoRSxJQUFJLENBQUNDLEtBQUssR0FBRztRQUNiLElBQUksQ0FBQ0MsT0FBTyxHQUFHO1FBQ2YsSUFBSSxDQUFDQyxTQUFTLEdBQUc7WUFDZmQsT0FBT0MsV0FBV1AsWUFBWSxDQUFDWiwwQkFBMEI7WUFDekRPLFlBQVlBLGNBQWM7WUFDMUJjLFlBQVlBLGNBQWMsS0FBSztZQUFNO1lBQ3JDQyxZQUFZQSxjQUFjO1lBQUs7WUFDL0JDLGVBQWVBLGlCQUFpQjtZQUNoQ0gsWUFBWUEsY0FBYztZQUMxQjtZQUNBSSxTQUFTQSxXQUFXO2dCQUFDO2dCQUFPO2dCQUFRO2dCQUFXO2dCQUFPO2dCQUFVO2FBQVE7WUFDeEU7WUFDQUUsYUFBYUEsZUFBZTtnQkFBQztnQkFBSztnQkFBSztnQkFBSztnQkFBSzthQUFJO1lBQ3JEO1lBQ0FELFlBQVlBLGNBQWM7Z0JBQ3hCO2dCQUNBO2dCQUNBO2dCQUNBO2dCQUNBO2dCQUNBO2dCQUNBO2dCQUNBO2dCQUNBO2FBQWdCO1FBRXBCO1FBRUEsSUFBSSxDQUFDUSxVQUFVLEdBQUc7UUFDbEIsSUFBSSxDQUFDQyxvQkFBb0IsR0FBRztRQUM1QixJQUFJLENBQUNDLEtBQUssR0FBRztRQUNiLElBQUksQ0FBQ0MsR0FBRyxHQUFHO1FBQ1gsSUFBSSxDQUFDQyxJQUFJLEdBQUc7UUFDWixJQUFJLENBQUNDLE1BQU0sR0FBRztRQUVkO1FBQ0EsSUFBSSxDQUFDVixPQUFPLENBQUNXLFNBQVMsQ0FBQ0MsQ0FBQUE7WUFDckIsSUFBSSxDQUFDVCxPQUFPLEdBQUc7WUFDZixJQUFJLElBQUksQ0FBQ0QsS0FBSyxFQUFFO2dCQUNkLElBQUksQ0FBQ0EsS0FBSyxDQUFDVTtZQUNiLE9BQU87Z0JBQ0wsSUFBSSxDQUFDQSxNQUFNLEdBQUdBO1lBQ2hCO1FBQ0Y7SUFDRjtJQUVBQyxnQkFBaUI7UUFDZixJQUFJLElBQUksQ0FBQ2IsT0FBTyxDQUFDYSxhQUFhLEVBQUU7WUFDOUIsSUFBSSxDQUFDYixPQUFPLENBQUNhLGFBQWE7UUFDNUI7SUFDRjtJQUVBQyxVQUFXQyxVQUFVLEVBQUVDLE9BQU8sRUFBRUMsTUFBTSxFQUFFO1FBQ3RDLElBQUksSUFBSSxDQUFDakIsT0FBTyxDQUFDYyxTQUFTLEVBQUU7WUFDMUIsSUFBSSxDQUFDZCxPQUFPLENBQUNjLFNBQVMsQ0FBQ0MsWUFBWUMsU0FBU0M7UUFDOUM7SUFDRjtJQUVBTixVQUFXVCxLQUFLLEVBQUU7UUFDaEIsSUFBSSxJQUFJLENBQUNDLE9BQU8sRUFBRTtZQUNoQkQsTUFBTSxJQUFJLENBQUNVLE1BQU07UUFDbkIsT0FBTztZQUNMLElBQUksQ0FBQ1YsS0FBSyxHQUFHQTtRQUNmO0lBQ0Y7SUFFQWdCLFdBQVlDLEtBQUssRUFBRTtRQUNqQixJQUFJLElBQUksQ0FBQ25CLE9BQU8sQ0FBQ2tCLFVBQVUsRUFBRSxPQUFPLElBQUksQ0FBQ2xCLE9BQU8sQ0FBQ2tCLFVBQVUsQ0FBQ0M7SUFDOUQ7SUFFQSxRQUFRL0MsMEJBQXlCLENBQUdnRCxHQUFHLEVBQUUsRUFBRUMsS0FBSyxFQUFFbkMsSUFBQUEsRUFBTSxFQUFFb0MsRUFBRSxFQUFFO1FBQzVELE1BQU0sRUFBRVAsVUFBVSxFQUFFUSxJQUFJLEVBQUVQLE9BQUFBLEVBQVMsR0FBR0k7UUFDdEMsTUFBTSxFQUFFSSxNQUFNLEVBQUVwQyxZQUFBQSxFQUFjLEdBQUdGO1FBQ2pDLE1BQU0sRUFDSk0sVUFBVSxFQUNWRSxVQUFVLEVBQ1ZELFVBQVUsRUFDVkUsYUFBYSxFQUNiRyxXQUFXLEVBQ1hELFVBQVUsRUFDVkQsT0FBQUEsRUFDRCxHQUFHUjtRQUNKLE1BQU0sRUFBRXFDLE9BQUFBLEVBQVMsR0FBR0o7UUFFcEI7UUFDQSxJQUFJRSxRQUFRQSxTQUFTLHVCQUF1QixDQUFDMUIsV0FBVzZCLFFBQVEsQ0FBQ0gsT0FBTztZQUN0RUQsR0FBR0Y7WUFDSDtRQUNGO1FBRUE7UUFDQSxJQUFJTyxNQUFNQyxPQUFPLENBQUNoQyxZQUFZLENBQUNBLFFBQVE4QixRQUFRLENBQUNGLFNBQVM7WUFDdkRGLEdBQUdGO1lBQ0g7UUFDRjtRQUVBO1FBQ0EsSUFDRUwsY0FBYyxRQUNkWSxNQUFNQyxPQUFPLENBQUM5QixnQkFDZCxDQUFDQSxZQUFZNEIsUUFBUSxDQUFDWCxhQUN0QjtZQUNBTyxHQUFHRjtZQUNIO1FBQ0Y7UUFFQTtRQUNBLElBQUlLLFVBQVVqQyxZQUFZO1lBQ3hCOEIsR0FBR0Y7WUFDSDtRQUNGO1FBRUEsSUFBSVMsbUJBQW1CYixTQUFPLENBQUcsY0FBYztRQUMvQyxJQUFJYSxrQkFBa0I7WUFDcEJBLG1CQUFtQkMsT0FBT0Q7WUFDMUJBLG1CQUFtQkMsT0FBT0MsS0FBSyxDQUFDRixvQkFDNUJuRCwwQkFBMEJtRCxvQkFDMUJBLG1CQUFtQixLQUFJO1FBQzdCO1FBRUEsTUFBTUcsZUFDSkgsbUJBQW1CLElBQ2ZJLEtBQUtDLEdBQUcsQ0FBQ0wsa0JBQWtCcEMsY0FDM0J3QyxLQUFLQyxHQUFHLENBQUN4QyxhQUFhQyxpQkFBa0I4QixDQUFBQSxVQUFVLElBQUloQztRQUU1RDBDLFdBQVcsSUFBTWIsR0FBRyxPQUFPVTtJQUM3QjtJQUVBSSxVQUFXckIsVUFBVSxFQUFFc0IsVUFBVSxFQUFFM0IsTUFBTSxFQUFFNEIsYUFBYSxFQUFFO1FBQ3hELE1BQU10QixVQUFVekMsYUFBYThEO1FBRTdCLElBQUksQ0FBQ2hDLFVBQVUsSUFBSTtRQUVuQixJQUFJVSxjQUFjLEtBQUs7WUFDckIsSUFBSSxJQUFJLENBQUNYLFNBQVMsQ0FBQ04sV0FBVyxDQUFDNEIsUUFBUSxDQUFDWCxnQkFBZ0IsT0FBTztnQkFDN0QsT0FBTyxJQUFJLENBQUNmLE9BQU8sQ0FBQ29DLFNBQVMsQ0FDM0JyQixZQUNBc0IsWUFDQTNCLFFBQ0E0QjtZQUVKLE9BQU87Z0JBQ0wsSUFBSSxDQUFDcEMsS0FBSyxDQUNSLElBQUk3QixrQkFBa0Isa0JBQWtCMEMsWUFBWTtvQkFDbERDO29CQUNBdUIsTUFBTTt3QkFDSkMsT0FBTyxJQUFJLENBQUNuQyxVQUFBQTtvQkFDZDtnQkFDRjtnQkFFRixPQUFPO1lBQ1Q7UUFDRjtRQUVBO1FBQ0EsSUFBSSxJQUFJLENBQUNLLE1BQU0sSUFBSSxNQUFNO1lBQ3ZCLElBQUksQ0FBQ0EsTUFBTSxHQUFHO1lBRWQsSUFBSUssZUFBZSxLQUFLO2dCQUN0QixPQUFPO1lBQ1Q7WUFFQSxNQUFNMEIsZUFBZWpFLGlCQUFpQndDLE9BQU8sQ0FBQyxnQkFBZ0I7WUFDOUQ7WUFDQSxJQUFJLENBQUN5QixjQUFjO2dCQUNqQixJQUFJLENBQUN2QyxLQUFLLENBQ1IsSUFBSTdCLGtCQUFrQiwwQkFBMEIwQyxZQUFZO29CQUMxREM7b0JBQ0F1QixNQUFNO3dCQUFFQyxPQUFPLElBQUksQ0FBQ25DLFVBQUFBO29CQUFXO2dCQUNqQztnQkFFRixPQUFPO1lBQ1Q7WUFFQTtZQUNBLElBQUksSUFBSSxDQUFDSSxJQUFJLElBQUksUUFBUSxJQUFJLENBQUNBLElBQUksS0FBS08sUUFBUVAsSUFBSSxFQUFFO2dCQUNuRCxJQUFJLENBQUNQLEtBQUssQ0FDUixJQUFJN0Isa0JBQWtCLGlCQUFpQjBDLFlBQVk7b0JBQ2pEQztvQkFDQXVCLE1BQU07d0JBQUVDLE9BQU8sSUFBSSxDQUFDbkMsVUFBQUE7b0JBQVc7Z0JBQ2pDO2dCQUVGLE9BQU87WUFDVDtZQUVBLE1BQU0sRUFBRUUsS0FBSyxFQUFFbUMsSUFBSSxFQUFFbEMsTUFBTWtDLElBQUFBLEVBQU0sR0FBR0Q7WUFFcEN2RSxPQUFPLElBQUksQ0FBQ3FDLEtBQUssS0FBS0EsT0FBTztZQUM3QnJDLE9BQU8sSUFBSSxDQUFDc0MsR0FBRyxJQUFJLFFBQVEsSUFBSSxDQUFDQSxHQUFHLEtBQUtBLEtBQUs7WUFFN0MsSUFBSSxDQUFDRSxNQUFNLEdBQUdBO1lBQ2QsT0FBTztRQUNUO1FBRUEsSUFBSSxJQUFJLENBQUNGLEdBQUcsSUFBSSxNQUFNO1lBQ3BCLElBQUlPLGVBQWUsS0FBSztnQkFDdEI7Z0JBQ0EsTUFBTTRCLFFBQVFuRSxpQkFBaUJ3QyxPQUFPLENBQUMsZ0JBQWdCO2dCQUV2RCxJQUFJMkIsU0FBUyxNQUFNO29CQUNqQixPQUFPLElBQUksQ0FBQzNDLE9BQU8sQ0FBQ29DLFNBQVMsQ0FDM0JyQixZQUNBc0IsWUFDQTNCLFFBQ0E0QjtnQkFFSjtnQkFFQSxNQUFNLEVBQUUvQixLQUFLLEVBQUVtQyxJQUFJLEVBQUVsQyxNQUFNa0MsSUFBQUEsRUFBTSxHQUFHQztnQkFDcEN6RSxPQUNFcUMsU0FBUyxRQUFRdUIsT0FBT2MsUUFBUSxDQUFDckMsUUFDakM7Z0JBRUZyQyxPQUFPc0MsT0FBTyxRQUFRc0IsT0FBT2MsUUFBUSxDQUFDcEMsTUFBTTtnQkFFNUMsSUFBSSxDQUFDRCxLQUFLLEdBQUdBO2dCQUNiLElBQUksQ0FBQ0MsR0FBRyxHQUFHQTtZQUNiO1lBRUE7WUFDQSxJQUFJLElBQUksQ0FBQ0EsR0FBRyxJQUFJLE1BQU07Z0JBQ3BCLE1BQU1xQyxnQkFBZ0I3QixPQUFPLENBQUMsaUJBQWlCO2dCQUMvQyxJQUFJLENBQUNSLEdBQUcsR0FBR3FDLGlCQUFpQixPQUFPZixPQUFPZSxpQkFBaUI7WUFDN0Q7WUFFQTNFLE9BQU80RCxPQUFPYyxRQUFRLENBQUMsSUFBSSxDQUFDckMsS0FBSztZQUNqQ3JDLE9BQ0UsSUFBSSxDQUFDc0MsR0FBRyxJQUFJLFFBQVFzQixPQUFPYyxRQUFRLENBQUMsSUFBSSxDQUFDcEMsR0FBRyxHQUM1QztZQUdGLElBQUksQ0FBQ0UsTUFBTSxHQUFHQTtZQUNkLElBQUksQ0FBQ0QsSUFBSSxHQUFHTyxRQUFRUCxJQUFJLElBQUksT0FBT08sUUFBUVAsSUFBSSxHQUFHO1lBRWxEO1lBQ0E7WUFDQTtZQUNBLElBQUksSUFBSSxDQUFDQSxJQUFJLElBQUksUUFBUSxJQUFJLENBQUNBLElBQUksQ0FBQ3FDLFVBQVUsQ0FBQyxPQUFPO2dCQUNuRCxJQUFJLENBQUNyQyxJQUFJLEdBQUc7WUFDZDtZQUVBLE9BQU8sSUFBSSxDQUFDVCxPQUFPLENBQUNvQyxTQUFTLENBQzNCckIsWUFDQXNCLFlBQ0EzQixRQUNBNEI7UUFFSjtRQUVBLE1BQU1sQixNQUFNLElBQUkvQyxrQkFBa0Isa0JBQWtCMEMsWUFBWTtZQUM5REM7WUFDQXVCLE1BQU07Z0JBQUVDLE9BQU8sSUFBSSxDQUFDbkMsVUFBQUE7WUFBVztRQUNqQztRQUVBLElBQUksQ0FBQ0gsS0FBSyxDQUFDa0I7UUFFWCxPQUFPO0lBQ1Q7SUFFQTJCLE9BQVE1QixLQUFLLEVBQUU7UUFDYixJQUFJLENBQUNaLEtBQUssSUFBSVksTUFBTTZCLE1BQU07UUFFMUIsT0FBTyxJQUFJLENBQUNoRCxPQUFPLENBQUMrQyxNQUFNLENBQUM1QjtJQUM3QjtJQUVBOEIsV0FBWUMsV0FBVyxFQUFFO1FBQ3ZCLElBQUksQ0FBQzdDLFVBQVUsR0FBRztRQUNsQixPQUFPLElBQUksQ0FBQ0wsT0FBTyxDQUFDaUQsVUFBVSxDQUFDQztJQUNqQztJQUVBQyxRQUFTL0IsR0FBRyxFQUFFO1FBQ1osSUFBSSxJQUFJLENBQUNqQixPQUFPLElBQUk3QixZQUFZLElBQUksQ0FBQ1ksSUFBSSxDQUFDZSxJQUFJLEdBQUc7WUFDL0MsT0FBTyxJQUFJLENBQUNELE9BQU8sQ0FBQ21ELE9BQU8sQ0FBQy9CO1FBQzlCO1FBRUE7UUFDQTtRQUNBLElBQUksSUFBSSxDQUFDZixVQUFVLEdBQUcsSUFBSSxDQUFDQyxvQkFBb0IsR0FBRyxHQUFHO1lBQ25EO1lBQ0EsSUFBSSxDQUFDRCxVQUFVLEdBQ2IsSUFBSSxDQUFDQyxvQkFBb0IsR0FDeEIsS0FBSSxDQUFDRCxVQUFVLEdBQUcsSUFBSSxDQUFDQyxvQkFBb0I7UUFDaEQsT0FBTztZQUNMLElBQUksQ0FBQ0QsVUFBVSxJQUFJO1FBQ3JCO1FBRUEsSUFBSSxDQUFDRCxTQUFTLENBQUNkLEtBQUssQ0FDbEI4QixLQUNBO1lBQ0VDLE9BQU87Z0JBQUVJLFNBQVMsSUFBSSxDQUFDcEIsVUFBQUE7WUFBVztZQUNsQ25CLE1BQU07Z0JBQUVFLGNBQWMsSUFBSSxDQUFDZ0IsU0FBUztnQkFBRSxHQUFHLElBQUksQ0FBQ2xCLElBQUFBO1lBQUs7UUFDckQsR0FDQWtFLFFBQVFDLElBQUksQ0FBQyxJQUFJO1FBR25CLFNBQVNELFFBQVNoQyxHQUFHO1lBQ25CLElBQUlBLE9BQU8sUUFBUSxJQUFJLENBQUNqQixPQUFPLElBQUk3QixZQUFZLElBQUksQ0FBQ1ksSUFBSSxDQUFDZSxJQUFJLEdBQUc7Z0JBQzlELE9BQU8sSUFBSSxDQUFDRCxPQUFPLENBQUNtRCxPQUFPLENBQUMvQjtZQUM5QjtZQUVBLElBQUksSUFBSSxDQUFDYixLQUFLLEtBQUssR0FBRztnQkFDcEIsTUFBTVMsVUFBVTtvQkFBRTJCLE9BQU8sU0FBUyxJQUFJLENBQUNwQyxLQUFLLElBQUksSUFBSSxDQUFDQyxHQUFHLElBQUksR0FBRTtnQkFBRztnQkFFakU7Z0JBQ0EsSUFBSSxJQUFJLENBQUNDLElBQUksSUFBSSxNQUFNO29CQUNyQk8sT0FBTyxDQUFDLFdBQVcsR0FBRyxJQUFJLENBQUNQLElBQUk7Z0JBQ2pDO2dCQUVBLElBQUksQ0FBQ3ZCLElBQUksR0FBRztvQkFDVixHQUFHLElBQUksQ0FBQ0EsSUFBSTtvQkFDWjhCLFNBQVM7d0JBQ1AsR0FBRyxJQUFJLENBQUM5QixJQUFJLENBQUM4QixPQUFPO3dCQUNwQixHQUFHQSxPQUFBQTtvQkFDTDtnQkFDRjtZQUNGO1lBRUEsSUFBSTtnQkFDRixJQUFJLENBQUNWLG9CQUFvQixHQUFHLElBQUksQ0FBQ0QsVUFBVTtnQkFDM0MsSUFBSSxDQUFDTixRQUFRLENBQUMsSUFBSSxDQUFDYixJQUFJLEVBQUUsSUFBSTtZQUMvQixFQUFFLE9BQU9rQyxLQUFLO2dCQUNaLElBQUksQ0FBQ3BCLE9BQU8sQ0FBQ21ELE9BQU8sQ0FBQy9CO1lBQ3ZCO1FBQ0Y7SUFDRjtBQUNGO0FBRUFrQyxPQUFPQyxPQUFPLEdBQUd2RSIsInNvdXJjZXMiOlsid2VicGFjazovL21vY2t1cGZsb3cvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9oYW5kbGVyL3JldHJ5LWhhbmRsZXIuanM/NjZhYyIsIndlYnBhY2s6Ly9tb2NrdXBmbG93Ly4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvaGFuZGxlci9yZXRyeS1oYW5kbGVyLmpzPzY2YWMqIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZSgnbm9kZTphc3NlcnQnKVxuXG5jb25zdCB7IGtSZXRyeUhhbmRsZXJEZWZhdWx0UmV0cnkgfSA9IHJlcXVpcmUoJy4uL2NvcmUvc3ltYm9scycpXG5jb25zdCB7IFJlcXVlc3RSZXRyeUVycm9yIH0gPSByZXF1aXJlKCcuLi9jb3JlL2Vycm9ycycpXG5jb25zdCB7XG4gIGlzRGlzdHVyYmVkLFxuICBwYXJzZUhlYWRlcnMsXG4gIHBhcnNlUmFuZ2VIZWFkZXIsXG4gIHdyYXBSZXF1ZXN0Qm9keVxufSA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpXG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZVJldHJ5QWZ0ZXJIZWFkZXIgKHJldHJ5QWZ0ZXIpIHtcbiAgY29uc3QgY3VycmVudCA9IERhdGUubm93KClcbiAgcmV0dXJuIG5ldyBEYXRlKHJldHJ5QWZ0ZXIpLmdldFRpbWUoKSAtIGN1cnJlbnRcbn1cblxuY2xhc3MgUmV0cnlIYW5kbGVyIHtcbiAgY29uc3RydWN0b3IgKG9wdHMsIGhhbmRsZXJzKSB7XG4gICAgY29uc3QgeyByZXRyeU9wdGlvbnMsIC4uLmRpc3BhdGNoT3B0cyB9ID0gb3B0c1xuICAgIGNvbnN0IHtcbiAgICAgIC8vIFJldHJ5IHNjb3BlZFxuICAgICAgcmV0cnk6IHJldHJ5Rm4sXG4gICAgICBtYXhSZXRyaWVzLFxuICAgICAgbWF4VGltZW91dCxcbiAgICAgIG1pblRpbWVvdXQsXG4gICAgICB0aW1lb3V0RmFjdG9yLFxuICAgICAgLy8gUmVzcG9uc2Ugc2NvcGVkXG4gICAgICBtZXRob2RzLFxuICAgICAgZXJyb3JDb2RlcyxcbiAgICAgIHJldHJ5QWZ0ZXIsXG4gICAgICBzdGF0dXNDb2Rlc1xuICAgIH0gPSByZXRyeU9wdGlvbnMgPz8ge31cblxuICAgIHRoaXMuZGlzcGF0Y2ggPSBoYW5kbGVycy5kaXNwYXRjaFxuICAgIHRoaXMuaGFuZGxlciA9IGhhbmRsZXJzLmhhbmRsZXJcbiAgICB0aGlzLm9wdHMgPSB7IC4uLmRpc3BhdGNoT3B0cywgYm9keTogd3JhcFJlcXVlc3RCb2R5KG9wdHMuYm9keSkgfVxuICAgIHRoaXMuYWJvcnQgPSBudWxsXG4gICAgdGhpcy5hYm9ydGVkID0gZmFsc2VcbiAgICB0aGlzLnJldHJ5T3B0cyA9IHtcbiAgICAgIHJldHJ5OiByZXRyeUZuID8/IFJldHJ5SGFuZGxlcltrUmV0cnlIYW5kbGVyRGVmYXVsdFJldHJ5XSxcbiAgICAgIHJldHJ5QWZ0ZXI6IHJldHJ5QWZ0ZXIgPz8gdHJ1ZSxcbiAgICAgIG1heFRpbWVvdXQ6IG1heFRpbWVvdXQgPz8gMzAgKiAxMDAwLCAvLyAzMHMsXG4gICAgICBtaW5UaW1lb3V0OiBtaW5UaW1lb3V0ID8/IDUwMCwgLy8gLjVzXG4gICAgICB0aW1lb3V0RmFjdG9yOiB0aW1lb3V0RmFjdG9yID8/IDIsXG4gICAgICBtYXhSZXRyaWVzOiBtYXhSZXRyaWVzID8/IDUsXG4gICAgICAvLyBXaGF0IGVycm9ycyB3ZSBzaG91bGQgcmV0cnlcbiAgICAgIG1ldGhvZHM6IG1ldGhvZHMgPz8gWydHRVQnLCAnSEVBRCcsICdPUFRJT05TJywgJ1BVVCcsICdERUxFVEUnLCAnVFJBQ0UnXSxcbiAgICAgIC8vIEluZGljYXRlcyB3aGljaCBlcnJvcnMgdG8gcmV0cnlcbiAgICAgIHN0YXR1c0NvZGVzOiBzdGF0dXNDb2RlcyA/PyBbNTAwLCA1MDIsIDUwMywgNTA0LCA0MjldLFxuICAgICAgLy8gTGlzdCBvZiBlcnJvcnMgdG8gcmV0cnlcbiAgICAgIGVycm9yQ29kZXM6IGVycm9yQ29kZXMgPz8gW1xuICAgICAgICAnRUNPTk5SRVNFVCcsXG4gICAgICAgICdFQ09OTlJFRlVTRUQnLFxuICAgICAgICAnRU5PVEZPVU5EJyxcbiAgICAgICAgJ0VORVRET1dOJyxcbiAgICAgICAgJ0VORVRVTlJFQUNIJyxcbiAgICAgICAgJ0VIT1NURE9XTicsXG4gICAgICAgICdFSE9TVFVOUkVBQ0gnLFxuICAgICAgICAnRVBJUEUnLFxuICAgICAgICAnVU5EX0VSUl9TT0NLRVQnXG4gICAgICBdXG4gICAgfVxuXG4gICAgdGhpcy5yZXRyeUNvdW50ID0gMFxuICAgIHRoaXMucmV0cnlDb3VudENoZWNrcG9pbnQgPSAwXG4gICAgdGhpcy5zdGFydCA9IDBcbiAgICB0aGlzLmVuZCA9IG51bGxcbiAgICB0aGlzLmV0YWcgPSBudWxsXG4gICAgdGhpcy5yZXN1bWUgPSBudWxsXG5cbiAgICAvLyBIYW5kbGUgcG9zc2libGUgb25Db25uZWN0IGR1cGxpY2F0aW9uXG4gICAgdGhpcy5oYW5kbGVyLm9uQ29ubmVjdChyZWFzb24gPT4ge1xuICAgICAgdGhpcy5hYm9ydGVkID0gdHJ1ZVxuICAgICAgaWYgKHRoaXMuYWJvcnQpIHtcbiAgICAgICAgdGhpcy5hYm9ydChyZWFzb24pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJlYXNvbiA9IHJlYXNvblxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBvblJlcXVlc3RTZW50ICgpIHtcbiAgICBpZiAodGhpcy5oYW5kbGVyLm9uUmVxdWVzdFNlbnQpIHtcbiAgICAgIHRoaXMuaGFuZGxlci5vblJlcXVlc3RTZW50KClcbiAgICB9XG4gIH1cblxuICBvblVwZ3JhZGUgKHN0YXR1c0NvZGUsIGhlYWRlcnMsIHNvY2tldCkge1xuICAgIGlmICh0aGlzLmhhbmRsZXIub25VcGdyYWRlKSB7XG4gICAgICB0aGlzLmhhbmRsZXIub25VcGdyYWRlKHN0YXR1c0NvZGUsIGhlYWRlcnMsIHNvY2tldClcbiAgICB9XG4gIH1cblxuICBvbkNvbm5lY3QgKGFib3J0KSB7XG4gICAgaWYgKHRoaXMuYWJvcnRlZCkge1xuICAgICAgYWJvcnQodGhpcy5yZWFzb24pXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWJvcnQgPSBhYm9ydFxuICAgIH1cbiAgfVxuXG4gIG9uQm9keVNlbnQgKGNodW5rKSB7XG4gICAgaWYgKHRoaXMuaGFuZGxlci5vbkJvZHlTZW50KSByZXR1cm4gdGhpcy5oYW5kbGVyLm9uQm9keVNlbnQoY2h1bmspXG4gIH1cblxuICBzdGF0aWMgW2tSZXRyeUhhbmRsZXJEZWZhdWx0UmV0cnldIChlcnIsIHsgc3RhdGUsIG9wdHMgfSwgY2IpIHtcbiAgICBjb25zdCB7IHN0YXR1c0NvZGUsIGNvZGUsIGhlYWRlcnMgfSA9IGVyclxuICAgIGNvbnN0IHsgbWV0aG9kLCByZXRyeU9wdGlvbnMgfSA9IG9wdHNcbiAgICBjb25zdCB7XG4gICAgICBtYXhSZXRyaWVzLFxuICAgICAgbWluVGltZW91dCxcbiAgICAgIG1heFRpbWVvdXQsXG4gICAgICB0aW1lb3V0RmFjdG9yLFxuICAgICAgc3RhdHVzQ29kZXMsXG4gICAgICBlcnJvckNvZGVzLFxuICAgICAgbWV0aG9kc1xuICAgIH0gPSByZXRyeU9wdGlvbnNcbiAgICBjb25zdCB7IGNvdW50ZXIgfSA9IHN0YXRlXG5cbiAgICAvLyBBbnkgY29kZSB0aGF0IGlzIG5vdCBhIFVuZGljaSdzIG9yaWdpbmF0ZWQgYW5kIGFsbG93ZWQgdG8gcmV0cnlcbiAgICBpZiAoY29kZSAmJiBjb2RlICE9PSAnVU5EX0VSUl9SRVFfUkVUUlknICYmICFlcnJvckNvZGVzLmluY2x1ZGVzKGNvZGUpKSB7XG4gICAgICBjYihlcnIpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBJZiBhIHNldCBvZiBtZXRob2QgYXJlIHByb3ZpZGVkIGFuZCB0aGUgY3VycmVudCBtZXRob2QgaXMgbm90IGluIHRoZSBsaXN0XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobWV0aG9kcykgJiYgIW1ldGhvZHMuaW5jbHVkZXMobWV0aG9kKSkge1xuICAgICAgY2IoZXJyKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gSWYgYSBzZXQgb2Ygc3RhdHVzIGNvZGUgYXJlIHByb3ZpZGVkIGFuZCB0aGUgY3VycmVudCBzdGF0dXMgY29kZSBpcyBub3QgaW4gdGhlIGxpc3RcbiAgICBpZiAoXG4gICAgICBzdGF0dXNDb2RlICE9IG51bGwgJiZcbiAgICAgIEFycmF5LmlzQXJyYXkoc3RhdHVzQ29kZXMpICYmXG4gICAgICAhc3RhdHVzQ29kZXMuaW5jbHVkZXMoc3RhdHVzQ29kZSlcbiAgICApIHtcbiAgICAgIGNiKGVycilcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIElmIHdlIHJlYWNoZWQgdGhlIG1heCBudW1iZXIgb2YgcmV0cmllc1xuICAgIGlmIChjb3VudGVyID4gbWF4UmV0cmllcykge1xuICAgICAgY2IoZXJyKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgbGV0IHJldHJ5QWZ0ZXJIZWFkZXIgPSBoZWFkZXJzPy5bJ3JldHJ5LWFmdGVyJ11cbiAgICBpZiAocmV0cnlBZnRlckhlYWRlcikge1xuICAgICAgcmV0cnlBZnRlckhlYWRlciA9IE51bWJlcihyZXRyeUFmdGVySGVhZGVyKVxuICAgICAgcmV0cnlBZnRlckhlYWRlciA9IE51bWJlci5pc05hTihyZXRyeUFmdGVySGVhZGVyKVxuICAgICAgICA/IGNhbGN1bGF0ZVJldHJ5QWZ0ZXJIZWFkZXIocmV0cnlBZnRlckhlYWRlcilcbiAgICAgICAgOiByZXRyeUFmdGVySGVhZGVyICogMWUzIC8vIFJldHJ5LUFmdGVyIGlzIGluIHNlY29uZHNcbiAgICB9XG5cbiAgICBjb25zdCByZXRyeVRpbWVvdXQgPVxuICAgICAgcmV0cnlBZnRlckhlYWRlciA+IDBcbiAgICAgICAgPyBNYXRoLm1pbihyZXRyeUFmdGVySGVhZGVyLCBtYXhUaW1lb3V0KVxuICAgICAgICA6IE1hdGgubWluKG1pblRpbWVvdXQgKiB0aW1lb3V0RmFjdG9yICoqIChjb3VudGVyIC0gMSksIG1heFRpbWVvdXQpXG5cbiAgICBzZXRUaW1lb3V0KCgpID0+IGNiKG51bGwpLCByZXRyeVRpbWVvdXQpXG4gIH1cblxuICBvbkhlYWRlcnMgKHN0YXR1c0NvZGUsIHJhd0hlYWRlcnMsIHJlc3VtZSwgc3RhdHVzTWVzc2FnZSkge1xuICAgIGNvbnN0IGhlYWRlcnMgPSBwYXJzZUhlYWRlcnMocmF3SGVhZGVycylcblxuICAgIHRoaXMucmV0cnlDb3VudCArPSAxXG5cbiAgICBpZiAoc3RhdHVzQ29kZSA+PSAzMDApIHtcbiAgICAgIGlmICh0aGlzLnJldHJ5T3B0cy5zdGF0dXNDb2Rlcy5pbmNsdWRlcyhzdGF0dXNDb2RlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlci5vbkhlYWRlcnMoXG4gICAgICAgICAgc3RhdHVzQ29kZSxcbiAgICAgICAgICByYXdIZWFkZXJzLFxuICAgICAgICAgIHJlc3VtZSxcbiAgICAgICAgICBzdGF0dXNNZXNzYWdlXG4gICAgICAgIClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYWJvcnQoXG4gICAgICAgICAgbmV3IFJlcXVlc3RSZXRyeUVycm9yKCdSZXF1ZXN0IGZhaWxlZCcsIHN0YXR1c0NvZGUsIHtcbiAgICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgIGNvdW50OiB0aGlzLnJldHJ5Q291bnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICApXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENoZWNrcG9pbnQgZm9yIHJlc3VtZSBmcm9tIHdoZXJlIHdlIGxlZnQgaXRcbiAgICBpZiAodGhpcy5yZXN1bWUgIT0gbnVsbCkge1xuICAgICAgdGhpcy5yZXN1bWUgPSBudWxsXG5cbiAgICAgIGlmIChzdGF0dXNDb2RlICE9PSAyMDYpIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cblxuICAgICAgY29uc3QgY29udGVudFJhbmdlID0gcGFyc2VSYW5nZUhlYWRlcihoZWFkZXJzWydjb250ZW50LXJhbmdlJ10pXG4gICAgICAvLyBJZiBubyBjb250ZW50IHJhbmdlXG4gICAgICBpZiAoIWNvbnRlbnRSYW5nZSkge1xuICAgICAgICB0aGlzLmFib3J0KFxuICAgICAgICAgIG5ldyBSZXF1ZXN0UmV0cnlFcnJvcignQ29udGVudC1SYW5nZSBtaXNtYXRjaCcsIHN0YXR1c0NvZGUsIHtcbiAgICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgICBkYXRhOiB7IGNvdW50OiB0aGlzLnJldHJ5Q291bnQgfVxuICAgICAgICAgIH0pXG4gICAgICAgIClcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG5cbiAgICAgIC8vIExldCdzIHN0YXJ0IHdpdGggYSB3ZWFrIGV0YWcgY2hlY2tcbiAgICAgIGlmICh0aGlzLmV0YWcgIT0gbnVsbCAmJiB0aGlzLmV0YWcgIT09IGhlYWRlcnMuZXRhZykge1xuICAgICAgICB0aGlzLmFib3J0KFxuICAgICAgICAgIG5ldyBSZXF1ZXN0UmV0cnlFcnJvcignRVRhZyBtaXNtYXRjaCcsIHN0YXR1c0NvZGUsIHtcbiAgICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgICBkYXRhOiB7IGNvdW50OiB0aGlzLnJldHJ5Q291bnQgfVxuICAgICAgICAgIH0pXG4gICAgICAgIClcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHsgc3RhcnQsIHNpemUsIGVuZCA9IHNpemUgfSA9IGNvbnRlbnRSYW5nZVxuXG4gICAgICBhc3NlcnQodGhpcy5zdGFydCA9PT0gc3RhcnQsICdjb250ZW50LXJhbmdlIG1pc21hdGNoJylcbiAgICAgIGFzc2VydCh0aGlzLmVuZCA9PSBudWxsIHx8IHRoaXMuZW5kID09PSBlbmQsICdjb250ZW50LXJhbmdlIG1pc21hdGNoJylcblxuICAgICAgdGhpcy5yZXN1bWUgPSByZXN1bWVcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZW5kID09IG51bGwpIHtcbiAgICAgIGlmIChzdGF0dXNDb2RlID09PSAyMDYpIHtcbiAgICAgICAgLy8gRmlyc3QgdGltZSB3ZSByZWNlaXZlIDIwNlxuICAgICAgICBjb25zdCByYW5nZSA9IHBhcnNlUmFuZ2VIZWFkZXIoaGVhZGVyc1snY29udGVudC1yYW5nZSddKVxuXG4gICAgICAgIGlmIChyYW5nZSA9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlci5vbkhlYWRlcnMoXG4gICAgICAgICAgICBzdGF0dXNDb2RlLFxuICAgICAgICAgICAgcmF3SGVhZGVycyxcbiAgICAgICAgICAgIHJlc3VtZSxcbiAgICAgICAgICAgIHN0YXR1c01lc3NhZ2VcbiAgICAgICAgICApXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB7IHN0YXJ0LCBzaXplLCBlbmQgPSBzaXplIH0gPSByYW5nZVxuICAgICAgICBhc3NlcnQoXG4gICAgICAgICAgc3RhcnQgIT0gbnVsbCAmJiBOdW1iZXIuaXNGaW5pdGUoc3RhcnQpLFxuICAgICAgICAgICdjb250ZW50LXJhbmdlIG1pc21hdGNoJ1xuICAgICAgICApXG4gICAgICAgIGFzc2VydChlbmQgIT0gbnVsbCAmJiBOdW1iZXIuaXNGaW5pdGUoZW5kKSwgJ2ludmFsaWQgY29udGVudC1sZW5ndGgnKVxuXG4gICAgICAgIHRoaXMuc3RhcnQgPSBzdGFydFxuICAgICAgICB0aGlzLmVuZCA9IGVuZFxuICAgICAgfVxuXG4gICAgICAvLyBXZSBtYWtlIG91ciBiZXN0IHRvIGNoZWNrcG9pbnQgdGhlIGJvZHkgZm9yIGZ1cnRoZXIgcmFuZ2UgaGVhZGVyc1xuICAgICAgaWYgKHRoaXMuZW5kID09IG51bGwpIHtcbiAgICAgICAgY29uc3QgY29udGVudExlbmd0aCA9IGhlYWRlcnNbJ2NvbnRlbnQtbGVuZ3RoJ11cbiAgICAgICAgdGhpcy5lbmQgPSBjb250ZW50TGVuZ3RoICE9IG51bGwgPyBOdW1iZXIoY29udGVudExlbmd0aCkgOiBudWxsXG4gICAgICB9XG5cbiAgICAgIGFzc2VydChOdW1iZXIuaXNGaW5pdGUodGhpcy5zdGFydCkpXG4gICAgICBhc3NlcnQoXG4gICAgICAgIHRoaXMuZW5kID09IG51bGwgfHwgTnVtYmVyLmlzRmluaXRlKHRoaXMuZW5kKSxcbiAgICAgICAgJ2ludmFsaWQgY29udGVudC1sZW5ndGgnXG4gICAgICApXG5cbiAgICAgIHRoaXMucmVzdW1lID0gcmVzdW1lXG4gICAgICB0aGlzLmV0YWcgPSBoZWFkZXJzLmV0YWcgIT0gbnVsbCA/IGhlYWRlcnMuZXRhZyA6IG51bGxcblxuICAgICAgLy8gV2VhayBldGFncyBhcmUgbm90IHVzZWZ1bCBmb3IgY29tcGFyaXNvbiBub3IgY2FjaGVcbiAgICAgIC8vIGZvciBpbnN0YW5jZSBub3Qgc2FmZSB0byBhc3N1bWUgaWYgdGhlIHJlc3BvbnNlIGlzIGJ5dGUtcGVyLWJ5dGVcbiAgICAgIC8vIGVxdWFsXG4gICAgICBpZiAodGhpcy5ldGFnICE9IG51bGwgJiYgdGhpcy5ldGFnLnN0YXJ0c1dpdGgoJ1cvJykpIHtcbiAgICAgICAgdGhpcy5ldGFnID0gbnVsbFxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5oYW5kbGVyLm9uSGVhZGVycyhcbiAgICAgICAgc3RhdHVzQ29kZSxcbiAgICAgICAgcmF3SGVhZGVycyxcbiAgICAgICAgcmVzdW1lLFxuICAgICAgICBzdGF0dXNNZXNzYWdlXG4gICAgICApXG4gICAgfVxuXG4gICAgY29uc3QgZXJyID0gbmV3IFJlcXVlc3RSZXRyeUVycm9yKCdSZXF1ZXN0IGZhaWxlZCcsIHN0YXR1c0NvZGUsIHtcbiAgICAgIGhlYWRlcnMsXG4gICAgICBkYXRhOiB7IGNvdW50OiB0aGlzLnJldHJ5Q291bnQgfVxuICAgIH0pXG5cbiAgICB0aGlzLmFib3J0KGVycilcblxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgb25EYXRhIChjaHVuaykge1xuICAgIHRoaXMuc3RhcnQgKz0gY2h1bmsubGVuZ3RoXG5cbiAgICByZXR1cm4gdGhpcy5oYW5kbGVyLm9uRGF0YShjaHVuaylcbiAgfVxuXG4gIG9uQ29tcGxldGUgKHJhd1RyYWlsZXJzKSB7XG4gICAgdGhpcy5yZXRyeUNvdW50ID0gMFxuICAgIHJldHVybiB0aGlzLmhhbmRsZXIub25Db21wbGV0ZShyYXdUcmFpbGVycylcbiAgfVxuXG4gIG9uRXJyb3IgKGVycikge1xuICAgIGlmICh0aGlzLmFib3J0ZWQgfHwgaXNEaXN0dXJiZWQodGhpcy5vcHRzLmJvZHkpKSB7XG4gICAgICByZXR1cm4gdGhpcy5oYW5kbGVyLm9uRXJyb3IoZXJyKVxuICAgIH1cblxuICAgIC8vIFdlIHJlY29uY2lsZSBpbiBjYXNlIG9mIGEgbWl4IGJldHdlZW4gbmV0d29yayBlcnJvcnNcbiAgICAvLyBhbmQgc2VydmVyIGVycm9yIHJlc3BvbnNlXG4gICAgaWYgKHRoaXMucmV0cnlDb3VudCAtIHRoaXMucmV0cnlDb3VudENoZWNrcG9pbnQgPiAwKSB7XG4gICAgICAvLyBXZSBjb3VudCB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBsYXN0IGNoZWNrcG9pbnQgYW5kIHRoZSBjdXJyZW50IHJldHJ5IGNvdW50XG4gICAgICB0aGlzLnJldHJ5Q291bnQgPVxuICAgICAgICB0aGlzLnJldHJ5Q291bnRDaGVja3BvaW50ICtcbiAgICAgICAgKHRoaXMucmV0cnlDb3VudCAtIHRoaXMucmV0cnlDb3VudENoZWNrcG9pbnQpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmV0cnlDb3VudCArPSAxXG4gICAgfVxuXG4gICAgdGhpcy5yZXRyeU9wdHMucmV0cnkoXG4gICAgICBlcnIsXG4gICAgICB7XG4gICAgICAgIHN0YXRlOiB7IGNvdW50ZXI6IHRoaXMucmV0cnlDb3VudCB9LFxuICAgICAgICBvcHRzOiB7IHJldHJ5T3B0aW9uczogdGhpcy5yZXRyeU9wdHMsIC4uLnRoaXMub3B0cyB9XG4gICAgICB9LFxuICAgICAgb25SZXRyeS5iaW5kKHRoaXMpXG4gICAgKVxuXG4gICAgZnVuY3Rpb24gb25SZXRyeSAoZXJyKSB7XG4gICAgICBpZiAoZXJyICE9IG51bGwgfHwgdGhpcy5hYm9ydGVkIHx8IGlzRGlzdHVyYmVkKHRoaXMub3B0cy5ib2R5KSkge1xuICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVyLm9uRXJyb3IoZXJyKVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5zdGFydCAhPT0gMCkge1xuICAgICAgICBjb25zdCBoZWFkZXJzID0geyByYW5nZTogYGJ5dGVzPSR7dGhpcy5zdGFydH0tJHt0aGlzLmVuZCA/PyAnJ31gIH1cblxuICAgICAgICAvLyBXZWFrIGV0YWcgY2hlY2sgLSB3ZWFrIGV0YWdzIHdpbGwgbWFrZSBjb21wYXJpc29uIGFsZ29yaXRobXMgbmV2ZXIgbWF0Y2hcbiAgICAgICAgaWYgKHRoaXMuZXRhZyAhPSBudWxsKSB7XG4gICAgICAgICAgaGVhZGVyc1snaWYtbWF0Y2gnXSA9IHRoaXMuZXRhZ1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5vcHRzID0ge1xuICAgICAgICAgIC4uLnRoaXMub3B0cyxcbiAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAuLi50aGlzLm9wdHMuaGVhZGVycyxcbiAgICAgICAgICAgIC4uLmhlYWRlcnNcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5yZXRyeUNvdW50Q2hlY2twb2ludCA9IHRoaXMucmV0cnlDb3VudFxuICAgICAgICB0aGlzLmRpc3BhdGNoKHRoaXMub3B0cywgdGhpcylcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICB0aGlzLmhhbmRsZXIub25FcnJvcihlcnIpXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmV0cnlIYW5kbGVyXG4iXSwibmFtZXMiOlsiYXNzZXJ0IiwicmVxdWlyZSIsImtSZXRyeUhhbmRsZXJEZWZhdWx0UmV0cnkiLCJSZXF1ZXN0UmV0cnlFcnJvciIsImlzRGlzdHVyYmVkIiwicGFyc2VIZWFkZXJzIiwicGFyc2VSYW5nZUhlYWRlciIsIndyYXBSZXF1ZXN0Qm9keSIsImNhbGN1bGF0ZVJldHJ5QWZ0ZXJIZWFkZXIiLCJyZXRyeUFmdGVyIiwiY3VycmVudCIsIkRhdGUiLCJub3ciLCJnZXRUaW1lIiwiUmV0cnlIYW5kbGVyIiwiY29uc3RydWN0b3IiLCJvcHRzIiwiaGFuZGxlcnMiLCJyZXRyeU9wdGlvbnMiLCJkaXNwYXRjaE9wdHMiLCJyZXRyeSIsInJldHJ5Rm4iLCJtYXhSZXRyaWVzIiwibWF4VGltZW91dCIsIm1pblRpbWVvdXQiLCJ0aW1lb3V0RmFjdG9yIiwibWV0aG9kcyIsImVycm9yQ29kZXMiLCJzdGF0dXNDb2RlcyIsImRpc3BhdGNoIiwiaGFuZGxlciIsImJvZHkiLCJhYm9ydCIsImFib3J0ZWQiLCJyZXRyeU9wdHMiLCJyZXRyeUNvdW50IiwicmV0cnlDb3VudENoZWNrcG9pbnQiLCJzdGFydCIsImVuZCIsImV0YWciLCJyZXN1bWUiLCJvbkNvbm5lY3QiLCJyZWFzb24iLCJvblJlcXVlc3RTZW50Iiwib25VcGdyYWRlIiwic3RhdHVzQ29kZSIsImhlYWRlcnMiLCJzb2NrZXQiLCJvbkJvZHlTZW50IiwiY2h1bmsiLCJlcnIiLCJzdGF0ZSIsImNiIiwiY29kZSIsIm1ldGhvZCIsImNvdW50ZXIiLCJpbmNsdWRlcyIsIkFycmF5IiwiaXNBcnJheSIsInJldHJ5QWZ0ZXJIZWFkZXIiLCJOdW1iZXIiLCJpc05hTiIsInJldHJ5VGltZW91dCIsIk1hdGgiLCJtaW4iLCJzZXRUaW1lb3V0Iiwib25IZWFkZXJzIiwicmF3SGVhZGVycyIsInN0YXR1c01lc3NhZ2UiLCJkYXRhIiwiY291bnQiLCJjb250ZW50UmFuZ2UiLCJzaXplIiwicmFuZ2UiLCJpc0Zpbml0ZSIsImNvbnRlbnRMZW5ndGgiLCJzdGFydHNXaXRoIiwib25EYXRhIiwibGVuZ3RoIiwib25Db21wbGV0ZSIsInJhd1RyYWlsZXJzIiwib25FcnJvciIsIm9uUmV0cnkiLCJiaW5kIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/handler/retry-handler.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/interceptor/dump.js":
/*!*****************************************************!*\
  !*** ./node_modules/undici/lib/interceptor/dump.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst util = __webpack_require__(/*! ../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\");\nconst { InvalidArgumentError, RequestAbortedError } = __webpack_require__(/*! ../core/errors */ \"(ssr)/./node_modules/undici/lib/core/errors.js\");\nconst DecoratorHandler = __webpack_require__(/*! ../handler/decorator-handler */ \"(ssr)/./node_modules/undici/lib/handler/decorator-handler.js\");\nclass DumpHandler extends DecoratorHandler {\n    #maxSize;\n    #abort;\n    #dumped;\n    #aborted;\n    #size;\n    #reason;\n    #handler;\n    constructor({ maxSize }, handler){\n        super(handler);\n        this.#maxSize = 1024 * 1024;\n        this.#abort = null;\n        this.#dumped = false;\n        this.#aborted = false;\n        this.#size = 0;\n        this.#reason = null;\n        this.#handler = null;\n        if (maxSize != null && (!Number.isFinite(maxSize) || maxSize < 1)) {\n            throw new InvalidArgumentError(\"maxSize must be a number greater than 0\");\n        }\n        this.#maxSize = maxSize ?? this.#maxSize;\n        this.#handler = handler;\n    }\n    onConnect(abort) {\n        this.#abort = abort;\n        this.#handler.onConnect(this.#customAbort.bind(this));\n    }\n    #customAbort(reason) {\n        this.#aborted = true;\n        this.#reason = reason;\n    }\n    // TODO: will require adjustment after new hooks are out\n    onHeaders(statusCode, rawHeaders, resume, statusMessage) {\n        const headers = util.parseHeaders(rawHeaders);\n        const contentLength = headers[\"content-length\"];\n        if (contentLength != null && contentLength > this.#maxSize) {\n            throw new RequestAbortedError(`Response size (${contentLength}) larger than maxSize (${this.#maxSize})`);\n        }\n        if (this.#aborted) {\n            return true;\n        }\n        return this.#handler.onHeaders(statusCode, rawHeaders, resume, statusMessage);\n    }\n    onError(err) {\n        if (this.#dumped) {\n            return;\n        }\n        err = this.#reason ?? err;\n        this.#handler.onError(err);\n    }\n    onData(chunk) {\n        this.#size = this.#size + chunk.length;\n        if (this.#size >= this.#maxSize) {\n            this.#dumped = true;\n            if (this.#aborted) {\n                this.#handler.onError(this.#reason);\n            } else {\n                this.#handler.onComplete([]);\n            }\n        }\n        return true;\n    }\n    onComplete(trailers) {\n        if (this.#dumped) {\n            return;\n        }\n        if (this.#aborted) {\n            this.#handler.onError(this.reason);\n            return;\n        }\n        this.#handler.onComplete(trailers);\n    }\n}\nfunction createDumpInterceptor({ maxSize: defaultMaxSize } = {\n    maxSize: 1024 * 1024\n}) {\n    return (dispatch)=>{\n        return function Intercept(opts, handler) {\n            const { dumpMaxSize = defaultMaxSize } = opts;\n            const dumpHandler = new DumpHandler({\n                maxSize: dumpMaxSize\n            }, handler);\n            return dispatch(opts, dumpHandler);\n        };\n    };\n}\nmodule.exports = createDumpInterceptor;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9pbnRlcmNlcHRvci9kdW1wLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTUEsT0FBT0MsbUJBQU9BLENBQUM7QUFDckIsTUFBTSxFQUFFQyxvQkFBb0IsRUFBRUMsbUJBQUFBLEVBQXFCLEdBQUdGLG1CQUFPQSxDQUFDO0FBQzlELE1BQU1HLG1CQUFtQkgsbUJBQU9BLENBQUM7QUFFakMsTUFBTUksb0JBQW9CRDtJQUN4QixDQUFDRSxPQUFPLENBQWM7SUFDdEIsQ0FBQ0MsS0FBSyxDQUFPO0lBQ2IsQ0FBQ0MsTUFBTSxDQUFRO0lBQ2YsQ0FBQ0MsT0FBTyxDQUFRO0lBQ2hCLENBQUNDLElBQUksQ0FBSTtJQUNULENBQUNDLE1BQU0sQ0FBTztJQUNkLENBQUNDLE9BQU8sQ0FBTztJQUVmQyxZQUFhLEVBQUVQLE9BQUFBLEVBQVMsRUFBRU0sT0FBTyxDQUFFO1FBQ2pDLEtBQUssQ0FBQ0E7YUFUUixDQUFDTixPQUFPLEdBQUcsT0FBTzthQUNsQixDQUFDQyxLQUFLLEdBQUc7YUFDVCxDQUFDQyxNQUFNLEdBQUc7YUFDVixDQUFDQyxPQUFPLEdBQUc7YUFDWCxDQUFDQyxJQUFJLEdBQUc7YUFDUixDQUFDQyxNQUFNLEdBQUc7YUFDVixDQUFDQyxPQUFPLEdBQUc7UUFLVCxJQUFJTixXQUFXLFFBQVMsRUFBQ1EsT0FBT0MsUUFBUSxDQUFDVCxZQUFZQSxVQUFVLElBQUk7WUFDakUsTUFBTSxJQUFJSixxQkFBcUI7UUFDakM7UUFFQSxJQUFJLENBQUMsQ0FBQ0ksT0FBTyxHQUFHQSxXQUFXLElBQUksQ0FBQyxDQUFDQSxPQUFPO1FBQ3hDLElBQUksQ0FBQyxDQUFDTSxPQUFPLEdBQUdBO0lBQ2xCO0lBRUFJLFVBQVdULEtBQUssRUFBRTtRQUNoQixJQUFJLENBQUMsQ0FBQ0EsS0FBSyxHQUFHQTtRQUVkLElBQUksQ0FBQyxDQUFDSyxPQUFPLENBQUNJLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQ0MsV0FBVyxDQUFDQyxJQUFJLENBQUMsSUFBSTtJQUNyRDtJQUVBLENBQUNELFdBQVdFLENBQUVSLE1BQU07UUFDbEIsSUFBSSxDQUFDLENBQUNGLE9BQU8sR0FBRztRQUNoQixJQUFJLENBQUMsQ0FBQ0UsTUFBTSxHQUFHQTtJQUNqQjtJQUVBO0lBQ0FTLFVBQVdDLFVBQVUsRUFBRUMsVUFBVSxFQUFFQyxNQUFNLEVBQUVDLGFBQWEsRUFBRTtRQUN4RCxNQUFNQyxVQUFVekIsS0FBSzBCLFlBQVksQ0FBQ0o7UUFDbEMsTUFBTUssZ0JBQWdCRixPQUFPLENBQUMsaUJBQWlCO1FBRS9DLElBQUlFLGlCQUFpQixRQUFRQSxnQkFBZ0IsSUFBSSxDQUFDLENBQUNyQixPQUFPLEVBQUU7WUFDMUQsTUFBTSxJQUFJSCxvQkFDUixrQkFBa0J3QixjQUFhLHlCQUM3QixJQUFJLENBQUMsQ0FBQ3JCLE9BQU8sR0FFakI7UUFDRjtRQUVBLElBQUksSUFBSSxDQUFDLENBQUNHLE9BQU8sRUFBRTtZQUNqQixPQUFPO1FBQ1Q7UUFFQSxPQUFPLElBQUksQ0FBQyxDQUFDRyxPQUFPLENBQUNRLFNBQVMsQ0FDNUJDLFlBQ0FDLFlBQ0FDLFFBQ0FDO0lBRUo7SUFFQUksUUFBU0MsR0FBRyxFQUFFO1FBQ1osSUFBSSxJQUFJLENBQUMsQ0FBQ3JCLE1BQU0sRUFBRTtZQUNoQjtRQUNGO1FBRUFxQixNQUFNLElBQUksQ0FBQyxDQUFDbEIsTUFBTSxJQUFJa0I7UUFFdEIsSUFBSSxDQUFDLENBQUNqQixPQUFPLENBQUNnQixPQUFPLENBQUNDO0lBQ3hCO0lBRUFDLE9BQVFDLEtBQUssRUFBRTtRQUNiLElBQUksQ0FBQyxDQUFDckIsSUFBSSxHQUFHLElBQUksQ0FBQyxDQUFDQSxJQUFJLEdBQUdxQixNQUFNQyxNQUFNO1FBRXRDLElBQUksSUFBSSxDQUFDLENBQUN0QixJQUFJLElBQUksSUFBSSxDQUFDLENBQUNKLE9BQU8sRUFBRTtZQUMvQixJQUFJLENBQUMsQ0FBQ0UsTUFBTSxHQUFHO1lBRWYsSUFBSSxJQUFJLENBQUMsQ0FBQ0MsT0FBTyxFQUFFO2dCQUNqQixJQUFJLENBQUMsQ0FBQ0csT0FBTyxDQUFDZ0IsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDakIsTUFBTTtZQUNwQyxPQUFPO2dCQUNMLElBQUksQ0FBQyxDQUFDQyxPQUFPLENBQUNxQixVQUFVLENBQUMsRUFBRTtZQUM3QjtRQUNGO1FBRUEsT0FBTztJQUNUO0lBRUFBLFdBQVlDLFFBQVEsRUFBRTtRQUNwQixJQUFJLElBQUksQ0FBQyxDQUFDMUIsTUFBTSxFQUFFO1lBQ2hCO1FBQ0Y7UUFFQSxJQUFJLElBQUksQ0FBQyxDQUFDQyxPQUFPLEVBQUU7WUFDakIsSUFBSSxDQUFDLENBQUNHLE9BQU8sQ0FBQ2dCLE9BQU8sQ0FBQyxJQUFJLENBQUNqQixNQUFNO1lBQ2pDO1FBQ0Y7UUFFQSxJQUFJLENBQUMsQ0FBQ0MsT0FBTyxDQUFDcUIsVUFBVSxDQUFDQztJQUMzQjtBQUNGO0FBRUEsU0FBU0Msc0JBQ1AsRUFBRTdCLFNBQVM4QixjQUFBQSxFQUFnQixHQUFHO0lBQzVCOUIsU0FBUyxPQUFPO0FBQ2xCLENBQUM7SUFFRCxPQUFPK0IsQ0FBQUE7UUFDTCxPQUFPLFNBQVNDLFVBQVdDLElBQUksRUFBRTNCLE9BQU87WUFDdEMsTUFBTSxFQUFFNEIsY0FBY0osY0FBQUEsRUFBZ0IsR0FDcENHO1lBRUYsTUFBTUUsY0FBYyxJQUFJcEMsWUFDdEI7Z0JBQUVDLFNBQVNrQztZQUFZLEdBQ3ZCNUI7WUFHRixPQUFPeUIsU0FBU0UsTUFBTUU7UUFDeEI7SUFDRjtBQUNGO0FBRUFDLE9BQU9DLE9BQU8sR0FBR1IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tb2NrdXBmbG93Ly4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvaW50ZXJjZXB0b3IvZHVtcC5qcz9kZjlmIiwid2VicGFjazovL21vY2t1cGZsb3cvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9pbnRlcmNlcHRvci9kdW1wLmpzP2RmOWYqIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB1dGlsID0gcmVxdWlyZSgnLi4vY29yZS91dGlsJylcbmNvbnN0IHsgSW52YWxpZEFyZ3VtZW50RXJyb3IsIFJlcXVlc3RBYm9ydGVkRXJyb3IgfSA9IHJlcXVpcmUoJy4uL2NvcmUvZXJyb3JzJylcbmNvbnN0IERlY29yYXRvckhhbmRsZXIgPSByZXF1aXJlKCcuLi9oYW5kbGVyL2RlY29yYXRvci1oYW5kbGVyJylcblxuY2xhc3MgRHVtcEhhbmRsZXIgZXh0ZW5kcyBEZWNvcmF0b3JIYW5kbGVyIHtcbiAgI21heFNpemUgPSAxMDI0ICogMTAyNFxuICAjYWJvcnQgPSBudWxsXG4gICNkdW1wZWQgPSBmYWxzZVxuICAjYWJvcnRlZCA9IGZhbHNlXG4gICNzaXplID0gMFxuICAjcmVhc29uID0gbnVsbFxuICAjaGFuZGxlciA9IG51bGxcblxuICBjb25zdHJ1Y3RvciAoeyBtYXhTaXplIH0sIGhhbmRsZXIpIHtcbiAgICBzdXBlcihoYW5kbGVyKVxuXG4gICAgaWYgKG1heFNpemUgIT0gbnVsbCAmJiAoIU51bWJlci5pc0Zpbml0ZShtYXhTaXplKSB8fCBtYXhTaXplIDwgMSkpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignbWF4U2l6ZSBtdXN0IGJlIGEgbnVtYmVyIGdyZWF0ZXIgdGhhbiAwJylcbiAgICB9XG5cbiAgICB0aGlzLiNtYXhTaXplID0gbWF4U2l6ZSA/PyB0aGlzLiNtYXhTaXplXG4gICAgdGhpcy4jaGFuZGxlciA9IGhhbmRsZXJcbiAgfVxuXG4gIG9uQ29ubmVjdCAoYWJvcnQpIHtcbiAgICB0aGlzLiNhYm9ydCA9IGFib3J0XG5cbiAgICB0aGlzLiNoYW5kbGVyLm9uQ29ubmVjdCh0aGlzLiNjdXN0b21BYm9ydC5iaW5kKHRoaXMpKVxuICB9XG5cbiAgI2N1c3RvbUFib3J0IChyZWFzb24pIHtcbiAgICB0aGlzLiNhYm9ydGVkID0gdHJ1ZVxuICAgIHRoaXMuI3JlYXNvbiA9IHJlYXNvblxuICB9XG5cbiAgLy8gVE9ETzogd2lsbCByZXF1aXJlIGFkanVzdG1lbnQgYWZ0ZXIgbmV3IGhvb2tzIGFyZSBvdXRcbiAgb25IZWFkZXJzIChzdGF0dXNDb2RlLCByYXdIZWFkZXJzLCByZXN1bWUsIHN0YXR1c01lc3NhZ2UpIHtcbiAgICBjb25zdCBoZWFkZXJzID0gdXRpbC5wYXJzZUhlYWRlcnMocmF3SGVhZGVycylcbiAgICBjb25zdCBjb250ZW50TGVuZ3RoID0gaGVhZGVyc1snY29udGVudC1sZW5ndGgnXVxuXG4gICAgaWYgKGNvbnRlbnRMZW5ndGggIT0gbnVsbCAmJiBjb250ZW50TGVuZ3RoID4gdGhpcy4jbWF4U2l6ZSkge1xuICAgICAgdGhyb3cgbmV3IFJlcXVlc3RBYm9ydGVkRXJyb3IoXG4gICAgICAgIGBSZXNwb25zZSBzaXplICgke2NvbnRlbnRMZW5ndGh9KSBsYXJnZXIgdGhhbiBtYXhTaXplICgke1xuICAgICAgICAgIHRoaXMuI21heFNpemVcbiAgICAgICAgfSlgXG4gICAgICApXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuI2Fib3J0ZWQpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuI2hhbmRsZXIub25IZWFkZXJzKFxuICAgICAgc3RhdHVzQ29kZSxcbiAgICAgIHJhd0hlYWRlcnMsXG4gICAgICByZXN1bWUsXG4gICAgICBzdGF0dXNNZXNzYWdlXG4gICAgKVxuICB9XG5cbiAgb25FcnJvciAoZXJyKSB7XG4gICAgaWYgKHRoaXMuI2R1bXBlZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgZXJyID0gdGhpcy4jcmVhc29uID8/IGVyclxuXG4gICAgdGhpcy4jaGFuZGxlci5vbkVycm9yKGVycilcbiAgfVxuXG4gIG9uRGF0YSAoY2h1bmspIHtcbiAgICB0aGlzLiNzaXplID0gdGhpcy4jc2l6ZSArIGNodW5rLmxlbmd0aFxuXG4gICAgaWYgKHRoaXMuI3NpemUgPj0gdGhpcy4jbWF4U2l6ZSkge1xuICAgICAgdGhpcy4jZHVtcGVkID0gdHJ1ZVxuXG4gICAgICBpZiAodGhpcy4jYWJvcnRlZCkge1xuICAgICAgICB0aGlzLiNoYW5kbGVyLm9uRXJyb3IodGhpcy4jcmVhc29uKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy4jaGFuZGxlci5vbkNvbXBsZXRlKFtdKVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBvbkNvbXBsZXRlICh0cmFpbGVycykge1xuICAgIGlmICh0aGlzLiNkdW1wZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmICh0aGlzLiNhYm9ydGVkKSB7XG4gICAgICB0aGlzLiNoYW5kbGVyLm9uRXJyb3IodGhpcy5yZWFzb24pXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLiNoYW5kbGVyLm9uQ29tcGxldGUodHJhaWxlcnMpXG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlRHVtcEludGVyY2VwdG9yIChcbiAgeyBtYXhTaXplOiBkZWZhdWx0TWF4U2l6ZSB9ID0ge1xuICAgIG1heFNpemU6IDEwMjQgKiAxMDI0XG4gIH1cbikge1xuICByZXR1cm4gZGlzcGF0Y2ggPT4ge1xuICAgIHJldHVybiBmdW5jdGlvbiBJbnRlcmNlcHQgKG9wdHMsIGhhbmRsZXIpIHtcbiAgICAgIGNvbnN0IHsgZHVtcE1heFNpemUgPSBkZWZhdWx0TWF4U2l6ZSB9ID1cbiAgICAgICAgb3B0c1xuXG4gICAgICBjb25zdCBkdW1wSGFuZGxlciA9IG5ldyBEdW1wSGFuZGxlcihcbiAgICAgICAgeyBtYXhTaXplOiBkdW1wTWF4U2l6ZSB9LFxuICAgICAgICBoYW5kbGVyXG4gICAgICApXG5cbiAgICAgIHJldHVybiBkaXNwYXRjaChvcHRzLCBkdW1wSGFuZGxlcilcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVEdW1wSW50ZXJjZXB0b3JcbiJdLCJuYW1lcyI6WyJ1dGlsIiwicmVxdWlyZSIsIkludmFsaWRBcmd1bWVudEVycm9yIiwiUmVxdWVzdEFib3J0ZWRFcnJvciIsIkRlY29yYXRvckhhbmRsZXIiLCJEdW1wSGFuZGxlciIsIm1heFNpemUiLCJhYm9ydCIsImR1bXBlZCIsImFib3J0ZWQiLCJzaXplIiwicmVhc29uIiwiaGFuZGxlciIsImNvbnN0cnVjdG9yIiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJvbkNvbm5lY3QiLCJjdXN0b21BYm9ydCIsImJpbmQiLCIjY3VzdG9tQWJvcnQiLCJvbkhlYWRlcnMiLCJzdGF0dXNDb2RlIiwicmF3SGVhZGVycyIsInJlc3VtZSIsInN0YXR1c01lc3NhZ2UiLCJoZWFkZXJzIiwicGFyc2VIZWFkZXJzIiwiY29udGVudExlbmd0aCIsIm9uRXJyb3IiLCJlcnIiLCJvbkRhdGEiLCJjaHVuayIsImxlbmd0aCIsIm9uQ29tcGxldGUiLCJ0cmFpbGVycyIsImNyZWF0ZUR1bXBJbnRlcmNlcHRvciIsImRlZmF1bHRNYXhTaXplIiwiZGlzcGF0Y2giLCJJbnRlcmNlcHQiLCJvcHRzIiwiZHVtcE1heFNpemUiLCJkdW1wSGFuZGxlciIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/interceptor/dump.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/interceptor/redirect-interceptor.js":
/*!*********************************************************************!*\
  !*** ./node_modules/undici/lib/interceptor/redirect-interceptor.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst RedirectHandler = __webpack_require__(/*! ../handler/redirect-handler */ \"(ssr)/./node_modules/undici/lib/handler/redirect-handler.js\");\nfunction createRedirectInterceptor({ maxRedirections: defaultMaxRedirections }) {\n    return (dispatch)=>{\n        return function Intercept(opts, handler) {\n            const { maxRedirections = defaultMaxRedirections } = opts;\n            if (!maxRedirections) {\n                return dispatch(opts, handler);\n            }\n            const redirectHandler = new RedirectHandler(dispatch, maxRedirections, opts, handler);\n            opts = {\n                ...opts,\n                maxRedirections: 0\n            }; // Stop sub dispatcher from also redirecting.\n            return dispatch(opts, redirectHandler);\n        };\n    };\n}\nmodule.exports = createRedirectInterceptor;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9pbnRlcmNlcHRvci9yZWRpcmVjdC1pbnRlcmNlcHRvci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU1BLGtCQUFrQkMsbUJBQU9BLENBQUM7QUFFaEMsU0FBU0MsMEJBQTJCLEVBQUVDLGlCQUFpQkMsc0JBQUFBLEVBQXdCO0lBQzdFLE9BQVFDLENBQUFBO1FBQ04sT0FBTyxTQUFTQyxVQUFXQyxJQUFJLEVBQUVDLE9BQU87WUFDdEMsTUFBTSxFQUFFTCxrQkFBa0JDLHNCQUFBQSxFQUF3QixHQUFHRztZQUVyRCxJQUFJLENBQUNKLGlCQUFpQjtnQkFDcEIsT0FBT0UsU0FBU0UsTUFBTUM7WUFDeEI7WUFFQSxNQUFNQyxrQkFBa0IsSUFBSVQsZ0JBQWdCSyxVQUFVRixpQkFBaUJJLE1BQU1DO1lBQzdFRCxPQUFPO2dCQUFFLEdBQUdBLElBQUk7Z0JBQUVKLGlCQUFpQjtZQUFFLEdBQUU7WUFDdkMsT0FBT0UsU0FBU0UsTUFBTUU7UUFDeEI7SUFDRjtBQUNGO0FBRUFDLE9BQU9DLE9BQU8sR0FBR1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tb2NrdXBmbG93Ly4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvaW50ZXJjZXB0b3IvcmVkaXJlY3QtaW50ZXJjZXB0b3IuanM/MTBiZSIsIndlYnBhY2s6Ly9tb2NrdXBmbG93Ly4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvaW50ZXJjZXB0b3IvcmVkaXJlY3QtaW50ZXJjZXB0b3IuanM/MTBiZSoiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IFJlZGlyZWN0SGFuZGxlciA9IHJlcXVpcmUoJy4uL2hhbmRsZXIvcmVkaXJlY3QtaGFuZGxlcicpXG5cbmZ1bmN0aW9uIGNyZWF0ZVJlZGlyZWN0SW50ZXJjZXB0b3IgKHsgbWF4UmVkaXJlY3Rpb25zOiBkZWZhdWx0TWF4UmVkaXJlY3Rpb25zIH0pIHtcbiAgcmV0dXJuIChkaXNwYXRjaCkgPT4ge1xuICAgIHJldHVybiBmdW5jdGlvbiBJbnRlcmNlcHQgKG9wdHMsIGhhbmRsZXIpIHtcbiAgICAgIGNvbnN0IHsgbWF4UmVkaXJlY3Rpb25zID0gZGVmYXVsdE1heFJlZGlyZWN0aW9ucyB9ID0gb3B0c1xuXG4gICAgICBpZiAoIW1heFJlZGlyZWN0aW9ucykge1xuICAgICAgICByZXR1cm4gZGlzcGF0Y2gob3B0cywgaGFuZGxlcilcbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVkaXJlY3RIYW5kbGVyID0gbmV3IFJlZGlyZWN0SGFuZGxlcihkaXNwYXRjaCwgbWF4UmVkaXJlY3Rpb25zLCBvcHRzLCBoYW5kbGVyKVxuICAgICAgb3B0cyA9IHsgLi4ub3B0cywgbWF4UmVkaXJlY3Rpb25zOiAwIH0gLy8gU3RvcCBzdWIgZGlzcGF0Y2hlciBmcm9tIGFsc28gcmVkaXJlY3RpbmcuXG4gICAgICByZXR1cm4gZGlzcGF0Y2gob3B0cywgcmVkaXJlY3RIYW5kbGVyKVxuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZVJlZGlyZWN0SW50ZXJjZXB0b3JcbiJdLCJuYW1lcyI6WyJSZWRpcmVjdEhhbmRsZXIiLCJyZXF1aXJlIiwiY3JlYXRlUmVkaXJlY3RJbnRlcmNlcHRvciIsIm1heFJlZGlyZWN0aW9ucyIsImRlZmF1bHRNYXhSZWRpcmVjdGlvbnMiLCJkaXNwYXRjaCIsIkludGVyY2VwdCIsIm9wdHMiLCJoYW5kbGVyIiwicmVkaXJlY3RIYW5kbGVyIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/interceptor/redirect-interceptor.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/interceptor/redirect.js":
/*!*********************************************************!*\
  !*** ./node_modules/undici/lib/interceptor/redirect.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst RedirectHandler = __webpack_require__(/*! ../handler/redirect-handler */ \"(ssr)/./node_modules/undici/lib/handler/redirect-handler.js\");\nmodule.exports = (opts)=>{\n    const globalMaxRedirections = opts?.maxRedirections;\n    return (dispatch)=>{\n        return function redirectInterceptor(opts, handler) {\n            const { maxRedirections = globalMaxRedirections, ...baseOpts } = opts;\n            if (!maxRedirections) {\n                return dispatch(opts, handler);\n            }\n            const redirectHandler = new RedirectHandler(dispatch, maxRedirections, opts, handler);\n            return dispatch(baseOpts, redirectHandler);\n        };\n    };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9pbnRlcmNlcHRvci9yZWRpcmVjdC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLE1BQU1BLGtCQUFrQkMsbUJBQU9BLENBQUM7QUFFaENDLE9BQU9DLE9BQU8sR0FBR0MsQ0FBQUE7SUFDZixNQUFNQyx3QkFBd0JELE1BQU1FO0lBQ3BDLE9BQU9DLENBQUFBO1FBQ0wsT0FBTyxTQUFTQyxvQkFBcUJKLElBQUksRUFBRUssT0FBTztZQUNoRCxNQUFNLEVBQUVILGtCQUFrQkQscUJBQXFCLEVBQUUsR0FBR0ssVUFBVSxHQUFHTjtZQUVqRSxJQUFJLENBQUNFLGlCQUFpQjtnQkFDcEIsT0FBT0MsU0FBU0gsTUFBTUs7WUFDeEI7WUFFQSxNQUFNRSxrQkFBa0IsSUFBSVgsZ0JBQzFCTyxVQUNBRCxpQkFDQUYsTUFDQUs7WUFHRixPQUFPRixTQUFTRyxVQUFVQztRQUM1QjtJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tb2NrdXBmbG93Ly4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvaW50ZXJjZXB0b3IvcmVkaXJlY3QuanM/NzQ3MyIsIndlYnBhY2s6Ly9tb2NrdXBmbG93Ly4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvaW50ZXJjZXB0b3IvcmVkaXJlY3QuanM/NzQ3MyoiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5jb25zdCBSZWRpcmVjdEhhbmRsZXIgPSByZXF1aXJlKCcuLi9oYW5kbGVyL3JlZGlyZWN0LWhhbmRsZXInKVxuXG5tb2R1bGUuZXhwb3J0cyA9IG9wdHMgPT4ge1xuICBjb25zdCBnbG9iYWxNYXhSZWRpcmVjdGlvbnMgPSBvcHRzPy5tYXhSZWRpcmVjdGlvbnNcbiAgcmV0dXJuIGRpc3BhdGNoID0+IHtcbiAgICByZXR1cm4gZnVuY3Rpb24gcmVkaXJlY3RJbnRlcmNlcHRvciAob3B0cywgaGFuZGxlcikge1xuICAgICAgY29uc3QgeyBtYXhSZWRpcmVjdGlvbnMgPSBnbG9iYWxNYXhSZWRpcmVjdGlvbnMsIC4uLmJhc2VPcHRzIH0gPSBvcHRzXG5cbiAgICAgIGlmICghbWF4UmVkaXJlY3Rpb25zKSB7XG4gICAgICAgIHJldHVybiBkaXNwYXRjaChvcHRzLCBoYW5kbGVyKVxuICAgICAgfVxuXG4gICAgICBjb25zdCByZWRpcmVjdEhhbmRsZXIgPSBuZXcgUmVkaXJlY3RIYW5kbGVyKFxuICAgICAgICBkaXNwYXRjaCxcbiAgICAgICAgbWF4UmVkaXJlY3Rpb25zLFxuICAgICAgICBvcHRzLFxuICAgICAgICBoYW5kbGVyXG4gICAgICApXG5cbiAgICAgIHJldHVybiBkaXNwYXRjaChiYXNlT3B0cywgcmVkaXJlY3RIYW5kbGVyKVxuICAgIH1cbiAgfVxufVxuIl0sIm5hbWVzIjpbIlJlZGlyZWN0SGFuZGxlciIsInJlcXVpcmUiLCJtb2R1bGUiLCJleHBvcnRzIiwib3B0cyIsImdsb2JhbE1heFJlZGlyZWN0aW9ucyIsIm1heFJlZGlyZWN0aW9ucyIsImRpc3BhdGNoIiwicmVkaXJlY3RJbnRlcmNlcHRvciIsImhhbmRsZXIiLCJiYXNlT3B0cyIsInJlZGlyZWN0SGFuZGxlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/interceptor/redirect.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/interceptor/retry.js":
/*!******************************************************!*\
  !*** ./node_modules/undici/lib/interceptor/retry.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst RetryHandler = __webpack_require__(/*! ../handler/retry-handler */ \"(ssr)/./node_modules/undici/lib/handler/retry-handler.js\");\nmodule.exports = (globalOpts)=>{\n    return (dispatch)=>{\n        return function retryInterceptor(opts, handler) {\n            return dispatch(opts, new RetryHandler({\n                ...opts,\n                retryOptions: {\n                    ...globalOpts,\n                    ...opts.retryOptions\n                }\n            }, {\n                handler,\n                dispatch\n            }));\n        };\n    };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9pbnRlcmNlcHRvci9yZXRyeS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLE1BQU1BLGVBQWVDLG1CQUFPQSxDQUFDO0FBRTdCQyxPQUFPQyxPQUFPLEdBQUdDLENBQUFBO0lBQ2YsT0FBT0MsQ0FBQUE7UUFDTCxPQUFPLFNBQVNDLGlCQUFrQkMsSUFBSSxFQUFFQyxPQUFPO1lBQzdDLE9BQU9ILFNBQ0xFLE1BQ0EsSUFBSVAsYUFDRjtnQkFBRSxHQUFHTyxJQUFJO2dCQUFFRSxjQUFjO29CQUFFLEdBQUdMLFVBQVU7b0JBQUUsR0FBR0csS0FBS0UsWUFBQUE7Z0JBQWE7WUFBRSxHQUNqRTtnQkFDRUQ7Z0JBQ0FIO1lBQ0Y7UUFHTjtJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tb2NrdXBmbG93Ly4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvaW50ZXJjZXB0b3IvcmV0cnkuanM/MWQ3OSIsIndlYnBhY2s6Ly9tb2NrdXBmbG93Ly4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvaW50ZXJjZXB0b3IvcmV0cnkuanM/MWQ3OSoiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5jb25zdCBSZXRyeUhhbmRsZXIgPSByZXF1aXJlKCcuLi9oYW5kbGVyL3JldHJ5LWhhbmRsZXInKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdsb2JhbE9wdHMgPT4ge1xuICByZXR1cm4gZGlzcGF0Y2ggPT4ge1xuICAgIHJldHVybiBmdW5jdGlvbiByZXRyeUludGVyY2VwdG9yIChvcHRzLCBoYW5kbGVyKSB7XG4gICAgICByZXR1cm4gZGlzcGF0Y2goXG4gICAgICAgIG9wdHMsXG4gICAgICAgIG5ldyBSZXRyeUhhbmRsZXIoXG4gICAgICAgICAgeyAuLi5vcHRzLCByZXRyeU9wdGlvbnM6IHsgLi4uZ2xvYmFsT3B0cywgLi4ub3B0cy5yZXRyeU9wdGlvbnMgfSB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGhhbmRsZXIsXG4gICAgICAgICAgICBkaXNwYXRjaFxuICAgICAgICAgIH1cbiAgICAgICAgKVxuICAgICAgKVxuICAgIH1cbiAgfVxufVxuIl0sIm5hbWVzIjpbIlJldHJ5SGFuZGxlciIsInJlcXVpcmUiLCJtb2R1bGUiLCJleHBvcnRzIiwiZ2xvYmFsT3B0cyIsImRpc3BhdGNoIiwicmV0cnlJbnRlcmNlcHRvciIsIm9wdHMiLCJoYW5kbGVyIiwicmV0cnlPcHRpb25zIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/interceptor/retry.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/llhttp/constants.js":
/*!*****************************************************!*\
  !*** ./node_modules/undici/lib/llhttp/constants.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.SPECIAL_HEADERS = exports.HEADER_STATE = exports.MINOR = exports.MAJOR = exports.CONNECTION_TOKEN_CHARS = exports.HEADER_CHARS = exports.TOKEN = exports.STRICT_TOKEN = exports.HEX = exports.URL_CHAR = exports.STRICT_URL_CHAR = exports.USERINFO_CHARS = exports.MARK = exports.ALPHANUM = exports.NUM = exports.HEX_MAP = exports.NUM_MAP = exports.ALPHA = exports.FINISH = exports.H_METHOD_MAP = exports.METHOD_MAP = exports.METHODS_RTSP = exports.METHODS_ICE = exports.METHODS_HTTP = exports.METHODS = exports.LENIENT_FLAGS = exports.FLAGS = exports.TYPE = exports.ERROR = void 0;\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/undici/lib/llhttp/utils.js\");\n// C headers\nvar ERROR;\n(function(ERROR) {\n    ERROR[ERROR[\"OK\"] = 0] = \"OK\";\n    ERROR[ERROR[\"INTERNAL\"] = 1] = \"INTERNAL\";\n    ERROR[ERROR[\"STRICT\"] = 2] = \"STRICT\";\n    ERROR[ERROR[\"LF_EXPECTED\"] = 3] = \"LF_EXPECTED\";\n    ERROR[ERROR[\"UNEXPECTED_CONTENT_LENGTH\"] = 4] = \"UNEXPECTED_CONTENT_LENGTH\";\n    ERROR[ERROR[\"CLOSED_CONNECTION\"] = 5] = \"CLOSED_CONNECTION\";\n    ERROR[ERROR[\"INVALID_METHOD\"] = 6] = \"INVALID_METHOD\";\n    ERROR[ERROR[\"INVALID_URL\"] = 7] = \"INVALID_URL\";\n    ERROR[ERROR[\"INVALID_CONSTANT\"] = 8] = \"INVALID_CONSTANT\";\n    ERROR[ERROR[\"INVALID_VERSION\"] = 9] = \"INVALID_VERSION\";\n    ERROR[ERROR[\"INVALID_HEADER_TOKEN\"] = 10] = \"INVALID_HEADER_TOKEN\";\n    ERROR[ERROR[\"INVALID_CONTENT_LENGTH\"] = 11] = \"INVALID_CONTENT_LENGTH\";\n    ERROR[ERROR[\"INVALID_CHUNK_SIZE\"] = 12] = \"INVALID_CHUNK_SIZE\";\n    ERROR[ERROR[\"INVALID_STATUS\"] = 13] = \"INVALID_STATUS\";\n    ERROR[ERROR[\"INVALID_EOF_STATE\"] = 14] = \"INVALID_EOF_STATE\";\n    ERROR[ERROR[\"INVALID_TRANSFER_ENCODING\"] = 15] = \"INVALID_TRANSFER_ENCODING\";\n    ERROR[ERROR[\"CB_MESSAGE_BEGIN\"] = 16] = \"CB_MESSAGE_BEGIN\";\n    ERROR[ERROR[\"CB_HEADERS_COMPLETE\"] = 17] = \"CB_HEADERS_COMPLETE\";\n    ERROR[ERROR[\"CB_MESSAGE_COMPLETE\"] = 18] = \"CB_MESSAGE_COMPLETE\";\n    ERROR[ERROR[\"CB_CHUNK_HEADER\"] = 19] = \"CB_CHUNK_HEADER\";\n    ERROR[ERROR[\"CB_CHUNK_COMPLETE\"] = 20] = \"CB_CHUNK_COMPLETE\";\n    ERROR[ERROR[\"PAUSED\"] = 21] = \"PAUSED\";\n    ERROR[ERROR[\"PAUSED_UPGRADE\"] = 22] = \"PAUSED_UPGRADE\";\n    ERROR[ERROR[\"PAUSED_H2_UPGRADE\"] = 23] = \"PAUSED_H2_UPGRADE\";\n    ERROR[ERROR[\"USER\"] = 24] = \"USER\";\n})(ERROR = exports.ERROR || (exports.ERROR = {}));\nvar TYPE;\n(function(TYPE) {\n    TYPE[TYPE[\"BOTH\"] = 0] = \"BOTH\";\n    TYPE[TYPE[\"REQUEST\"] = 1] = \"REQUEST\";\n    TYPE[TYPE[\"RESPONSE\"] = 2] = \"RESPONSE\";\n})(TYPE = exports.TYPE || (exports.TYPE = {}));\nvar FLAGS;\n(function(FLAGS) {\n    FLAGS[FLAGS[\"CONNECTION_KEEP_ALIVE\"] = 1] = \"CONNECTION_KEEP_ALIVE\";\n    FLAGS[FLAGS[\"CONNECTION_CLOSE\"] = 2] = \"CONNECTION_CLOSE\";\n    FLAGS[FLAGS[\"CONNECTION_UPGRADE\"] = 4] = \"CONNECTION_UPGRADE\";\n    FLAGS[FLAGS[\"CHUNKED\"] = 8] = \"CHUNKED\";\n    FLAGS[FLAGS[\"UPGRADE\"] = 16] = \"UPGRADE\";\n    FLAGS[FLAGS[\"CONTENT_LENGTH\"] = 32] = \"CONTENT_LENGTH\";\n    FLAGS[FLAGS[\"SKIPBODY\"] = 64] = \"SKIPBODY\";\n    FLAGS[FLAGS[\"TRAILING\"] = 128] = \"TRAILING\";\n    // 1 << 8 is unused\n    FLAGS[FLAGS[\"TRANSFER_ENCODING\"] = 512] = \"TRANSFER_ENCODING\";\n})(FLAGS = exports.FLAGS || (exports.FLAGS = {}));\nvar LENIENT_FLAGS;\n(function(LENIENT_FLAGS) {\n    LENIENT_FLAGS[LENIENT_FLAGS[\"HEADERS\"] = 1] = \"HEADERS\";\n    LENIENT_FLAGS[LENIENT_FLAGS[\"CHUNKED_LENGTH\"] = 2] = \"CHUNKED_LENGTH\";\n    LENIENT_FLAGS[LENIENT_FLAGS[\"KEEP_ALIVE\"] = 4] = \"KEEP_ALIVE\";\n})(LENIENT_FLAGS = exports.LENIENT_FLAGS || (exports.LENIENT_FLAGS = {}));\nvar METHODS;\n(function(METHODS) {\n    METHODS[METHODS[\"DELETE\"] = 0] = \"DELETE\";\n    METHODS[METHODS[\"GET\"] = 1] = \"GET\";\n    METHODS[METHODS[\"HEAD\"] = 2] = \"HEAD\";\n    METHODS[METHODS[\"POST\"] = 3] = \"POST\";\n    METHODS[METHODS[\"PUT\"] = 4] = \"PUT\";\n    /* pathological */ METHODS[METHODS[\"CONNECT\"] = 5] = \"CONNECT\";\n    METHODS[METHODS[\"OPTIONS\"] = 6] = \"OPTIONS\";\n    METHODS[METHODS[\"TRACE\"] = 7] = \"TRACE\";\n    /* WebDAV */ METHODS[METHODS[\"COPY\"] = 8] = \"COPY\";\n    METHODS[METHODS[\"LOCK\"] = 9] = \"LOCK\";\n    METHODS[METHODS[\"MKCOL\"] = 10] = \"MKCOL\";\n    METHODS[METHODS[\"MOVE\"] = 11] = \"MOVE\";\n    METHODS[METHODS[\"PROPFIND\"] = 12] = \"PROPFIND\";\n    METHODS[METHODS[\"PROPPATCH\"] = 13] = \"PROPPATCH\";\n    METHODS[METHODS[\"SEARCH\"] = 14] = \"SEARCH\";\n    METHODS[METHODS[\"UNLOCK\"] = 15] = \"UNLOCK\";\n    METHODS[METHODS[\"BIND\"] = 16] = \"BIND\";\n    METHODS[METHODS[\"REBIND\"] = 17] = \"REBIND\";\n    METHODS[METHODS[\"UNBIND\"] = 18] = \"UNBIND\";\n    METHODS[METHODS[\"ACL\"] = 19] = \"ACL\";\n    /* subversion */ METHODS[METHODS[\"REPORT\"] = 20] = \"REPORT\";\n    METHODS[METHODS[\"MKACTIVITY\"] = 21] = \"MKACTIVITY\";\n    METHODS[METHODS[\"CHECKOUT\"] = 22] = \"CHECKOUT\";\n    METHODS[METHODS[\"MERGE\"] = 23] = \"MERGE\";\n    /* upnp */ METHODS[METHODS[\"M-SEARCH\"] = 24] = \"M-SEARCH\";\n    METHODS[METHODS[\"NOTIFY\"] = 25] = \"NOTIFY\";\n    METHODS[METHODS[\"SUBSCRIBE\"] = 26] = \"SUBSCRIBE\";\n    METHODS[METHODS[\"UNSUBSCRIBE\"] = 27] = \"UNSUBSCRIBE\";\n    /* RFC-5789 */ METHODS[METHODS[\"PATCH\"] = 28] = \"PATCH\";\n    METHODS[METHODS[\"PURGE\"] = 29] = \"PURGE\";\n    /* CalDAV */ METHODS[METHODS[\"MKCALENDAR\"] = 30] = \"MKCALENDAR\";\n    /* RFC-2068, section 19.6.1.2 */ METHODS[METHODS[\"LINK\"] = 31] = \"LINK\";\n    METHODS[METHODS[\"UNLINK\"] = 32] = \"UNLINK\";\n    /* icecast */ METHODS[METHODS[\"SOURCE\"] = 33] = \"SOURCE\";\n    /* RFC-7540, section 11.6 */ METHODS[METHODS[\"PRI\"] = 34] = \"PRI\";\n    /* RFC-2326 RTSP */ METHODS[METHODS[\"DESCRIBE\"] = 35] = \"DESCRIBE\";\n    METHODS[METHODS[\"ANNOUNCE\"] = 36] = \"ANNOUNCE\";\n    METHODS[METHODS[\"SETUP\"] = 37] = \"SETUP\";\n    METHODS[METHODS[\"PLAY\"] = 38] = \"PLAY\";\n    METHODS[METHODS[\"PAUSE\"] = 39] = \"PAUSE\";\n    METHODS[METHODS[\"TEARDOWN\"] = 40] = \"TEARDOWN\";\n    METHODS[METHODS[\"GET_PARAMETER\"] = 41] = \"GET_PARAMETER\";\n    METHODS[METHODS[\"SET_PARAMETER\"] = 42] = \"SET_PARAMETER\";\n    METHODS[METHODS[\"REDIRECT\"] = 43] = \"REDIRECT\";\n    METHODS[METHODS[\"RECORD\"] = 44] = \"RECORD\";\n    /* RAOP */ METHODS[METHODS[\"FLUSH\"] = 45] = \"FLUSH\";\n})(METHODS = exports.METHODS || (exports.METHODS = {}));\nexports.METHODS_HTTP = [\n    METHODS.DELETE,\n    METHODS.GET,\n    METHODS.HEAD,\n    METHODS.POST,\n    METHODS.PUT,\n    METHODS.CONNECT,\n    METHODS.OPTIONS,\n    METHODS.TRACE,\n    METHODS.COPY,\n    METHODS.LOCK,\n    METHODS.MKCOL,\n    METHODS.MOVE,\n    METHODS.PROPFIND,\n    METHODS.PROPPATCH,\n    METHODS.SEARCH,\n    METHODS.UNLOCK,\n    METHODS.BIND,\n    METHODS.REBIND,\n    METHODS.UNBIND,\n    METHODS.ACL,\n    METHODS.REPORT,\n    METHODS.MKACTIVITY,\n    METHODS.CHECKOUT,\n    METHODS.MERGE,\n    METHODS[\"M-SEARCH\"],\n    METHODS.NOTIFY,\n    METHODS.SUBSCRIBE,\n    METHODS.UNSUBSCRIBE,\n    METHODS.PATCH,\n    METHODS.PURGE,\n    METHODS.MKCALENDAR,\n    METHODS.LINK,\n    METHODS.UNLINK,\n    METHODS.PRI,\n    // TODO(indutny): should we allow it with HTTP?\n    METHODS.SOURCE\n];\nexports.METHODS_ICE = [\n    METHODS.SOURCE\n];\nexports.METHODS_RTSP = [\n    METHODS.OPTIONS,\n    METHODS.DESCRIBE,\n    METHODS.ANNOUNCE,\n    METHODS.SETUP,\n    METHODS.PLAY,\n    METHODS.PAUSE,\n    METHODS.TEARDOWN,\n    METHODS.GET_PARAMETER,\n    METHODS.SET_PARAMETER,\n    METHODS.REDIRECT,\n    METHODS.RECORD,\n    METHODS.FLUSH,\n    // For AirPlay\n    METHODS.GET,\n    METHODS.POST\n];\nexports.METHOD_MAP = utils_1.enumToMap(METHODS);\nexports.H_METHOD_MAP = {};\nObject.keys(exports.METHOD_MAP).forEach((key)=>{\n    if (/^H/.test(key)) {\n        exports.H_METHOD_MAP[key] = exports.METHOD_MAP[key];\n    }\n});\nvar FINISH;\n(function(FINISH) {\n    FINISH[FINISH[\"SAFE\"] = 0] = \"SAFE\";\n    FINISH[FINISH[\"SAFE_WITH_CB\"] = 1] = \"SAFE_WITH_CB\";\n    FINISH[FINISH[\"UNSAFE\"] = 2] = \"UNSAFE\";\n})(FINISH = exports.FINISH || (exports.FINISH = {}));\nexports.ALPHA = [];\nfor(let i = \"A\".charCodeAt(0); i <= \"Z\".charCodeAt(0); i++){\n    // Upper case\n    exports.ALPHA.push(String.fromCharCode(i));\n    // Lower case\n    exports.ALPHA.push(String.fromCharCode(i + 0x20));\n}\nexports.NUM_MAP = {\n    0: 0,\n    1: 1,\n    2: 2,\n    3: 3,\n    4: 4,\n    5: 5,\n    6: 6,\n    7: 7,\n    8: 8,\n    9: 9\n};\nexports.HEX_MAP = {\n    0: 0,\n    1: 1,\n    2: 2,\n    3: 3,\n    4: 4,\n    5: 5,\n    6: 6,\n    7: 7,\n    8: 8,\n    9: 9,\n    A: 0XA,\n    B: 0XB,\n    C: 0XC,\n    D: 0XD,\n    E: 0XE,\n    F: 0XF,\n    a: 0xa,\n    b: 0xb,\n    c: 0xc,\n    d: 0xd,\n    e: 0xe,\n    f: 0xf\n};\nexports.NUM = [\n    \"0\",\n    \"1\",\n    \"2\",\n    \"3\",\n    \"4\",\n    \"5\",\n    \"6\",\n    \"7\",\n    \"8\",\n    \"9\"\n];\nexports.ALPHANUM = exports.ALPHA.concat(exports.NUM);\nexports.MARK = [\n    \"-\",\n    \"_\",\n    \".\",\n    \"!\",\n    \"~\",\n    \"*\",\n    \"'\",\n    \"(\",\n    \")\"\n];\nexports.USERINFO_CHARS = exports.ALPHANUM.concat(exports.MARK).concat([\n    \"%\",\n    \";\",\n    \":\",\n    \"&\",\n    \"=\",\n    \"+\",\n    \"$\",\n    \",\"\n]);\n// TODO(indutny): use RFC\nexports.STRICT_URL_CHAR = [\n    \"!\",\n    '\"',\n    \"$\",\n    \"%\",\n    \"&\",\n    \"'\",\n    \"(\",\n    \")\",\n    \"*\",\n    \"+\",\n    \",\",\n    \"-\",\n    \".\",\n    \"/\",\n    \":\",\n    \";\",\n    \"<\",\n    \"=\",\n    \">\",\n    \"@\",\n    \"[\",\n    \"\\\\\",\n    \"]\",\n    \"^\",\n    \"_\",\n    \"`\",\n    \"{\",\n    \"|\",\n    \"}\",\n    \"~\"\n].concat(exports.ALPHANUM);\nexports.URL_CHAR = exports.STRICT_URL_CHAR.concat([\n    \"\t\",\n    \"\\f\"\n]);\n// All characters with 0x80 bit set to 1\nfor(let i = 0x80; i <= 0xff; i++){\n    exports.URL_CHAR.push(i);\n}\nexports.HEX = exports.NUM.concat([\n    \"a\",\n    \"b\",\n    \"c\",\n    \"d\",\n    \"e\",\n    \"f\",\n    \"A\",\n    \"B\",\n    \"C\",\n    \"D\",\n    \"E\",\n    \"F\"\n]);\n/* Tokens as defined by rfc 2616. Also lowercases them.\n *        token       = 1*<any CHAR except CTLs or separators>\n *     separators     = \"(\" | \")\" | \"<\" | \">\" | \"@\"\n *                    | \",\" | \";\" | \":\" | \"\\\" | <\">\n *                    | \"/\" | \"[\" | \"]\" | \"?\" | \"=\"\n *                    | \"{\" | \"}\" | SP | HT\n */ exports.STRICT_TOKEN = [\n    \"!\",\n    \"#\",\n    \"$\",\n    \"%\",\n    \"&\",\n    \"'\",\n    \"*\",\n    \"+\",\n    \"-\",\n    \".\",\n    \"^\",\n    \"_\",\n    \"`\",\n    \"|\",\n    \"~\"\n].concat(exports.ALPHANUM);\nexports.TOKEN = exports.STRICT_TOKEN.concat([\n    \" \"\n]);\n/*\n * Verify that a char is a valid visible (printable) US-ASCII\n * character or %x80-FF\n */ exports.HEADER_CHARS = [\n    \"\t\"\n];\nfor(let i = 32; i <= 255; i++){\n    if (i !== 127) {\n        exports.HEADER_CHARS.push(i);\n    }\n}\n// ',' = \\x44\nexports.CONNECTION_TOKEN_CHARS = exports.HEADER_CHARS.filter((c)=>c !== 44);\nexports.MAJOR = exports.NUM_MAP;\nexports.MINOR = exports.MAJOR;\nvar HEADER_STATE;\n(function(HEADER_STATE) {\n    HEADER_STATE[HEADER_STATE[\"GENERAL\"] = 0] = \"GENERAL\";\n    HEADER_STATE[HEADER_STATE[\"CONNECTION\"] = 1] = \"CONNECTION\";\n    HEADER_STATE[HEADER_STATE[\"CONTENT_LENGTH\"] = 2] = \"CONTENT_LENGTH\";\n    HEADER_STATE[HEADER_STATE[\"TRANSFER_ENCODING\"] = 3] = \"TRANSFER_ENCODING\";\n    HEADER_STATE[HEADER_STATE[\"UPGRADE\"] = 4] = \"UPGRADE\";\n    HEADER_STATE[HEADER_STATE[\"CONNECTION_KEEP_ALIVE\"] = 5] = \"CONNECTION_KEEP_ALIVE\";\n    HEADER_STATE[HEADER_STATE[\"CONNECTION_CLOSE\"] = 6] = \"CONNECTION_CLOSE\";\n    HEADER_STATE[HEADER_STATE[\"CONNECTION_UPGRADE\"] = 7] = \"CONNECTION_UPGRADE\";\n    HEADER_STATE[HEADER_STATE[\"TRANSFER_ENCODING_CHUNKED\"] = 8] = \"TRANSFER_ENCODING_CHUNKED\";\n})(HEADER_STATE = exports.HEADER_STATE || (exports.HEADER_STATE = {}));\nexports.SPECIAL_HEADERS = {\n    \"connection\": HEADER_STATE.CONNECTION,\n    \"content-length\": HEADER_STATE.CONTENT_LENGTH,\n    \"proxy-connection\": HEADER_STATE.CONNECTION,\n    \"transfer-encoding\": HEADER_STATE.TRANSFER_ENCODING,\n    \"upgrade\": HEADER_STATE.UPGRADE\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9sbGh0dHAvY29uc3RhbnRzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCx1QkFBdUIsR0FBR0Esb0JBQW9CLEdBQUdBLGFBQWEsR0FBR0EsYUFBYSxHQUFHQSw4QkFBOEIsR0FBR0Esb0JBQW9CLEdBQUdBLGFBQWEsR0FBR0Esb0JBQW9CLEdBQUdBLFdBQVcsR0FBR0EsZ0JBQWdCLEdBQUdBLHVCQUF1QixHQUFHQSxzQkFBc0IsR0FBR0EsWUFBWSxHQUFHQSxnQkFBZ0IsR0FBR0EsV0FBVyxHQUFHQSxlQUFlLEdBQUdBLGVBQWUsR0FBR0EsYUFBYSxHQUFHQSxjQUFjLEdBQUdBLG9CQUFvQixHQUFHQSxrQkFBa0IsR0FBR0Esb0JBQW9CLEdBQUdBLG1CQUFtQixHQUFHQSxvQkFBb0IsR0FBR0EsZUFBZSxHQUFHQSxxQkFBcUIsR0FBR0EsYUFBYSxHQUFHQSxZQUFZLEdBQUdBLGFBQWEsR0FBRyxLQUFLO0FBQ3ZrQixNQUFNK0IsVUFBVUMsbUJBQU9BLENBQUMsZ0VBQVM7QUFDakM7QUFDQSxJQUFJRjtBQUNILFVBQVVBLEtBQUs7SUFDWkEsS0FBSyxDQUFDQSxLQUFLLENBQUMsS0FBSyxHQUFHLEVBQUUsR0FBRztJQUN6QkEsS0FBSyxDQUFDQSxLQUFLLENBQUMsV0FBVyxHQUFHLEVBQUUsR0FBRztJQUMvQkEsS0FBSyxDQUFDQSxLQUFLLENBQUMsU0FBUyxHQUFHLEVBQUUsR0FBRztJQUM3QkEsS0FBSyxDQUFDQSxLQUFLLENBQUMsY0FBYyxHQUFHLEVBQUUsR0FBRztJQUNsQ0EsS0FBSyxDQUFDQSxLQUFLLENBQUMsNEJBQTRCLEdBQUcsRUFBRSxHQUFHO0lBQ2hEQSxLQUFLLENBQUNBLEtBQUssQ0FBQyxvQkFBb0IsR0FBRyxFQUFFLEdBQUc7SUFDeENBLEtBQUssQ0FBQ0EsS0FBSyxDQUFDLGlCQUFpQixHQUFHLEVBQUUsR0FB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QUNyREEsWUFBWSxDQUFDQSxZQUFZLENBQUMscUJBQXFCLEdBQUcsRUFBRSxHQUFHO0lBQ3ZEQSxZQUFZLENBQUNBLFlBQVksQ0FBQyw0QkFBNEIsR0FBRyxFQUFFLEdBQUc7QUFDbEUsR0FBR0EsZUFBZUgsUUFBUUcsWUFBWSxJQUFLSCxDQUFBQSxvQkFBb0IsR0FBRyxDQUFDO0FBQ25FQSx1QkFBdUIsR0FBRztJQUN0QixjQUFjRyxhQUFhbUcsVUFBVTtJQUNyQyxrQkFBa0JuRyxhQUFhb0csY0FBYztJQUM3QyxvQkFBb0JwRyxhQUFhbUcsVUFBVTtJQUMzQyxxQkFBcUJuRyxhQUFhcUcsaUJBQWlCO0lBQ25ELFdBQVdyRyxhQUFhc0csT0FBQUE7QUFDNUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tb2NrdXBmbG93Ly4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvbGxodHRwL2NvbnN0YW50cy5qcz9lZDkwIiwid2VicGFjazovL21vY2t1cGZsb3cvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9sbGh0dHAvY29uc3RhbnRzLmpzP2VkOTAqIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TUEVDSUFMX0hFQURFUlMgPSBleHBvcnRzLkhFQURFUl9TVEFURSA9IGV4cG9ydHMuTUlOT1IgPSBleHBvcnRzLk1BSk9SID0gZXhwb3J0cy5DT05ORUNUSU9OX1RPS0VOX0NIQVJTID0gZXhwb3J0cy5IRUFERVJfQ0hBUlMgPSBleHBvcnRzLlRPS0VOID0gZXhwb3J0cy5TVFJJQ1RfVE9LRU4gPSBleHBvcnRzLkhFWCA9IGV4cG9ydHMuVVJMX0NIQVIgPSBleHBvcnRzLlNUUklDVF9VUkxfQ0hBUiA9IGV4cG9ydHMuVVNFUklORk9fQ0hBUlMgPSBleHBvcnRzLk1BUksgPSBleHBvcnRzLkFMUEhBTlVNID0gZXhwb3J0cy5OVU0gPSBleHBvcnRzLkhFWF9NQVAgPSBleHBvcnRzLk5VTV9NQVAgPSBleHBvcnRzLkFMUEhBID0gZXhwb3J0cy5GSU5JU0ggPSBleHBvcnRzLkhfTUVUSE9EX01BUCA9IGV4cG9ydHMuTUVUSE9EX01BUCA9IGV4cG9ydHMuTUVUSE9EU19SVFNQID0gZXhwb3J0cy5NRVRIT0RTX0lDRSA9IGV4cG9ydHMuTUVUSE9EU19IVFRQID0gZXhwb3J0cy5NRVRIT0RTID0gZXhwb3J0cy5MRU5JRU5UX0ZMQUdTID0gZXhwb3J0cy5GTEFHUyA9IGV4cG9ydHMuVFlQRSA9IGV4cG9ydHMuRVJST1IgPSB2b2lkIDA7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG4vLyBDIGhlYWRlcnNcbnZhciBFUlJPUjtcbihmdW5jdGlvbiAoRVJST1IpIHtcbiAgICBFUlJPUltFUlJPUltcIk9LXCJdID0gMF0gPSBcIk9LXCI7XG4gICAgRVJST1JbRVJST1JbXCJJTlRFUk5BTFwiXSA9IDFdID0gXCJJTlRFUk5BTFwiO1xuICAgIEVSUk9SW0VSUk9SW1wiU1RSSUNUXCJdID0gMl0gPSBcIlNUUklDVFwiO1xuICAgIEVSUk9SW0VSUk9SW1wiTEZfRVhQRUNURURcIl0gPSAzXSA9IFwiTEZfRVhQRUNURURcIjtcbiAgICBFUlJPUltFUlJPUltcIlVORVhQRUNURURfQ09OVEVOVF9MRU5HVEhcIl0gPSA0XSA9IFwiVU5FWFBFQ1RFRF9DT05URU5UX0xFTkdUSFwiO1xuICAgIEVSUk9SW0VSUk9SW1wiQ0xPU0VEX0NPTk5FQ1RJT05cIl0gPSA1XSA9IFwiQ0xPU0VEX0NPTk5FQ1RJT05cIjtcbiAgICBFUlJPUltFUlJPUltcIklOVkFMSURfTUVUSE9EXCJdID0gNl0gPSBcIklOVkFMSURfTUVUSE9EXCI7XG4gICAgRVJST1JbRVJST1JbXCJJTlZBTElEX1VSTFwiXSA9IDddID0gXCJJTlZBTElEX1VSTFwiO1xuICAgIEVSUk9SW0VSUk9SW1wiSU5WQUxJRF9DT05TVEFOVFwiXSA9IDhdID0gXCJJTlZBTElEX0NPTlNUQU5UXCI7XG4gICAgRVJST1JbRVJST1JbXCJJTlZBTElEX1ZFUlNJT05cIl0gPSA5XSA9IFwiSU5WQUxJRF9WRVJTSU9OXCI7XG4gICAgRVJST1JbRVJST1JbXCJJTlZBTElEX0hFQURFUl9UT0tFTlwiXSA9IDEwXSA9IFwiSU5WQUxJRF9IRUFERVJfVE9LRU5cIjtcbiAgICBFUlJPUltFUlJPUltcIklOVkFMSURfQ09OVEVOVF9MRU5HVEhcIl0gPSAxMV0gPSBcIklOVkFMSURfQ09OVEVOVF9MRU5HVEhcIjtcbiAgICBFUlJPUltFUlJPUltcIklOVkFMSURfQ0hVTktfU0laRVwiXSA9IDEyXSA9IFwiSU5WQUxJRF9DSFVOS19TSVpFXCI7XG4gICAgRVJST1JbRVJST1JbXCJJTlZBTElEX1NUQVRVU1wiXSA9IDEzXSA9IFwiSU5WQUxJRF9TVEFUVVNcIjtcbiAgICBFUlJPUltFUlJPUltcIklOVkFMSURfRU9GX1NUQVRFXCJdID0gMTRdID0gXCJJTlZBTElEX0VPRl9TVEFURVwiO1xuICAgIEVSUk9SW0VSUk9SW1wiSU5WQUxJRF9UUkFOU0ZFUl9FTkNPRElOR1wiXSA9IDE1XSA9IFwiSU5WQUxJRF9UUkFOU0ZFUl9FTkNPRElOR1wiO1xuICAgIEVSUk9SW0VSUk9SW1wiQ0JfTUVTU0FHRV9CRUdJTlwiXSA9IDE2XSA9IFwiQ0JfTUVTU0FHRV9CRUdJTlwiO1xuICAgIEVSUk9SW0VSUk9SW1wiQ0JfSEVBREVSU19DT01QTEVURVwiXSA9IDE3XSA9IFwiQ0JfSEVBREVSU19DT01QTEVURVwiO1xuICAgIEVSUk9SW0VSUk9SW1wiQ0JfTUVTU0FHRV9DT01QTEVURVwiXSA9IDE4XSA9IFwiQ0JfTUVTU0FHRV9DT01QTEVURVwiO1xuICAgIEVSUk9SW0VSUk9SW1wiQ0JfQ0hVTktfSEVBREVSXCJdID0gMTldID0gXCJDQl9DSFVOS19IRUFERVJcIjtcbiAgICBFUlJPUltFUlJPUltcIkNCX0NIVU5LX0NPTVBMRVRFXCJdID0gMjBdID0gXCJDQl9DSFVOS19DT01QTEVURVwiO1xuICAgIEVSUk9SW0VSUk9SW1wiUEFVU0VEXCJdID0gMjFdID0gXCJQQVVTRURcIjtcbiAgICBFUlJPUltFUlJPUltcIlBBVVNFRF9VUEdSQURFXCJdID0gMjJdID0gXCJQQVVTRURfVVBHUkFERVwiO1xuICAgIEVSUk9SW0VSUk9SW1wiUEFVU0VEX0gyX1VQR1JBREVcIl0gPSAyM10gPSBcIlBBVVNFRF9IMl9VUEdSQURFXCI7XG4gICAgRVJST1JbRVJST1JbXCJVU0VSXCJdID0gMjRdID0gXCJVU0VSXCI7XG59KShFUlJPUiA9IGV4cG9ydHMuRVJST1IgfHwgKGV4cG9ydHMuRVJST1IgPSB7fSkpO1xudmFyIFRZUEU7XG4oZnVuY3Rpb24gKFRZUEUpIHtcbiAgICBUWVBFW1RZUEVbXCJCT1RIXCJdID0gMF0gPSBcIkJPVEhcIjtcbiAgICBUWVBFW1RZUEVbXCJSRVFVRVNUXCJdID0gMV0gPSBcIlJFUVVFU1RcIjtcbiAgICBUWVBFW1RZUEVbXCJSRVNQT05TRVwiXSA9IDJdID0gXCJSRVNQT05TRVwiO1xufSkoVFlQRSA9IGV4cG9ydHMuVFlQRSB8fCAoZXhwb3J0cy5UWVBFID0ge30pKTtcbnZhciBGTEFHUztcbihmdW5jdGlvbiAoRkxBR1MpIHtcbiAgICBGTEFHU1tGTEFHU1tcIkNPTk5FQ1RJT05fS0VFUF9BTElWRVwiXSA9IDFdID0gXCJDT05ORUNUSU9OX0tFRVBfQUxJVkVcIjtcbiAgICBGTEFHU1tGTEFHU1tcIkNPTk5FQ1RJT05fQ0xPU0VcIl0gPSAyXSA9IFwiQ09OTkVDVElPTl9DTE9TRVwiO1xuICAgIEZMQUdTW0ZMQUdTW1wiQ09OTkVDVElPTl9VUEdSQURFXCJdID0gNF0gPSBcIkNPTk5FQ1RJT05fVVBHUkFERVwiO1xuICAgIEZMQUdTW0ZMQUdTW1wiQ0hVTktFRFwiXSA9IDhdID0gXCJDSFVOS0VEXCI7XG4gICAgRkxBR1NbRkxBR1NbXCJVUEdSQURFXCJdID0gMTZdID0gXCJVUEdSQURFXCI7XG4gICAgRkxBR1NbRkxBR1NbXCJDT05URU5UX0xFTkdUSFwiXSA9IDMyXSA9IFwiQ09OVEVOVF9MRU5HVEhcIjtcbiAgICBGTEFHU1tGTEFHU1tcIlNLSVBCT0RZXCJdID0gNjRdID0gXCJTS0lQQk9EWVwiO1xuICAgIEZMQUdTW0ZMQUdTW1wiVFJBSUxJTkdcIl0gPSAxMjhdID0gXCJUUkFJTElOR1wiO1xuICAgIC8vIDEgPDwgOCBpcyB1bnVzZWRcbiAgICBGTEFHU1tGTEFHU1tcIlRSQU5TRkVSX0VOQ09ESU5HXCJdID0gNTEyXSA9IFwiVFJBTlNGRVJfRU5DT0RJTkdcIjtcbn0pKEZMQUdTID0gZXhwb3J0cy5GTEFHUyB8fCAoZXhwb3J0cy5GTEFHUyA9IHt9KSk7XG52YXIgTEVOSUVOVF9GTEFHUztcbihmdW5jdGlvbiAoTEVOSUVOVF9GTEFHUykge1xuICAgIExFTklFTlRfRkxBR1NbTEVOSUVOVF9GTEFHU1tcIkhFQURFUlNcIl0gPSAxXSA9IFwiSEVBREVSU1wiO1xuICAgIExFTklFTlRfRkxBR1NbTEVOSUVOVF9GTEFHU1tcIkNIVU5LRURfTEVOR1RIXCJdID0gMl0gPSBcIkNIVU5LRURfTEVOR1RIXCI7XG4gICAgTEVOSUVOVF9GTEFHU1tMRU5JRU5UX0ZMQUdTW1wiS0VFUF9BTElWRVwiXSA9IDRdID0gXCJLRUVQX0FMSVZFXCI7XG59KShMRU5JRU5UX0ZMQUdTID0gZXhwb3J0cy5MRU5JRU5UX0ZMQUdTIHx8IChleHBvcnRzLkxFTklFTlRfRkxBR1MgPSB7fSkpO1xudmFyIE1FVEhPRFM7XG4oZnVuY3Rpb24gKE1FVEhPRFMpIHtcbiAgICBNRVRIT0RTW01FVEhPRFNbXCJERUxFVEVcIl0gPSAwXSA9IFwiREVMRVRFXCI7XG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiR0VUXCJdID0gMV0gPSBcIkdFVFwiO1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIkhFQURcIl0gPSAyXSA9IFwiSEVBRFwiO1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIlBPU1RcIl0gPSAzXSA9IFwiUE9TVFwiO1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIlBVVFwiXSA9IDRdID0gXCJQVVRcIjtcbiAgICAvKiBwYXRob2xvZ2ljYWwgKi9cbiAgICBNRVRIT0RTW01FVEhPRFNbXCJDT05ORUNUXCJdID0gNV0gPSBcIkNPTk5FQ1RcIjtcbiAgICBNRVRIT0RTW01FVEhPRFNbXCJPUFRJT05TXCJdID0gNl0gPSBcIk9QVElPTlNcIjtcbiAgICBNRVRIT0RTW01FVEhPRFNbXCJUUkFDRVwiXSA9IDddID0gXCJUUkFDRVwiO1xuICAgIC8qIFdlYkRBViAqL1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIkNPUFlcIl0gPSA4XSA9IFwiQ09QWVwiO1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIkxPQ0tcIl0gPSA5XSA9IFwiTE9DS1wiO1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIk1LQ09MXCJdID0gMTBdID0gXCJNS0NPTFwiO1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIk1PVkVcIl0gPSAxMV0gPSBcIk1PVkVcIjtcbiAgICBNRVRIT0RTW01FVEhPRFNbXCJQUk9QRklORFwiXSA9IDEyXSA9IFwiUFJPUEZJTkRcIjtcbiAgICBNRVRIT0RTW01FVEhPRFNbXCJQUk9QUEFUQ0hcIl0gPSAxM10gPSBcIlBST1BQQVRDSFwiO1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIlNFQVJDSFwiXSA9IDE0XSA9IFwiU0VBUkNIXCI7XG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiVU5MT0NLXCJdID0gMTVdID0gXCJVTkxPQ0tcIjtcbiAgICBNRVRIT0RTW01FVEhPRFNbXCJCSU5EXCJdID0gMTZdID0gXCJCSU5EXCI7XG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiUkVCSU5EXCJdID0gMTddID0gXCJSRUJJTkRcIjtcbiAgICBNRVRIT0RTW01FVEhPRFNbXCJVTkJJTkRcIl0gPSAxOF0gPSBcIlVOQklORFwiO1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIkFDTFwiXSA9IDE5XSA9IFwiQUNMXCI7XG4gICAgLyogc3VidmVyc2lvbiAqL1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIlJFUE9SVFwiXSA9IDIwXSA9IFwiUkVQT1JUXCI7XG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiTUtBQ1RJVklUWVwiXSA9IDIxXSA9IFwiTUtBQ1RJVklUWVwiO1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIkNIRUNLT1VUXCJdID0gMjJdID0gXCJDSEVDS09VVFwiO1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIk1FUkdFXCJdID0gMjNdID0gXCJNRVJHRVwiO1xuICAgIC8qIHVwbnAgKi9cbiAgICBNRVRIT0RTW01FVEhPRFNbXCJNLVNFQVJDSFwiXSA9IDI0XSA9IFwiTS1TRUFSQ0hcIjtcbiAgICBNRVRIT0RTW01FVEhPRFNbXCJOT1RJRllcIl0gPSAyNV0gPSBcIk5PVElGWVwiO1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIlNVQlNDUklCRVwiXSA9IDI2XSA9IFwiU1VCU0NSSUJFXCI7XG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiVU5TVUJTQ1JJQkVcIl0gPSAyN10gPSBcIlVOU1VCU0NSSUJFXCI7XG4gICAgLyogUkZDLTU3ODkgKi9cbiAgICBNRVRIT0RTW01FVEhPRFNbXCJQQVRDSFwiXSA9IDI4XSA9IFwiUEFUQ0hcIjtcbiAgICBNRVRIT0RTW01FVEhPRFNbXCJQVVJHRVwiXSA9IDI5XSA9IFwiUFVSR0VcIjtcbiAgICAvKiBDYWxEQVYgKi9cbiAgICBNRVRIT0RTW01FVEhPRFNbXCJNS0NBTEVOREFSXCJdID0gMzBdID0gXCJNS0NBTEVOREFSXCI7XG4gICAgLyogUkZDLTIwNjgsIHNlY3Rpb24gMTkuNi4xLjIgKi9cbiAgICBNRVRIT0RTW01FVEhPRFNbXCJMSU5LXCJdID0gMzFdID0gXCJMSU5LXCI7XG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiVU5MSU5LXCJdID0gMzJdID0gXCJVTkxJTktcIjtcbiAgICAvKiBpY2VjYXN0ICovXG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiU09VUkNFXCJdID0gMzNdID0gXCJTT1VSQ0VcIjtcbiAgICAvKiBSRkMtNzU0MCwgc2VjdGlvbiAxMS42ICovXG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiUFJJXCJdID0gMzRdID0gXCJQUklcIjtcbiAgICAvKiBSRkMtMjMyNiBSVFNQICovXG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiREVTQ1JJQkVcIl0gPSAzNV0gPSBcIkRFU0NSSUJFXCI7XG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiQU5OT1VOQ0VcIl0gPSAzNl0gPSBcIkFOTk9VTkNFXCI7XG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiU0VUVVBcIl0gPSAzN10gPSBcIlNFVFVQXCI7XG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiUExBWVwiXSA9IDM4XSA9IFwiUExBWVwiO1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIlBBVVNFXCJdID0gMzldID0gXCJQQVVTRVwiO1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIlRFQVJET1dOXCJdID0gNDBdID0gXCJURUFSRE9XTlwiO1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIkdFVF9QQVJBTUVURVJcIl0gPSA0MV0gPSBcIkdFVF9QQVJBTUVURVJcIjtcbiAgICBNRVRIT0RTW01FVEhPRFNbXCJTRVRfUEFSQU1FVEVSXCJdID0gNDJdID0gXCJTRVRfUEFSQU1FVEVSXCI7XG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiUkVESVJFQ1RcIl0gPSA0M10gPSBcIlJFRElSRUNUXCI7XG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiUkVDT1JEXCJdID0gNDRdID0gXCJSRUNPUkRcIjtcbiAgICAvKiBSQU9QICovXG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiRkxVU0hcIl0gPSA0NV0gPSBcIkZMVVNIXCI7XG59KShNRVRIT0RTID0gZXhwb3J0cy5NRVRIT0RTIHx8IChleHBvcnRzLk1FVEhPRFMgPSB7fSkpO1xuZXhwb3J0cy5NRVRIT0RTX0hUVFAgPSBbXG4gICAgTUVUSE9EUy5ERUxFVEUsXG4gICAgTUVUSE9EUy5HRVQsXG4gICAgTUVUSE9EUy5IRUFELFxuICAgIE1FVEhPRFMuUE9TVCxcbiAgICBNRVRIT0RTLlBVVCxcbiAgICBNRVRIT0RTLkNPTk5FQ1QsXG4gICAgTUVUSE9EUy5PUFRJT05TLFxuICAgIE1FVEhPRFMuVFJBQ0UsXG4gICAgTUVUSE9EUy5DT1BZLFxuICAgIE1FVEhPRFMuTE9DSyxcbiAgICBNRVRIT0RTLk1LQ09MLFxuICAgIE1FVEhPRFMuTU9WRSxcbiAgICBNRVRIT0RTLlBST1BGSU5ELFxuICAgIE1FVEhPRFMuUFJPUFBBVENILFxuICAgIE1FVEhPRFMuU0VBUkNILFxuICAgIE1FVEhPRFMuVU5MT0NLLFxuICAgIE1FVEhPRFMuQklORCxcbiAgICBNRVRIT0RTLlJFQklORCxcbiAgICBNRVRIT0RTLlVOQklORCxcbiAgICBNRVRIT0RTLkFDTCxcbiAgICBNRVRIT0RTLlJFUE9SVCxcbiAgICBNRVRIT0RTLk1LQUNUSVZJVFksXG4gICAgTUVUSE9EUy5DSEVDS09VVCxcbiAgICBNRVRIT0RTLk1FUkdFLFxuICAgIE1FVEhPRFNbJ00tU0VBUkNIJ10sXG4gICAgTUVUSE9EUy5OT1RJRlksXG4gICAgTUVUSE9EUy5TVUJTQ1JJQkUsXG4gICAgTUVUSE9EUy5VTlNVQlNDUklCRSxcbiAgICBNRVRIT0RTLlBBVENILFxuICAgIE1FVEhPRFMuUFVSR0UsXG4gICAgTUVUSE9EUy5NS0NBTEVOREFSLFxuICAgIE1FVEhPRFMuTElOSyxcbiAgICBNRVRIT0RTLlVOTElOSyxcbiAgICBNRVRIT0RTLlBSSSxcbiAgICAvLyBUT0RPKGluZHV0bnkpOiBzaG91bGQgd2UgYWxsb3cgaXQgd2l0aCBIVFRQP1xuICAgIE1FVEhPRFMuU09VUkNFLFxuXTtcbmV4cG9ydHMuTUVUSE9EU19JQ0UgPSBbXG4gICAgTUVUSE9EUy5TT1VSQ0UsXG5dO1xuZXhwb3J0cy5NRVRIT0RTX1JUU1AgPSBbXG4gICAgTUVUSE9EUy5PUFRJT05TLFxuICAgIE1FVEhPRFMuREVTQ1JJQkUsXG4gICAgTUVUSE9EUy5BTk5PVU5DRSxcbiAgICBNRVRIT0RTLlNFVFVQLFxuICAgIE1FVEhPRFMuUExBWSxcbiAgICBNRVRIT0RTLlBBVVNFLFxuICAgIE1FVEhPRFMuVEVBUkRPV04sXG4gICAgTUVUSE9EUy5HRVRfUEFSQU1FVEVSLFxuICAgIE1FVEhPRFMuU0VUX1BBUkFNRVRFUixcbiAgICBNRVRIT0RTLlJFRElSRUNULFxuICAgIE1FVEhPRFMuUkVDT1JELFxuICAgIE1FVEhPRFMuRkxVU0gsXG4gICAgLy8gRm9yIEFpclBsYXlcbiAgICBNRVRIT0RTLkdFVCxcbiAgICBNRVRIT0RTLlBPU1QsXG5dO1xuZXhwb3J0cy5NRVRIT0RfTUFQID0gdXRpbHNfMS5lbnVtVG9NYXAoTUVUSE9EUyk7XG5leHBvcnRzLkhfTUVUSE9EX01BUCA9IHt9O1xuT2JqZWN0LmtleXMoZXhwb3J0cy5NRVRIT0RfTUFQKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICBpZiAoL15ILy50ZXN0KGtleSkpIHtcbiAgICAgICAgZXhwb3J0cy5IX01FVEhPRF9NQVBba2V5XSA9IGV4cG9ydHMuTUVUSE9EX01BUFtrZXldO1xuICAgIH1cbn0pO1xudmFyIEZJTklTSDtcbihmdW5jdGlvbiAoRklOSVNIKSB7XG4gICAgRklOSVNIW0ZJTklTSFtcIlNBRkVcIl0gPSAwXSA9IFwiU0FGRVwiO1xuICAgIEZJTklTSFtGSU5JU0hbXCJTQUZFX1dJVEhfQ0JcIl0gPSAxXSA9IFwiU0FGRV9XSVRIX0NCXCI7XG4gICAgRklOSVNIW0ZJTklTSFtcIlVOU0FGRVwiXSA9IDJdID0gXCJVTlNBRkVcIjtcbn0pKEZJTklTSCA9IGV4cG9ydHMuRklOSVNIIHx8IChleHBvcnRzLkZJTklTSCA9IHt9KSk7XG5leHBvcnRzLkFMUEhBID0gW107XG5mb3IgKGxldCBpID0gJ0EnLmNoYXJDb2RlQXQoMCk7IGkgPD0gJ1onLmNoYXJDb2RlQXQoMCk7IGkrKykge1xuICAgIC8vIFVwcGVyIGNhc2VcbiAgICBleHBvcnRzLkFMUEhBLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShpKSk7XG4gICAgLy8gTG93ZXIgY2FzZVxuICAgIGV4cG9ydHMuQUxQSEEucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGkgKyAweDIwKSk7XG59XG5leHBvcnRzLk5VTV9NQVAgPSB7XG4gICAgMDogMCwgMTogMSwgMjogMiwgMzogMywgNDogNCxcbiAgICA1OiA1LCA2OiA2LCA3OiA3LCA4OiA4LCA5OiA5LFxufTtcbmV4cG9ydHMuSEVYX01BUCA9IHtcbiAgICAwOiAwLCAxOiAxLCAyOiAyLCAzOiAzLCA0OiA0LFxuICAgIDU6IDUsIDY6IDYsIDc6IDcsIDg6IDgsIDk6IDksXG4gICAgQTogMFhBLCBCOiAwWEIsIEM6IDBYQywgRDogMFhELCBFOiAwWEUsIEY6IDBYRixcbiAgICBhOiAweGEsIGI6IDB4YiwgYzogMHhjLCBkOiAweGQsIGU6IDB4ZSwgZjogMHhmLFxufTtcbmV4cG9ydHMuTlVNID0gW1xuICAgICcwJywgJzEnLCAnMicsICczJywgJzQnLCAnNScsICc2JywgJzcnLCAnOCcsICc5Jyxcbl07XG5leHBvcnRzLkFMUEhBTlVNID0gZXhwb3J0cy5BTFBIQS5jb25jYXQoZXhwb3J0cy5OVU0pO1xuZXhwb3J0cy5NQVJLID0gWyctJywgJ18nLCAnLicsICchJywgJ34nLCAnKicsICdcXCcnLCAnKCcsICcpJ107XG5leHBvcnRzLlVTRVJJTkZPX0NIQVJTID0gZXhwb3J0cy5BTFBIQU5VTVxuICAgIC5jb25jYXQoZXhwb3J0cy5NQVJLKVxuICAgIC5jb25jYXQoWyclJywgJzsnLCAnOicsICcmJywgJz0nLCAnKycsICckJywgJywnXSk7XG4vLyBUT0RPKGluZHV0bnkpOiB1c2UgUkZDXG5leHBvcnRzLlNUUklDVF9VUkxfQ0hBUiA9IFtcbiAgICAnIScsICdcIicsICckJywgJyUnLCAnJicsICdcXCcnLFxuICAgICcoJywgJyknLCAnKicsICcrJywgJywnLCAnLScsICcuJywgJy8nLFxuICAgICc6JywgJzsnLCAnPCcsICc9JywgJz4nLFxuICAgICdAJywgJ1snLCAnXFxcXCcsICddJywgJ14nLCAnXycsXG4gICAgJ2AnLFxuICAgICd7JywgJ3wnLCAnfScsICd+Jyxcbl0uY29uY2F0KGV4cG9ydHMuQUxQSEFOVU0pO1xuZXhwb3J0cy5VUkxfQ0hBUiA9IGV4cG9ydHMuU1RSSUNUX1VSTF9DSEFSXG4gICAgLmNvbmNhdChbJ1xcdCcsICdcXGYnXSk7XG4vLyBBbGwgY2hhcmFjdGVycyB3aXRoIDB4ODAgYml0IHNldCB0byAxXG5mb3IgKGxldCBpID0gMHg4MDsgaSA8PSAweGZmOyBpKyspIHtcbiAgICBleHBvcnRzLlVSTF9DSEFSLnB1c2goaSk7XG59XG5leHBvcnRzLkhFWCA9IGV4cG9ydHMuTlVNLmNvbmNhdChbJ2EnLCAnYicsICdjJywgJ2QnLCAnZScsICdmJywgJ0EnLCAnQicsICdDJywgJ0QnLCAnRScsICdGJ10pO1xuLyogVG9rZW5zIGFzIGRlZmluZWQgYnkgcmZjIDI2MTYuIEFsc28gbG93ZXJjYXNlcyB0aGVtLlxuICogICAgICAgIHRva2VuICAgICAgID0gMSo8YW55IENIQVIgZXhjZXB0IENUTHMgb3Igc2VwYXJhdG9ycz5cbiAqICAgICBzZXBhcmF0b3JzICAgICA9IFwiKFwiIHwgXCIpXCIgfCBcIjxcIiB8IFwiPlwiIHwgXCJAXCJcbiAqICAgICAgICAgICAgICAgICAgICB8IFwiLFwiIHwgXCI7XCIgfCBcIjpcIiB8IFwiXFxcIiB8IDxcIj5cbiAqICAgICAgICAgICAgICAgICAgICB8IFwiL1wiIHwgXCJbXCIgfCBcIl1cIiB8IFwiP1wiIHwgXCI9XCJcbiAqICAgICAgICAgICAgICAgICAgICB8IFwie1wiIHwgXCJ9XCIgfCBTUCB8IEhUXG4gKi9cbmV4cG9ydHMuU1RSSUNUX1RPS0VOID0gW1xuICAgICchJywgJyMnLCAnJCcsICclJywgJyYnLCAnXFwnJyxcbiAgICAnKicsICcrJywgJy0nLCAnLicsXG4gICAgJ14nLCAnXycsICdgJyxcbiAgICAnfCcsICd+Jyxcbl0uY29uY2F0KGV4cG9ydHMuQUxQSEFOVU0pO1xuZXhwb3J0cy5UT0tFTiA9IGV4cG9ydHMuU1RSSUNUX1RPS0VOLmNvbmNhdChbJyAnXSk7XG4vKlxuICogVmVyaWZ5IHRoYXQgYSBjaGFyIGlzIGEgdmFsaWQgdmlzaWJsZSAocHJpbnRhYmxlKSBVUy1BU0NJSVxuICogY2hhcmFjdGVyIG9yICV4ODAtRkZcbiAqL1xuZXhwb3J0cy5IRUFERVJfQ0hBUlMgPSBbJ1xcdCddO1xuZm9yIChsZXQgaSA9IDMyOyBpIDw9IDI1NTsgaSsrKSB7XG4gICAgaWYgKGkgIT09IDEyNykge1xuICAgICAgICBleHBvcnRzLkhFQURFUl9DSEFSUy5wdXNoKGkpO1xuICAgIH1cbn1cbi8vICcsJyA9IFxceDQ0XG5leHBvcnRzLkNPTk5FQ1RJT05fVE9LRU5fQ0hBUlMgPSBleHBvcnRzLkhFQURFUl9DSEFSUy5maWx0ZXIoKGMpID0+IGMgIT09IDQ0KTtcbmV4cG9ydHMuTUFKT1IgPSBleHBvcnRzLk5VTV9NQVA7XG5leHBvcnRzLk1JTk9SID0gZXhwb3J0cy5NQUpPUjtcbnZhciBIRUFERVJfU1RBVEU7XG4oZnVuY3Rpb24gKEhFQURFUl9TVEFURSkge1xuICAgIEhFQURFUl9TVEFURVtIRUFERVJfU1RBVEVbXCJHRU5FUkFMXCJdID0gMF0gPSBcIkdFTkVSQUxcIjtcbiAgICBIRUFERVJfU1RBVEVbSEVBREVSX1NUQVRFW1wiQ09OTkVDVElPTlwiXSA9IDFdID0gXCJDT05ORUNUSU9OXCI7XG4gICAgSEVBREVSX1NUQVRFW0hFQURFUl9TVEFURVtcIkNPTlRFTlRfTEVOR1RIXCJdID0gMl0gPSBcIkNPTlRFTlRfTEVOR1RIXCI7XG4gICAgSEVBREVSX1NUQVRFW0hFQURFUl9TVEFURVtcIlRSQU5TRkVSX0VOQ09ESU5HXCJdID0gM10gPSBcIlRSQU5TRkVSX0VOQ09ESU5HXCI7XG4gICAgSEVBREVSX1NUQVRFW0hFQURFUl9TVEFURVtcIlVQR1JBREVcIl0gPSA0XSA9IFwiVVBHUkFERVwiO1xuICAgIEhFQURFUl9TVEFURVtIRUFERVJfU1RBVEVbXCJDT05ORUNUSU9OX0tFRVBfQUxJVkVcIl0gPSA1XSA9IFwiQ09OTkVDVElPTl9LRUVQX0FMSVZFXCI7XG4gICAgSEVBREVSX1NUQVRFW0hFQURFUl9TVEFURVtcIkNPTk5FQ1RJT05fQ0xPU0VcIl0gPSA2XSA9IFwiQ09OTkVDVElPTl9DTE9TRVwiO1xuICAgIEhFQURFUl9TVEFURVtIRUFERVJfU1RBVEVbXCJDT05ORUNUSU9OX1VQR1JBREVcIl0gPSA3XSA9IFwiQ09OTkVDVElPTl9VUEdSQURFXCI7XG4gICAgSEVBREVSX1NUQVRFW0hFQURFUl9TVEFURVtcIlRSQU5TRkVSX0VOQ09ESU5HX0NIVU5LRURcIl0gPSA4XSA9IFwiVFJBTlNGRVJfRU5DT0RJTkdfQ0hVTktFRFwiO1xufSkoSEVBREVSX1NUQVRFID0gZXhwb3J0cy5IRUFERVJfU1RBVEUgfHwgKGV4cG9ydHMuSEVBREVSX1NUQVRFID0ge30pKTtcbmV4cG9ydHMuU1BFQ0lBTF9IRUFERVJTID0ge1xuICAgICdjb25uZWN0aW9uJzogSEVBREVSX1NUQVRFLkNPTk5FQ1RJT04sXG4gICAgJ2NvbnRlbnQtbGVuZ3RoJzogSEVBREVSX1NUQVRFLkNPTlRFTlRfTEVOR1RILFxuICAgICdwcm94eS1jb25uZWN0aW9uJzogSEVBREVSX1NUQVRFLkNPTk5FQ1RJT04sXG4gICAgJ3RyYW5zZmVyLWVuY29kaW5nJzogSEVBREVSX1NUQVRFLlRSQU5TRkVSX0VOQ09ESU5HLFxuICAgICd1cGdyYWRlJzogSEVBREVSX1NUQVRFLlVQR1JBREUsXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uc3RhbnRzLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIlNQRUNJQUxfSEVBREVSUyIsIkhFQURFUl9TVEFURSIsIk1JTk9SIiwiTUFKT1IiLCJDT05ORUNUSU9OX1RPS0VOX0NIQVJTIiwiSEVBREVSX0NIQVJTIiwiVE9LRU4iLCJTVFJJQ1RfVE9LRU4iLCJIRVgiLCJVUkxfQ0hBUiIsIlNUUklDVF9VUkxfQ0hBUiIsIlVTRVJJTkZPX0NIQVJTIiwiTUFSSyIsIkFMUEhBTlVNIiwiTlVNIiwiSEVYX01BUCIsIk5VTV9NQVAiLCJBTFBIQSIsIkZJTklTSCIsIkhfTUVUSE9EX01BUCIsIk1FVEhPRF9NQVAiLCJNRVRIT0RTX1JUU1AiLCJNRVRIT0RTX0lDRSIsIk1FVEhPRFNfSFRUUCIsIk1FVEhPRFMiLCJMRU5JRU5UX0ZMQUdTIiwiRkxBR1MiLCJUWVBFIiwiRVJST1IiLCJ1dGlsc18xIiwicmVxdWlyZSIsIkRFTEVURSIsIkdFVCIsIkhFQUQiLCJQT1NUIiwiUFVUIiwiQ09OTkVDVCIsIk9QVElPTlMiLCJUUkFDRSIsIkNPUFkiLCJMT0NLIiwiTUtDT0wiLCJNT1ZFIiwiUFJPUEZJTkQiLCJQUk9QUEFUQ0giLCJTRUFSQ0giLCJVTkxPQ0siLCJCSU5EIiwiUkVCSU5EIiwiVU5CSU5EIiwiQUNMIiwiUkVQT1JUIiwiTUtBQ1RJVklUWSIsIkNIRUNLT1VUIiwiTUVSR0UiLCJOT1RJRlkiLCJTVUJTQ1JJQkUiLCJVTlNVQlNDUklCRSIsIlBBVENIIiwiUFVSR0UiLCJNS0NBTEVOREFSIiwiTElOSyIsIlVOTElOSyIsIlBSSSIsIlNPVVJDRSIsIkRFU0NSSUJFIiwiQU5OT1VOQ0UiLCJTRVRVUCIsIlBMQVkiLCJQQVVTRSIsIlRFQVJET1dOIiwiR0VUX1BBUkFNRVRFUiIsIlNFVF9QQVJBTUVURVIiLCJSRURJUkVDVCIsIlJFQ09SRCIsIkZMVVNIIiwiZW51bVRvTWFwIiwia2V5cyIsImZvckVhY2giLCJrZXkiLCJ0ZXN0IiwiaSIsImNoYXJDb2RlQXQiLCJwdXNoIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwiQSIsIkIiLCJDIiwiRCIsIkUiLCJGIiwiYSIsImIiLCJjIiwiZCIsImUiLCJmIiwiY29uY2F0IiwiZmlsdGVyIiwiQ09OTkVDVElPTiIsIkNPTlRFTlRfTEVOR1RIIiwiVFJBTlNGRVJfRU5DT0RJTkciLCJVUEdSQURFIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/llhttp/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/llhttp/llhttp-wasm.js":
/*!*******************************************************!*\
  !*** ./node_modules/undici/lib/llhttp/llhttp-wasm.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { Buffer } = __webpack_require__(/*! node:buffer */ \"node:buffer\");\nmodule.exports = Buffer.from(\"AGFzbQEAAAABJwdgAX8Bf2ADf39/AX9gAX8AYAJ/fwBgBH9/f38Bf2AAAGADf39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQAEA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAAy0sBQYAAAIAAAAAAAACAQIAAgICAAADAAAAAAMDAwMBAQEBAQEBAQEAAAIAAAAEBQFwARISBQMBAAIGCAF/AUGA1AQLB9EFIgZtZW1vcnkCAAtfaW5pdGlhbGl6ZQAIGV9faW5kaXJlY3RfZnVuY3Rpb25fdGFibGUBAAtsbGh0dHBfaW5pdAAJGGxsaHR0cF9zaG91bGRfa2VlcF9hbGl2ZQAvDGxsaHR0cF9hbGxvYwALBm1hbGxvYwAxC2xsaHR0cF9mcmVlAAwEZnJlZQAMD2xsaHR0cF9nZXRfdHlwZQANFWxsaHR0cF9nZXRfaHR0cF9tYWpvcgAOFWxsaHR0cF9nZXRfaHR0cF9taW5vcgAPEWxsaHR0cF9nZXRfbWV0aG9kABAWbGxodHRwX2dldF9zdGF0dXNfY29kZQAREmxsaHR0cF9nZXRfdXBncmFkZQASDGxsaHR0cF9yZXNldAATDmxsaHR0cF9leGVjdXRlABQUbGxodHRwX3NldHRpbmdzX2luaXQAFQ1sbGh0dHBfZmluaXNoABYMbGxodHRwX3BhdXNlABcNbGxodHRwX3Jlc3VtZQAYG2xsaHR0cF9yZXN1bWVfYWZ0ZXJfdXBncmFkZQAZEGxsaHR0cF9nZXRfZXJybm8AGhdsbGh0dHBfZ2V0X2Vycm9yX3JlYXNvbgAbF2xsaHR0cF9zZXRfZXJyb3JfcmVhc29uABwUbGxodHRwX2dldF9lcnJvcl9wb3MAHRFsbGh0dHBfZXJybm9fbmFtZQAeEmxsaHR0cF9tZXRob2RfbmFtZQAfEmxsaHR0cF9zdGF0dXNfbmFtZQAgGmxsaHR0cF9zZXRfbGVu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PgtBhwEMPQtBiAEMPAtBiQEMOwtBigEMOgtBiwEMOQtBjAEMOAtBjQEMNwtBjgEMNgtBjwEMNQtBkAEMNAtBkQEMMwtBkgEMMgtBkwEMMQtBlAEMMAtBlQEMLwtBlgEMLgtBlwEMLQtBmAEMLAtBmQEMKwtBmgEMKgtBmwEMKQtBnAEMKAtBnQEMJwtBngEMJgtBnwEMJQtBoAEMJAtBoQEMIwtBogEMIgtBowEMIQtBpAEMIAtBpQEMHwtBpgEMHgtBpwEMHQtBqAEMHAtBqQEMGwtBqgEMGgtBqwEMGQtBrAEMGAtBrQEMFwtBrgEMFgtBAQwVC0GvAQwUC0GwAQwTC0GxAQwSC0GzAQwRC0GyAQwQC0G0AQwPC0G1AQwOC0G2AQwNC0G3AQwMC0G4AQwLC0G5AQwKC0G6AQwJC0G7AQwIC0HGAQwHC0G8AQwGC0G9AQwFC0G+AQwEC0G/AQwDC0HAAQwCC0HCAQwBC0HBAQshAwNAAkACQAJAAkACQAJAAkACQAJAIAICfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJ/AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAgJ/AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACfwJAAkACfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAC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iQEhAwykAgtBASABLQAAQd8ARw1nGiABQQFqIQEMXgtBigEhAyABIARGDaICIAIoAgAiACAEIAFraiEFIAEgAGtBAWohBgNAIAEtAAAgAEGMzwBqLQAARw1kIABBAUYN+gEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMogILQYsBIQMgASAERg2hAiACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEGOzwBqLQAARw1kIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyiAgsgAkEANgIAIAZBAWohAUECDGULQYwBIQMgASAERg2gAiACKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEHwzwBqLQAARw1jIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyhAgsgAkEANgIAIAZBAWohAUEfDGQLQY0BIQMgASAERg2fAiACKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEHyzwBqLQAARw1iIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAygAgsgAkEANgIAIAZBAWohAUEJDGMLIAEgBEYEQEGOASEDDJ8CCwJAAkAgAS0AAEHJAGsOBwBiYmJiYgFiCyABQQFqIQFB+AAhAwyGAgsgAUEBaiEBQfkAIQMMhQILQY8BIQMgASAERg2dAiACKAIAIgAgBCABa2ohBSABIABrQQVqIQYCQANAIAEtAAAgAEGRzwBqLQAARw1gIABBBUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyeAgsgAkEANgIAIAZBAWohAUEYDGELQZABIQMgASAERg2cAiACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEGXzwBqLQAARw1fIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAydAgsgAkEANgIAIAZBAWohAUEXDGALQZEBIQMgASAERg2bAiACKAIAIgAgBCABa2ohBSABIABrQQZqIQYCQANAIAEtAAAgAEGazwBqLQAARw1eIABBBkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAycAgsgAkEANgIAIAZBAWohAUEV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JSIARQ0RIAJB5QA2AhwgAiABNgIUIAIgADYCDEEAIQMMtAELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0gIAJB0wA2AhwgAiABNgIUIAIgADYCDEEAIQMMswELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0iIAJB0gA2AhwgAiABNgIUIAIgADYCDEEAIQMMsgELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0OIAJB5QA2AhwgAiABNgIUIAIgADYCDEEAIQMMsQELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0dIAJB0wA2AhwgAiABNgIUIAIgADYCDEEAIQMMsAELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0fIAJB0gA2AhwgAiABNgIUIAIgADYCDEEAIQMMrwELIABBP0cNASABQQFqCyEBQQUhAwyUAQtBACEDIAJBADYCHCACIAE2AhQgAkH9EjYCECACQQc2AgwMrAELIAJBADYCHCACIAE2AhQgAkHcCDYCECACQQc2AgxBACEDDKsBCyACKAIEIQAgAkEANgIEIAIgACABECUiAEUNByACQeUANgIcIAIgATYCFCACIAA2AgxBACEDDKoBCyACKAIEIQAgAkEANgIEIAIgACABECUiAEUNFiACQdMANgIcIAIgATYCFCACIAA2AgxBACEDDKkBCyACKAIEIQAgAkEANgIEIAIgACABECUiAEUNGCACQdIANgIcIAIgATYCFCACIAA2AgxBACEDDKgBCyACQQA2AhwgAiABNgIUIAJBxgo2AhAgAkEHNgIMQQAhAwynAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDQMgAkHlADYCHCACIAE2AhQgAiAANgIMQQAhAwymAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDRIgAkHTADYCHCACIAE2AhQgAiAANgIMQQAhAwylAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDRQgAkHSADYCHCACIAE2AhQgAiAANgIMQQAhAwykAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDQAgAkHlADYCHCACIAE2AhQgAiAANgIMQQAhAwyjAQtB1QAhAwyJAQsgAEEVRwRAIAJBADYCHCACIAE2AhQgAkG5DTYCECACQRo2AgxB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AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIABB5ABrDvQDY2IAAWFhYWFhYQIDBAVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhBgcICQoLDA0OD2FhYWFhEGFhYWFhYWFhYWFhEWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYRITFBUWFxgZGhthYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhHB0eHyAhIiMkJSYnKCkqKywtLi8wMTIzNDU2YTc4OTphYWFhYWFhYTthYWE8YWFhYT0+P2FhYWFhYWFhQGFhQWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYUJDREVGR0hJSktMTU5PUFFSU2FhYWFhYWFhVFVWV1hZWlthXF1hYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFeYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhX2BhC0HhJw8LQaQhDwtByywPC0H+MQ8LQcAkDwtBqyQPC0GNKA8LQeImDwtBgDAPC0G5Lw8LQdckDwtB7x8PC0HhHw8LQfofDwtB8iAPC0GoLw8LQa4yDwtBiDAPC0HsJw8LQYIiDwtBjh0PC0HQLg8LQcojDwtBxTIPC0HfHA8LQdIcDwtBxCAPC0HXIA8LQaIfDwtB7S4PC0GrMA8LQdQlDwtBzC4PC0H6Lg8LQfwrDwtB0jAPC0HxHQ8LQbsgDwtB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CABB3AgLii1JbnZhbGlkIGNoYXIgaW4gdXJsIHF1ZXJ5AFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fYm9keQBDb250ZW50LUxlbmd0aCBvdmVyZmxvdwBDaHVuayBzaXplIG92ZXJmbG93AFJlc3BvbnNlIG92ZXJmbG93AEludmFsaWQgbWV0aG9kIGZvciBIVFRQL3gueCByZXF1ZXN0AEludmFsaWQgbWV0aG9kIGZvciBSVFNQL3gueCByZXF1ZXN0AEV4cGVjdGVkIFNPVVJDRSBtZXRob2QgZm9yIElDRS94LnggcmVxdWVzdABJbnZhbGlkIGNoYXIgaW4gdXJsIGZyYWdtZW50IHN0YXJ0AEV4cGVjdGVkIGRvdABTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3N0YXR1cwBJbnZhbGlkIHJlc3BvbnNlIHN0YXR1cwBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zAFVzZXIgY2FsbGJhY2sgZXJyb3IAYG9uX3Jlc2V0YCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfaGVhZGVyYCBjYWxsYmFjayBlcnJvcgBgb25fbWVzc2FnZV9iZWdpbmAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2V4dGVuc2lvbl92YWx1ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX3N0YXR1c19jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX3ZlcnNpb25fY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl91cmxfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9jaHVua19jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2hlYWRlcl92YWx1ZV9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX21lc3NhZ2VfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXRob2RfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9oZWFkZXJfZmllbGRfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9jaHVua19leHRlbnNpb25fbmFtZWAgY2FsbGJhY2sgZXJyb3IAVW5leHBlY3RlZCBjaGFyIGluIHVybCBzZXJ2ZXIASW52YWxpZCBoZWFkZXIgdmFsdWUgY2hhcgBJbnZhbGlkIGhlYWRlciBmaWVsZCBjaGFyAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fdmVyc2lvbgBJbnZhbGlkIG1pbm9yIHZlcnNpb24ASW52YWxpZCBtYWpvciB2ZXJzaW9uAEV4cGVjdGVkIHNwYWNlIGFmdGVyIHZlcnNpb24ARXhwZWN0ZWQgQ1JMRiBhZnRlciB2ZXJzaW9uAEludmFsaWQgSFRUUCB2ZXJzaW9uAEludmFsaWQgaGVhZGVyIHRva2VuAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fdXJsAEludmFsaWQgY2hhcmFjdGVycyBpbiB1cmwAVW5leHBlY3RlZCBzdGFydCBjaGFyIGluIHVybABEb3VibGUgQCBpbiB1cmwARW1wdHkgQ29udGVudC1MZW5ndGgASW52YWxpZCBjaGFyYWN0ZXIgaW4gQ29udGVudC1MZW5ndGgARHVwbGljYXRlIENvbnRlbnQtTGVuZ3RoAEludmFsaWQgY2hhciBpbiB1cmwgcGF0aABDb250ZW50LUxlbmd0aCBjYW4ndCBiZSBwcmVzZW50IHdpdGggVHJhbnNmZXItRW5jb2RpbmcASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgc2l6ZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2hlYWRlcl92YWx1ZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2NodW5rX2V4dGVuc2lvbl92YWx1ZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIHZhbHVlAE1pc3NpbmcgZXhwZWN0ZWQgTEYgYWZ0ZXIgaGVhZGVyIHZhbHVlAEludmFsaWQgYFRyYW5zZmVyLUVuY29kaW5nYCBoZWFkZXIgdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBxdW90ZSB2YWx1ZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIHF1b3RlZCB2YWx1ZQBQYXVzZWQgYnkgb25faGVhZGVyc19jb21wbGV0ZQBJbnZhbGlkIEVPRiBzdGF0ZQBvbl9yZXNldCBwYXVzZQBvbl9jaHVua19oZWFkZXIgcGF1c2UAb25fbWVzc2FnZV9iZWdpbiBwYXVzZQBvbl9jaHVua19leHRlbnNpb25fdmFsdWUgcGF1c2UAb25fc3RhdHVzX2NvbXBsZXRlIHBhdXNlAG9uX3ZlcnNpb25fY29tcGxldGUgcGF1c2UAb25fdXJsX2NvbXBsZXRlIHBhdXNlAG9uX2NodW5rX2NvbXBsZXRlIHBhdXNlAG9uX2hlYWRlcl92YWx1ZV9jb21wbGV0ZSBwYXVzZQBvbl9tZXNzYWdlX2NvbXBsZXRlIHBhdXNlAG9uX21ldGhvZF9jb21wbGV0ZSBwYXVzZQBvbl9oZWFkZXJfZmllbGRfY29tcGxldGUgcGF1c2UAb25fY2h1bmtfZXh0ZW5zaW9uX25hbWUgcGF1c2UAVW5leHBlY3RlZCBzcGFjZSBhZnRlciBzdGFydCBsaW5lAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fY2h1bmtfZXh0ZW5zaW9uX25hbWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBuYW1lAFBhdXNlIG9uIENPTk5FQ1QvVXBncmFkZQBQYXVzZSBvbiBQUkkvVXBncmFkZQBFeHBlY3RlZCBIVFRQLzIgQ29ubmVjdGlvbiBQcmVmYWNlAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fbWV0aG9kAEV4cGVjdGVkIHNwYWNlIGFmdGVyIG1ldGhvZABTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2hlYWRlcl9maWVsZABQYXVzZWQASW52YWxpZCB3b3JkIGVuY291bnRlcmVkAEludmFsaWQgbWV0aG9kIGVuY291bnRlcmVkAFVuZXhwZWN0ZWQgY2hhciBpbiB1cmwgc2NoZW1hAFJlcXVlc3QgaGFzIGludmFsaWQgYFRyYW5zZmVyLUVuY29kaW5nYABTV0lUQ0hfUFJPWFkAVVNFX1BST1hZAE1LQUNUSVZJVFkAVU5QUk9DRVNTQUJMRV9FTlRJVFkAQ09QWQBNT1ZFRF9QRVJNQU5FTlRMWQBUT09fRUFSTFkATk9USUZZAEZBSUxFRF9ERVBFTkRFTkNZAEJBRF9HQVRFV0FZAFBMQVkAUFVUAENIRUNLT1VUAEdBVEVXQVlfVElNRU9VVABSRVFVRVNUX1RJTUVPVVQATkVUV09SS19DT05ORUNUX1RJTUVPVVQAQ09OTkVDVElPTl9USU1FT1VUAExPR0lOX1RJTUVPVVQATkVUV09SS19SRUFEX1RJTUVPVVQAUE9TVABNSVNESVJFQ1RFRF9SRVFVRVNUAENMSUVOVF9DTE9TRURfUkVRVUVTVABDTElFTlRfQ0xPU0VEX0xPQURfQkFMQU5DRURfUkVRVUVTVABCQURfUkVRVUVTVABIVFRQX1JFUVVFU1RfU0VOVF9UT19IVFRQU19QT1JUAFJFUE9SVABJTV9BX1RFQVBPVABSRVNFVF9DT05URU5UAE5PX0NPTlRFTlQAUEFSVElBTF9DT05URU5UAEhQRV9JTlZBTElEX0NPTlNUQU5UAEhQRV9DQl9SRVNFVABHRVQASFBFX1NUUklDVABDT05GTElDVABURU1QT1JBUllfUkVESVJFQ1QAUEVSTUFORU5UX1JFRElSRUNUAENPTk5FQ1QATVVMVElfU1RBVFVTAEhQRV9JTlZBTElEX1NUQVRVUwBUT09fTUFOWV9SRVFVRVNUUwBFQVJMWV9ISU5UUwBVTkFWQUlMQUJMRV9GT1JfTEVHQUxfUkVBU09OUwBPUFRJT05TAFNXSVRDSElOR19QUk9UT0NPTFMAVkFSSUFOVF9BTFNPX05FR09USUFURVMATVVMVElQTEVfQ0hPSUNFUwBJTlRFUk5BTF9TRVJWRVJfRVJST1IAV0VCX1NFUlZFUl9VTktOT1dOX0VSUk9SAFJBSUxHVU5fRVJST1IASURFTlRJVFlfUFJPVklERVJfQVVUSEVOVElDQVRJT05fRVJST1IAU1NMX0NFUlRJRklDQVRFX0VSUk9SAElOVkFMSURfWF9GT1JXQVJERURfRk9SAFNFVF9QQVJBTUVURVIAR0VUX1BBUkFNRVRFUgBIUEVfVVNFUgBTRUVfT1RIRVIASFBFX0NCX0NIVU5LX0hFQURFUgBNS0NBTEVOREFSAFNFVFVQAFdFQl9TRVJWRVJfSVNfRE9XTgBURUFSRE9XTgBIUEVfQ0xPU0VEX0NPTk5FQ1RJT04ASEVVUklTVElDX0VYUElSQVRJT04ARElTQ09OTkVDVEVEX09QRVJBVElPTgBOT05fQVVUSE9SSVRBVElWRV9JTkZPUk1BVElPTgBIUEVfSU5WQUxJRF9WRVJTSU9OAEhQRV9DQl9NRVNTQUdFX0JFR0lOAFNJVEVfSVNfRlJPWkVOAEhQRV9JTlZBTElEX0hFQURFUl9UT0tFTgBJTlZBTElEX1RPS0VOAEZPUkJJRERFTgBFTkhBTkNFX1lPVVJfQ0FMTQBIUEVfSU5WQUxJRF9VUkwAQkxPQ0tFRF9CWV9QQVJFTlRBTF9DT05UUk9MAE1LQ09MAEFDTABIUEVfSU5URVJOQUwAUkVRVUVTVF9IRUFERVJfRklFTERTX1RPT19MQVJHRV9VTk9GRklDSUFMAEhQRV9PSwBVTkxJTksAVU5MT0NLAFBSSQBSRVRSWV9XSVRIAEhQRV9JTlZBTElEX0NPTlRFTlRfTEVOR1RIAEhQRV9VTkVYUEVDVEVEX0NPTlRFTlRfTEVOR1RIAEZMVVNIAFBST1BQQVRDSABNLVNFQVJDSABVUklfVE9PX0xPTkcAUFJPQ0VTU0lORwBNSVNDRUxMQU5FT1VTX1BFUlNJU1RFTlRfV0FSTklORwBNSVNDRUxMQU5FT1VTX1dBUk5JTkcASFBFX0lOVkFMSURfVFJBTlNGRVJfRU5DT0RJTkcARXhwZWN0ZWQgQ1JMRgBIUEVfSU5WQUxJRF9DSFVOS19TSVpFAE1PVkUAQ09OVElOVUUASFBFX0NCX1NUQVRVU19DT01QTEVURQBIUEVfQ0JfSEVBREVSU19DT01QTEVURQBIUEVfQ0JfVkVSU0lPTl9DT01QTEVURQBIUEVfQ0JfVVJMX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19DT01QTEVURQBIUEVfQ0JfSEVBREVSX1ZBTFVFX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19FWFRFTlNJT05fVkFMVUVfQ09NUExFVEUASFBFX0NCX0NIVU5LX0VYVEVOU0lPTl9OQU1FX0NPTVBMRVRFAEhQRV9DQl9NRVNTQUdFX0NPTVBMRVRFAEhQRV9DQl9NRVRIT0RfQ09NUExFVEUASFBFX0NCX0hFQURFUl9GSUVMRF9DT01QTEVURQBERUxFVEUASFBFX0lOVkFMSURfRU9GX1NUQVRFAElOVkFMSURfU1NMX0NFUlRJRklDQVRFAFBBVVNFAE5PX1JFU1BPTlNFAFVOU1VQUE9SVEVEX01FRElBX1RZUEUAR09ORQBOT1RfQUNDRVBUQUJMRQBTRVJWSUNFX1VOQVZBSUxBQkxFAFJBTkdFX05PVF9TQVRJU0ZJQUJMRQBPUklHSU5fSVNfVU5SRUFDSEFCTEUAUkVTUE9OU0VfSVNfU1RBTEUAUFVSR0UATUVSR0UAUkVRVUVTVF9IRUFERVJfRklFTERTX1RPT19MQVJHRQBSRVFVRVNUX0hFQURFUl9UT09fTEFSR0UAUEFZTE9BRF9UT09fTEFSR0UASU5TVUZGSUNJRU5UX1NUT1JBR0UASFBFX1BBVVNFRF9VUEdSQURFAEhQRV9QQVVTRURfSDJfVVBHUkFERQBTT1VSQ0UAQU5OT1VOQ0UAVFJBQ0UASFBFX1VORVhQRUNURURfU1BBQ0UAREVTQ1JJQkUAVU5TVUJTQ1JJQkUAUkVDT1JEAEhQRV9JTlZBTElEX01FVEhPRABOT1RfRk9VTkQAUFJPUEZJTkQAVU5CSU5EAFJFQklORABVTkFVVEhPUklaRUQATUVUSE9EX05PVF9BTExPV0VEAEhUVFBfVkVSU0lPTl9OT1RfU1VQUE9SVEVEAEFMUkVBRFlfUkVQT1JURUQAQUNDRVBURUQATk9UX0lNUExFTUVOVEVEAExPT1BfREVURUNURUQASFBFX0NSX0VYUEVDVEVEAEhQRV9MRl9FWFBFQ1RFRABDUkVBVEVEAElNX1VTRUQASFBFX1BBVVNFRABUSU1FT1VUX09DQ1VSRUQAUEFZTUVOVF9SRVFVSVJFRABQUkVDT05ESVRJT05fUkVRVUlSRUQAUFJPWFlfQVVUSEVOVElDQVRJT05fUkVRVUlSRUQATkVUV09SS19BVVRIRU5USUNBVElPTl9SRVFVSVJFRABMRU5HVEhfUkVRVUlSRUQAU1NMX0NFUlRJRklDQVRFX1JFUVVJUkVEAFVQR1JBREVfUkVRVUlSRUQAUEFHRV9FWFBJUkVEAFBSRUNPTkRJVElPTl9GQUlMRUQARVhQRUNUQVRJT05fRkFJTEVEAFJFVkFMSURBVElPTl9GQUlMRUQAU1NMX0hBTkRTSEFLRV9GQUlMRUQATE9DS0VEAFRSQU5TRk9STUFUSU9OX0FQUExJRUQATk9UX01PRElGSUVEAE5PVF9FWFRFTkRFRABCQU5EV0lEVEhfTElNSVRfRVhDRUVERUQAU0lURV9JU19PVkVSTE9BREVEAEhFQUQARXhwZWN0ZWQgSFRUUC8AAF4TAAAmEwAAMBAAAPAXAACdEwAAFRIAADkXAADwEgAAChAAAHUSAACtEgAAghMAAE8UAAB/EAAAoBUAACMUAACJEgAAixQAAE0VAADUEQAAzxQAABAYAADJFgAA3BYAAMERAADgFwAAuxQAAHQUAAB8FQAA5RQAAAgXAAAfEAAAZRUAAKMUAAAoFQAAAhUAAJkVAAAsEAAAixkAAE8PAADUDgAAahAAAM4QAAACFwAAiQ4AAG4TAAAcEwAAZhQAAFYXAADBEwAAzRMAAGwTAABoFwAAZhcAAF8XAAAiEwAAzg8AAGkOAADYDgAAYxYAAMsTAACqDgAAKBcAACYXAADFEwAAXRYAAOgRAABnEwAAZRMAAPIWAABzEwAAHRcAAPkWAADzEQAAzw4AAM4VAAAMEgAAsxEAAKURAABhEAAAMhcAALsTAEH5NQsBAQBBkDYL4AEBAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQBB/TcLAQEAQZE4C14CAwICAgICAAACAgACAgACAgICAgICAgICAAQAAAAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAAgACAEH9OQsBAQBBkToLXgIAAgICAgIAAAICAAICAAICAgICAgICAgIAAwAEAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgIAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgACAAIAQfA7Cw1sb3NlZWVwLWFsaXZlAEGJPAsBAQBBoDwL4AEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQBBiT4LAQEAQaA+C+cBAQEBAQEBAQEBAQEBAgEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQFjaHVua2VkAEGwwAALXwEBAAEBAQEBAAABAQABAQABAQEBAQEBAQEBAAAAAAAAAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQABAEGQwgALIWVjdGlvbmVudC1sZW5ndGhvbnJveHktY29ubmVjdGlvbgBBwMIACy1yYW5zZmVyLWVuY29kaW5ncGdyYWRlDQoNCg0KU00NCg0KVFRQL0NFL1RTUC8AQfnCAAsFAQIAAQMAQZDDAAvgAQQBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAEH5xAALBQECAAEDAEGQxQAL4AEEAQEFAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQBB+cYACwQBAAABAEGRxwAL3wEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAEH6yAALBAEAAAIAQZDJAAtfAwQAAAQEBAQEBAQEBAQEBQQEBAQEBAQEBAQEBAAEAAYHBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQABAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAQAQfrKAAsEAQAAAQBBkMsACwEBAEGqywALQQIAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAEH6zAALBAEAAAEAQZDNAAsBAQBBms0ACwYCAAAAAAIAQbHNAAs6AwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwBB8M4AC5YBTk9VTkNFRUNLT1VUTkVDVEVURUNSSUJFTFVTSEVURUFEU0VBUkNIUkdFQ1RJVklUWUxFTkRBUlZFT1RJRllQVElPTlNDSFNFQVlTVEFUQ0hHRU9SRElSRUNUT1JUUkNIUEFSQU1FVEVSVVJDRUJTQ1JJQkVBUkRPV05BQ0VJTkROS0NLVUJTQ1JJQkVIVFRQL0FEVFAv\", \"base64\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9sbGh0dHAvbGxodHRwLXdhc20uanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNLEVBQUVBLE1BQUFBLEVBQVEsR0FBR0MsbUJBQU9BLENBQUM7QUFFM0JDLE9BQU9DLE9BQU8sR0FBR0gsT0FBT0ksSUFBSSxDQUFDLHd6K0RBQXd6K0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tb2NrdXBmbG93Ly4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvbGxodHRwL2xsaHR0cC13YXNtLmpzPzkxOGMiLCJ3ZWJwYWNrOi8vbW9ja3VwZmxvdy8uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2xsaHR0cC9sbGh0dHAtd2FzbS5qcz85MThjKiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyBCdWZmZXIgfSA9IHJlcXVpcmUoJ25vZGU6YnVmZmVyJylcblxubW9kdWxlLmV4cG9ydHMgPSBCdWZmZXIuZnJvbSgnQUdGemJRRUFBQUFCSndkZ0FYOEJmMkFEZjM5L0FYOWdBWDhBWUFKL2Z3QmdCSDkvZjM4QmYyQUFBR0FEZjM5L0FBTExBUWdEWlc1MkdIZGhjMjFmYjI1ZmFHVmhaR1Z5YzE5amIyMXdiR1YwWlFBRUEyVnVkaFYzWVhOdFgyOXVYMjFsYzNOaFoyVmZZbVZuYVc0QUFBTmxibllMZDJGemJWOXZibDkxY213QUFRTmxibllPZDJGemJWOXZibDl6ZEdGMGRYTUFBUU5sYm5ZVWQyRnpiVjl2Ymw5b1pXRmtaWEpmWm1sbGJHUUFBUU5sYm5ZVWQyRnpiVjl2Ymw5b1pXRmtaWEpmZG1Gc2RXVUFBUU5sYm5ZTWQyRnpiVjl2Ymw5aWIyUjVBQUVEWlc1MkdIZGhjMjFmYjI1ZmJXVnpjMkZuWlY5amIyMXdiR1YwWlFBQUF5MHNCUVlBQUFJQUFBQUFBQUFDQVFJQUFnSUNBQUFEQUFBQUFBTURBd01CQVFFQkFRRUJBUUVBQUFJQUFBQUVCUUZ3QVJJU0JRTUJBQUlHQ0FGL0FVR0ExQVFMQjlFRklnWnRaVzF2Y25rQ0FBdGZhVzVwZEdsaGJHbDZaUUFJR1Y5ZmFXNWthWEpsWTNSZlpuVnVZM1JwYjI1ZmRHRmliR1VCQUF0c2JHaDBkSEJmYVc1cGRBQUpHR3hzYUhSMGNGOXphRzkxYkdSZmEyVmxjRjloYkdsMlpRQXZER3hzYUhSMGNGOWhiR3h2WXdBTEJtMWhiR3h2WXdBeEMyeHNhSFIwY0Y5bWNtVmxBQXdFWm5KbFpRQU1EMnhzYUhSMGNGOW5aWFJmZEhsd1pRQU5GV3hzYUhSMGNGOW5aWFJmYUhSMGNGOXRZV3B2Y2dBT0ZXeHNhSFIwY0Y5blpYUmZhSFIwY0Y5dGFXNXZjZ0FQRVd4c2FIUjBjRjluWlhSZmJXVjBhRzlrQUJBV2JHeG9kSFJ3WDJkbGRGOXpkR0YwZFhOZlkyOWtaUUFSRW14c2FIUjBjRjluWlhSZmRYQm5jbUZrWlFBU0RHeHNhSFIwY0Y5eVpYTmxkQUFURG14c2FIUjBjRjlsZUdWamRYUmxBQlFVYkd4b2RIUndYM05sZEhScGJtZHpYMmx1YVhRQUZRMXNiR2gwZEhCZlptbHVhWE5vQUJZTWJHeG9kSFJ3WDNCaGRYTmxBQmNOYkd4b2RIUndYM0psYzNWdFpRQVlHMnhzYUhSMGNGOXlaWE4xYldWZllXWjBaWEpmZFhCbmNtRmtaUUFaRUd4c2FIUjBjRjluWlhSZlpYSnlibThBR2hkc2JHaDBkSEJmWjJWMFgyVnljbTl5WDNKbFlYTnZiZ0FiRjJ4c2FIUjBjRjl6WlhSZlpYSnliM0pmY21WaGMyOXVBQndVYkd4b2RIUndYMmRsZEY5bGNuSnZjbDl3YjNNQUhSRnNiR2gwZEhCZlpYSnlibTlmYm1GdFpRQWVFbXhzYUhSMGNGOXRaWFJvYjJSZmJtRnRaUUFmRW14c2FIUjBjRjl6ZEdGMGRYTmZibUZ0WlFBZ0dteHNhSFIwY0Y5elpYUmZiR1Z1YVdWdWRGOW9aV0ZrWlhKekFDRWhiR3hvZEhSd1gzTmxkRjlzWlc1cFpXNTBYMk5vZFc1clpXUmZiR1Z1WjNSb0FDSWRiR3hvZEhSd1gzTmxkRjlzWlc1cFpXNTBYMnRsWlhCZllXeHBkbVVBSXlSc2JHaDBkSEJmYzJWMFgyeGxibWxsYm5SZmRISmhibk5tWlhKZlpXNWpiMlJwYm1jQUpCaHNiR2gwZEhCZmJXVnpjMkZuWlY5dVpXVmtjMTlsYjJZQUxna1hBUUJCQVFzUkFRSURCQVVLQmdjckxTd3FLU2dsSnlZSzA3TUNMQllBUVlqUUFDZ0NBQVJBQUF0QmlOQUFRUUUyQWdBTEZBQWdBQkF3SUFBZ0FqWUNPQ0FBSUFFNkFDZ0xGQUFnQUNBQUx3RXlJQUF0QUM0Z0FCQXZFQUFMSGdFQmYwSEFBQkF5SWdFUU1DQUJRWUFJTmdJNElBRWdBRG9BS0NBQkM0OE1BUWQvQWtBZ0FFVU5BQ0FBUVFocklnRWdBRUVFYXlnQ0FDSUFRWGh4SWdScUlRVUNRQ0FBUVFGeERRQWdBRUVEY1VVTkFTQUJJQUVvQWdBaUFHc2lBVUdjMEFBb0FnQkpEUUVnQUNBRWFpRUVBa0FDUUVHZzBBQW9BZ0FnQVVjRVFDQUFRZjhCVFFSQUlBQkJBM1loQXlBQktBSUlJZ0FnQVNnQ0RDSUNSZ1JBUVl6UUFFR00wQUFvQWdCQmZpQURkM0UyQWdBTUJRc2dBaUFBTmdJSUlBQWdBallDREF3RUN5QUJLQUlZSVFZZ0FTQUJLQUlNSWdCSEJFQWdBQ0FCS0FJSUlnSTJBZ2dnQWlBQU5nSU1EQU1MSUFGQkZHb2lBeWdDQUNJQ1JRUkFJQUVvQWhBaUFrVU5BaUFCUVJCcUlRTUxBMEFnQXlFSElBSWlBRUVVYWlJREtBSUFJZ0lOQUNBQVFSQnFJUU1nQUNnQ0VDSUNEUUFMSUFkQkFEWUNBQXdDQ3lBRktBSUVJZ0JCQTNGQkEwY05BaUFGSUFCQmZuRTJBZ1JCbE5BQUlBUTJBZ0FnQlNBRU5nSUFJQUVnQkVFQmNqWUNCQXdEQzBFQUlRQUxJQVpGRFFBQ1FDQUJLQUljSWdKQkFuUkJ2TklBYWlJREtBSUFJQUZHQkVBZ0F5QUFOZ0lBSUFBTkFVR1EwQUJCa05BQUtBSUFRWDRnQW5keE5nSUFEQUlMSUFaQkVFRVVJQVlvQWhBZ0FVWWJhaUFBTmdJQUlBQkZEUUVMSUFBZ0JqWUNHQ0FCS0FJUUlnSUVRQ0FBSUFJMkFoQWdBaUFBTmdJWUN5QUJRUlJxS0FJQUlnSkZEUUFnQUVFVWFpQUNOZ0lBSUFJZ0FEWUNHQXNnQVNBRlR3MEFJQVVvQWdRaUFFRUJjVVVOQUFKQUFrQUNRQUpBSUFCQkFuRkZCRUJCcE5BQUtBSUFJQVZHQkVCQnBOQUFJQUUyQWdCQm1OQUFRWmpRQUNnQ0FDQUVhaUlBTmdJQUlBRWdBRUVCY2pZQ0JDQUJRYURRQUNnQ0FFY05Ca0dVMEFCQkFEWUNBRUdnMEFCQkFEWUNBQXdHQzBHZzBBQW9BZ0FnQlVZRVFFR2cwQUFnQVRZQ0FFR1UwQUJCbE5BQUtBSUFJQVJxSWdBMkFnQWdBU0FBUVFGeU5nSUVJQUFnQVdvZ0FEWUNBQXdHQ3lBQVFYaHhJQVJxSVFRZ0FFSC9BVTBFUUNBQVFRTjJJUU1nQlNnQ0NDSUFJQVVvQWd3aUFrWUVRRUdNMEFCQmpOQUFLQUlBUVg0Z0EzZHhOZ0lBREFVTElBSWdBRFlDQ0NBQUlBSTJBZ3dNQkFzZ0JTZ0NHQ0VHSUFVZ0JTZ0NEQ0lBUndSQVFaelFBQ2dDQUJvZ0FDQUZLQUlJSWdJMkFnZ2dBaUFBTmdJTURBTUxJQVZCRkdvaUF5Z0NBQ0lDUlFSQUlBVW9BaEFpQWtVTkFpQUZRUkJxSVFNTEEwQWdBeUVISUFJaUFFRVVhaUlES0FJQUlnSU5BQ0FBUVJCcUlRTWdBQ2dDRUNJQ0RRQUxJQWRCQURZQ0FBd0NDeUFGSUFCQmZuRTJBZ1FnQVNBRWFpQUVOZ0lBSUFFZ0JFRUJjallDQkF3REMwRUFJUUFMSUFaRkRRQUNRQ0FGS0FJY0lnSkJBblJCdk5JQWFpSURLQUlBSUFWR0JFQWdBeUFBTmdJQUlBQU5BVUdRMEFCQmtOQUFLQUlBUVg0Z0FuZHhOZ0lBREFJTElBWkJFRUVVSUFZb0FoQWdCVVliYWlBQU5nSUFJQUJGRFFFTElBQWdCallDR0NBRktBSVFJZ0lFUUNBQUlBSTJBaEFnQWlBQU5nSVlDeUFGUVJScUtBSUFJZ0pGRFFBZ0FFRVVhaUFDTmdJQUlBSWdBRFlDR0FzZ0FTQUVhaUFFTmdJQUlBRWdCRUVCY2pZQ0JDQUJRYURRQUNnQ0FFY05BRUdVMEFBZ0JEWUNBQXdCQ3lBRVFmOEJUUVJBSUFSQmVIRkJ0TkFBYWlFQUFuOUJqTkFBS0FJQUlnSkJBU0FFUVFOMmRDSURjVVVFUUVHTTBBQWdBaUFEY2pZQ0FDQUFEQUVMSUFBb0FnZ0xJZ0lnQVRZQ0RDQUFJQUUyQWdnZ0FTQUFOZ0lNSUFFZ0FqWUNDQXdCQzBFZklRSWdCRUgvLy84SFRRUkFJQVJCSmlBRVFRaDJaeUlBYTNaQkFYRWdBRUVCZEd0QlBtb2hBZ3NnQVNBQ05nSWNJQUZDQURjQ0VDQUNRUUowUWJ6U0FHb2hBQUpBUVpEUUFDZ0NBQ0lEUVFFZ0FuUWlCM0ZGQkVBZ0FDQUJOZ0lBUVpEUUFDQURJQWR5TmdJQUlBRWdBRFlDR0NBQklBRTJBZ2dnQVNBQk5nSU1EQUVMSUFSQkdTQUNRUUYyYTBFQUlBSkJIMGNiZENFQ0lBQW9BZ0FoQUFKQUEwQWdBQ0lES0FJRVFYaHhJQVJHRFFFZ0FrRWRkaUVBSUFKQkFYUWhBaUFESUFCQkJIRnFRUkJxSWdjb0FnQWlBQTBBQ3lBSElBRTJBZ0FnQVNBRE5nSVlJQUVnQVRZQ0RDQUJJQUUyQWdnTUFRc2dBeWdDQ0NJQUlBRTJBZ3dnQXlBQk5nSUlJQUZCQURZQ0dDQUJJQU0yQWd3Z0FTQUFOZ0lJQzBHczBBQkJyTkFBS0FJQVFRRnJJZ0JCZnlBQUd6WUNBQXNMQndBZ0FDMEFLQXNIQUNBQUxRQXFDd2NBSUFBdEFDc0xCd0FnQUMwQUtRc0hBQ0FBTHdFeUN3Y0FJQUF0QUM0TFFBRUVmeUFBS0FJWUlRRWdBQzBBTFNFQ0lBQXRBQ2doQXlBQUtBSTRJUVFnQUJBd0lBQWdCRFlDT0NBQUlBTTZBQ2dnQUNBQ09nQXRJQUFnQVRZQ0dBdTc0Z0VDQjM4RGZpQUJJQUpxSVFRQ1FDQUFJZ0lvQWd3aUFBMEFJQUlvQWdRRVFDQUNJQUUyQWdRTEl3QkJFR3NpQ0NRQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDZndKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUlBSW9BaHdpQTBFQmF3N2RBZG9CQWRrQkFnTUVCUVlIQ0FrS0N3d05EdGdCRHhEWEFSRVMxZ0VURkJVV0Z4Z1pHaHZnQWQ4QkhCMGUxUUVmSUNFaUl5UWwxQUVtSnlncEtpc3Mwd0hTQVMwdTBRSFFBUzh3TVRJek5EVTJOemc1T2pzOFBUNC9RRUZDUTBSRlJ0c0JSMGhKU3M4QnpnRkx6UUZNekFGTlRrOVFVVkpUVkZWV1YxaFpXbHRjWFY1ZllHRmlZMlJsWm1kb2FXcHJiRzF1YjNCeGNuTjBkWFozZUhsNmUzeDlmbitBQVlFQmdnR0RBWVFCaFFHR0FZY0JpQUdKQVlvQml3R01BWTBCamdHUEFaQUJrUUdTQVpNQmxBR1ZBWllCbHdHWUFaa0JtZ0diQVp3Qm5RR2VBWjhCb0FHaEFhSUJvd0drQWFVQnBnR25BYWdCcVFHcUFhc0JyQUd0QWE0QnJ3R3dBYkVCc2dHekFiUUJ0UUcyQWJjQnl3SEtBYmdCeVFHNUFjZ0J1Z0c3QWJ3QnZRRytBYjhCd0FIQkFjSUJ3d0hFQWNVQnhnRUEzQUVMUVFBTXhnRUxRUTRNeFFFTFFRME14QUVMUVE4TXd3RUxRUkFNd2dFTFFSTU13UUVMUVJRTXdBRUxRUlVNdndFTFFSWU12Z0VMUVJnTXZRRUxRUmtNdkFFTFFSb011d0VMUVJzTXVnRUxRUndNdVFFTFFSME11QUVMUVFnTXR3RUxRUjRNdGdFTFFTQU10UUVMUVI4TXRBRUxRUWNNc3dFTFFTRU1zZ0VMUVNJTXNRRUxRU01Nc0FFTFFTUU1yd0VMUVJJTXJnRUxRUkVNclFFTFFTVU1yQUVMUVNZTXF3RUxRU2NNcWdFTFFTZ01xUUVMUWNNQkRLZ0JDMEVxREtjQkMwRXJES1lCQzBFc0RLVUJDMEV0REtRQkMwRXVES01CQzBFdkRLSUJDMEhFQVF5aEFRdEJNQXlnQVF0Qk5BeWZBUXRCREF5ZUFRdEJNUXlkQVF0Qk1neWNBUXRCTXd5YkFRdEJPUXlhQVF0Qk5ReVpBUXRCeFFFTW1BRUxRUXNNbHdFTFFUb01sZ0VMUVRZTWxRRUxRUW9NbEFFTFFUY01rd0VMUVRnTWtnRUxRVHdNa1FFTFFUc01rQUVMUVQwTWp3RUxRUWtNamdFTFFTa01qUUVMUVQ0TWpBRUxRVDhNaXdFTFFjQUFESW9CQzBIQkFBeUpBUXRCd2dBTWlBRUxRY01BREljQkMwSEVBQXlHQVF0QnhRQU1oUUVMUWNZQURJUUJDMEVYRElNQkMwSEhBQXlDQVF0QnlBQU1nUUVMUWNrQURJQUJDMEhLQUF4L0MwSExBQXgrQzBITkFBeDlDMEhNQUF4OEMwSE9BQXg3QzBIUEFBeDZDMEhRQUF4NUMwSFJBQXg0QzBIU0FBeDNDMEhUQUF4MkMwSFVBQXgxQzBIV0FBeDBDMEhWQUF4ekMwRUdESElMUWRjQURIRUxRUVVNY0F0QjJBQU1id3RCQkF4dUMwSFpBQXh0QzBIYUFBeHNDMEhiQUF4ckMwSGNBQXhxQzBFRERHa0xRZDBBREdnTFFkNEFER2NMUWQ4QURHWUxRZUVBREdVTFFlQUFER1FMUWVJQURHTUxRZU1BREdJTFFRSU1ZUXRCNUFBTVlBdEI1UUFNWHd0QjVnQU1YZ3RCNXdBTVhRdEI2QUFNWEF0QjZRQU1Xd3RCNmdBTVdndEI2d0FNV1F0QjdBQU1XQXRCN1FBTVZ3dEI3Z0FNVmd0Qjd3QU1WUXRCOEFBTVZBdEI4UUFNVXd0QjhnQU1VZ3RCOHdBTVVRdEI5QUFNVUF0QjlRQU1Ud3RCOWdBTVRndEI5d0FNVFF0QitBQU1UQXRCK1FBTVN3dEIrZ0FNU2d0Qit3QU1TUXRCL0FBTVNBdEIvUUFNUnd0Qi9nQU1SZ3RCL3dBTVJRdEJnQUVNUkF0QmdRRU1Rd3RCZ2dFTVFndEJnd0VNUVF0QmhBRU1RQXRCaFFFTVB3dEJoZ0VNUGd0Qmh3RU1QUXRCaUFFTVBBdEJpUUVNT3d0QmlnRU1PZ3RCaXdFTU9RdEJqQUVNT0F0QmpRRU1Od3RCamdFTU5ndEJqd0VNTlF0QmtBRU1OQXRCa1FFTU13dEJrZ0VNTWd0Qmt3RU1NUXRCbEFFTU1BdEJsUUVNTHd0QmxnRU1MZ3RCbHdFTUxRdEJtQUVNTEF0Qm1RRU1Ld3RCbWdFTUtndEJtd0VNS1F0Qm5BRU1LQXRCblFFTUp3dEJuZ0VNSmd0Qm53RU1KUXRCb0FFTUpBdEJvUUVNSXd0Qm9nRU1JZ3RCb3dFTUlRdEJwQUVNSUF0QnBRRU1Id3RCcGdFTUhndEJwd0VNSFF0QnFBRU1IQXRCcVFFTUd3dEJxZ0VNR2d0QnF3RU1HUXRCckFFTUdBdEJyUUVNRnd0QnJnRU1GZ3RCQVF3VkMwR3ZBUXdVQzBHd0FRd1RDMEd4QVF3U0MwR3pBUXdSQzBHeUFRd1FDMEcwQVF3UEMwRzFBUXdPQzBHMkFRd05DMEczQVF3TUMwRzRBUXdMQzBHNUFRd0tDMEc2QVF3SkMwRzdBUXdJQzBIR0FRd0hDMEc4QVF3R0MwRzlBUXdGQzBHK0FRd0VDMEcvQVF3REMwSEFBUXdDQzBIQ0FRd0JDMEhCQVFzaEF3TkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFJQUlDZndKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUovQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FnQWdKL0FrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDZndKQUFrQUNmd0pBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDZndKQUFrQUNRQUpBQW44Q1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FDQUREc1lCQUFFQ0F3UUZCZ2NJQ1FvTERBME9EeEFSRWhNVUZSWVhHQmthR3h3ZEh5QWhJeVVtS0NvckxDOHdNVEl6TkRVMk56azZPenc5bEFOQVFrUkZSa2xMVGs5UVVWSlRWRlZXV0ZwYlhGMWVYMkJoWW1Oa1pXWm5hR3BzYjNCeGMzVjJlSGw2ZTN4L2dBR0JBWUlCZ3dHRUFZVUJoZ0dIQVlnQmlRR0tBWXNCakFHTkFZNEJqd0dRQVpFQmtnR1RBWlFCbFFHV0FaY0JtQUdaQVpvQm13R2NBWjBCbmdHZkFhQUJvUUdpQWFNQnBBR2xBYVlCcHdHb0Fha0JxZ0dyQWF3QnJRR3VBYThCc0FHeEFiSUJzd0cwQWJVQnRnRzNBYmdCdVFHNkFic0J2QUc5QWI0QnZ3SEFBY0VCd2dIREFjUUJ4UUhHQWNjQnlBSEpBY3NCekFITkFjNEJ6d0dLQTRrRGlBT0hBNFFEZ3dPQUEvc0MrZ0w1QXZnQzl3TDBBdk1DOGdMTEFzRUNzQUxaQVFzZ0FTQUVSdzN3QWtIZEFTRURETE1EQ3lBQklBUkhEY2dCUWNNQklRTU1zZ01MSUFFZ0JFY05lMEgzQUNFRERMRURDeUFCSUFSSERYQkI3d0FoQXd5d0F3c2dBU0FFUncxcFFlb0FJUU1NcndNTElBRWdCRWNOWlVIb0FDRURESzREQ3lBQklBUkhEV0pCNWdBaEF3eXRBd3NnQVNBRVJ3MGFRUmdoQXd5c0F3c2dBU0FFUncwVlFSSWhBd3lyQXdzZ0FTQUVSdzFDUWNVQUlRTU1xZ01MSUFFZ0JFY05ORUUvSVFNTXFRTUxJQUVnQkVjTk1rRThJUU1NcUFNTElBRWdCRWNOSzBFeElRTU1wd01MSUFJdEFDNUJBVVlObndNTXdRSUxRUUFoQUFKQUFrQUNRQ0FDTFFBcVJRMEFJQUl0QUN0RkRRQWdBaThCTUNJRFFRSnhSUTBCREFJTElBSXZBVEFpQTBFQmNVVU5BUXRCQVNFQUlBSXRBQ2hCQVVZTkFDQUNMd0V5SWdWQjVBQnJRZVFBU1EwQUlBVkJ6QUZHRFFBZ0JVR3dBa1lOQUNBRFFjQUFjUTBBUVFBaEFDQURRWWdFY1VHQUJFWU5BQ0FEUVNoeFFRQkhJUUFMSUFKQkFEc0JNQ0FDUVFBNkFDOGdBRVVOM3dJZ0FrSUFOd01nRE9BQ0MwRUFJUUFDUUNBQ0tBSTRJZ05GRFFBZ0F5Z0NMQ0lEUlEwQUlBSWdBeEVBQUNFQUN5QUFSUTNNQVNBQVFSVkhEZDBDSUFKQkJEWUNIQ0FDSUFFMkFoUWdBa0d3R0RZQ0VDQUNRUlUyQWd4QkFDRURES1FEQ3lBQklBUkdCRUJCQmlFRERLUURDeUFCUVFGcUlRRkJBQ0VBQWtBZ0FpZ0NPQ0lEUlEwQUlBTW9BbFFpQTBVTkFDQUNJQU1SQUFBaEFBc2dBQTNaQWd3Y0N5QUNRZ0EzQXlCQkVpRURESWtEQ3lBQklBUkhEUlpCSFNFRERLRURDeUFCSUFSSEJFQWdBVUVCYWlFQlFSQWhBd3lJQXd0QkJ5RURES0FEQ3lBQ0lBSXBBeUFpQ2lBRUlBRnJyU0lMZlNJTVFnQWdDaUFNV2hzM0F5QWdDaUFMV0EzVUFrRUlJUU1NbndNTElBRWdCRWNFUUNBQ1FRazJBZ2dnQWlBQk5nSUVRUlFoQXd5R0F3dEJDU0VEREo0REN5QUNLUU1nUWdCU0RjY0JJQUlnQWk4Qk1FR0FBWEk3QVRBTVFnc2dBU0FFUncwL1FkQUFJUU1NbkFNTElBRWdCRVlFUUVFTElRTU1uQU1MSUFGQkFXb2hBVUVBSVFBQ1FDQUNLQUk0SWdORkRRQWdBeWdDVUNJRFJRMEFJQUlnQXhFQUFDRUFDeUFBRGM4Q0RNWUJDMEVBSVFBQ1FDQUNLQUk0SWdORkRRQWdBeWdDU0NJRFJRMEFJQUlnQXhFQUFDRUFDeUFBUlEzR0FTQUFRUlZIRGMwQ0lBSkJDellDSENBQ0lBRTJBaFFnQWtHQ0dUWUNFQ0FDUVJVMkFneEJBQ0VEREpvREMwRUFJUUFDUUNBQ0tBSTRJZ05GRFFBZ0F5Z0NTQ0lEUlEwQUlBSWdBeEVBQUNFQUN5QUFSUTBNSUFCQkZVY055Z0lnQWtFYU5nSWNJQUlnQVRZQ0ZDQUNRWUlaTmdJUUlBSkJGVFlDREVFQUlRTU1tUU1MUVFBaEFBSkFJQUlvQWpnaUEwVU5BQ0FES0FKTUlnTkZEUUFnQWlBREVRQUFJUUFMSUFCRkRjUUJJQUJCRlVjTnh3SWdBa0VMTmdJY0lBSWdBVFlDRkNBQ1FaRVhOZ0lRSUFKQkZUWUNERUVBSVFNTW1BTUxJQUVnQkVZRVFFRVBJUU1NbUFNTElBRXRBQUFpQUVFN1JnMEhJQUJCRFVjTnhBSWdBVUVCYWlFQkRNTUJDMEVBSVFBQ1FDQUNLQUk0SWdORkRRQWdBeWdDVENJRFJRMEFJQUlnQXhFQUFDRUFDeUFBUlEzREFTQUFRUlZIRGNJQ0lBSkJEellDSENBQ0lBRTJBaFFnQWtHUkZ6WUNFQ0FDUVJVMkFneEJBQ0VEREpZREN3TkFJQUV0QUFCQjhEVnFMUUFBSWdCQkFVY0VRQ0FBUVFKSERjRUNJQUlvQWdRaEFFRUFJUU1nQWtFQU5nSUVJQUlnQUNBQlFRRnFJZ0VRTFNJQURjSUNETVVCQ3lBRUlBRkJBV29pQVVjTkFBdEJFaUVEREpVREMwRUFJUUFDUUNBQ0tBSTRJZ05GRFFBZ0F5Z0NUQ0lEUlEwQUlBSWdBeEVBQUNFQUN5QUFSUTNGQVNBQVFSVkhEYjBDSUFKQkd6WUNIQ0FDSUFFMkFoUWdBa0dSRnpZQ0VDQUNRUlUyQWd4QkFDRURESlFEQ3lBQklBUkdCRUJCRmlFRERKUURDeUFDUVFvMkFnZ2dBaUFCTmdJRVFRQWhBQUpBSUFJb0FqZ2lBMFVOQUNBREtBSklJZ05GRFFBZ0FpQURFUUFBSVFBTElBQkZEY0lCSUFCQkZVY051UUlnQWtFVk5nSWNJQUlnQVRZQ0ZDQUNRWUlaTmdJUUlBSkJGVFlDREVFQUlRTU1rd01MSUFFZ0JFY0VRQU5BSUFFdEFBQkI4RGRxTFFBQUlnQkJBa2NFUUFKQUlBQkJBV3NPQk1RQ3ZRSUF2Z0s5QWdzZ0FVRUJhaUVCUVFnaEF3ejhBZ3NnQkNBQlFRRnFJZ0ZIRFFBTFFSVWhBd3lUQXd0QkZTRURESklEQ3dOQUlBRXRBQUJCOERscUxRQUFJZ0JCQWtjRVFDQUFRUUZyRGdURkFyY0N3d0s0QXJjQ0N5QUVJQUZCQVdvaUFVY05BQXRCR0NFRERKRURDeUFCSUFSSEJFQWdBa0VMTmdJSUlBSWdBVFlDQkVFSElRTU0rQUlMUVJraEF3eVFBd3NnQVVFQmFpRUJEQUlMSUFFZ0JFWUVRRUVhSVFNTWp3TUxBa0FnQVMwQUFFRU5hdzRVdFFHL0FiOEJ2d0cvQWI4QnZ3Ry9BYjhCdndHL0FiOEJ2d0cvQWI4QnZ3Ry9BYjhCdndFQXZ3RUxRUUFoQXlBQ1FRQTJBaHdnQWtHdkN6WUNFQ0FDUVFJMkFnd2dBaUFCUVFGcU5nSVVESTREQ3lBQklBUkdCRUJCR3lFRERJNERDeUFCTFFBQUlnQkJPMGNFUUNBQVFRMUhEYkVDSUFGQkFXb2hBUXk2QVFzZ0FVRUJhaUVCQzBFaUlRTU04d0lMSUFFZ0JFWUVRRUVjSVFNTWpBTUxRZ0FoQ2dKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQWdBUzBBQUVFd2F3NDN3UUxBQWdBQkFnTUVCUVlIMEFIUUFkQUIwQUhRQWRBQjBBRUlDUW9MREEzUUFkQUIwQUhRQWRBQjBBSFFBZEFCMEFIUUFkQUIwQUhRQWRBQjBBSFFBZEFCMEFIUUFkQUIwQUhRQWRBQjBBSFFBZEFCRGc4UUVSSVQwQUVMUWdJaENnekFBZ3RDQXlFS0RMOENDMElFSVFvTXZnSUxRZ1VoQ2d5OUFndENCaUVLREx3Q0MwSUhJUW9NdXdJTFFnZ2hDZ3k2QWd0Q0NTRUtETGtDQzBJS0lRb011QUlMUWdzaENneTNBZ3RDRENFS0RMWUNDMElOSVFvTXRRSUxRZzRoQ2d5MEFndENEeUVLRExNQ0MwSUtJUW9Nc2dJTFFnc2hDZ3l4QWd0Q0RDRUtETEFDQzBJTklRb01yd0lMUWc0aENneXVBZ3RDRHlFS0RLMENDMElBSVFvQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFJQUV0QUFCQk1Hc09OOEFDdndJQUFRSURCQVVHQjc0Q3ZnSytBcjRDdmdLK0FyNENDQWtLQ3d3TnZnSytBcjRDdmdLK0FyNEN2Z0srQXI0Q3ZnSytBcjRDdmdLK0FyNEN2Z0srQXI0Q3ZnSytBcjRDdmdLK0FyNEN2Z0srQWc0UEVCRVNFNzRDQzBJQ0lRb012d0lMUWdNaENneStBZ3RDQkNFS0RMMENDMElGSVFvTXZBSUxRZ1loQ2d5N0FndENCeUVLRExvQ0MwSUlJUW9NdVFJTFFna2hDZ3k0QWd0Q0NpRUtETGNDQzBJTElRb010Z0lMUWd3aENneTFBZ3RDRFNFS0RMUUNDMElPSVFvTXN3SUxRZzhoQ2d5eUFndENDaUVLRExFQ0MwSUxJUW9Nc0FJTFFnd2hDZ3l2QWd0Q0RTRUtESzRDQzBJT0lRb01yUUlMUWc4aENneXNBZ3NnQWlBQ0tRTWdJZ29nQkNBQmE2MGlDMzBpREVJQUlBb2dERm9iTndNZ0lBb2dDMWdOcHdKQkh5RURESWtEQ3lBQklBUkhCRUFnQWtFSk5nSUlJQUlnQVRZQ0JFRWxJUU1NOEFJTFFTQWhBd3lJQXd0QkFTRUZJQUl2QVRBaUEwRUljVVVFUUNBQ0tRTWdRZ0JTSVFVTEFrQWdBaTBBTGdSQVFRRWhBQ0FDTFFBcFFRVkdEUUVnQTBIQUFIRkZJQVZ4UlEwQkMwRUFJUUFnQTBIQUFIRU5BRUVDSVFBZ0EwRUljUTBBSUFOQmdBUnhCRUFDUUNBQ0xRQW9RUUZIRFFBZ0FpMEFMVUVLY1EwQVFRVWhBQXdDQzBFRUlRQU1BUXNnQTBFZ2NVVUVRQUpBSUFJdEFDaEJBVVlOQUNBQ0x3RXlJZ0JCNUFCclFlUUFTUTBBSUFCQnpBRkdEUUFnQUVHd0FrWU5BRUVFSVFBZ0EwRW9jVVVOQWlBRFFZZ0VjVUdBQkVZTkFndEJBQ0VBREFFTFFRQkJBeUFDS1FNZ1VCc2hBQXNnQUVFQmF3NEZ2Z0lBc0FFQnBBS2hBZ3RCRVNFRERPMENDeUFDUVFFNkFDOE1oQU1MSUFFZ0JFY05uUUpCSkNFRERJUURDeUFCSUFSSERSeEJ4Z0FoQXd5REF3dEJBQ0VBQWtBZ0FpZ0NPQ0lEUlEwQUlBTW9Ba1FpQTBVTkFDQUNJQU1SQUFBaEFBc2dBRVVOSnlBQVFSVkhEWmdDSUFKQjBBQTJBaHdnQWlBQk5nSVVJQUpCa1JnMkFoQWdBa0VWTmdJTVFRQWhBd3lDQXdzZ0FTQUVSZ1JBUVNnaEF3eUNBd3RCQUNFRElBSkJBRFlDQkNBQ1FRdzJBZ2dnQWlBQklBRVFLaUlBUlEyVUFpQUNRU2MyQWh3Z0FpQUJOZ0lVSUFJZ0FEWUNEQXlCQXdzZ0FTQUVSZ1JBUVNraEF3eUJBd3NnQVMwQUFDSUFRU0JHRFJNZ0FFRUpSdzJWQWlBQlFRRnFJUUVNRkFzZ0FTQUVSd1JBSUFGQkFXb2hBUXdXQzBFcUlRTU0vd0lMSUFFZ0JFWUVRRUVySVFNTS93SUxJQUV0QUFBaUFFRUpSeUFBUVNCSGNRMlFBaUFDTFFBc1FRaEhEZDBDSUFKQkFEb0FMQXpkQWdzZ0FTQUVSZ1JBUVN3aEF3eitBZ3NnQVMwQUFFRUtSdzJPQWlBQlFRRnFJUUVNc0FFTElBRWdCRWNOaWdKQkx5RUREUHdDQ3dOQUlBRXRBQUFpQUVFZ1J3UkFJQUJCQ21zT0JJUUNpQUtJQW9RQ2hnSUxJQVFnQVVFQmFpSUJSdzBBQzBFeElRTU0rd0lMUVRJaEF5QUJJQVJHRGZvQ0lBSW9BZ0FpQUNBRUlBRnJhaUVISUFFZ0FHdEJBMm9oQmdKQUEwQWdBRUh3TzJvdEFBQWdBUzBBQUNJRlFTQnlJQVVnQlVIQkFHdEIvd0Z4UVJwSkcwSC9BWEZIRFFFZ0FFRURSZ1JBUVFZaEFRemlBZ3NnQUVFQmFpRUFJQVFnQVVFQmFpSUJSdzBBQ3lBQ0lBYzJBZ0FNK3dJTElBSkJBRFlDQUF5R0FndEJNeUVESUFRZ0FTSUFSZzM1QWlBRUlBRnJJQUlvQWdBaUFXb2hCeUFBSUFGclFRaHFJUVlDUUFOQUlBRkI5RHRxTFFBQUlBQXRBQUFpQlVFZ2NpQUZJQVZCd1FCclFmOEJjVUVhU1J0Qi93RnhSdzBCSUFGQkNFWUVRRUVGSVFFTTRRSUxJQUZCQVdvaEFTQUVJQUJCQVdvaUFFY05BQXNnQWlBSE5nSUFEUG9DQ3lBQ1FRQTJBZ0FnQUNFQkRJVUNDMEUwSVFNZ0JDQUJJZ0JHRGZnQ0lBUWdBV3NnQWlnQ0FDSUJhaUVISUFBZ0FXdEJCV29oQmdKQUEwQWdBVUhRd2dCcUxRQUFJQUF0QUFBaUJVRWdjaUFGSUFWQndRQnJRZjhCY1VFYVNSdEIvd0Z4UncwQklBRkJCVVlFUUVFSElRRU00QUlMSUFGQkFXb2hBU0FFSUFCQkFXb2lBRWNOQUFzZ0FpQUhOZ0lBRFBrQ0N5QUNRUUEyQWdBZ0FDRUJESVFDQ3lBQklBUkhCRUFEUUNBQkxRQUFRWUErYWkwQUFDSUFRUUZIQkVBZ0FFRUNSZzBKRElFQ0N5QUVJQUZCQVdvaUFVY05BQXRCTUNFRERQZ0NDMEV3SVFNTTl3SUxJQUVnQkVjRVFBTkFJQUV0QUFBaUFFRWdSd1JBSUFCQkNtc09CUDhCL2dIK0FmOEIvZ0VMSUFRZ0FVRUJhaUlCUncwQUMwRTRJUU1NOXdJTFFUZ2hBd3oyQWdzRFFDQUJMUUFBSWdCQklFY2dBRUVKUjNFTjlnRWdCQ0FCUVFGcUlnRkhEUUFMUVR3aEF3ejFBZ3NEUUNBQkxRQUFJZ0JCSUVjRVFBSkFJQUJCQ21zT0JQa0JCQVQ1QVFBTElBQkJMRVlOOVFFTUF3c2dCQ0FCUVFGcUlnRkhEUUFMUVQ4aEF3ejBBZ3RCd0FBaEF5QUJJQVJHRGZNQ0lBSW9BZ0FpQUNBRUlBRnJhaUVGSUFFZ0FHdEJCbW9oQmdKQUEwQWdBRUdBUUdzdEFBQWdBUzBBQUVFZ2NrY05BU0FBUVFaR0Rkc0NJQUJCQVdvaEFDQUVJQUZCQVdvaUFVY05BQXNnQWlBRk5nSUFEUFFDQ3lBQ1FRQTJBZ0FMUVRZaEF3elpBZ3NnQVNBRVJnUkFRY0VBSVFNTThnSUxJQUpCRERZQ0NDQUNJQUUyQWdRZ0FpMEFMRUVCYXc0RSt3SHVBZXdCNndIVUFnc2dBVUVCYWlFQkRQb0JDeUFCSUFSSEJFQURRQUpBSUFFdEFBQWlBRUVnY2lBQUlBQkJ3UUJyUWY4QmNVRWFTUnRCL3dGeElnQkJDVVlOQUNBQVFTQkdEUUFDUUFKQUFrQUNRQ0FBUWVNQWF3NFRBQU1EQXdNREF3TUJBd01EQXdNREF3TURBZ01MSUFGQkFXb2hBVUV4SVFNTTNBSUxJQUZCQVdvaEFVRXlJUU1NMndJTElBRkJBV29oQVVFeklRTU0yZ0lMRFA0QkN5QUVJQUZCQVdvaUFVY05BQXRCTlNFRERQQUNDMEUxSVFNTTd3SUxJQUVnQkVjRVFBTkFJQUV0QUFCQmdEeHFMUUFBUVFGSERmY0JJQVFnQVVFQmFpSUJSdzBBQzBFOUlRTU03d0lMUVQwaEF3enVBZ3RCQUNFQUFrQWdBaWdDT0NJRFJRMEFJQU1vQWtBaUEwVU5BQ0FDSUFNUkFBQWhBQXNnQUVVTkFTQUFRUlZIRGVZQklBSkJ3Z0EyQWh3Z0FpQUJOZ0lVSUFKQjR4ZzJBaEFnQWtFVk5nSU1RUUFoQXd6dEFnc2dBVUVCYWlFQkMwRThJUU1NMGdJTElBRWdCRVlFUUVIQ0FDRURET3NDQ3dKQUEwQUNRQ0FCTFFBQVFRbHJEaGdBQXN3Q3pBTFJBc3dDekFMTUFzd0N6QUxNQXN3Q3pBTE1Bc3dDekFMTUFzd0N6QUxNQXN3Q3pBTE1BZ0RNQWdzZ0JDQUJRUUZxSWdGSERRQUxRY0lBSVFNTTZ3SUxJQUZCQVdvaEFTQUNMUUF0UVFGeFJRMytBUXRCTENFREROQUNDeUFCSUFSSERkNEJRY1FBSVFNTTZBSUxBMEFnQVMwQUFFR1F3QUJxTFFBQVFRRkhEWndCSUFRZ0FVRUJhaUlCUncwQUMwSEZBQ0VERE9jQ0N5QUJMUUFBSWdCQklFWU4vZ0VnQUVFNlJ3M0FBaUFDS0FJRUlRQkJBQ0VESUFKQkFEWUNCQ0FDSUFBZ0FSQXBJZ0FOM2dFTTNRRUxRY2NBSVFNZ0JDQUJJZ0JHRGVVQ0lBUWdBV3NnQWlnQ0FDSUJhaUVISUFBZ0FXdEJCV29oQmdOQUlBRkJrTUlBYWkwQUFDQUFMUUFBSWdWQklISWdCU0FGUWNFQWEwSC9BWEZCR2trYlFmOEJjVWNOdndJZ0FVRUZSZzNDQWlBQlFRRnFJUUVnQkNBQVFRRnFJZ0JIRFFBTElBSWdCellDQUF6bEFndEJ5QUFoQXlBRUlBRWlBRVlONUFJZ0JDQUJheUFDS0FJQUlnRnFJUWNnQUNBQmEwRUphaUVHQTBBZ0FVR1d3Z0JxTFFBQUlBQXRBQUFpQlVFZ2NpQUZJQVZCd1FCclFmOEJjVUVhU1J0Qi93RnhSdzIrQWtFQ0lBRkJDVVlOd2dJYUlBRkJBV29oQVNBRUlBQkJBV29pQUVjTkFBc2dBaUFITmdJQURPUUNDeUFCSUFSR0JFQkJ5UUFoQXd6a0Fnc0NRQUpBSUFFdEFBQWlBRUVnY2lBQUlBQkJ3UUJyUWY4QmNVRWFTUnRCL3dGeFFlNEFhdzRIQUw4Q3Z3Sy9BcjhDdndJQnZ3SUxJQUZCQVdvaEFVRStJUU1NeXdJTElBRkJBV29oQVVFL0lRTU15Z0lMUWNvQUlRTWdCQ0FCSWdCR0RlSUNJQVFnQVdzZ0FpZ0NBQ0lCYWlFR0lBQWdBV3RCQVdvaEJ3TkFJQUZCb01JQWFpMEFBQ0FBTFFBQUlnVkJJSElnQlNBRlFjRUFhMEgvQVhGQkdra2JRZjhCY1VjTnZBSWdBVUVCUmcyK0FpQUJRUUZxSVFFZ0JDQUFRUUZxSWdCSERRQUxJQUlnQmpZQ0FBemlBZ3RCeXdBaEF5QUVJQUVpQUVZTjRRSWdCQ0FCYXlBQ0tBSUFJZ0ZxSVFjZ0FDQUJhMEVPYWlFR0EwQWdBVUdpd2dCcUxRQUFJQUF0QUFBaUJVRWdjaUFGSUFWQndRQnJRZjhCY1VFYVNSdEIvd0Z4UncyN0FpQUJRUTVHRGI0Q0lBRkJBV29oQVNBRUlBQkJBV29pQUVjTkFBc2dBaUFITmdJQURPRUNDMEhNQUNFRElBUWdBU0lBUmczZ0FpQUVJQUZySUFJb0FnQWlBV29oQnlBQUlBRnJRUTlxSVFZRFFDQUJRY0RDQUdvdEFBQWdBQzBBQUNJRlFTQnlJQVVnQlVIQkFHdEIvd0Z4UVJwSkcwSC9BWEZIRGJvQ1FRTWdBVUVQUmcyK0Fob2dBVUVCYWlFQklBUWdBRUVCYWlJQVJ3MEFDeUFDSUFjMkFnQU00QUlMUWMwQUlRTWdCQ0FCSWdCR0RkOENJQVFnQVdzZ0FpZ0NBQ0lCYWlFSElBQWdBV3RCQldvaEJnTkFJQUZCME1JQWFpMEFBQ0FBTFFBQUlnVkJJSElnQlNBRlFjRUFhMEgvQVhGQkdra2JRZjhCY1VjTnVRSkJCQ0FCUVFWR0RiMENHaUFCUVFGcUlRRWdCQ0FBUVFGcUlnQkhEUUFMSUFJZ0J6WUNBQXpmQWdzZ0FTQUVSZ1JBUWM0QUlRTU0zd0lMQWtBQ1FBSkFBa0FnQVMwQUFDSUFRU0J5SUFBZ0FFSEJBR3RCL3dGeFFScEpHMEgvQVhGQjR3QnJEaE1BdkFLOEFyd0N2QUs4QXJ3Q3ZBSzhBcndDdkFLOEFyd0NBYndDdkFLOEFnSUR2QUlMSUFGQkFXb2hBVUhCQUNFRERNZ0NDeUFCUVFGcUlRRkJ3Z0FoQXd6SEFnc2dBVUVCYWlFQlFjTUFJUU1NeGdJTElBRkJBV29oQVVIRUFDRURETVVDQ3lBQklBUkhCRUFnQWtFTk5nSUlJQUlnQVRZQ0JFSEZBQ0VERE1VQ0MwSFBBQ0VERE4wQ0N3SkFBa0FnQVMwQUFFRUthdzRFQVpBQmtBRUFrQUVMSUFGQkFXb2hBUXRCS0NFRERNTUNDeUFCSUFSR0JFQkIwUUFoQXd6Y0Fnc2dBUzBBQUVFZ1J3MEFJQUZCQVdvaEFTQUNMUUF0UVFGeFJRM1FBUXRCRnlFRERNRUNDeUFCSUFSSERjc0JRZElBSVFNTTJRSUxRZE1BSVFNZ0FTQUVSZzNZQWlBQ0tBSUFJZ0FnQkNBQmEyb2hCaUFCSUFCclFRRnFJUVVEUUNBQkxRQUFJQUJCMXNJQWFpMEFBRWNOeHdFZ0FFRUJSZzNLQVNBQVFRRnFJUUFnQkNBQlFRRnFJZ0ZIRFFBTElBSWdCallDQUF6WUFnc2dBU0FFUmdSQVFkVUFJUU1NMkFJTElBRXRBQUJCQ2tjTndnRWdBVUVCYWlFQkRNb0JDeUFCSUFSR0JFQkIxZ0FoQXd6WEFnc0NRQUpBSUFFdEFBQkJDbXNPQkFEREFjTUJBY01CQ3lBQlFRRnFJUUVNeWdFTElBRkJBV29oQVVIS0FDRURETDBDQzBFQUlRQUNRQ0FDS0FJNElnTkZEUUFnQXlnQ1BDSURSUTBBSUFJZ0F4RUFBQ0VBQ3lBQURiOEJRYzBBSVFNTXZBSUxJQUl0QUNsQklrWU56d0lNaVFFTElBUWdBU0lGUmdSQVFkc0FJUU1NMUFJTFFRQWhBRUVCSVFGQkFTRUdRUUFoQXdKQUFuOENRQUpBQWtBQ1FBSkFBa0FDUUNBRkxRQUFRVEJyRGdyRkFjUUJBQUVDQXdRRkJnakRBUXRCQWd3R0MwRUREQVVMUVFRTUJBdEJCUXdEQzBFR0RBSUxRUWNNQVF0QkNBc2hBMEVBSVFGQkFDRUdETDBCQzBFSklRTkJBU0VBUVFBaEFVRUFJUVlNdkFFTElBRWdCRVlFUUVIZEFDRURETk1DQ3lBQkxRQUFRUzVIRGJnQklBRkJBV29oQVF5SUFRc2dBU0FFUncyMkFVSGZBQ0VERE5FQ0N5QUJJQVJIQkVBZ0FrRU9OZ0lJSUFJZ0FUWUNCRUhRQUNFRERMZ0NDMEhnQUNFREROQUNDMEhoQUNFRElBRWdCRVlOendJZ0FpZ0NBQ0lBSUFRZ0FXdHFJUVVnQVNBQWEwRURhaUVHQTBBZ0FTMEFBQ0FBUWVMQ0FHb3RBQUJIRGJFQklBQkJBMFlOc3dFZ0FFRUJhaUVBSUFRZ0FVRUJhaUlCUncwQUN5QUNJQVUyQWdBTXp3SUxRZUlBSVFNZ0FTQUVSZzNPQWlBQ0tBSUFJZ0FnQkNBQmEyb2hCU0FCSUFCclFRSnFJUVlEUUNBQkxRQUFJQUJCNXNJQWFpMEFBRWNOc0FFZ0FFRUNSZzJ2QVNBQVFRRnFJUUFnQkNBQlFRRnFJZ0ZIRFFBTElBSWdCVFlDQUF6T0FndEI0d0FoQXlBQklBUkdEYzBDSUFJb0FnQWlBQ0FFSUFGcmFpRUZJQUVnQUd0QkEyb2hCZ05BSUFFdEFBQWdBRUhwd2dCcUxRQUFSdzJ2QVNBQVFRTkdEYTBCSUFCQkFXb2hBQ0FFSUFGQkFXb2lBVWNOQUFzZ0FpQUZOZ0lBRE0wQ0N5QUJJQVJHQkVCQjVRQWhBd3pOQWdzZ0FVRUJhaUVCUVFBaEFBSkFJQUlvQWpnaUEwVU5BQ0FES0FJd0lnTkZEUUFnQWlBREVRQUFJUUFMSUFBTnFnRkIxZ0FoQXd5ekFnc2dBU0FFUndSQUEwQWdBUzBBQUNJQVFTQkhCRUFDUUFKQUFrQWdBRUhJQUdzT0N3QUJzd0d6QWJNQnN3R3pBYk1Cc3dHekFRS3pBUXNnQVVFQmFpRUJRZElBSVFNTXR3SUxJQUZCQVdvaEFVSFRBQ0VERExZQ0N5QUJRUUZxSVFGQjFBQWhBd3kxQWdzZ0JDQUJRUUZxSWdGSERRQUxRZVFBSVFNTXpBSUxRZVFBSVFNTXl3SUxBMEFnQVMwQUFFSHd3Z0JxTFFBQUlnQkJBVWNFUUNBQVFRSnJEZ09uQWFZQnBRR2tBUXNnQkNBQlFRRnFJZ0ZIRFFBTFFlWUFJUU1NeWdJTElBRkJBV29nQVNBRVJ3MENHa0huQUNFRERNa0NDd05BSUFFdEFBQkI4TVFBYWkwQUFDSUFRUUZIQkVBQ1FDQUFRUUpyRGdTaUFhRUJvQUVBbndFTFFkY0FJUU1Nc1FJTElBUWdBVUVCYWlJQlJ3MEFDMEhvQUNFRERNZ0NDeUFCSUFSR0JFQkI2UUFoQXd6SUFnc0NRQ0FCTFFBQUlnQkJDbXNPR3JjQm13R2JBYlFCbXdHYkFac0Jtd0diQVpzQm13R2JBWnNCbXdHYkFac0Jtd0diQVpzQm13R2JBWnNCcEFHYkFac0JBSmtCQ3lBQlFRRnFDeUVCUVFZaEF3eXRBZ3NEUUNBQkxRQUFRZkRHQUdvdEFBQkJBVWNOZlNBRUlBRkJBV29pQVVjTkFBdEI2Z0FoQXd6RkFnc2dBVUVCYWlBQklBUkhEUUlhUWVzQUlRTU14QUlMSUFFZ0JFWUVRRUhzQUNFRERNUUNDeUFCUVFGcURBRUxJQUVnQkVZRVFFSHRBQ0VERE1NQ0N5QUJRUUZxQ3lFQlFRUWhBd3lvQWdzZ0FTQUVSZ1JBUWU0QUlRTU13UUlMQWtBQ1FBSkFJQUV0QUFCQjhNZ0FhaTBBQUVFQmF3NEhrQUdQQVk0QkFId0JBbzBCQ3lBQlFRRnFJUUVNQ3dzZ0FVRUJhZ3lUQVF0QkFDRURJQUpCQURZQ0hDQUNRWnNTTmdJUUlBSkJCellDRENBQ0lBRkJBV28yQWhRTXdBSUxBa0FEUUNBQkxRQUFRZkRJQUdvdEFBQWlBRUVFUndSQUFrQUNRQ0FBUVFGckRnZVVBWk1Ca2dHTkFRQUVBWTBCQzBIYUFDRURES29DQ3lBQlFRRnFJUUZCM0FBaEF3eXBBZ3NnQkNBQlFRRnFJZ0ZIRFFBTFFlOEFJUU1Nd0FJTElBRkJBV29Na1FFTElBUWdBU0lBUmdSQVFmQUFJUU1NdndJTElBQXRBQUJCTDBjTkFTQUFRUUZxSVFFTUJ3c2dCQ0FCSWdCR0JFQkI4UUFoQXd5K0Fnc2dBQzBBQUNJQlFTOUdCRUFnQUVFQmFpRUJRZDBBSVFNTXBRSUxJQUZCQ21zaUEwRVdTdzBBSUFBaEFVRUJJQU4wUVltQWdBSnhEZmtCQzBFQUlRTWdBa0VBTmdJY0lBSWdBRFlDRkNBQ1FZd2NOZ0lRSUFKQkJ6WUNEQXk4QWdzZ0FTQUVSd1JBSUFGQkFXb2hBVUhlQUNFRERLTUNDMEh5QUNFRERMc0NDeUFCSUFSR0JFQkI5QUFoQXd5N0Fnc0NRQ0FCTFFBQVFmRE1BR290QUFCQkFXc09BL2NCY3dDQ0FRdEI0UUFoQXd5aEFnc2dBU0FFUndSQUEwQWdBUzBBQUVId3lnQnFMUUFBSWdCQkEwY0VRQUpBSUFCQkFXc09BdmtCQUlVQkMwSGZBQ0VEREtNQ0N5QUVJQUZCQVdvaUFVY05BQXRCOHdBaEF3eTZBZ3RCOHdBaEF3eTVBZ3NnQVNBRVJ3UkFJQUpCRHpZQ0NDQUNJQUUyQWdSQjRBQWhBd3lnQWd0QjlRQWhBd3k0QWdzZ0FTQUVSZ1JBUWZZQUlRTU11QUlMSUFKQkR6WUNDQ0FDSUFFMkFnUUxRUU1oQXd5ZEFnc0RRQ0FCTFFBQVFTQkhEWTRDSUFRZ0FVRUJhaUlCUncwQUMwSDNBQ0VERExVQ0N5QUJJQVJHQkVCQitBQWhBd3kxQWdzZ0FTMEFBRUVnUncxNklBRkJBV29oQVF4YkMwRUFJUUFDUUNBQ0tBSTRJZ05GRFFBZ0F5Z0NPQ0lEUlEwQUlBSWdBeEVBQUNFQUN5QUFEWGdNZ0FJTElBRWdCRVlFUUVINkFDRURETE1DQ3lBQkxRQUFRY3dBUncxMElBRkJBV29oQVVFVERIWUxRZnNBSVFNZ0FTQUVSZzJ4QWlBQ0tBSUFJZ0FnQkNBQmEyb2hCU0FCSUFCclFRVnFJUVlEUUNBQkxRQUFJQUJCOE00QWFpMEFBRWNOY3lBQVFRVkdEWFVnQUVFQmFpRUFJQVFnQVVFQmFpSUJSdzBBQ3lBQ0lBVTJBZ0FNc1FJTElBRWdCRVlFUUVIOEFDRURETEVDQ3dKQUFrQWdBUzBBQUVIREFHc09EQUIwZEhSMGRIUjBkSFIwQVhRTElBRkJBV29oQVVIbUFDRURESmdDQ3lBQlFRRnFJUUZCNXdBaEF3eVhBZ3RCL1FBaEF5QUJJQVJHRGE4Q0lBSW9BZ0FpQUNBRUlBRnJhaUVGSUFFZ0FHdEJBbW9oQmdKQUEwQWdBUzBBQUNBQVFlM1BBR290QUFCSERYSWdBRUVDUmcwQklBQkJBV29oQUNBRUlBRkJBV29pQVVjTkFBc2dBaUFGTmdJQURMQUNDeUFDUVFBMkFnQWdCa0VCYWlFQlFSQU1jd3RCL2dBaEF5QUJJQVJHRGE0Q0lBSW9BZ0FpQUNBRUlBRnJhaUVGSUFFZ0FHdEJCV29oQmdKQUEwQWdBUzBBQUNBQVFmYk9BR290QUFCSERYRWdBRUVGUmcwQklBQkJBV29oQUNBRUlBRkJBV29pQVVjTkFBc2dBaUFGTmdJQURLOENDeUFDUVFBMkFnQWdCa0VCYWlFQlFSWU1jZ3RCL3dBaEF5QUJJQVJHRGEwQ0lBSW9BZ0FpQUNBRUlBRnJhaUVGSUFFZ0FHdEJBMm9oQmdKQUEwQWdBUzBBQUNBQVFmek9BR290QUFCSERYQWdBRUVEUmcwQklBQkJBV29oQUNBRUlBRkJBV29pQVVjTkFBc2dBaUFGTmdJQURLNENDeUFDUVFBMkFnQWdCa0VCYWlFQlFRVU1jUXNnQVNBRVJnUkFRWUFCSVFNTXJRSUxJQUV0QUFCQjJRQkhEVzRnQVVFQmFpRUJRUWdNY0FzZ0FTQUVSZ1JBUVlFQklRTU1yQUlMQWtBQ1FDQUJMUUFBUWM0QWF3NERBRzhCYndzZ0FVRUJhaUVCUWVzQUlRTU1rd0lMSUFGQkFXb2hBVUhzQUNFRERKSUNDeUFCSUFSR0JFQkJnZ0VoQXd5ckFnc0NRQUpBSUFFdEFBQkJ5QUJyRGdnQWJtNXVibTV1QVc0TElBRkJBV29oQVVIcUFDRURESklDQ3lBQlFRRnFJUUZCN1FBaEF3eVJBZ3RCZ3dFaEF5QUJJQVJHRGFrQ0lBSW9BZ0FpQUNBRUlBRnJhaUVGSUFFZ0FHdEJBbW9oQmdKQUEwQWdBUzBBQUNBQVFZRFBBR290QUFCSERXd2dBRUVDUmcwQklBQkJBV29oQUNBRUlBRkJBV29pQVVjTkFBc2dBaUFGTmdJQURLb0NDeUFDUVFBMkFnQWdCa0VCYWlFQlFRQU1iUXRCaEFFaEF5QUJJQVJHRGFnQ0lBSW9BZ0FpQUNBRUlBRnJhaUVGSUFFZ0FHdEJCR29oQmdKQUEwQWdBUzBBQUNBQVFZUFBBR290QUFCSERXc2dBRUVFUmcwQklBQkJBV29oQUNBRUlBRkJBV29pQVVjTkFBc2dBaUFGTmdJQURLa0NDeUFDUVFBMkFnQWdCa0VCYWlFQlFTTU1iQXNnQVNBRVJnUkFRWVVCSVFNTXFBSUxBa0FDUUNBQkxRQUFRY3dBYXc0SUFHdHJhMnRyYXdGckN5QUJRUUZxSVFGQjd3QWhBd3lQQWdzZ0FVRUJhaUVCUWZBQUlRTU1qZ0lMSUFFZ0JFWUVRRUdHQVNFRERLY0NDeUFCTFFBQVFjVUFSdzFvSUFGQkFXb2hBUXhnQzBHSEFTRURJQUVnQkVZTnBRSWdBaWdDQUNJQUlBUWdBV3RxSVFVZ0FTQUFhMEVEYWlFR0FrQURRQ0FCTFFBQUlBQkJpTThBYWkwQUFFY05hQ0FBUVFOR0RRRWdBRUVCYWlFQUlBUWdBVUVCYWlJQlJ3MEFDeUFDSUFVMkFnQU1wZ0lMSUFKQkFEWUNBQ0FHUVFGcUlRRkJMUXhwQzBHSUFTRURJQUVnQkVZTnBBSWdBaWdDQUNJQUlBUWdBV3RxSVFVZ0FTQUFhMEVJYWlFR0FrQURRQ0FCTFFBQUlBQkIwTThBYWkwQUFFY05aeUFBUVFoR0RRRWdBRUVCYWlFQUlBUWdBVUVCYWlJQlJ3MEFDeUFDSUFVMkFnQU1wUUlMSUFKQkFEWUNBQ0FHUVFGcUlRRkJLUXhvQ3lBQklBUkdCRUJCaVFFaEF3eWtBZ3RCQVNBQkxRQUFRZDhBUncxbkdpQUJRUUZxSVFFTVhndEJpZ0VoQXlBQklBUkdEYUlDSUFJb0FnQWlBQ0FFSUFGcmFpRUZJQUVnQUd0QkFXb2hCZ05BSUFFdEFBQWdBRUdNendCcUxRQUFSdzFrSUFCQkFVWU4rZ0VnQUVFQmFpRUFJQVFnQVVFQmFpSUJSdzBBQ3lBQ0lBVTJBZ0FNb2dJTFFZc0JJUU1nQVNBRVJnMmhBaUFDS0FJQUlnQWdCQ0FCYTJvaEJTQUJJQUJyUVFKcUlRWUNRQU5BSUFFdEFBQWdBRUdPendCcUxRQUFSdzFrSUFCQkFrWU5BU0FBUVFGcUlRQWdCQ0FCUVFGcUlnRkhEUUFMSUFJZ0JUWUNBQXlpQWdzZ0FrRUFOZ0lBSUFaQkFXb2hBVUVDREdVTFFZd0JJUU1nQVNBRVJnMmdBaUFDS0FJQUlnQWdCQ0FCYTJvaEJTQUJJQUJyUVFGcUlRWUNRQU5BSUFFdEFBQWdBRUh3endCcUxRQUFSdzFqSUFCQkFVWU5BU0FBUVFGcUlRQWdCQ0FCUVFGcUlnRkhEUUFMSUFJZ0JUWUNBQXloQWdzZ0FrRUFOZ0lBSUFaQkFXb2hBVUVmREdRTFFZMEJJUU1nQVNBRVJnMmZBaUFDS0FJQUlnQWdCQ0FCYTJvaEJTQUJJQUJyUVFGcUlRWUNRQU5BSUFFdEFBQWdBRUh5endCcUxRQUFSdzFpSUFCQkFVWU5BU0FBUVFGcUlRQWdCQ0FCUVFGcUlnRkhEUUFMSUFJZ0JUWUNBQXlnQWdzZ0FrRUFOZ0lBSUFaQkFXb2hBVUVKREdNTElBRWdCRVlFUUVHT0FTRURESjhDQ3dKQUFrQWdBUzBBQUVISkFHc09Cd0JpWW1KaVlnRmlDeUFCUVFGcUlRRkIrQUFoQXd5R0Fnc2dBVUVCYWlFQlFma0FJUU1NaFFJTFFZOEJJUU1nQVNBRVJnMmRBaUFDS0FJQUlnQWdCQ0FCYTJvaEJTQUJJQUJyUVFWcUlRWUNRQU5BSUFFdEFBQWdBRUdSendCcUxRQUFSdzFnSUFCQkJVWU5BU0FBUVFGcUlRQWdCQ0FCUVFGcUlnRkhEUUFMSUFJZ0JUWUNBQXllQWdzZ0FrRUFOZ0lBSUFaQkFXb2hBVUVZREdFTFFaQUJJUU1nQVNBRVJnMmNBaUFDS0FJQUlnQWdCQ0FCYTJvaEJTQUJJQUJyUVFKcUlRWUNRQU5BSUFFdEFBQWdBRUdYendCcUxRQUFSdzFmSUFCQkFrWU5BU0FBUVFGcUlRQWdCQ0FCUVFGcUlnRkhEUUFMSUFJZ0JUWUNBQXlkQWdzZ0FrRUFOZ0lBSUFaQkFXb2hBVUVYREdBTFFaRUJJUU1nQVNBRVJnMmJBaUFDS0FJQUlnQWdCQ0FCYTJvaEJTQUJJQUJyUVFacUlRWUNRQU5BSUFFdEFBQWdBRUdhendCcUxRQUFSdzFlSUFCQkJrWU5BU0FBUVFGcUlRQWdCQ0FCUVFGcUlnRkhEUUFMSUFJZ0JUWUNBQXljQWdzZ0FrRUFOZ0lBSUFaQkFXb2hBVUVWREY4TFFaSUJJUU1nQVNBRVJnMmFBaUFDS0FJQUlnQWdCQ0FCYTJvaEJTQUJJQUJyUVFWcUlRWUNRQU5BSUFFdEFBQWdBRUdoendCcUxRQUFSdzFkSUFCQkJVWU5BU0FBUVFGcUlRQWdCQ0FCUVFGcUlnRkhEUUFMSUFJZ0JUWUNBQXliQWdzZ0FrRUFOZ0lBSUFaQkFXb2hBVUVlREY0TElBRWdCRVlFUUVHVEFTRURESm9DQ3lBQkxRQUFRY3dBUncxYklBRkJBV29oQVVFS0RGMExJQUVnQkVZRVFFR1VBU0VEREprQ0N3SkFBa0FnQVMwQUFFSEJBR3NPRHdCY1hGeGNYRnhjWEZ4Y1hGeGNBVndMSUFGQkFXb2hBVUgrQUNFRERJQUNDeUFCUVFGcUlRRkIvd0FoQXd6L0FRc2dBU0FFUmdSQVFaVUJJUU1NbUFJTEFrQUNRQ0FCTFFBQVFjRUFhdzREQUZzQld3c2dBVUVCYWlFQlFmMEFJUU1NL3dFTElBRkJBV29oQVVHQUFTRUREUDRCQzBHV0FTRURJQUVnQkVZTmxnSWdBaWdDQUNJQUlBUWdBV3RxSVFVZ0FTQUFhMEVCYWlFR0FrQURRQ0FCTFFBQUlBQkJwODhBYWkwQUFFY05XU0FBUVFGR0RRRWdBRUVCYWlFQUlBUWdBVUVCYWlJQlJ3MEFDeUFDSUFVMkFnQU1sd0lMSUFKQkFEWUNBQ0FHUVFGcUlRRkJDd3hhQ3lBQklBUkdCRUJCbHdFaEF3eVdBZ3NDUUFKQUFrQUNRQ0FCTFFBQVFTMXJEaU1BVzF0YlcxdGJXMXRiVzF0YlcxdGJXMXRiVzF0Ylcxc0JXMXRiVzFzQ1cxdGJBMXNMSUFGQkFXb2hBVUg3QUNFRERQOEJDeUFCUVFGcUlRRkIvQUFoQXd6K0FRc2dBVUVCYWlFQlFZRUJJUU1NL1FFTElBRkJBV29oQVVHQ0FTRUREUHdCQzBHWUFTRURJQUVnQkVZTmxBSWdBaWdDQUNJQUlBUWdBV3RxSVFVZ0FTQUFhMEVFYWlFR0FrQURRQ0FCTFFBQUlBQkJxYzhBYWkwQUFFY05WeUFBUVFSR0RRRWdBRUVCYWlFQUlBUWdBVUVCYWlJQlJ3MEFDeUFDSUFVMkFnQU1sUUlMSUFKQkFEWUNBQ0FHUVFGcUlRRkJHUXhZQzBHWkFTRURJQUVnQkVZTmt3SWdBaWdDQUNJQUlBUWdBV3RxSVFVZ0FTQUFhMEVGYWlFR0FrQURRQ0FCTFFBQUlBQkJyczhBYWkwQUFFY05WaUFBUVFWR0RRRWdBRUVCYWlFQUlBUWdBVUVCYWlJQlJ3MEFDeUFDSUFVMkFnQU1sQUlMSUFKQkFEWUNBQ0FHUVFGcUlRRkJCZ3hYQzBHYUFTRURJQUVnQkVZTmtnSWdBaWdDQUNJQUlBUWdBV3RxSVFVZ0FTQUFhMEVCYWlFR0FrQURRQ0FCTFFBQUlBQkJ0TThBYWkwQUFFY05WU0FBUVFGR0RRRWdBRUVCYWlFQUlBUWdBVUVCYWlJQlJ3MEFDeUFDSUFVMkFnQU1rd0lMSUFKQkFEWUNBQ0FHUVFGcUlRRkJIQXhXQzBHYkFTRURJQUVnQkVZTmtRSWdBaWdDQUNJQUlBUWdBV3RxSVFVZ0FTQUFhMEVCYWlFR0FrQURRQ0FCTFFBQUlBQkJ0czhBYWkwQUFFY05WQ0FBUVFGR0RRRWdBRUVCYWlFQUlBUWdBVUVCYWlJQlJ3MEFDeUFDSUFVMkFnQU1rZ0lMSUFKQkFEWUNBQ0FHUVFGcUlRRkJKd3hWQ3lBQklBUkdCRUJCbkFFaEF3eVJBZ3NDUUFKQUlBRXRBQUJCMUFCckRnSUFBVlFMSUFGQkFXb2hBVUdHQVNFRERQZ0JDeUFCUVFGcUlRRkJod0VoQXd6M0FRdEJuUUVoQXlBQklBUkdEWThDSUFJb0FnQWlBQ0FFSUFGcmFpRUZJQUVnQUd0QkFXb2hCZ0pBQTBBZ0FTMEFBQ0FBUWJqUEFHb3RBQUJIRFZJZ0FFRUJSZzBCSUFCQkFXb2hBQ0FFSUFGQkFXb2lBVWNOQUFzZ0FpQUZOZ0lBREpBQ0N5QUNRUUEyQWdBZ0JrRUJhaUVCUVNZTVV3dEJuZ0VoQXlBQklBUkdEWTRDSUFJb0FnQWlBQ0FFSUFGcmFpRUZJQUVnQUd0QkFXb2hCZ0pBQTBBZ0FTMEFBQ0FBUWJyUEFHb3RBQUJIRFZFZ0FFRUJSZzBCSUFCQkFXb2hBQ0FFSUFGQkFXb2lBVWNOQUFzZ0FpQUZOZ0lBREk4Q0N5QUNRUUEyQWdBZ0JrRUJhaUVCUVFNTVVndEJud0VoQXlBQklBUkdEWTBDSUFJb0FnQWlBQ0FFSUFGcmFpRUZJQUVnQUd0QkFtb2hCZ0pBQTBBZ0FTMEFBQ0FBUWUzUEFHb3RBQUJIRFZBZ0FFRUNSZzBCSUFCQkFXb2hBQ0FFSUFGQkFXb2lBVWNOQUFzZ0FpQUZOZ0lBREk0Q0N5QUNRUUEyQWdBZ0JrRUJhaUVCUVF3TVVRdEJvQUVoQXlBQklBUkdEWXdDSUFJb0FnQWlBQ0FFSUFGcmFpRUZJQUVnQUd0QkEyb2hCZ0pBQTBBZ0FTMEFBQ0FBUWJ6UEFHb3RBQUJIRFU4Z0FFRURSZzBCSUFCQkFXb2hBQ0FFSUFGQkFXb2lBVWNOQUFzZ0FpQUZOZ0lBREkwQ0N5QUNRUUEyQWdBZ0JrRUJhaUVCUVEwTVVBc2dBU0FFUmdSQVFhRUJJUU1NakFJTEFrQUNRQ0FCTFFBQVFjWUFhdzRMQUU5UFQwOVBUMDlQVHdGUEN5QUJRUUZxSVFGQml3RWhBd3p6QVFzZ0FVRUJhaUVCUVl3QklRTU04Z0VMSUFFZ0JFWUVRRUdpQVNFRERJc0NDeUFCTFFBQVFkQUFSdzFNSUFGQkFXb2hBUXhHQ3lBQklBUkdCRUJCb3dFaEF3eUtBZ3NDUUFKQUlBRXRBQUJCeVFCckRnY0JUVTFOVFUwQVRRc2dBVUVCYWlFQlFZNEJJUU1NOFFFTElBRkJBV29oQVVFaURFMExRYVFCSVFNZ0FTQUVSZzJJQWlBQ0tBSUFJZ0FnQkNBQmEyb2hCU0FCSUFCclFRRnFJUVlDUUFOQUlBRXRBQUFnQUVIQXp3QnFMUUFBUncxTElBQkJBVVlOQVNBQVFRRnFJUUFnQkNBQlFRRnFJZ0ZIRFFBTElBSWdCVFlDQUF5SkFnc2dBa0VBTmdJQUlBWkJBV29oQVVFZERFd0xJQUVnQkVZRVFFR2xBU0VERElnQ0N3SkFBa0FnQVMwQUFFSFNBR3NPQXdCTEFVc0xJQUZCQVdvaEFVR1FBU0VERE84QkN5QUJRUUZxSVFGQkJBeExDeUFCSUFSR0JFQkJwZ0VoQXd5SEFnc0NRQUpBQWtBQ1FBSkFJQUV0QUFCQndRQnJEaFVBVFUxTlRVMU5UVTFOVFFGTlRRSk5UUU5OVFFSTkN5QUJRUUZxSVFGQmlBRWhBd3p4QVFzZ0FVRUJhaUVCUVlrQklRTU04QUVMSUFGQkFXb2hBVUdLQVNFRERPOEJDeUFCUVFGcUlRRkJqd0VoQXd6dUFRc2dBVUVCYWlFQlFaRUJJUU1NN1FFTFFhY0JJUU1nQVNBRVJnMkZBaUFDS0FJQUlnQWdCQ0FCYTJvaEJTQUJJQUJyUVFKcUlRWUNRQU5BSUFFdEFBQWdBRUh0endCcUxRQUFSdzFJSUFCQkFrWU5BU0FBUVFGcUlRQWdCQ0FCUVFGcUlnRkhEUUFMSUFJZ0JUWUNBQXlHQWdzZ0FrRUFOZ0lBSUFaQkFXb2hBVUVSREVrTFFhZ0JJUU1nQVNBRVJnMkVBaUFDS0FJQUlnQWdCQ0FCYTJvaEJTQUJJQUJyUVFKcUlRWUNRQU5BSUFFdEFBQWdBRUhDendCcUxRQUFSdzFISUFCQkFrWU5BU0FBUVFGcUlRQWdCQ0FCUVFGcUlnRkhEUUFMSUFJZ0JUWUNBQXlGQWdzZ0FrRUFOZ0lBSUFaQkFXb2hBVUVzREVnTFFha0JJUU1nQVNBRVJnMkRBaUFDS0FJQUlnQWdCQ0FCYTJvaEJTQUJJQUJyUVFScUlRWUNRQU5BSUFFdEFBQWdBRUhGendCcUxRQUFSdzFHSUFCQkJFWU5BU0FBUVFGcUlRQWdCQ0FCUVFGcUlnRkhEUUFMSUFJZ0JUWUNBQXlFQWdzZ0FrRUFOZ0lBSUFaQkFXb2hBVUVyREVjTFFhb0JJUU1nQVNBRVJnMkNBaUFDS0FJQUlnQWdCQ0FCYTJvaEJTQUJJQUJyUVFKcUlRWUNRQU5BSUFFdEFBQWdBRUhLendCcUxRQUFSdzFGSUFCQkFrWU5BU0FBUVFGcUlRQWdCQ0FCUVFGcUlnRkhEUUFMSUFJZ0JUWUNBQXlEQWdzZ0FrRUFOZ0lBSUFaQkFXb2hBVUVVREVZTElBRWdCRVlFUUVHckFTRURESUlDQ3dKQUFrQUNRQUpBSUFFdEFBQkJ3Z0JyRGc4QUFRSkhSMGRIUjBkSFIwZEhSd05IQ3lBQlFRRnFJUUZCa3dFaEF3enJBUXNnQVVFQmFpRUJRWlFCSVFNTTZnRUxJQUZCQVdvaEFVR1ZBU0VERE9rQkN5QUJRUUZxSVFGQmxnRWhBd3pvQVFzZ0FTQUVSZ1JBUWF3QklRTU1nUUlMSUFFdEFBQkJ4UUJIRFVJZ0FVRUJhaUVCREQwTFFhMEJJUU1nQVNBRVJnMy9BU0FDS0FJQUlnQWdCQ0FCYTJvaEJTQUJJQUJyUVFKcUlRWUNRQU5BSUFFdEFBQWdBRUhOendCcUxRQUFSdzFDSUFCQkFrWU5BU0FBUVFGcUlRQWdCQ0FCUVFGcUlnRkhEUUFMSUFJZ0JUWUNBQXlBQWdzZ0FrRUFOZ0lBSUFaQkFXb2hBVUVPREVNTElBRWdCRVlFUUVHdUFTRUREUDhCQ3lBQkxRQUFRZEFBUncxQUlBRkJBV29oQVVFbERFSUxRYThCSVFNZ0FTQUVSZzM5QVNBQ0tBSUFJZ0FnQkNBQmEyb2hCU0FCSUFCclFRaHFJUVlDUUFOQUlBRXRBQUFnQUVIUXp3QnFMUUFBUncxQUlBQkJDRVlOQVNBQVFRRnFJUUFnQkNBQlFRRnFJZ0ZIRFFBTElBSWdCVFlDQUF6K0FRc2dBa0VBTmdJQUlBWkJBV29oQVVFcURFRUxJQUVnQkVZRVFFR3dBU0VERFAwQkN3SkFBa0FnQVMwQUFFSFZBR3NPQ3dCQVFFQkFRRUJBUUVBQlFBc2dBVUVCYWlFQlFab0JJUU1NNUFFTElBRkJBV29oQVVHYkFTRURET01CQ3lBQklBUkdCRUJCc1FFaEF3ejhBUXNDUUFKQUlBRXRBQUJCd1FCckRoUUFQejgvUHo4L1B6OC9QejgvUHo4L1B6OC9BVDhMSUFGQkFXb2hBVUdaQVNFRERPTUJDeUFCUVFGcUlRRkJuQUVoQXd6aUFRdEJzZ0VoQXlBQklBUkdEZm9CSUFJb0FnQWlBQ0FFSUFGcmFpRUZJQUVnQUd0QkEyb2hCZ0pBQTBBZ0FTMEFBQ0FBUWRuUEFHb3RBQUJIRFQwZ0FFRURSZzBCSUFCQkFXb2hBQ0FFSUFGQkFXb2lBVWNOQUFzZ0FpQUZOZ0lBRFBzQkN5QUNRUUEyQWdBZ0JrRUJhaUVCUVNFTVBndEJzd0VoQXlBQklBUkdEZmtCSUFJb0FnQWlBQ0FFSUFGcmFpRUZJQUVnQUd0QkJtb2hCZ0pBQTBBZ0FTMEFBQ0FBUWQzUEFHb3RBQUJIRFR3Z0FFRUdSZzBCSUFCQkFXb2hBQ0FFSUFGQkFXb2lBVWNOQUFzZ0FpQUZOZ0lBRFBvQkN5QUNRUUEyQWdBZ0JrRUJhaUVCUVJvTVBRc2dBU0FFUmdSQVFiUUJJUU1NK1FFTEFrQUNRQUpBSUFFdEFBQkJ4UUJyRGhFQVBUMDlQVDA5UFQwOUFUMDlQVDA5QWowTElBRkJBV29oQVVHZEFTRURET0VCQ3lBQlFRRnFJUUZCbmdFaEF3emdBUXNnQVVFQmFpRUJRWjhCSVFNTTN3RUxRYlVCSVFNZ0FTQUVSZzMzQVNBQ0tBSUFJZ0FnQkNBQmEyb2hCU0FCSUFCclFRVnFJUVlDUUFOQUlBRXRBQUFnQUVIa3p3QnFMUUFBUncwNklBQkJCVVlOQVNBQVFRRnFJUUFnQkNBQlFRRnFJZ0ZIRFFBTElBSWdCVFlDQUF6NEFRc2dBa0VBTmdJQUlBWkJBV29oQVVFb0REc0xRYllCSVFNZ0FTQUVSZzMyQVNBQ0tBSUFJZ0FnQkNBQmEyb2hCU0FCSUFCclFRSnFJUVlDUUFOQUlBRXRBQUFnQUVIcXp3QnFMUUFBUncwNUlBQkJBa1lOQVNBQVFRRnFJUUFnQkNBQlFRRnFJZ0ZIRFFBTElBSWdCVFlDQUF6M0FRc2dBa0VBTmdJQUlBWkJBV29oQVVFSEREb0xJQUVnQkVZRVFFRzNBU0VERFBZQkN3SkFBa0FnQVMwQUFFSEZBR3NPRGdBNU9UazVPVGs1T1RrNU9Ua0JPUXNnQVVFQmFpRUJRYUVCSVFNTTNRRUxJQUZCQVdvaEFVR2lBU0VERE53QkMwRzRBU0VESUFFZ0JFWU45QUVnQWlnQ0FDSUFJQVFnQVd0cUlRVWdBU0FBYTBFQ2FpRUdBa0FEUUNBQkxRQUFJQUJCN2M4QWFpMEFBRWNOTnlBQVFRSkdEUUVnQUVFQmFpRUFJQVFnQVVFQmFpSUJSdzBBQ3lBQ0lBVTJBZ0FNOVFFTElBSkJBRFlDQUNBR1FRRnFJUUZCRWd3NEMwRzVBU0VESUFFZ0JFWU44d0VnQWlnQ0FDSUFJQVFnQVd0cUlRVWdBU0FBYTBFQmFpRUdBa0FEUUNBQkxRQUFJQUJCOE04QWFpMEFBRWNOTmlBQVFRRkdEUUVnQUVFQmFpRUFJQVFnQVVFQmFpSUJSdzBBQ3lBQ0lBVTJBZ0FNOUFFTElBSkJBRFlDQUNBR1FRRnFJUUZCSUF3M0MwRzZBU0VESUFFZ0JFWU44Z0VnQWlnQ0FDSUFJQVFnQVd0cUlRVWdBU0FBYTBFQmFpRUdBa0FEUUNBQkxRQUFJQUJCOHM4QWFpMEFBRWNOTlNBQVFRRkdEUUVnQUVFQmFpRUFJQVFnQVVFQmFpSUJSdzBBQ3lBQ0lBVTJBZ0FNOHdFTElBSkJBRFlDQUNBR1FRRnFJUUZCRHd3MkN5QUJJQVJHQkVCQnV3RWhBd3p5QVFzQ1FBSkFJQUV0QUFCQnlRQnJEZ2NBTlRVMU5UVUJOUXNnQVVFQmFpRUJRYVVCSVFNTTJRRUxJQUZCQVdvaEFVR21BU0VERE5nQkMwRzhBU0VESUFFZ0JFWU44QUVnQWlnQ0FDSUFJQVFnQVd0cUlRVWdBU0FBYTBFSGFpRUdBa0FEUUNBQkxRQUFJQUJCOU04QWFpMEFBRWNOTXlBQVFRZEdEUUVnQUVFQmFpRUFJQVFnQVVFQmFpSUJSdzBBQ3lBQ0lBVTJBZ0FNOFFFTElBSkJBRFlDQUNBR1FRRnFJUUZCR3d3MEN5QUJJQVJHQkVCQnZRRWhBd3p3QVFzQ1FBSkFBa0FnQVMwQUFFSENBR3NPRWdBME5EUTBORFEwTkRRQk5EUTBORFEwQWpRTElBRkJBV29oQVVHa0FTRURETmdCQ3lBQlFRRnFJUUZCcHdFaEF3elhBUXNnQVVFQmFpRUJRYWdCSVFNTTFnRUxJQUVnQkVZRVFFRytBU0VERE84QkN5QUJMUUFBUWM0QVJ3MHdJQUZCQVdvaEFRd3NDeUFCSUFSR0JFQkJ2d0VoQXd6dUFRc0NRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUNBQkxRQUFRY0VBYXc0VkFBRUNBejhFQlFZL1B6OEhDQWtLQ3o4TURRNFBQd3NnQVVFQmFpRUJRZWdBSVFNTTR3RUxJQUZCQVdvaEFVSHBBQ0VERE9JQkN5QUJRUUZxSVFGQjdnQWhBd3poQVFzZ0FVRUJhaUVCUWZJQUlRTU00QUVMSUFGQkFXb2hBVUh6QUNFREROOEJDeUFCUVFGcUlRRkI5Z0FoQXd6ZUFRc2dBVUVCYWlFQlFmY0FJUU1NM1FFTElBRkJBV29oQVVINkFDRURETndCQ3lBQlFRRnFJUUZCZ3dFaEF3emJBUXNnQVVFQmFpRUJRWVFCSVFNTTJnRUxJQUZCQVdvaEFVR0ZBU0VERE5rQkN5QUJRUUZxSVFGQmtnRWhBd3pZQVFzZ0FVRUJhaUVCUVpnQklRTU0xd0VMSUFGQkFXb2hBVUdnQVNFREROWUJDeUFCUVFGcUlRRkJvd0VoQXd6VkFRc2dBVUVCYWlFQlFhb0JJUU1NMUFFTElBRWdCRWNFUUNBQ1FSQTJBZ2dnQWlBQk5nSUVRYXNCSVFNTTFBRUxRY0FCSVFNTTdBRUxRUUFoQUFKQUlBSW9BamdpQTBVTkFDQURLQUkwSWdORkRRQWdBaUFERVFBQUlRQUxJQUJGRFY0Z0FFRVZSdzBISUFKQjBRQTJBaHdnQWlBQk5nSVVJQUpCc0JjMkFoQWdBa0VWTmdJTVFRQWhBd3pyQVFzZ0FVRUJhaUFCSUFSSERRZ2FRY0lCSVFNTTZnRUxBMEFDUUNBQkxRQUFRUXByRGdRSUFBQUxBQXNnQkNBQlFRRnFJZ0ZIRFFBTFFjTUJJUU1NNlFFTElBRWdCRWNFUUNBQ1FSRTJBZ2dnQWlBQk5nSUVRUUVoQXd6UUFRdEJ4QUVoQXd6b0FRc2dBU0FFUmdSQVFjVUJJUU1NNkFFTEFrQUNRQ0FCTFFBQVFRcHJEZ1FCS0NnQUtBc2dBVUVCYWd3SkN5QUJRUUZxREFVTElBRWdCRVlFUUVIR0FTRURET2NCQ3dKQUFrQWdBUzBBQUVFS2F3NFhBUXNMQVFzTEN3c0xDd3NMQ3dzTEN3c0xDd3NMQ3dBTEN5QUJRUUZxSVFFTFFiQUJJUU1NelFFTElBRWdCRVlFUUVISUFTRURET1lCQ3lBQkxRQUFRU0JIRFFrZ0FrRUFPd0V5SUFGQkFXb2hBVUd6QVNFRERNd0JDd05BSUFFaEFBSkFJQUVnQkVjRVFDQUJMUUFBUVRCclFmOEJjU0lEUVFwSkRRRU1Kd3RCeHdFaEF3em1BUXNDUUNBQ0x3RXlJZ0ZCbVROTERRQWdBaUFCUVFwc0lnVTdBVElnQlVIKy93TnhJQU5CLy84RGMwc05BQ0FBUVFGcUlRRWdBaUFESUFWcUlnTTdBVElnQTBILy93TnhRZWdIU1EwQkN3dEJBQ0VESUFKQkFEWUNIQ0FDUWNFSk5nSVFJQUpCRFRZQ0RDQUNJQUJCQVdvMkFoUU01QUVMSUFKQkFEWUNIQ0FDSUFFMkFoUWdBa0h3RERZQ0VDQUNRUnMyQWd4QkFDRURET01CQ3lBQ0tBSUVJUUFnQWtFQU5nSUVJQUlnQUNBQkVDWWlBQTBCSUFGQkFXb0xJUUZCclFFaEF3eklBUXNnQWtIQkFUWUNIQ0FDSUFBMkFnd2dBaUFCUVFGcU5nSVVRUUFoQXd6Z0FRc2dBaWdDQkNFQUlBSkJBRFlDQkNBQ0lBQWdBUkFtSWdBTkFTQUJRUUZxQ3lFQlFhNEJJUU1NeFFFTElBSkJ3Z0UyQWh3Z0FpQUFOZ0lNSUFJZ0FVRUJhallDRkVFQUlRTU0zUUVMSUFKQkFEWUNIQ0FDSUFFMkFoUWdBa0dYQ3pZQ0VDQUNRUTAyQWd4QkFDRURETndCQ3lBQ1FRQTJBaHdnQWlBQk5nSVVJQUpCNHhBMkFoQWdBa0VKTmdJTVFRQWhBd3piQVFzZ0FrRUNPZ0FvREt3QkMwRUFJUU1nQWtFQU5nSWNJQUpCcndzMkFoQWdBa0VDTmdJTUlBSWdBVUVCYWpZQ0ZBelpBUXRCQWlFRERMOEJDMEVOSVFNTXZnRUxRU1loQXd5OUFRdEJGU0VEREx3QkMwRVdJUU1NdXdFTFFSZ2hBd3k2QVF0QkhDRURETGtCQzBFZElRTU11QUVMUVNBaEF3eTNBUXRCSVNFRERMWUJDMEVqSVFNTXRRRUxRY1lBSVFNTXRBRUxRUzRoQXd5ekFRdEJQU0VERExJQkMwSExBQ0VERExFQkMwSE9BQ0VERExBQkMwSFlBQ0VEREs4QkMwSFpBQ0VEREs0QkMwSGJBQ0VEREswQkMwSHhBQ0VEREt3QkMwSDBBQ0VEREtzQkMwR05BU0VEREtvQkMwR1hBU0VEREtrQkMwR3BBU0VEREtnQkMwR3ZBU0VEREtjQkMwR3hBU0VEREtZQkN5QUNRUUEyQWdBTFFRQWhBeUFDUVFBMkFod2dBaUFCTmdJVUlBSkI4UnMyQWhBZ0FrRUdOZ0lNREwwQkN5QUNRUUEyQWdBZ0JrRUJhaUVCUVNRTE9nQXBJQUlvQWdRaEFDQUNRUUEyQWdRZ0FpQUFJQUVRSnlJQVJRUkFRZVVBSVFNTW93RUxJQUpCK1FBMkFod2dBaUFCTmdJVUlBSWdBRFlDREVFQUlRTU11d0VMSUFCQkZVY0VRQ0FDUVFBMkFod2dBaUFCTmdJVUlBSkJ6QTQyQWhBZ0FrRWdOZ0lNUVFBaEF3eTdBUXNnQWtINEFEWUNIQ0FDSUFFMkFoUWdBa0hLR0RZQ0VDQUNRUlUyQWd4QkFDRURETG9CQ3lBQ1FRQTJBaHdnQWlBQk5nSVVJQUpCamhzMkFoQWdBa0VHTmdJTVFRQWhBd3k1QVFzZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUWY0Uk5nSVFJQUpCQnpZQ0RFRUFJUU1NdUFFTElBSkJBRFlDSENBQ0lBRTJBaFFnQWtHTUhEWUNFQ0FDUVFjMkFneEJBQ0VERExjQkN5QUNRUUEyQWh3Z0FpQUJOZ0lVSUFKQnd3ODJBaEFnQWtFSE5nSU1RUUFoQXd5MkFRc2dBa0VBTmdJY0lBSWdBVFlDRkNBQ1FjTVBOZ0lRSUFKQkJ6WUNERUVBSVFNTXRRRUxJQUlvQWdRaEFDQUNRUUEyQWdRZ0FpQUFJQUVRSlNJQVJRMFJJQUpCNVFBMkFod2dBaUFCTmdJVUlBSWdBRFlDREVFQUlRTU10QUVMSUFJb0FnUWhBQ0FDUVFBMkFnUWdBaUFBSUFFUUpTSUFSUTBnSUFKQjB3QTJBaHdnQWlBQk5nSVVJQUlnQURZQ0RFRUFJUU1Nc3dFTElBSW9BZ1FoQUNBQ1FRQTJBZ1FnQWlBQUlBRVFKU0lBUlEwaUlBSkIwZ0EyQWh3Z0FpQUJOZ0lVSUFJZ0FEWUNERUVBSVFNTXNnRUxJQUlvQWdRaEFDQUNRUUEyQWdRZ0FpQUFJQUVRSlNJQVJRME9JQUpCNVFBMkFod2dBaUFCTmdJVUlBSWdBRFlDREVFQUlRTU1zUUVMSUFJb0FnUWhBQ0FDUVFBMkFnUWdBaUFBSUFFUUpTSUFSUTBkSUFKQjB3QTJBaHdnQWlBQk5nSVVJQUlnQURZQ0RFRUFJUU1Nc0FFTElBSW9BZ1FoQUNBQ1FRQTJBZ1FnQWlBQUlBRVFKU0lBUlEwZklBSkIwZ0EyQWh3Z0FpQUJOZ0lVSUFJZ0FEWUNERUVBSVFNTXJ3RUxJQUJCUDBjTkFTQUJRUUZxQ3lFQlFRVWhBd3lVQVF0QkFDRURJQUpCQURZQ0hDQUNJQUUyQWhRZ0FrSDlFallDRUNBQ1FRYzJBZ3dNckFFTElBSkJBRFlDSENBQ0lBRTJBaFFnQWtIY0NEWUNFQ0FDUVFjMkFneEJBQ0VEREtzQkN5QUNLQUlFSVFBZ0FrRUFOZ0lFSUFJZ0FDQUJFQ1VpQUVVTkJ5QUNRZVVBTmdJY0lBSWdBVFlDRkNBQ0lBQTJBZ3hCQUNFRERLb0JDeUFDS0FJRUlRQWdBa0VBTmdJRUlBSWdBQ0FCRUNVaUFFVU5GaUFDUWRNQU5nSWNJQUlnQVRZQ0ZDQUNJQUEyQWd4QkFDRURES2tCQ3lBQ0tBSUVJUUFnQWtFQU5nSUVJQUlnQUNBQkVDVWlBRVVOR0NBQ1FkSUFOZ0ljSUFJZ0FUWUNGQ0FDSUFBMkFneEJBQ0VEREtnQkN5QUNRUUEyQWh3Z0FpQUJOZ0lVSUFKQnhnbzJBaEFnQWtFSE5nSU1RUUFoQXd5bkFRc2dBaWdDQkNFQUlBSkJBRFlDQkNBQ0lBQWdBUkFsSWdCRkRRTWdBa0hsQURZQ0hDQUNJQUUyQWhRZ0FpQUFOZ0lNUVFBaEF3eW1BUXNnQWlnQ0JDRUFJQUpCQURZQ0JDQUNJQUFnQVJBbElnQkZEUklnQWtIVEFEWUNIQ0FDSUFFMkFoUWdBaUFBTmdJTVFRQWhBd3lsQVFzZ0FpZ0NCQ0VBSUFKQkFEWUNCQ0FDSUFBZ0FSQWxJZ0JGRFJRZ0FrSFNBRFlDSENBQ0lBRTJBaFFnQWlBQU5nSU1RUUFoQXd5a0FRc2dBaWdDQkNFQUlBSkJBRFlDQkNBQ0lBQWdBUkFsSWdCRkRRQWdBa0hsQURZQ0hDQUNJQUUyQWhRZ0FpQUFOZ0lNUVFBaEF3eWpBUXRCMVFBaEF3eUpBUXNnQUVFVlJ3UkFJQUpCQURZQ0hDQUNJQUUyQWhRZ0FrRzVEVFlDRUNBQ1FSbzJBZ3hCQUNFRERLSUJDeUFDUWVRQU5nSWNJQUlnQVRZQ0ZDQUNRZU1YTmdJUUlBSkJGVFlDREVFQUlRTU1vUUVMSUFKQkFEWUNBQ0FHUVFGcUlRRWdBaTBBS1NJQVFTTnJRUXRKRFFRQ1FDQUFRUVpMRFFCQkFTQUFkRUhLQUhGRkRRQU1CUXRCQUNFRElBSkJBRFlDSENBQ0lBRTJBaFFnQWtIM0NUWUNFQ0FDUVFnMkFnd01vQUVMSUFKQkFEWUNBQ0FHUVFGcUlRRWdBaTBBS1VFaFJnMERJQUpCQURZQ0hDQUNJQUUyQWhRZ0FrR2JDallDRUNBQ1FRZzJBZ3hCQUNFRERKOEJDeUFDUVFBMkFnQUxRUUFoQXlBQ1FRQTJBaHdnQWlBQk5nSVVJQUpCa0RNMkFoQWdBa0VJTmdJTURKMEJDeUFDUVFBMkFnQWdCa0VCYWlFQklBSXRBQ2xCSTBrTkFDQUNRUUEyQWh3Z0FpQUJOZ0lVSUFKQjB3azJBaEFnQWtFSU5nSU1RUUFoQXd5Y0FRdEIwUUFoQXd5Q0FRc2dBUzBBQUVFd2F5SUFRZjhCY1VFS1NRUkFJQUlnQURvQUtpQUJRUUZxSVFGQnp3QWhBd3lDQVFzZ0FpZ0NCQ0VBSUFKQkFEWUNCQ0FDSUFBZ0FSQW9JZ0JGRFlZQklBSkIzZ0EyQWh3Z0FpQUJOZ0lVSUFJZ0FEWUNERUVBSVFNTW1nRUxJQUlvQWdRaEFDQUNRUUEyQWdRZ0FpQUFJQUVRS0NJQVJRMkdBU0FDUWR3QU5nSWNJQUlnQVRZQ0ZDQUNJQUEyQWd4QkFDRURESmtCQ3lBQ0tBSUVJUUFnQWtFQU5nSUVJQUlnQUNBRkVDZ2lBRVVFUUNBRklRRU1od0VMSUFKQjJnQTJBaHdnQWlBRk5nSVVJQUlnQURZQ0RBeVlBUXRCQUNFQlFRRWhBd3NnQWlBRE9nQXJJQVZCQVdvaEF3SkFBa0FDUUNBQ0xRQXRRUkJ4RFFBQ1FBSkFBa0FnQWkwQUtnNERBUUFDQkFzZ0JrVU5Bd3dDQ3lBQURRRU1BZ3NnQVVVTkFRc2dBaWdDQkNFQUlBSkJBRFlDQkNBQ0lBQWdBeEFvSWdCRkJFQWdBeUVCREFJTElBSkIyQUEyQWh3Z0FpQUROZ0lVSUFJZ0FEWUNERUVBSVFNTW1BRUxJQUlvQWdRaEFDQUNRUUEyQWdRZ0FpQUFJQU1RS0NJQVJRUkFJQU1oQVF5SEFRc2dBa0haQURZQ0hDQUNJQU0yQWhRZ0FpQUFOZ0lNUVFBaEF3eVhBUXRCekFBaEF3eDlDeUFBUVJWSEJFQWdBa0VBTmdJY0lBSWdBVFlDRkNBQ1FaUU5OZ0lRSUFKQklUWUNERUVBSVFNTWxnRUxJQUpCMXdBMkFod2dBaUFCTmdJVUlBSkJ5UmMyQWhBZ0FrRVZOZ0lNUVFBaEF3eVZBUXRCQUNFRElBSkJBRFlDSENBQ0lBRTJBaFFnQWtHQUVUWUNFQ0FDUVFrMkFnd01sQUVMSUFJb0FnUWhBQ0FDUVFBMkFnUWdBaUFBSUFFUUpTSUFSUTBBSUFKQjB3QTJBaHdnQWlBQk5nSVVJQUlnQURZQ0RFRUFJUU1Na3dFTFFja0FJUU1NZVFzZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUWNFb05nSVFJQUpCQnpZQ0RDQUNRUUEyQWdCQkFDRURESkVCQ3lBQ0tBSUVJUUJCQUNFRElBSkJBRFlDQkNBQ0lBQWdBUkFsSWdCRkRRQWdBa0hTQURZQ0hDQUNJQUUyQWhRZ0FpQUFOZ0lNREpBQkMwSElBQ0VEREhZTElBSkJBRFlDQUNBRklRRUxJQUpCZ0JJN0FTb2dBVUVCYWlFQlFRQWhBQUpBSUFJb0FqZ2lBMFVOQUNBREtBSXdJZ05GRFFBZ0FpQURFUUFBSVFBTElBQU5BUXRCeHdBaEF3eHpDeUFBUVJWR0JFQWdBa0hSQURZQ0hDQUNJQUUyQWhRZ0FrSGpGellDRUNBQ1FSVTJBZ3hCQUNFRERJd0JDMEVBSVFNZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUWJrTk5nSVFJQUpCR2pZQ0RBeUxBUXRCQUNFRElBSkJBRFlDSENBQ0lBRTJBaFFnQWtHZ0dUWUNFQ0FDUVI0MkFnd01pZ0VMSUFFdEFBQkJPa1lFUUNBQ0tBSUVJUUJCQUNFRElBSkJBRFlDQkNBQ0lBQWdBUkFwSWdCRkRRRWdBa0hEQURZQ0hDQUNJQUEyQWd3Z0FpQUJRUUZxTmdJVURJb0JDMEVBSVFNZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUWJFUk5nSVFJQUpCQ2pZQ0RBeUpBUXNnQVVFQmFpRUJRVHNoQXd4dkN5QUNRY01BTmdJY0lBSWdBRFlDRENBQ0lBRkJBV28yQWhRTWh3RUxRUUFoQXlBQ1FRQTJBaHdnQWlBQk5nSVVJQUpCOEE0MkFoQWdBa0VjTmdJTURJWUJDeUFDSUFJdkFUQkJFSEk3QVRBTVpnc0NRQ0FDTHdFd0lnQkJDSEZGRFFBZ0FpMEFLRUVCUncwQUlBSXRBQzFCQ0hGRkRRTUxJQUlnQUVIMyt3TnhRWUFFY2pzQk1Bd0VDeUFCSUFSSEJFQUNRQU5BSUFFdEFBQkJNR3NpQUVIL0FYRkJDazhFUUVFMUlRTU1iZ3NnQWlrRElDSUtRcG16NXN5WnMrYk1HVllOQVNBQ0lBcENDbjRpQ2pjRElDQUtJQUN0UXY4Qmd5SUxRbitGVmcwQklBSWdDaUFMZkRjRElDQUVJQUZCQVdvaUFVY05BQXRCT1NFRERJVUJDeUFDS0FJRUlRQkJBQ0VESUFKQkFEWUNCQ0FDSUFBZ0FVRUJhaUlCRUNvaUFBME1ESGNMUVRraEF3eURBUXNnQWkwQU1FRWdjUTBHUWNVQklRTU1hUXRCQUNFRElBSkJBRFlDQkNBQ0lBRWdBUkFxSWdCRkRRUWdBa0U2TmdJY0lBSWdBRFlDRENBQ0lBRkJBV28yQWhRTWdRRUxJQUl0QUNoQkFVY05BQ0FDTFFBdFFRaHhSUTBCQzBFM0lRTU1aZ3NnQWlnQ0JDRUFRUUFoQXlBQ1FRQTJBZ1FnQWlBQUlBRVFLaUlBQkVBZ0FrRTdOZ0ljSUFJZ0FEWUNEQ0FDSUFGQkFXbzJBaFFNZndzZ0FVRUJhaUVCREc0TElBSkJDRG9BTEF3RUN5QUJRUUZxSVFFTWJRdEJBQ0VESUFKQkFEWUNIQ0FDSUFFMkFoUWdBa0hrRWpZQ0VDQUNRUVEyQWd3TWV3c2dBaWdDQkNFQVFRQWhBeUFDUVFBMkFnUWdBaUFBSUFFUUtpSUFSUTFzSUFKQk56WUNIQ0FDSUFFMkFoUWdBaUFBTmdJTURIb0xJQUlnQWk4Qk1FRWdjanNCTUF0Qk1DRURERjhMSUFKQk5qWUNIQ0FDSUFFMkFoUWdBaUFBTmdJTURIY0xJQUJCTEVjTkFTQUJRUUZxSVFCQkFTRUJBa0FDUUFKQUFrQUNRQ0FDTFFBc1FRVnJEZ1FEQVFJRUFBc2dBQ0VCREFRTFFRSWhBUXdCQzBFRUlRRUxJQUpCQVRvQUxDQUNJQUl2QVRBZ0FYSTdBVEFnQUNFQkRBRUxJQUlnQWk4Qk1FRUljanNCTUNBQUlRRUxRVGtoQXd4Y0N5QUNRUUE2QUN3TFFUUWhBd3hhQ3lBQklBUkdCRUJCTFNFRERITUxBa0FDUUFOQUFrQWdBUzBBQUVFS2F3NEVBZ0FBQXdBTElBUWdBVUVCYWlJQlJ3MEFDMEV0SVFNTWRBc2dBaWdDQkNFQVFRQWhBeUFDUVFBMkFnUWdBaUFBSUFFUUtpSUFSUTBDSUFKQkxEWUNIQ0FDSUFFMkFoUWdBaUFBTmdJTURITUxJQUlvQWdRaEFFRUFJUU1nQWtFQU5nSUVJQUlnQUNBQkVDb2lBRVVFUUNBQlFRRnFJUUVNQWdzZ0FrRXNOZ0ljSUFJZ0FEWUNEQ0FDSUFGQkFXbzJBaFFNY2dzZ0FTMEFBRUVOUmdSQUlBSW9BZ1FoQUVFQUlRTWdBa0VBTmdJRUlBSWdBQ0FCRUNvaUFFVUVRQ0FCUVFGcUlRRU1BZ3NnQWtFc05nSWNJQUlnQURZQ0RDQUNJQUZCQVdvMkFoUU1jZ3NnQWkwQUxVRUJjUVJBUWNRQklRTU1XUXNnQWlnQ0JDRUFRUUFoQXlBQ1FRQTJBZ1FnQWlBQUlBRVFLaUlBRFFFTVpRdEJMeUVEREZjTElBSkJMallDSENBQ0lBRTJBaFFnQWlBQU5nSU1ERzhMUVFBaEF5QUNRUUEyQWh3Z0FpQUJOZ0lVSUFKQjhCUTJBaEFnQWtFRE5nSU1ERzRMUVFFaEF3SkFBa0FDUUFKQUlBSXRBQ3hCQldzT0JBTUJBZ0FFQ3lBQ0lBSXZBVEJCQ0hJN0FUQU1Bd3RCQWlFRERBRUxRUVFoQXdzZ0FrRUJPZ0FzSUFJZ0FpOEJNQ0FEY2pzQk1BdEJLaUVEREZNTFFRQWhBeUFDUVFBMkFod2dBaUFCTmdJVUlBSkI0UTgyQWhBZ0FrRUtOZ0lNREdzTFFRRWhBd0pBQWtBQ1FBSkFBa0FDUUNBQ0xRQXNRUUpyRGdjRkJBUURBUUlBQkFzZ0FpQUNMd0V3UVFoeU93RXdEQU1MUVFJaEF3d0JDMEVFSVFNTElBSkJBVG9BTENBQ0lBSXZBVEFnQTNJN0FUQUxRU3NoQXd4U0MwRUFJUU1nQWtFQU5nSWNJQUlnQVRZQ0ZDQUNRYXNTTmdJUUlBSkJDellDREF4cUMwRUFJUU1nQWtFQU5nSWNJQUlnQVRZQ0ZDQUNRZjBOTmdJUUlBSkJIVFlDREF4cEN5QUJJQVJIQkVBRFFDQUJMUUFBUVNCSERVZ2dCQ0FCUVFGcUlnRkhEUUFMUVNVaEF3eHBDMEVsSVFNTWFBc2dBaTBBTFVFQmNRUkFRY01CSVFNTVR3c2dBaWdDQkNFQVFRQWhBeUFDUVFBMkFnUWdBaUFBSUFFUUtTSUFCRUFnQWtFbU5nSWNJQUlnQURZQ0RDQUNJQUZCQVdvMkFoUU1hQXNnQVVFQmFpRUJERndMSUFGQkFXb2hBU0FDTHdFd0lnQkJnQUZ4QkVCQkFDRUFBa0FnQWlnQ09DSURSUTBBSUFNb0FsUWlBMFVOQUNBQ0lBTVJBQUFoQUFzZ0FFVU5CaUFBUVJWSERSOGdBa0VGTmdJY0lBSWdBVFlDRkNBQ1Fma1hOZ0lRSUFKQkZUWUNERUVBSVFNTVp3c0NRQ0FBUWFBRWNVR2dCRWNOQUNBQ0xRQXRRUUp4RFFCQkFDRURJQUpCQURZQ0hDQUNJQUUyQWhRZ0FrR1dFellDRUNBQ1FRUTJBZ3dNWndzZ0FnSi9JQUl2QVRCQkZIRkJGRVlFUUVFQklBSXRBQ2hCQVVZTkFSb2dBaThCTWtIbEFFWU1BUXNnQWkwQUtVRUZSZ3M2QUM1QkFDRUFBa0FnQWlnQ09DSURSUTBBSUFNb0FpUWlBMFVOQUNBQ0lBTVJBQUFoQUFzQ1FBSkFBa0FDUUFKQUlBQU9GZ0lCQUFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFNRUN5QUNRUUU2QUM0TElBSWdBaThCTUVIQUFISTdBVEFMUVNjaEF3eFBDeUFDUVNNMkFod2dBaUFCTmdJVUlBSkJwUlkyQWhBZ0FrRVZOZ0lNUVFBaEF3eG5DMEVBSVFNZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUWRVTE5nSVFJQUpCRVRZQ0RBeG1DMEVBSVFBQ1FDQUNLQUk0SWdORkRRQWdBeWdDTENJRFJRMEFJQUlnQXhFQUFDRUFDeUFBRFFFTFFRNGhBd3hMQ3lBQVFSVkdCRUFnQWtFQ05nSWNJQUlnQVRZQ0ZDQUNRYkFZTmdJUUlBSkJGVFlDREVFQUlRTU1aQXRCQUNFRElBSkJBRFlDSENBQ0lBRTJBaFFnQWtHbkRqWUNFQ0FDUVJJMkFnd01Zd3RCQUNFRElBSkJBRFlDSENBQ0lBRTJBaFFnQWtHcUhEWUNFQ0FDUVE4MkFnd01ZZ3NnQWlnQ0JDRUFRUUFoQXlBQ1FRQTJBZ1FnQWlBQUlBRWdDcWRxSWdFUUt5SUFSUTBBSUFKQkJUWUNIQ0FDSUFFMkFoUWdBaUFBTmdJTURHRUxRUThoQXd4SEMwRUFJUU1nQWtFQU5nSWNJQUlnQVRZQ0ZDQUNRYzBUTmdJUUlBSkJERFlDREF4ZkMwSUJJUW9MSUFGQkFXb2hBUUpBSUFJcEF5QWlDMEwvLy8vLy8vLy8vdzlZQkVBZ0FpQUxRZ1NHSUFxRU53TWdEQUVMUVFBaEF5QUNRUUEyQWh3Z0FpQUJOZ0lVSUFKQnJRazJBaEFnQWtFTU5nSU1ERjRMUVNRaEF3eEVDMEVBSVFNZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUWMwVE5nSVFJQUpCRERZQ0RBeGNDeUFDS0FJRUlRQkJBQ0VESUFKQkFEWUNCQ0FDSUFBZ0FSQXNJZ0JGQkVBZ0FVRUJhaUVCREZJTElBSkJGellDSENBQ0lBQTJBZ3dnQWlBQlFRRnFOZ0lVREZzTElBSW9BZ1FoQUVFQUlRTWdBa0VBTmdJRUFrQWdBaUFBSUFFUUxDSUFSUVJBSUFGQkFXb2hBUXdCQ3lBQ1FSWTJBaHdnQWlBQU5nSU1JQUlnQVVFQmFqWUNGQXhiQzBFZklRTU1RUXRCQUNFRElBSkJBRFlDSENBQ0lBRTJBaFFnQWtHYUR6WUNFQ0FDUVNJMkFnd01XUXNnQWlnQ0JDRUFRUUFoQXlBQ1FRQTJBZ1FnQWlBQUlBRVFMU0lBUlFSQUlBRkJBV29oQVF4UUN5QUNRUlEyQWh3Z0FpQUFOZ0lNSUFJZ0FVRUJhallDRkF4WUN5QUNLQUlFSVFCQkFDRURJQUpCQURZQ0JBSkFJQUlnQUNBQkVDMGlBRVVFUUNBQlFRRnFJUUVNQVFzZ0FrRVROZ0ljSUFJZ0FEWUNEQ0FDSUFGQkFXbzJBaFFNV0F0QkhpRURERDRMUVFBaEF5QUNRUUEyQWh3Z0FpQUJOZ0lVSUFKQnhndzJBaEFnQWtFak5nSU1ERllMSUFJb0FnUWhBRUVBSVFNZ0FrRUFOZ0lFSUFJZ0FDQUJFQzBpQUVVRVFDQUJRUUZxSVFFTVRnc2dBa0VSTmdJY0lBSWdBRFlDRENBQ0lBRkJBV28yQWhRTVZRc2dBa0VRTmdJY0lBSWdBVFlDRkNBQ0lBQTJBZ3dNVkF0QkFDRURJQUpCQURZQ0hDQUNJQUUyQWhRZ0FrSEdERFlDRUNBQ1FTTTJBZ3dNVXd0QkFDRURJQUpCQURZQ0hDQUNJQUUyQWhRZ0FrSEFGVFlDRUNBQ1FRSTJBZ3dNVWdzZ0FpZ0NCQ0VBUVFBaEF5QUNRUUEyQWdRQ1FDQUNJQUFnQVJBdElnQkZCRUFnQVVFQmFpRUJEQUVMSUFKQkRqWUNIQ0FDSUFBMkFnd2dBaUFCUVFGcU5nSVVERklMUVJzaEF3dzRDMEVBSVFNZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUWNZTU5nSVFJQUpCSXpZQ0RBeFFDeUFDS0FJRUlRQkJBQ0VESUFKQkFEWUNCQUpBSUFJZ0FDQUJFQ3dpQUVVRVFDQUJRUUZxSVFFTUFRc2dBa0VOTmdJY0lBSWdBRFlDRENBQ0lBRkJBV28yQWhRTVVBdEJHaUVERERZTFFRQWhBeUFDUVFBMkFod2dBaUFCTmdJVUlBSkJtZzgyQWhBZ0FrRWlOZ0lNREU0TElBSW9BZ1FoQUVFQUlRTWdBa0VBTmdJRUFrQWdBaUFBSUFFUUxDSUFSUVJBSUFGQkFXb2hBUXdCQ3lBQ1FRdzJBaHdnQWlBQU5nSU1JQUlnQVVFQmFqWUNGQXhPQzBFWklRTU1OQXRCQUNFRElBSkJBRFlDSENBQ0lBRTJBaFFnQWtHYUR6WUNFQ0FDUVNJMkFnd01UQXNnQUVFVlJ3UkFRUUFoQXlBQ1FRQTJBaHdnQWlBQk5nSVVJQUpCZ3d3MkFoQWdBa0VUTmdJTURFd0xJQUpCQ2pZQ0hDQUNJQUUyQWhRZ0FrSGtGallDRUNBQ1FSVTJBZ3hCQUNFRERFc0xJQUlvQWdRaEFFRUFJUU1nQWtFQU5nSUVJQUlnQUNBQklBcW5haUlCRUNzaUFBUkFJQUpCQnpZQ0hDQUNJQUUyQWhRZ0FpQUFOZ0lNREVzTFFSTWhBd3d4Q3lBQVFSVkhCRUJCQUNFRElBSkJBRFlDSENBQ0lBRTJBaFFnQWtIYURUWUNFQ0FDUVJRMkFnd01TZ3NnQWtFZU5nSWNJQUlnQVRZQ0ZDQUNRZmtYTmdJUUlBSkJGVFlDREVFQUlRTU1TUXRCQUNFQUFrQWdBaWdDT0NJRFJRMEFJQU1vQWl3aUEwVU5BQ0FDSUFNUkFBQWhBQXNnQUVVTlFTQUFRUlZHQkVBZ0FrRUROZ0ljSUFJZ0FUWUNGQ0FDUWJBWU5nSVFJQUpCRlRZQ0RFRUFJUU1NU1F0QkFDRURJQUpCQURZQ0hDQUNJQUUyQWhRZ0FrR25EallDRUNBQ1FSSTJBZ3dNU0F0QkFDRURJQUpCQURZQ0hDQUNJQUUyQWhRZ0FrSGFEVFlDRUNBQ1FSUTJBZ3dNUnd0QkFDRURJQUpCQURZQ0hDQUNJQUUyQWhRZ0FrR25EallDRUNBQ1FSSTJBZ3dNUmdzZ0FrRUFPZ0F2SUFJdEFDMUJCSEZGRFQ4TElBSkJBRG9BTHlBQ1FRRTZBRFJCQUNFRERDc0xRUUFoQXlBQ1FRQTJBaHdnQWtIa0VUWUNFQ0FDUVFjMkFnd2dBaUFCUVFGcU5nSVVERU1MQWtBRFFBSkFJQUV0QUFCQkNtc09CQUFDQWdBQ0N5QUVJQUZCQVdvaUFVY05BQXRCM1FFaEF3eERDd0pBQWtBZ0FpMEFORUVCUncwQVFRQWhBQUpBSUFJb0FqZ2lBMFVOQUNBREtBSllJZ05GRFFBZ0FpQURFUUFBSVFBTElBQkZEUUFnQUVFVlJ3MEJJQUpCM0FFMkFod2dBaUFCTmdJVUlBSkIxUlkyQWhBZ0FrRVZOZ0lNUVFBaEF3eEVDMEhCQVNFRERDb0xJQUpCQURZQ0hDQUNJQUUyQWhRZ0FrSHBDellDRUNBQ1FSODJBZ3hCQUNFRERFSUxBa0FDUUNBQ0xRQW9RUUZyRGdJRUFRQUxRY0FCSVFNTUtRdEJ1UUVoQXd3b0N5QUNRUUk2QUM5QkFDRUFBa0FnQWlnQ09DSURSUTBBSUFNb0FnQWlBMFVOQUNBQ0lBTVJBQUFoQUFzZ0FFVUVRRUhDQVNFRERDZ0xJQUJCRlVjRVFDQUNRUUEyQWh3Z0FpQUJOZ0lVSUFKQnBBdzJBaEFnQWtFUU5nSU1RUUFoQXd4QkN5QUNRZHNCTmdJY0lBSWdBVFlDRkNBQ1Fmb1dOZ0lRSUFKQkZUWUNERUVBSVFNTVFBc2dBU0FFUmdSQVFkb0JJUU1NUUFzZ0FTMEFBRUhJQUVZTkFTQUNRUUU2QUNnTFFhd0JJUU1NSlF0QnZ3RWhBd3drQ3lBQklBUkhCRUFnQWtFUU5nSUlJQUlnQVRZQ0JFRytBU0VERENRTFFka0JJUU1NUEFzZ0FTQUVSZ1JBUWRnQklRTU1QQXNnQVMwQUFFSElBRWNOQkNBQlFRRnFJUUZCdlFFaEF3d2lDeUFCSUFSR0JFQkIxd0VoQXd3N0N3SkFBa0FnQVMwQUFFSEZBR3NPRUFBRkJRVUZCUVVGQlFVRkJRVUZCUUVGQ3lBQlFRRnFJUUZCdXdFaEF3d2lDeUFCUVFGcUlRRkJ2QUVoQXd3aEMwSFdBU0VESUFFZ0JFWU5PU0FDS0FJQUlnQWdCQ0FCYTJvaEJTQUJJQUJyUVFKcUlRWUNRQU5BSUFFdEFBQWdBRUdEMEFCcUxRQUFSdzBESUFCQkFrWU5BU0FBUVFGcUlRQWdCQ0FCUVFGcUlnRkhEUUFMSUFJZ0JUWUNBQXc2Q3lBQ0tBSUVJUUFnQWtJQU53TUFJQUlnQUNBR1FRRnFJZ0VRSnlJQVJRUkFRY1lCSVFNTUlRc2dBa0hWQVRZQ0hDQUNJQUUyQWhRZ0FpQUFOZ0lNUVFBaEF3dzVDMEhVQVNFRElBRWdCRVlOT0NBQ0tBSUFJZ0FnQkNBQmEyb2hCU0FCSUFCclFRRnFJUVlDUUFOQUlBRXRBQUFnQUVHQjBBQnFMUUFBUncwQ0lBQkJBVVlOQVNBQVFRRnFJUUFnQkNBQlFRRnFJZ0ZIRFFBTElBSWdCVFlDQUF3NUN5QUNRWUVFT3dFb0lBSW9BZ1FoQUNBQ1FnQTNBd0FnQWlBQUlBWkJBV29pQVJBbklnQU5Bd3dDQ3lBQ1FRQTJBZ0FMUVFBaEF5QUNRUUEyQWh3Z0FpQUJOZ0lVSUFKQjJCczJBaEFnQWtFSU5nSU1ERFlMUWJvQklRTU1IQXNnQWtIVEFUWUNIQ0FDSUFFMkFoUWdBaUFBTmdJTVFRQWhBd3cwQzBFQUlRQUNRQ0FDS0FJNElnTkZEUUFnQXlnQ09DSURSUTBBSUFJZ0F4RUFBQ0VBQ3lBQVJRMEFJQUJCRlVZTkFTQUNRUUEyQWh3Z0FpQUJOZ0lVSUFKQnpBNDJBaEFnQWtFZ05nSU1RUUFoQXd3ekMwSGtBQ0VEREJrTElBSkIrQUEyQWh3Z0FpQUJOZ0lVSUFKQnloZzJBaEFnQWtFVk5nSU1RUUFoQXd3eEMwSFNBU0VESUFRZ0FTSUFSZzB3SUFRZ0FXc2dBaWdDQUNJQmFpRUZJQUFnQVd0QkJHb2hCZ0pBQTBBZ0FDMEFBQ0FCUWZ6UEFHb3RBQUJIRFFFZ0FVRUVSZzBESUFGQkFXb2hBU0FFSUFCQkFXb2lBRWNOQUFzZ0FpQUZOZ0lBRERFTElBSkJBRFlDSENBQ0lBQTJBaFFnQWtHUU16WUNFQ0FDUVFnMkFnd2dBa0VBTmdJQVFRQWhBd3d3Q3lBQklBUkhCRUFnQWtFT05nSUlJQUlnQVRZQ0JFRzNBU0VEREJjTFFkRUJJUU1NTHdzZ0FrRUFOZ0lBSUFaQkFXb2hBUXRCdUFFaEF3d1VDeUFCSUFSR0JFQkIwQUVoQXd3dEN5QUJMUUFBUVRCcklnQkIvd0Z4UVFwSkJFQWdBaUFBT2dBcUlBRkJBV29oQVVHMkFTRUREQlFMSUFJb0FnUWhBQ0FDUVFBMkFnUWdBaUFBSUFFUUtDSUFSUTBVSUFKQnp3RTJBaHdnQWlBQk5nSVVJQUlnQURZQ0RFRUFJUU1NTEFzZ0FTQUVSZ1JBUWM0QklRTU1MQXNDUUNBQkxRQUFRUzVHQkVBZ0FVRUJhaUVCREFFTElBSW9BZ1FoQUNBQ1FRQTJBZ1FnQWlBQUlBRVFLQ0lBUlEwVklBSkJ6UUUyQWh3Z0FpQUJOZ0lVSUFJZ0FEWUNERUVBSVFNTUxBdEJ0UUVoQXd3U0N5QUVJQUVpQlVZRVFFSE1BU0VERENzTFFRQWhBRUVCSVFGQkFTRUdRUUFoQXdKQUFrQUNRQUpBQWtBQ2Z3SkFBa0FDUUFKQUFrQUNRQUpBSUFVdEFBQkJNR3NPQ2dvSkFBRUNBd1FGQmdnTEMwRUNEQVlMUVFNTUJRdEJCQXdFQzBFRkRBTUxRUVlNQWd0QkJ3d0JDMEVJQ3lFRFFRQWhBVUVBSVFZTUFndEJDU0VEUVFFaEFFRUFJUUZCQUNFR0RBRUxRUUFoQVVFQklRTUxJQUlnQXpvQUt5QUZRUUZxSVFNQ1FBSkFJQUl0QUMxQkVIRU5BQUpBQWtBQ1FDQUNMUUFxRGdNQkFBSUVDeUFHUlEwRERBSUxJQUFOQVF3Q0N5QUJSUTBCQ3lBQ0tBSUVJUUFnQWtFQU5nSUVJQUlnQUNBREVDZ2lBRVVFUUNBRElRRU1Bd3NnQWtISkFUWUNIQ0FDSUFNMkFoUWdBaUFBTmdJTVFRQWhBd3d0Q3lBQ0tBSUVJUUFnQWtFQU5nSUVJQUlnQUNBREVDZ2lBRVVFUUNBRElRRU1HQXNnQWtIS0FUWUNIQ0FDSUFNMkFoUWdBaUFBTmdJTVFRQWhBd3dzQ3lBQ0tBSUVJUUFnQWtFQU5nSUVJQUlnQUNBRkVDZ2lBRVVFUUNBRklRRU1GZ3NnQWtITEFUWUNIQ0FDSUFVMkFoUWdBaUFBTmdJTURDc0xRYlFCSVFNTUVRdEJBQ0VBQWtBZ0FpZ0NPQ0lEUlEwQUlBTW9BandpQTBVTkFDQUNJQU1SQUFBaEFBc0NRQ0FBQkVBZ0FFRVZSZzBCSUFKQkFEWUNIQ0FDSUFFMkFoUWdBa0dVRFRZQ0VDQUNRU0UyQWd4QkFDRUREQ3NMUWJJQklRTU1FUXNnQWtISUFUWUNIQ0FDSUFFMkFoUWdBa0hKRnpZQ0VDQUNRUlUyQWd4QkFDRUREQ2tMSUFKQkFEWUNBQ0FHUVFGcUlRRkI5UUFoQXd3UEN5QUNMUUFwUVFWR0JFQkI0d0FoQXd3UEMwSGlBQ0VEREE0TElBQWhBU0FDUVFBMkFnQUxJQUpCQURvQUxFRUpJUU1NREFzZ0FrRUFOZ0lBSUFkQkFXb2hBVUhBQUNFRERBc0xRUUVMT2dBc0lBSkJBRFlDQUNBR1FRRnFJUUVMUVNraEF3d0lDMEU0SVFNTUJ3c0NRQ0FCSUFSSEJFQURRQ0FCTFFBQVFZQSthaTBBQUNJQVFRRkhCRUFnQUVFQ1J3MERJQUZCQVdvaEFRd0ZDeUFFSUFGQkFXb2lBVWNOQUF0QlBpRUREQ0VMUVQ0aEF3d2dDd3NnQWtFQU9nQXNEQUVMUVFzaEF3d0VDMEU2SVFNTUF3c2dBVUVCYWlFQlFTMGhBd3dDQ3lBQ0lBRTZBQ3dnQWtFQU5nSUFJQVpCQVdvaEFVRU1JUU1NQVFzZ0FrRUFOZ0lBSUFaQkFXb2hBVUVLSVFNTUFBc0FDMEVBSVFNZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUWMwUU5nSVFJQUpCQ1RZQ0RBd1hDMEVBSVFNZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUWVrS05nSVFJQUpCQ1RZQ0RBd1dDMEVBSVFNZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUWJjUU5nSVFJQUpCQ1RZQ0RBd1ZDMEVBSVFNZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUVp3Uk5nSVFJQUpCQ1RZQ0RBd1VDMEVBSVFNZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUWMwUU5nSVFJQUpCQ1RZQ0RBd1RDMEVBSVFNZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUWVrS05nSVFJQUpCQ1RZQ0RBd1NDMEVBSVFNZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUWJjUU5nSVFJQUpCQ1RZQ0RBd1JDMEVBSVFNZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUVp3Uk5nSVFJQUpCQ1RZQ0RBd1FDMEVBSVFNZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUVpjVk5nSVFJQUpCRHpZQ0RBd1BDMEVBSVFNZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUVpjVk5nSVFJQUpCRHpZQ0RBd09DMEVBSVFNZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUWNBU05nSVFJQUpCQ3pZQ0RBd05DMEVBSVFNZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUVpVSk5nSVFJQUpCQ3pZQ0RBd01DMEVBSVFNZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUWVFUE5nSVFJQUpCQ2pZQ0RBd0xDMEVBSVFNZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUWZzUE5nSVFJQUpCQ2pZQ0RBd0tDMEVBSVFNZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUWZFWk5nSVFJQUpCQWpZQ0RBd0pDMEVBSVFNZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUWNRVU5nSVFJQUpCQWpZQ0RBd0lDMEVBSVFNZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUWZJVk5nSVFJQUpCQWpZQ0RBd0hDeUFDUVFJMkFod2dBaUFCTmdJVUlBSkJuQm8yQWhBZ0FrRVdOZ0lNUVFBaEF3d0dDMEVCSVFNTUJRdEIxQUFoQXlBQklBUkdEUVFnQ0VFSWFpRUpJQUlvQWdBaEJRSkFBa0FnQVNBRVJ3UkFJQVZCMk1JQWFpRUhJQVFnQldvZ0FXc2hBQ0FGUVg5elFRcHFJZ1VnQVdvaEJnTkFJQUV0QUFBZ0J5MEFBRWNFUUVFQ0lRY01Bd3NnQlVVRVFFRUFJUWNnQmlFQkRBTUxJQVZCQVdzaEJTQUhRUUZxSVFjZ0JDQUJRUUZxSWdGSERRQUxJQUFoQlNBRUlRRUxJQWxCQVRZQ0FDQUNJQVUyQWdBTUFRc2dBa0VBTmdJQUlBa2dCellDQUFzZ0NTQUJOZ0lFSUFnb0Fnd2hBQ0FJS0FJSURnTUJCQUlBQ3dBTElBSkJBRFlDSENBQ1FiVWFOZ0lRSUFKQkZ6WUNEQ0FDSUFCQkFXbzJBaFJCQUNFRERBSUxJQUpCQURZQ0hDQUNJQUEyQWhRZ0FrSEtHallDRUNBQ1FRazJBZ3hCQUNFRERBRUxJQUVnQkVZRVFFRWlJUU1NQVFzZ0FrRUpOZ0lJSUFJZ0FUWUNCRUVoSVFNTElBaEJFR29rQUNBRFJRUkFJQUlvQWd3aEFBd0JDeUFDSUFNMkFoeEJBQ0VBSUFJb0FnUWlBVVVOQUNBQ0lBRWdCQ0FDS0FJSUVRRUFJZ0ZGRFFBZ0FpQUVOZ0lVSUFJZ0FUWUNEQ0FCSVFBTElBQUx2Z0lCQW44Z0FFRUFPZ0FBSUFCQjNBQnFJZ0ZCQVd0QkFEb0FBQ0FBUVFBNkFBSWdBRUVBT2dBQklBRkJBMnRCQURvQUFDQUJRUUpyUVFBNkFBQWdBRUVBT2dBRElBRkJCR3RCQURvQUFFRUFJQUJyUVFOeElnRWdBR29pQUVFQU5nSUFRZHdBSUFGclFYeHhJZ0lnQUdvaUFVRUVhMEVBTmdJQUFrQWdBa0VKU1EwQUlBQkJBRFlDQ0NBQVFRQTJBZ1FnQVVFSWEwRUFOZ0lBSUFGQkRHdEJBRFlDQUNBQ1FSbEpEUUFnQUVFQU5nSVlJQUJCQURZQ0ZDQUFRUUEyQWhBZ0FFRUFOZ0lNSUFGQkVHdEJBRFlDQUNBQlFSUnJRUUEyQWdBZ0FVRVlhMEVBTmdJQUlBRkJIR3RCQURZQ0FDQUNJQUJCQkhGQkdISWlBbXNpQVVFZ1NRMEFJQUFnQW1vaEFBTkFJQUJDQURjREdDQUFRZ0EzQXhBZ0FFSUFOd01JSUFCQ0FEY0RBQ0FBUVNCcUlRQWdBVUVnYXlJQlFSOUxEUUFMQ3d0V0FRRi9Ba0FnQUNnQ0RBMEFBa0FDUUFKQUFrQWdBQzBBTHc0REFRQURBZ3NnQUNnQ09DSUJSUTBBSUFFb0Fpd2lBVVVOQUNBQUlBRVJBQUFpQVEwREMwRUFEd3NBQ3lBQVFjTVdOZ0lRUVE0aEFRc2dBUXNhQUNBQUtBSU1SUVJBSUFCQjBSczJBaEFnQUVFVk5nSU1Dd3NVQUNBQUtBSU1RUlZHQkVBZ0FFRUFOZ0lNQ3dzVUFDQUFLQUlNUVJaR0JFQWdBRUVBTmdJTUN3c0hBQ0FBS0FJTUN3Y0FJQUFvQWhBTENRQWdBQ0FCTmdJUUN3Y0FJQUFvQWhRTEZ3QWdBRUVrVHdSQUFBc2dBRUVDZEVHZ00yb29BZ0FMRndBZ0FFRXVUd1JBQUFzZ0FFRUNkRUd3Tkdvb0FnQUx2d2tCQVg5QjZ5Z2hBUUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBSUFCQjVBQnJEdlFEWTJJQUFXRmhZV0ZoWVFJREJBVmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoQmdjSUNRb0xEQTBPRDJGaFlXRmhFR0ZoWVdGaFlXRmhZV0ZoRVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVJJVEZCVVdGeGdaR2h0aFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaEhCMGVIeUFoSWlNa0pTWW5LQ2txS3l3dExpOHdNVEl6TkRVMllUYzRPVHBoWVdGaFlXRmhZVHRoWVdFOFlXRmhZVDArUDJGaFlXRmhZV0ZoUUdGaFFXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZVUpEUkVWR1IwaEpTa3RNVFU1UFVGRlNVMkZoWVdGaFlXRmhWRlZXVjFoWldsdGhYRjFoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGZVlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFgyQmhDMEhoSnc4TFFhUWhEd3RCeXl3UEMwSCtNUThMUWNBa0R3dEJxeVFQQzBHTktBOExRZUltRHd0QmdEQVBDMEc1THc4TFFkY2tEd3RCN3g4UEMwSGhIdzhMUWZvZkR3dEI4aUFQQzBHb0x3OExRYTR5RHd0QmlEQVBDMEhzSnc4TFFZSWlEd3RCamgwUEMwSFFMZzhMUWNvakR3dEJ4VElQQzBIZkhBOExRZEljRHd0QnhDQVBDMEhYSUE4TFFhSWZEd3RCN1M0UEMwR3JNQThMUWRRbER3dEJ6QzRQQzBINkxnOExRZndyRHd0QjBqQVBDMEh4SFE4TFFic2dEd3RCOXlzUEMwR1FNUThMUWRjeER3dEJvaTBQQzBIVUp3OExRZUFyRHd0Qm55d1BDMEhyTVE4TFFkVWZEd3RCeWpFUEMwSGVKUThMUWRRZUR3dEI5QndQQzBHbk1nOExRYkVkRHd0Qm9CMFBDMEc1TVE4TFFid3dEd3RCa2lFUEMwR3pKZzhMUWVrc0R3dEJyQjRQQzBIVUt3OExRZmNtRHd0QmdDWVBDMEd3SVE4TFFmNGVEd3RCalNNUEMwR0pMUThMUWZjaUR3dEJvREVQQzBHdUh3OExRY1lsRHd0QjZCNFBDMEdUSWc4TFFjSXZEd3RCd3gwUEMwR0xMQThMUWVFZER3dEJqUzhQQzBIcUlROExRYlF0RHd0QjBpOFBDMEhmTWc4TFFkSXlEd3RCOERBUEMwR3BJZzhMUWZrakR3dEJtUjRQQzBHMUxBOExRWnN3RHd0QmtqSVBDMEcyS3c4TFFjSWlEd3RCK0RJUEMwR2VKUThMUWRBaUR3dEJ1aDRQQzBHQkhnOExBQXRCMWlFaEFRc2dBUXNXQUNBQUlBQXRBQzFCL2dGeElBRkJBRWR5T2dBdEN4a0FJQUFnQUMwQUxVSDlBWEVnQVVFQVIwRUJkSEk2QUMwTEdRQWdBQ0FBTFFBdFFmc0JjU0FCUVFCSFFRSjBjam9BTFFzWkFDQUFJQUF0QUMxQjl3RnhJQUZCQUVkQkEzUnlPZ0F0Q3o0QkFuOENRQ0FBS0FJNElnTkZEUUFnQXlnQ0JDSURSUTBBSUFBZ0FTQUNJQUZySUFNUkFRQWlCRUYvUncwQUlBQkJ4aEUyQWhCQkdDRUVDeUFFQ3o0QkFuOENRQ0FBS0FJNElnTkZEUUFnQXlnQ0NDSURSUTBBSUFBZ0FTQUNJQUZySUFNUkFRQWlCRUYvUncwQUlBQkI5Z28yQWhCQkdDRUVDeUFFQ3o0QkFuOENRQ0FBS0FJNElnTkZEUUFnQXlnQ0RDSURSUTBBSUFBZ0FTQUNJQUZySUFNUkFRQWlCRUYvUncwQUlBQkI3Um8yQWhCQkdDRUVDeUFFQ3o0QkFuOENRQ0FBS0FJNElnTkZEUUFnQXlnQ0VDSURSUTBBSUFBZ0FTQUNJQUZySUFNUkFRQWlCRUYvUncwQUlBQkJsUkEyQWhCQkdDRUVDeUFFQ3o0QkFuOENRQ0FBS0FJNElnTkZEUUFnQXlnQ0ZDSURSUTBBSUFBZ0FTQUNJQUZySUFNUkFRQWlCRUYvUncwQUlBQkJxaHMyQWhCQkdDRUVDeUFFQ3o0QkFuOENRQ0FBS0FJNElnTkZEUUFnQXlnQ0dDSURSUTBBSUFBZ0FTQUNJQUZySUFNUkFRQWlCRUYvUncwQUlBQkI3Uk0yQWhCQkdDRUVDeUFFQ3o0QkFuOENRQ0FBS0FJNElnTkZEUUFnQXlnQ0tDSURSUTBBSUFBZ0FTQUNJQUZySUFNUkFRQWlCRUYvUncwQUlBQkI5Z2cyQWhCQkdDRUVDeUFFQ3o0QkFuOENRQ0FBS0FJNElnTkZEUUFnQXlnQ0hDSURSUTBBSUFBZ0FTQUNJQUZySUFNUkFRQWlCRUYvUncwQUlBQkJ3aGsyQWhCQkdDRUVDeUFFQ3o0QkFuOENRQ0FBS0FJNElnTkZEUUFnQXlnQ0lDSURSUTBBSUFBZ0FTQUNJQUZySUFNUkFRQWlCRUYvUncwQUlBQkJsQlEyQWhCQkdDRUVDeUFFQzFrQkFuOENRQ0FBTFFBb1FRRkdEUUFnQUM4Qk1pSUJRZVFBYTBIa0FFa05BQ0FCUWN3QlJnMEFJQUZCc0FKR0RRQWdBQzhCTUNJQVFjQUFjUTBBUVFFaEFpQUFRWWdFY1VHQUJFWU5BQ0FBUVNoeFJTRUNDeUFDQzR3QkFRSi9Ba0FDUUFKQUlBQXRBQ3BGRFFBZ0FDMEFLMFVOQUNBQUx3RXdJZ0ZCQW5GRkRRRU1BZ3NnQUM4Qk1DSUJRUUZ4UlEwQkMwRUJJUUlnQUMwQUtFRUJSZzBBSUFBdkFUSWlBRUhrQUd0QjVBQkpEUUFnQUVITUFVWU5BQ0FBUWJBQ1JnMEFJQUZCd0FCeERRQkJBQ0VDSUFGQmlBUnhRWUFFUmcwQUlBRkJLSEZCQUVjaEFnc2dBZ3RYQUNBQVFSaHFRZ0EzQXdBZ0FFSUFOd01BSUFCQk9HcENBRGNEQUNBQVFUQnFRZ0EzQXdBZ0FFRW9ha0lBTndNQUlBQkJJR3BDQURjREFDQUFRUkJxUWdBM0F3QWdBRUVJYWtJQU53TUFJQUJCM1FFMkFod0xCZ0FnQUJBeUM1b3RBUXQvSXdCQkVHc2lDaVFBUWFUUUFDZ0NBQ0lKUlFSQVFlVFRBQ2dDQUNJRlJRUkFRZkRUQUVKL053SUFRZWpUQUVLQWdJU0FnSURBQURjQ0FFSGswd0FnQ2tFSWFrRndjVUhZcXRXcUJYTWlCVFlDQUVINDB3QkJBRFlDQUVISTB3QkJBRFlDQUF0QnpOTUFRWURVQkRZQ0FFR2MwQUJCZ05RRU5nSUFRYkRRQUNBRk5nSUFRYXpRQUVGL05nSUFRZERUQUVHQXJBTTJBZ0FEUUNBQlFjalFBR29nQVVHODBBQnFJZ0kyQWdBZ0FpQUJRYlRRQUdvaUF6WUNBQ0FCUWNEUUFHb2dBellDQUNBQlFkRFFBR29nQVVIRTBBQnFJZ00yQWdBZ0F5QUNOZ0lBSUFGQjJOQUFhaUFCUWN6UUFHb2lBallDQUNBQ0lBTTJBZ0FnQVVIVTBBQnFJQUkyQWdBZ0FVRWdhaUlCUVlBQ1J3MEFDMEdNMUFSQndhc0ROZ0lBUWFqUUFFSDAwd0FvQWdBMkFnQkJtTkFBUWNDckF6WUNBRUdrMEFCQmlOUUVOZ0lBUWN6L0IwRTROZ0lBUVlqVUJDRUpDd0pBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUlBQkI3QUZOQkVCQmpOQUFLQUlBSWdaQkVDQUFRUk5xUVhCeElBQkJDMGtiSWdSQkEzWWlBSFlpQVVFRGNRUkFBa0FnQVVFQmNTQUFja0VCY3lJQ1FRTjBJZ0JCdE5BQWFpSUJJQUJCdk5BQWFpZ0NBQ0lBS0FJSUlnTkdCRUJCak5BQUlBWkJmaUFDZDNFMkFnQU1BUXNnQVNBRE5nSUlJQU1nQVRZQ0RBc2dBRUVJYWlFQklBQWdBa0VEZENJQ1FRTnlOZ0lFSUFBZ0Ftb2lBQ0FBS0FJRVFRRnlOZ0lFREJFTFFaVFFBQ2dDQUNJSUlBUlBEUUVnQVFSQUFrQkJBaUFBZENJQ1FRQWdBbXR5SUFFZ0FIUnhhQ0lBUVFOMElnSkJ0TkFBYWlJQklBSkJ2TkFBYWlnQ0FDSUNLQUlJSWdOR0JFQkJqTkFBSUFaQmZpQUFkM0VpQmpZQ0FBd0JDeUFCSUFNMkFnZ2dBeUFCTmdJTUN5QUNJQVJCQTNJMkFnUWdBRUVEZENJQUlBUnJJUVVnQUNBQ2FpQUZOZ0lBSUFJZ0JHb2lCQ0FGUVFGeU5nSUVJQWdFUUNBSVFYaHhRYlRRQUdvaEFFR2cwQUFvQWdBaEF3Si9RUUVnQ0VFRGRuUWlBU0FHY1VVRVFFR00wQUFnQVNBR2NqWUNBQ0FBREFFTElBQW9BZ2dMSWdFZ0F6WUNEQ0FBSUFNMkFnZ2dBeUFBTmdJTUlBTWdBVFlDQ0FzZ0FrRUlhaUVCUWFEUUFDQUVOZ0lBUVpUUUFDQUZOZ0lBREJFTFFaRFFBQ2dDQUNJTFJRMEJJQXRvUVFKMFFielNBR29vQWdBaUFDZ0NCRUY0Y1NBRWF5RUZJQUFoQWdOQUFrQWdBaWdDRUNJQlJRUkFJQUpCRkdvb0FnQWlBVVVOQVFzZ0FTZ0NCRUY0Y1NBRWF5SURJQVZKSVFJZ0F5QUZJQUliSVFVZ0FTQUFJQUliSVFBZ0FTRUNEQUVMQ3lBQUtBSVlJUWtnQUNnQ0RDSURJQUJIQkVCQm5OQUFLQUlBR2lBRElBQW9BZ2dpQVRZQ0NDQUJJQU0yQWd3TUVBc2dBRUVVYWlJQ0tBSUFJZ0ZGQkVBZ0FDZ0NFQ0lCUlEwRElBQkJFR29oQWdzRFFDQUNJUWNnQVNJRFFSUnFJZ0lvQWdBaUFRMEFJQU5CRUdvaEFpQURLQUlRSWdFTkFBc2dCMEVBTmdJQURBOExRWDhoQkNBQVFiOS9TdzBBSUFCQkUyb2lBVUZ3Y1NFRVFaRFFBQ2dDQUNJSVJRMEFRUUFnQkdzaEJRSkFBa0FDUUFKL1FRQWdCRUdBQWtrTkFCcEJIeUFFUWYvLy93ZExEUUFhSUFSQkppQUJRUWgyWnlJQWEzWkJBWEVnQUVFQmRHdEJQbW9MSWdaQkFuUkJ2TklBYWlnQ0FDSUNSUVJBUVFBaEFVRUFJUU1NQVF0QkFDRUJJQVJCR1NBR1FRRjJhMEVBSUFaQkgwY2JkQ0VBUVFBaEF3TkFBa0FnQWlnQ0JFRjRjU0FFYXlJSElBVlBEUUFnQWlFRElBY2lCUTBBUVFBaEJTQUNJUUVNQXdzZ0FTQUNRUlJxS0FJQUlnY2dCeUFDSUFCQkhYWkJCSEZxUVJCcUtBSUFJZ0pHR3lBQklBY2JJUUVnQUVFQmRDRUFJQUlOQUFzTElBRWdBM0pGQkVCQkFDRURRUUlnQm5RaUFFRUFJQUJyY2lBSWNTSUFSUTBESUFCb1FRSjBRYnpTQUdvb0FnQWhBUXNnQVVVTkFRc0RRQ0FCS0FJRVFYaHhJQVJySWdJZ0JVa2hBQ0FDSUFVZ0FCc2hCU0FCSUFNZ0FCc2hBeUFCS0FJUUlnQUVmeUFBQlNBQlFSUnFLQUlBQ3lJQkRRQUxDeUFEUlEwQUlBVkJsTkFBS0FJQUlBUnJUdzBBSUFNb0FoZ2hCeUFESUFNb0Fnd2lBRWNFUUVHYzBBQW9BZ0FhSUFBZ0F5Z0NDQ0lCTmdJSUlBRWdBRFlDREF3T0N5QURRUlJxSWdJb0FnQWlBVVVFUUNBREtBSVFJZ0ZGRFFNZ0EwRVFhaUVDQ3dOQUlBSWhCaUFCSWdCQkZHb2lBaWdDQUNJQkRRQWdBRUVRYWlFQ0lBQW9BaEFpQVEwQUN5QUdRUUEyQWdBTURRdEJsTkFBS0FJQUlnTWdCRThFUUVHZzBBQW9BZ0FoQVFKQUlBTWdCR3NpQWtFUVR3UkFJQUVnQkdvaUFDQUNRUUZ5TmdJRUlBRWdBMm9nQWpZQ0FDQUJJQVJCQTNJMkFnUU1BUXNnQVNBRFFRTnlOZ0lFSUFFZ0Eyb2lBQ0FBS0FJRVFRRnlOZ0lFUVFBaEFFRUFJUUlMUVpUUUFDQUNOZ0lBUWFEUUFDQUFOZ0lBSUFGQkNHb2hBUXdQQzBHWTBBQW9BZ0FpQXlBRVN3UkFJQVFnQ1dvaUFDQURJQVJySWdGQkFYSTJBZ1JCcE5BQUlBQTJBZ0JCbU5BQUlBRTJBZ0FnQ1NBRVFRTnlOZ0lFSUFsQkNHb2hBUXdQQzBFQUlRRWdCQUovUWVUVEFDZ0NBQVJBUWV6VEFDZ0NBQXdCQzBIdzB3QkNmemNDQUVIbzB3QkNnSUNFZ0lDQXdBQTNBZ0JCNU5NQUlBcEJER3BCY0hGQjJLclZxZ1Z6TmdJQVFmalRBRUVBTmdJQVFjalRBRUVBTmdJQVFZQ0FCQXNpQUNBRVFjY0FhaUlGYWlJR1FRQWdBR3NpQjNFaUFrOEVRRUg4MHdCQk1EWUNBQXdQQ3dKQVFjVFRBQ2dDQUNJQlJRMEFRYnpUQUNnQ0FDSUlJQUpxSVFBZ0FDQUJUU0FBSUFoTGNRMEFRUUFoQVVIODB3QkJNRFlDQUF3UEMwSEkwd0F0QUFCQkJIRU5CQUpBQWtBZ0NRUkFRY3pUQUNFQkEwQWdBU2dDQUNJQUlBbE5CRUFnQUNBQktBSUVhaUFKU3cwREN5QUJLQUlJSWdFTkFBc0xRUUFRTXlJQVFYOUdEUVVnQWlFR1FlalRBQ2dDQUNJQlFRRnJJZ01nQUhFRVFDQUNJQUJySUFBZ0EycEJBQ0FCYTNGcUlRWUxJQVFnQms4TkJTQUdRZjcvLy84SFN3MEZRY1RUQUNnQ0FDSURCRUJCdk5NQUtBSUFJZ2NnQm1vaEFTQUJJQWRORFFZZ0FTQURTdzBHQ3lBR0VETWlBU0FBUncwQkRBY0xJQVlnQTJzZ0IzRWlCa0grLy8vL0Iwc05CQ0FHRURNaEFDQUFJQUVvQWdBZ0FTZ0NCR3BHRFFNZ0FDRUJDd0pBSUFZZ0JFSElBR3BQRFFBZ0FVRi9SZzBBUWV6VEFDZ0NBQ0lBSUFVZ0JtdHFRUUFnQUd0eElnQkIvdi8vL3dkTEJFQWdBU0VBREFjTElBQVFNMEYvUndSQUlBQWdCbW9oQmlBQklRQU1Cd3RCQUNBR2F4QXpHZ3dFQ3lBQklnQkJmMGNOQlF3REMwRUFJUU1NREF0QkFDRUFEQW9MSUFCQmYwY05BZ3RCeU5NQVFjalRBQ2dDQUVFRWNqWUNBQXNnQWtIKy8vLy9CMHNOQVNBQ0VETWhBRUVBRURNaEFTQUFRWDlHRFFFZ0FVRi9SZzBCSUFBZ0FVOE5BU0FCSUFCcklnWWdCRUU0YWswTkFRdEJ2Tk1BUWJ6VEFDZ0NBQ0FHYWlJQk5nSUFRY0RUQUNnQ0FDQUJTUVJBUWNEVEFDQUJOZ0lBQ3dKQUFrQUNRRUdrMEFBb0FnQWlBZ1JBUWN6VEFDRUJBMEFnQUNBQktBSUFJZ01nQVNnQ0JDSUZha1lOQWlBQktBSUlJZ0VOQUFzTUFndEJuTkFBS0FJQUlnRkJBRWNnQUNBQlQzRkZCRUJCbk5BQUlBQTJBZ0FMUVFBaEFVSFEwd0FnQmpZQ0FFSE0wd0FnQURZQ0FFR3MwQUJCZnpZQ0FFR3cwQUJCNU5NQUtBSUFOZ0lBUWRqVEFFRUFOZ0lBQTBBZ0FVSEkwQUJxSUFGQnZOQUFhaUlDTmdJQUlBSWdBVUcwMEFCcUlnTTJBZ0FnQVVIQTBBQnFJQU0yQWdBZ0FVSFEwQUJxSUFGQnhOQUFhaUlETmdJQUlBTWdBallDQUNBQlFkalFBR29nQVVITTBBQnFJZ0kyQWdBZ0FpQUROZ0lBSUFGQjFOQUFhaUFDTmdJQUlBRkJJR29pQVVHQUFrY05BQXRCZUNBQWEwRVBjU0lCSUFCcUlnSWdCa0U0YXlJRElBRnJJZ0ZCQVhJMkFnUkJxTkFBUWZUVEFDZ0NBRFlDQUVHWTBBQWdBVFlDQUVHazBBQWdBallDQUNBQUlBTnFRVGcyQWdRTUFnc2dBQ0FDVFEwQUlBSWdBMGtOQUNBQktBSU1RUWh4RFFCQmVDQUNhMEVQY1NJQUlBSnFJZ05CbU5BQUtBSUFJQVpxSWdjZ0FHc2lBRUVCY2pZQ0JDQUJJQVVnQm1vMkFnUkJxTkFBUWZUVEFDZ0NBRFlDQUVHWTBBQWdBRFlDQUVHazBBQWdBellDQUNBQ0lBZHFRVGcyQWdRTUFRc2dBRUdjMEFBb0FnQkpCRUJCbk5BQUlBQTJBZ0FMSUFBZ0Jtb2hBMEhNMHdBaEFRSkFBa0FDUUFOQUlBTWdBU2dDQUVjRVFDQUJLQUlJSWdFTkFRd0NDd3NnQVMwQURFRUljVVVOQVF0QnpOTUFJUUVEUUNBQktBSUFJZ01nQWswRVFDQURJQUVvQWdScUlnVWdBa3NOQXdzZ0FTZ0NDQ0VCREFBTEFBc2dBU0FBTmdJQUlBRWdBU2dDQkNBR2FqWUNCQ0FBUVhnZ0FHdEJEM0ZxSWdrZ0JFRURjallDQkNBRFFYZ2dBMnRCRDNGcUlnWWdCQ0FKYWlJRWF5RUJJQUlnQmtZRVFFR2swQUFnQkRZQ0FFR1kwQUJCbU5BQUtBSUFJQUZxSWdBMkFnQWdCQ0FBUVFGeU5nSUVEQWdMUWFEUUFDZ0NBQ0FHUmdSQVFhRFFBQ0FFTmdJQVFaVFFBRUdVMEFBb0FnQWdBV29pQURZQ0FDQUVJQUJCQVhJMkFnUWdBQ0FFYWlBQU5nSUFEQWdMSUFZb0FnUWlCVUVEY1VFQlJ3MEdJQVZCZUhFaENDQUZRZjhCVFFSQUlBVkJBM1loQXlBR0tBSUlJZ0FnQmlnQ0RDSUNSZ1JBUVl6UUFFR00wQUFvQWdCQmZpQURkM0UyQWdBTUJ3c2dBaUFBTmdJSUlBQWdBallDREF3R0N5QUdLQUlZSVFjZ0JpQUdLQUlNSWdCSEJFQWdBQ0FHS0FJSUlnSTJBZ2dnQWlBQU5nSU1EQVVMSUFaQkZHb2lBaWdDQUNJRlJRUkFJQVlvQWhBaUJVVU5CQ0FHUVJCcUlRSUxBMEFnQWlFRElBVWlBRUVVYWlJQ0tBSUFJZ1VOQUNBQVFSQnFJUUlnQUNnQ0VDSUZEUUFMSUFOQkFEWUNBQXdFQzBGNElBQnJRUTl4SWdFZ0FHb2lCeUFHUVRocklnTWdBV3NpQVVFQmNqWUNCQ0FBSUFOcVFUZzJBZ1FnQWlBRlFUY2dCV3RCRDNGcVFUOXJJZ01nQXlBQ1FSQnFTUnNpQTBFak5nSUVRYWpRQUVIMDB3QW9BZ0EyQWdCQm1OQUFJQUUyQWdCQnBOQUFJQWMyQWdBZ0EwRVFha0hVMHdBcEFnQTNBZ0FnQTBITTB3QXBBZ0EzQWdoQjFOTUFJQU5CQ0dvMkFnQkIwTk1BSUFZMkFnQkJ6Tk1BSUFBMkFnQkIyTk1BUVFBMkFnQWdBMEVrYWlFQkEwQWdBVUVITmdJQUlBVWdBVUVFYWlJQlN3MEFDeUFDSUFOR0RRQWdBeUFES0FJRVFYNXhOZ0lFSUFNZ0F5QUNheUlGTmdJQUlBSWdCVUVCY2pZQ0JDQUZRZjhCVFFSQUlBVkJlSEZCdE5BQWFpRUFBbjlCak5BQUtBSUFJZ0ZCQVNBRlFRTjJkQ0lEY1VVRVFFR00wQUFnQVNBRGNqWUNBQ0FBREFFTElBQW9BZ2dMSWdFZ0FqWUNEQ0FBSUFJMkFnZ2dBaUFBTmdJTUlBSWdBVFlDQ0F3QkMwRWZJUUVnQlVILy8vOEhUUVJBSUFWQkppQUZRUWgyWnlJQWEzWkJBWEVnQUVFQmRHdEJQbW9oQVFzZ0FpQUJOZ0ljSUFKQ0FEY0NFQ0FCUVFKMFFielNBR29oQUVHUTBBQW9BZ0FpQTBFQklBRjBJZ1p4UlFSQUlBQWdBallDQUVHUTBBQWdBeUFHY2pZQ0FDQUNJQUEyQWhnZ0FpQUNOZ0lJSUFJZ0FqWUNEQXdCQ3lBRlFSa2dBVUVCZG10QkFDQUJRUjlIRzNRaEFTQUFLQUlBSVFNQ1FBTkFJQU1pQUNnQ0JFRjRjU0FGUmcwQklBRkJIWFloQXlBQlFRRjBJUUVnQUNBRFFRUnhha0VRYWlJR0tBSUFJZ01OQUFzZ0JpQUNOZ0lBSUFJZ0FEWUNHQ0FDSUFJMkFnd2dBaUFDTmdJSURBRUxJQUFvQWdnaUFTQUNOZ0lNSUFBZ0FqWUNDQ0FDUVFBMkFoZ2dBaUFBTmdJTUlBSWdBVFlDQ0F0Qm1OQUFLQUlBSWdFZ0JFME5BRUdrMEFBb0FnQWlBQ0FFYWlJQ0lBRWdCR3NpQVVFQmNqWUNCRUdZMEFBZ0FUWUNBRUdrMEFBZ0FqWUNBQ0FBSUFSQkEzSTJBZ1FnQUVFSWFpRUJEQWdMUVFBaEFVSDgwd0JCTURZQ0FBd0hDMEVBSVFBTElBZEZEUUFDUUNBR0tBSWNJZ0pCQW5SQnZOSUFhaUlES0FJQUlBWkdCRUFnQXlBQU5nSUFJQUFOQVVHUTBBQkJrTkFBS0FJQVFYNGdBbmR4TmdJQURBSUxJQWRCRUVFVUlBY29BaEFnQmtZYmFpQUFOZ0lBSUFCRkRRRUxJQUFnQnpZQ0dDQUdLQUlRSWdJRVFDQUFJQUkyQWhBZ0FpQUFOZ0lZQ3lBR1FSUnFLQUlBSWdKRkRRQWdBRUVVYWlBQ05nSUFJQUlnQURZQ0dBc2dBU0FJYWlFQklBWWdDR29pQmlnQ0JDRUZDeUFHSUFWQmZuRTJBZ1FnQVNBRWFpQUJOZ0lBSUFRZ0FVRUJjallDQkNBQlFmOEJUUVJBSUFGQmVIRkJ0TkFBYWlFQUFuOUJqTkFBS0FJQUlnSkJBU0FCUVFOMmRDSUJjVVVFUUVHTTBBQWdBU0FDY2pZQ0FDQUFEQUVMSUFBb0FnZ0xJZ0VnQkRZQ0RDQUFJQVEyQWdnZ0JDQUFOZ0lNSUFRZ0FUWUNDQXdCQzBFZklRVWdBVUgvLy84SFRRUkFJQUZCSmlBQlFRaDJaeUlBYTNaQkFYRWdBRUVCZEd0QlBtb2hCUXNnQkNBRk5nSWNJQVJDQURjQ0VDQUZRUUowUWJ6U0FHb2hBRUdRMEFBb0FnQWlBa0VCSUFWMElnTnhSUVJBSUFBZ0JEWUNBRUdRMEFBZ0FpQURjallDQUNBRUlBQTJBaGdnQkNBRU5nSUlJQVFnQkRZQ0RBd0JDeUFCUVJrZ0JVRUJkbXRCQUNBRlFSOUhHM1FoQlNBQUtBSUFJUUFDUUFOQUlBQWlBaWdDQkVGNGNTQUJSZzBCSUFWQkhYWWhBQ0FGUVFGMElRVWdBaUFBUVFSeGFrRVFhaUlES0FJQUlnQU5BQXNnQXlBRU5nSUFJQVFnQWpZQ0dDQUVJQVEyQWd3Z0JDQUVOZ0lJREFFTElBSW9BZ2dpQUNBRU5nSU1JQUlnQkRZQ0NDQUVRUUEyQWhnZ0JDQUNOZ0lNSUFRZ0FEWUNDQXNnQ1VFSWFpRUJEQUlMQWtBZ0IwVU5BQUpBSUFNb0Fod2lBVUVDZEVHODBnQnFJZ0lvQWdBZ0EwWUVRQ0FDSUFBMkFnQWdBQTBCUVpEUUFDQUlRWDRnQVhkeElnZzJBZ0FNQWdzZ0IwRVFRUlFnQnlnQ0VDQURSaHRxSUFBMkFnQWdBRVVOQVFzZ0FDQUhOZ0lZSUFNb0FoQWlBUVJBSUFBZ0FUWUNFQ0FCSUFBMkFoZ0xJQU5CRkdvb0FnQWlBVVVOQUNBQVFSUnFJQUUyQWdBZ0FTQUFOZ0lZQ3dKQUlBVkJEMDBFUUNBRElBUWdCV29pQUVFRGNqWUNCQ0FBSUFOcUlnQWdBQ2dDQkVFQmNqWUNCQXdCQ3lBRElBUnFJZ0lnQlVFQmNqWUNCQ0FESUFSQkEzSTJBZ1FnQWlBRmFpQUZOZ0lBSUFWQi93Rk5CRUFnQlVGNGNVRzAwQUJxSVFBQ2YwR00wQUFvQWdBaUFVRUJJQVZCQTNaMElnVnhSUVJBUVl6UUFDQUJJQVZ5TmdJQUlBQU1BUXNnQUNnQ0NBc2lBU0FDTmdJTUlBQWdBallDQ0NBQ0lBQTJBZ3dnQWlBQk5nSUlEQUVMUVI4aEFTQUZRZi8vL3dkTkJFQWdCVUVtSUFWQkNIWm5JZ0JyZGtFQmNTQUFRUUYwYTBFK2FpRUJDeUFDSUFFMkFod2dBa0lBTndJUUlBRkJBblJCdk5JQWFpRUFRUUVnQVhRaUJDQUljVVVFUUNBQUlBSTJBZ0JCa05BQUlBUWdDSEkyQWdBZ0FpQUFOZ0lZSUFJZ0FqWUNDQ0FDSUFJMkFnd01BUXNnQlVFWklBRkJBWFpyUVFBZ0FVRWZSeHQwSVFFZ0FDZ0NBQ0VFQWtBRFFDQUVJZ0FvQWdSQmVIRWdCVVlOQVNBQlFSMTJJUVFnQVVFQmRDRUJJQUFnQkVFRWNXcEJFR29pQmlnQ0FDSUVEUUFMSUFZZ0FqWUNBQ0FDSUFBMkFoZ2dBaUFDTmdJTUlBSWdBallDQ0F3QkN5QUFLQUlJSWdFZ0FqWUNEQ0FBSUFJMkFnZ2dBa0VBTmdJWUlBSWdBRFlDRENBQ0lBRTJBZ2dMSUFOQkNHb2hBUXdCQ3dKQUlBbEZEUUFDUUNBQUtBSWNJZ0ZCQW5SQnZOSUFhaUlDS0FJQUlBQkdCRUFnQWlBRE5nSUFJQU1OQVVHUTBBQWdDMEYrSUFGM2NUWUNBQXdDQ3lBSlFSQkJGQ0FKS0FJUUlBQkdHMm9nQXpZQ0FDQURSUTBCQ3lBRElBazJBaGdnQUNnQ0VDSUJCRUFnQXlBQk5nSVFJQUVnQXpZQ0dBc2dBRUVVYWlnQ0FDSUJSUTBBSUFOQkZHb2dBVFlDQUNBQklBTTJBaGdMQWtBZ0JVRVBUUVJBSUFBZ0JDQUZhaUlCUVFOeU5nSUVJQUFnQVdvaUFTQUJLQUlFUVFGeU5nSUVEQUVMSUFBZ0JHb2lCeUFGUVFGeU5nSUVJQUFnQkVFRGNqWUNCQ0FGSUFkcUlBVTJBZ0FnQ0FSQUlBaEJlSEZCdE5BQWFpRUJRYURRQUNnQ0FDRURBbjlCQVNBSVFRTjJkQ0lDSUFaeFJRUkFRWXpRQUNBQ0lBWnlOZ0lBSUFFTUFRc2dBU2dDQ0FzaUFpQUROZ0lNSUFFZ0F6WUNDQ0FESUFFMkFnd2dBeUFDTmdJSUMwR2cwQUFnQnpZQ0FFR1UwQUFnQlRZQ0FBc2dBRUVJYWlFQkN5QUtRUkJxSkFBZ0FRdERBQ0FBUlFSQVB3QkJFSFFQQ3dKQUlBQkIvLzhEY1EwQUlBQkJBRWdOQUNBQVFSQjJRQUFpQUVGL1JnUkFRZnpUQUVFd05nSUFRWDhQQ3lBQVFSQjBEd3NBQ3d2Y1B5SUFRWUFJQ3drQkFBQUFBZ0FBQUFNQVFaUUlDd1VFQUFBQUJRQkJwQWdMQ1FZQUFBQUhBQUFBQ0FCQjNBZ0xpaTFKYm5aaGJHbGtJR05vWVhJZ2FXNGdkWEpzSUhGMVpYSjVBRk53WVc0Z1kyRnNiR0poWTJzZ1pYSnliM0lnYVc0Z2IyNWZZbTlrZVFCRGIyNTBaVzUwTFV4bGJtZDBhQ0J2ZG1WeVpteHZkd0JEYUhWdWF5QnphWHBsSUc5MlpYSm1iRzkzQUZKbGMzQnZibk5sSUc5MlpYSm1iRzkzQUVsdWRtRnNhV1FnYldWMGFHOWtJR1p2Y2lCSVZGUlFMM2d1ZUNCeVpYRjFaWE4wQUVsdWRtRnNhV1FnYldWMGFHOWtJR1p2Y2lCU1ZGTlFMM2d1ZUNCeVpYRjFaWE4wQUVWNGNHVmpkR1ZrSUZOUFZWSkRSU0J0WlhSb2IyUWdabTl5SUVsRFJTOTRMbmdnY21WeGRXVnpkQUJKYm5aaGJHbGtJR05vWVhJZ2FXNGdkWEpzSUdaeVlXZHRaVzUwSUhOMFlYSjBBRVY0Y0dWamRHVmtJR1J2ZEFCVGNHRnVJR05oYkd4aVlXTnJJR1Z5Y205eUlHbHVJRzl1WDNOMFlYUjFjd0JKYm5aaGJHbGtJSEpsYzNCdmJuTmxJSE4wWVhSMWN3QkpiblpoYkdsa0lHTm9ZWEpoWTNSbGNpQnBiaUJqYUhWdWF5QmxlSFJsYm5OcGIyNXpBRlZ6WlhJZ1kyRnNiR0poWTJzZ1pYSnliM0lBWUc5dVgzSmxjMlYwWUNCallXeHNZbUZqYXlCbGNuSnZjZ0JnYjI1ZlkyaDFibXRmYUdWaFpHVnlZQ0JqWVd4c1ltRmpheUJsY25KdmNnQmdiMjVmYldWemMyRm5aVjlpWldkcGJtQWdZMkZzYkdKaFkyc2daWEp5YjNJQVlHOXVYMk5vZFc1clgyVjRkR1Z1YzJsdmJsOTJZV3gxWldBZ1kyRnNiR0poWTJzZ1pYSnliM0lBWUc5dVgzTjBZWFIxYzE5amIyMXdiR1YwWldBZ1kyRnNiR0poWTJzZ1pYSnliM0lBWUc5dVgzWmxjbk5wYjI1ZlkyOXRjR3hsZEdWZ0lHTmhiR3hpWVdOcklHVnljbTl5QUdCdmJsOTFjbXhmWTI5dGNHeGxkR1ZnSUdOaGJHeGlZV05ySUdWeWNtOXlBR0J2Ymw5amFIVnVhMTlqYjIxd2JHVjBaV0FnWTJGc2JHSmhZMnNnWlhKeWIzSUFZRzl1WDJobFlXUmxjbDkyWVd4MVpWOWpiMjF3YkdWMFpXQWdZMkZzYkdKaFkyc2daWEp5YjNJQVlHOXVYMjFsYzNOaFoyVmZZMjl0Y0d4bGRHVmdJR05oYkd4aVlXTnJJR1Z5Y205eUFHQnZibDl0WlhSb2IyUmZZMjl0Y0d4bGRHVmdJR05oYkd4aVlXTnJJR1Z5Y205eUFHQnZibDlvWldGa1pYSmZabWxsYkdSZlkyOXRjR3hsZEdWZ0lHTmhiR3hpWVdOcklHVnljbTl5QUdCdmJsOWphSFZ1YTE5bGVIUmxibk5wYjI1ZmJtRnRaV0FnWTJGc2JHSmhZMnNnWlhKeWIzSUFWVzVsZUhCbFkzUmxaQ0JqYUdGeUlHbHVJSFZ5YkNCelpYSjJaWElBU1c1MllXeHBaQ0JvWldGa1pYSWdkbUZzZFdVZ1kyaGhjZ0JKYm5aaGJHbGtJR2hsWVdSbGNpQm1hV1ZzWkNCamFHRnlBRk53WVc0Z1kyRnNiR0poWTJzZ1pYSnliM0lnYVc0Z2IyNWZkbVZ5YzJsdmJnQkpiblpoYkdsa0lHMXBibTl5SUhabGNuTnBiMjRBU1c1MllXeHBaQ0J0WVdwdmNpQjJaWEp6YVc5dUFFVjRjR1ZqZEdWa0lITndZV05sSUdGbWRHVnlJSFpsY25OcGIyNEFSWGh3WldOMFpXUWdRMUpNUmlCaFpuUmxjaUIyWlhKemFXOXVBRWx1ZG1Gc2FXUWdTRlJVVUNCMlpYSnphVzl1QUVsdWRtRnNhV1FnYUdWaFpHVnlJSFJ2YTJWdUFGTndZVzRnWTJGc2JHSmhZMnNnWlhKeWIzSWdhVzRnYjI1ZmRYSnNBRWx1ZG1Gc2FXUWdZMmhoY21GamRHVnljeUJwYmlCMWNtd0FWVzVsZUhCbFkzUmxaQ0J6ZEdGeWRDQmphR0Z5SUdsdUlIVnliQUJFYjNWaWJHVWdRQ0JwYmlCMWNtd0FSVzF3ZEhrZ1EyOXVkR1Z1ZEMxTVpXNW5kR2dBU1c1MllXeHBaQ0JqYUdGeVlXTjBaWElnYVc0Z1EyOXVkR1Z1ZEMxTVpXNW5kR2dBUkhWd2JHbGpZWFJsSUVOdmJuUmxiblF0VEdWdVozUm9BRWx1ZG1Gc2FXUWdZMmhoY2lCcGJpQjFjbXdnY0dGMGFBQkRiMjUwWlc1MExVeGxibWQwYUNCallXNG5kQ0JpWlNCd2NtVnpaVzUwSUhkcGRHZ2dWSEpoYm5ObVpYSXRSVzVqYjJScGJtY0FTVzUyWVd4cFpDQmphR0Z5WVdOMFpYSWdhVzRnWTJoMWJtc2djMmw2WlFCVGNHRnVJR05oYkd4aVlXTnJJR1Z5Y205eUlHbHVJRzl1WDJobFlXUmxjbDkyWVd4MVpRQlRjR0Z1SUdOaGJHeGlZV05ySUdWeWNtOXlJR2x1SUc5dVgyTm9kVzVyWDJWNGRHVnVjMmx2Ymw5MllXeDFaUUJKYm5aaGJHbGtJR05vWVhKaFkzUmxjaUJwYmlCamFIVnVheUJsZUhSbGJuTnBiMjV6SUhaaGJIVmxBRTFwYzNOcGJtY2daWGh3WldOMFpXUWdURVlnWVdaMFpYSWdhR1ZoWkdWeUlIWmhiSFZsQUVsdWRtRnNhV1FnWUZSeVlXNXpabVZ5TFVWdVkyOWthVzVuWUNCb1pXRmtaWElnZG1Gc2RXVUFTVzUyWVd4cFpDQmphR0Z5WVdOMFpYSWdhVzRnWTJoMWJtc2daWGgwWlc1emFXOXVjeUJ4ZFc5MFpTQjJZV3gxWlFCSmJuWmhiR2xrSUdOb1lYSmhZM1JsY2lCcGJpQmphSFZ1YXlCbGVIUmxibk5wYjI1eklIRjFiM1JsWkNCMllXeDFaUUJRWVhWelpXUWdZbmtnYjI1ZmFHVmhaR1Z5YzE5amIyMXdiR1YwWlFCSmJuWmhiR2xrSUVWUFJpQnpkR0YwWlFCdmJsOXlaWE5sZENCd1lYVnpaUUJ2Ymw5amFIVnVhMTlvWldGa1pYSWdjR0YxYzJVQWIyNWZiV1Z6YzJGblpWOWlaV2RwYmlCd1lYVnpaUUJ2Ymw5amFIVnVhMTlsZUhSbGJuTnBiMjVmZG1Gc2RXVWdjR0YxYzJVQWIyNWZjM1JoZEhWelgyTnZiWEJzWlhSbElIQmhkWE5sQUc5dVgzWmxjbk5wYjI1ZlkyOXRjR3hsZEdVZ2NHRjFjMlVBYjI1ZmRYSnNYMk52YlhCc1pYUmxJSEJoZFhObEFHOXVYMk5vZFc1clgyTnZiWEJzWlhSbElIQmhkWE5sQUc5dVgyaGxZV1JsY2w5MllXeDFaVjlqYjIxd2JHVjBaU0J3WVhWelpRQnZibDl0WlhOellXZGxYMk52YlhCc1pYUmxJSEJoZFhObEFHOXVYMjFsZEdodlpGOWpiMjF3YkdWMFpTQndZWFZ6WlFCdmJsOW9aV0ZrWlhKZlptbGxiR1JmWTI5dGNHeGxkR1VnY0dGMWMyVUFiMjVmWTJoMWJtdGZaWGgwWlc1emFXOXVYMjVoYldVZ2NHRjFjMlVBVlc1bGVIQmxZM1JsWkNCemNHRmpaU0JoWm5SbGNpQnpkR0Z5ZENCc2FXNWxBRk53WVc0Z1kyRnNiR0poWTJzZ1pYSnliM0lnYVc0Z2IyNWZZMmgxYm10ZlpYaDBaVzV6YVc5dVgyNWhiV1VBU1c1MllXeHBaQ0JqYUdGeVlXTjBaWElnYVc0Z1kyaDFibXNnWlhoMFpXNXphVzl1Y3lCdVlXMWxBRkJoZFhObElHOXVJRU5QVGs1RlExUXZWWEJuY21Ga1pRQlFZWFZ6WlNCdmJpQlFVa2t2VlhCbmNtRmtaUUJGZUhCbFkzUmxaQ0JJVkZSUUx6SWdRMjl1Ym1WamRHbHZiaUJRY21WbVlXTmxBRk53WVc0Z1kyRnNiR0poWTJzZ1pYSnliM0lnYVc0Z2IyNWZiV1YwYUc5a0FFVjRjR1ZqZEdWa0lITndZV05sSUdGbWRHVnlJRzFsZEdodlpBQlRjR0Z1SUdOaGJHeGlZV05ySUdWeWNtOXlJR2x1SUc5dVgyaGxZV1JsY2w5bWFXVnNaQUJRWVhWelpXUUFTVzUyWVd4cFpDQjNiM0prSUdWdVkyOTFiblJsY21Wa0FFbHVkbUZzYVdRZ2JXVjBhRzlrSUdWdVkyOTFiblJsY21Wa0FGVnVaWGh3WldOMFpXUWdZMmhoY2lCcGJpQjFjbXdnYzJOb1pXMWhBRkpsY1hWbGMzUWdhR0Z6SUdsdWRtRnNhV1FnWUZSeVlXNXpabVZ5TFVWdVkyOWthVzVuWUFCVFYwbFVRMGhmVUZKUFdGa0FWVk5GWDFCU1QxaFpBRTFMUVVOVVNWWkpWRmtBVlU1UVVrOURSVk5UUVVKTVJWOUZUbFJKVkZrQVEwOVFXUUJOVDFaRlJGOVFSVkpOUVU1RlRsUk1XUUJVVDA5ZlJVRlNURmtBVGs5VVNVWlpBRVpCU1V4RlJGOUVSVkJGVGtSRlRrTlpBRUpCUkY5SFFWUkZWMEZaQUZCTVFWa0FVRlZVQUVOSVJVTkxUMVZVQUVkQlZFVlhRVmxmVkVsTlJVOVZWQUJTUlZGVlJWTlVYMVJKVFVWUFZWUUFUa1ZVVjA5U1MxOURUMDVPUlVOVVgxUkpUVVZQVlZRQVEwOU9Ua1ZEVkVsUFRsOVVTVTFGVDFWVUFFeFBSMGxPWDFSSlRVVlBWVlFBVGtWVVYwOVNTMTlTUlVGRVgxUkpUVVZQVlZRQVVFOVRWQUJOU1ZORVNWSkZRMVJGUkY5U1JWRlZSVk5VQUVOTVNVVk9WRjlEVEU5VFJVUmZVa1ZSVlVWVFZBQkRURWxGVGxSZlEweFBVMFZFWDB4UFFVUmZRa0ZNUVU1RFJVUmZVa1ZSVlVWVFZBQkNRVVJmVWtWUlZVVlRWQUJJVkZSUVgxSkZVVlZGVTFSZlUwVk9WRjlVVDE5SVZGUlFVMTlRVDFKVUFGSkZVRTlTVkFCSlRWOUJYMVJGUVZCUFZBQlNSVk5GVkY5RFQwNVVSVTVVQUU1UFgwTlBUbFJGVGxRQVVFRlNWRWxCVEY5RFQwNVVSVTVVQUVoUVJWOUpUbFpCVEVsRVgwTlBUbE5VUVU1VUFFaFFSVjlEUWw5U1JWTkZWQUJIUlZRQVNGQkZYMU5VVWtsRFZBQkRUMDVHVEVsRFZBQlVSVTFRVDFKQlVsbGZVa1ZFU1ZKRlExUUFVRVZTVFVGT1JVNVVYMUpGUkVsU1JVTlVBRU5QVGs1RlExUUFUVlZNVkVsZlUxUkJWRlZUQUVoUVJWOUpUbFpCVEVsRVgxTlVRVlJWVXdCVVQwOWZUVUZPV1Y5U1JWRlZSVk5VVXdCRlFWSk1XVjlJU1U1VVV3QlZUa0ZXUVVsTVFVSk1SVjlHVDFKZlRFVkhRVXhmVWtWQlUwOU9Vd0JQVUZSSlQwNVRBRk5YU1ZSRFNFbE9SMTlRVWs5VVQwTlBURk1BVmtGU1NVRk9WRjlCVEZOUFgwNUZSMDlVU1VGVVJWTUFUVlZNVkVsUVRFVmZRMGhQU1VORlV3QkpUbFJGVWs1QlRGOVRSVkpXUlZKZlJWSlNUMUlBVjBWQ1gxTkZVbFpGVWw5VlRrdE9UMWRPWDBWU1VrOVNBRkpCU1V4SFZVNWZSVkpTVDFJQVNVUkZUbFJKVkZsZlVGSlBWa2xFUlZKZlFWVlVTRVZPVkVsRFFWUkpUMDVmUlZKU1QxSUFVMU5NWDBORlVsUkpSa2xEUVZSRlgwVlNVazlTQUVsT1ZrRk1TVVJmV0Y5R1QxSlhRVkpFUlVSZlJrOVNBRk5GVkY5UVFWSkJUVVZVUlZJQVIwVlVYMUJCVWtGTlJWUkZVZ0JJVUVWZlZWTkZVZ0JUUlVWZlQxUklSVklBU0ZCRlgwTkNYME5JVlU1TFgwaEZRVVJGVWdCTlMwTkJURVZPUkVGU0FGTkZWRlZRQUZkRlFsOVRSVkpXUlZKZlNWTmZSRTlYVGdCVVJVRlNSRTlYVGdCSVVFVmZRMHhQVTBWRVgwTlBUazVGUTFSSlQwNEFTRVZWVWtsVFZFbERYMFZZVUVsU1FWUkpUMDRBUkVsVFEwOU9Ua1ZEVkVWRVgwOVFSVkpCVkVsUFRnQk9UMDVmUVZWVVNFOVNTVlJCVkVsV1JWOUpUa1pQVWsxQlZFbFBUZ0JJVUVWZlNVNVdRVXhKUkY5V1JWSlRTVTlPQUVoUVJWOURRbDlOUlZOVFFVZEZYMEpGUjBsT0FGTkpWRVZmU1ZOZlJsSlBXa1ZPQUVoUVJWOUpUbFpCVEVsRVgwaEZRVVJGVWw5VVQwdEZUZ0JKVGxaQlRFbEVYMVJQUzBWT0FFWlBVa0pKUkVSRlRnQkZUa2hCVGtORlgxbFBWVkpmUTBGTVRRQklVRVZmU1U1V1FVeEpSRjlWVWt3QVFreFBRMHRGUkY5Q1dWOVFRVkpGVGxSQlRGOURUMDVVVWs5TUFFMUxRMDlNQUVGRFRBQklVRVZmU1U1VVJWSk9RVXdBVWtWUlZVVlRWRjlJUlVGRVJWSmZSa2xGVEVSVFgxUlBUMTlNUVZKSFJWOVZUazlHUmtsRFNVRk1BRWhRUlY5UFN3QlZUa3hKVGtzQVZVNU1UME5MQUZCU1NRQlNSVlJTV1Y5WFNWUklBRWhRUlY5SlRsWkJURWxFWDBOUFRsUkZUbFJmVEVWT1IxUklBRWhRUlY5VlRrVllVRVZEVkVWRVgwTlBUbFJGVGxSZlRFVk9SMVJJQUVaTVZWTklBRkJTVDFCUVFWUkRTQUJOTFZORlFWSkRTQUJWVWtsZlZFOVBYMHhQVGtjQVVGSlBRMFZUVTBsT1J3Qk5TVk5EUlV4TVFVNUZUMVZUWDFCRlVsTkpVMVJGVGxSZlYwRlNUa2xPUndCTlNWTkRSVXhNUVU1RlQxVlRYMWRCVWs1SlRrY0FTRkJGWDBsT1ZrRk1TVVJmVkZKQlRsTkdSVkpmUlU1RFQwUkpUa2NBUlhod1pXTjBaV1FnUTFKTVJnQklVRVZmU1U1V1FVeEpSRjlEU0ZWT1MxOVRTVnBGQUUxUFZrVUFRMDlPVkVsT1ZVVUFTRkJGWDBOQ1gxTlVRVlJWVTE5RFQwMVFURVZVUlFCSVVFVmZRMEpmU0VWQlJFVlNVMTlEVDAxUVRFVlVSUUJJVUVWZlEwSmZWa1ZTVTBsUFRsOURUMDFRVEVWVVJRQklVRVZmUTBKZlZWSk1YME5QVFZCTVJWUkZBRWhRUlY5RFFsOURTRlZPUzE5RFQwMVFURVZVUlFCSVVFVmZRMEpmU0VWQlJFVlNYMVpCVEZWRlgwTlBUVkJNUlZSRkFFaFFSVjlEUWw5RFNGVk9TMTlGV0ZSRlRsTkpUMDVmVmtGTVZVVmZRMDlOVUV4RlZFVUFTRkJGWDBOQ1gwTklWVTVMWDBWWVZFVk9VMGxQVGw5T1FVMUZYME5QVFZCTVJWUkZBRWhRUlY5RFFsOU5SVk5UUVVkRlgwTlBUVkJNUlZSRkFFaFFSVjlEUWw5TlJWUklUMFJmUTA5TlVFeEZWRVVBU0ZCRlgwTkNYMGhGUVVSRlVsOUdTVVZNUkY5RFQwMVFURVZVUlFCRVJVeEZWRVVBU0ZCRlgwbE9Wa0ZNU1VSZlJVOUdYMU5VUVZSRkFFbE9Wa0ZNU1VSZlUxTk1YME5GVWxSSlJrbERRVlJGQUZCQlZWTkZBRTVQWDFKRlUxQlBUbE5GQUZWT1UxVlFVRTlTVkVWRVgwMUZSRWxCWDFSWlVFVUFSMDlPUlFCT1QxUmZRVU5EUlZCVVFVSk1SUUJUUlZKV1NVTkZYMVZPUVZaQlNVeEJRa3hGQUZKQlRrZEZYMDVQVkY5VFFWUkpVMFpKUVVKTVJRQlBVa2xIU1U1ZlNWTmZWVTVTUlVGRFNFRkNURVVBVWtWVFVFOU9VMFZmU1ZOZlUxUkJURVVBVUZWU1IwVUFUVVZTUjBVQVVrVlJWVVZUVkY5SVJVRkVSVkpmUmtsRlRFUlRYMVJQVDE5TVFWSkhSUUJTUlZGVlJWTlVYMGhGUVVSRlVsOVVUMDlmVEVGU1IwVUFVRUZaVEU5QlJGOVVUMDlmVEVGU1IwVUFTVTVUVlVaR1NVTkpSVTVVWDFOVVQxSkJSMFVBU0ZCRlgxQkJWVk5GUkY5VlVFZFNRVVJGQUVoUVJWOVFRVlZUUlVSZlNESmZWVkJIVWtGRVJRQlRUMVZTUTBVQVFVNU9UMVZPUTBVQVZGSkJRMFVBU0ZCRlgxVk9SVmhRUlVOVVJVUmZVMUJCUTBVQVJFVlRRMUpKUWtVQVZVNVRWVUpUUTFKSlFrVUFVa1ZEVDFKRUFFaFFSVjlKVGxaQlRFbEVYMDFGVkVoUFJBQk9UMVJmUms5VlRrUUFVRkpQVUVaSlRrUUFWVTVDU1U1RUFGSkZRa2xPUkFCVlRrRlZWRWhQVWtsYVJVUUFUVVZVU0U5RVgwNVBWRjlCVEV4UFYwVkVBRWhVVkZCZlZrVlNVMGxQVGw5T1QxUmZVMVZRVUU5U1ZFVkVBRUZNVWtWQlJGbGZVa1ZRVDFKVVJVUUFRVU5EUlZCVVJVUUFUazlVWDBsTlVFeEZUVVZPVkVWRUFFeFBUMUJmUkVWVVJVTlVSVVFBU0ZCRlgwTlNYMFZZVUVWRFZFVkVBRWhRUlY5TVJsOUZXRkJGUTFSRlJBQkRVa1ZCVkVWRUFFbE5YMVZUUlVRQVNGQkZYMUJCVlZORlJBQlVTVTFGVDFWVVgwOURRMVZTUlVRQVVFRlpUVVZPVkY5U1JWRlZTVkpGUkFCUVVrVkRUMDVFU1ZSSlQwNWZVa1ZSVlVsU1JVUUFVRkpQV0ZsZlFWVlVTRVZPVkVsRFFWUkpUMDVmVWtWUlZVbFNSVVFBVGtWVVYwOVNTMTlCVlZSSVJVNVVTVU5CVkVsUFRsOVNSVkZWU1ZKRlJBQk1SVTVIVkVoZlVrVlJWVWxTUlVRQVUxTk1YME5GVWxSSlJrbERRVlJGWDFKRlVWVkpVa1ZFQUZWUVIxSkJSRVZmVWtWUlZVbFNSVVFBVUVGSFJWOUZXRkJKVWtWRUFGQlNSVU5QVGtSSlZFbFBUbDlHUVVsTVJVUUFSVmhRUlVOVVFWUkpUMDVmUmtGSlRFVkVBRkpGVmtGTVNVUkJWRWxQVGw5R1FVbE1SVVFBVTFOTVgwaEJUa1JUU0VGTFJWOUdRVWxNUlVRQVRFOURTMFZFQUZSU1FVNVRSazlTVFVGVVNVOU9YMEZRVUV4SlJVUUFUazlVWDAxUFJFbEdTVVZFQUU1UFZGOUZXRlJGVGtSRlJBQkNRVTVFVjBsRVZFaGZURWxOU1ZSZlJWaERSVVZFUlVRQVUwbFVSVjlKVTE5UFZrVlNURTlCUkVWRUFFaEZRVVFBUlhod1pXTjBaV1FnU0ZSVVVDOEFBRjRUQUFBbUV3QUFNQkFBQVBBWEFBQ2RFd0FBRlJJQUFEa1hBQUR3RWdBQUNoQUFBSFVTQUFDdEVnQUFnaE1BQUU4VUFBQi9FQUFBb0JVQUFDTVVBQUNKRWdBQWl4UUFBRTBWQUFEVUVRQUF6eFFBQUJBWUFBREpGZ0FBM0JZQUFNRVJBQURnRndBQXV4UUFBSFFVQUFCOEZRQUE1UlFBQUFnWEFBQWZFQUFBWlJVQUFLTVVBQUFvRlFBQUFoVUFBSmtWQUFBc0VBQUFpeGtBQUU4UEFBRFVEZ0FBYWhBQUFNNFFBQUFDRndBQWlRNEFBRzRUQUFBY0V3QUFaaFFBQUZZWEFBREJFd0FBelJNQUFHd1RBQUJvRndBQVpoY0FBRjhYQUFBaUV3QUF6ZzhBQUdrT0FBRFlEZ0FBWXhZQUFNc1RBQUNxRGdBQUtCY0FBQ1lYQUFERkV3QUFYUllBQU9nUkFBQm5Fd0FBWlJNQUFQSVdBQUJ6RXdBQUhSY0FBUGtXQUFEekVRQUF6dzRBQU00VkFBQU1FZ0FBc3hFQUFLVVJBQUJoRUFBQU1oY0FBTHNUQUVINU5Rc0JBUUJCa0RZTDRBRUJBUUlCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQUFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRQkIvVGNMQVFFQVFaRTRDMTRDQXdJQ0FnSUNBQUFDQWdBQ0FnQUNBZ0lDQWdJQ0FnSUNBQVFBQUFBQUFBSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FBQUFBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBQWdBQ0FFSDlPUXNCQVFCQmtUb0xYZ0lBQWdJQ0FnSUFBQUlDQUFJQ0FBSUNBZ0lDQWdJQ0FnSUFBd0FFQUFBQUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQUFBQUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0FDQUFJQVFmQTdDdzFzYjNObFpXVndMV0ZzYVhabEFFR0pQQXNCQVFCQm9Ed0w0QUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRQUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUJCaVQ0TEFRRUFRYUErQytjQkFRRUJBUUVCQVFFQkFRRUJBZ0VCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVBQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFGamFIVnVhMlZrQUVHd3dBQUxYd0VCQUFFQkFRRUJBQUFCQVFBQkFRQUJBUUVCQVFFQkFRRUJBQUFBQUFBQUFBRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFBQUFBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVBQVFBQkFFR1F3Z0FMSVdWamRHbHZibVZ1ZEMxc1pXNW5kR2h2Ym5KdmVIa3RZMjl1Ym1WamRHbHZiZ0JCd01JQUN5MXlZVzV6Wm1WeUxXVnVZMjlrYVc1bmNHZHlZV1JsRFFvTkNnMEtVMDBOQ2cwS1ZGUlFMME5GTDFSVFVDOEFRZm5DQUFzRkFRSUFBUU1BUVpEREFBdmdBUVFCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFBRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBRUg1eEFBTEJRRUNBQUVEQUVHUXhRQUw0QUVFQVFFRkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRQUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUJCK2NZQUN3UUJBQUFCQUVHUnh3QUwzd0VCQVFBQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQUFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFBRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBRUg2eUFBTEJBRUFBQUlBUVpESkFBdGZBd1FBQUFRRUJBUUVCQVFFQkFRRUJRUUVCQVFFQkFRRUJBUUVCQUFFQUFZSEJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUFBUUFCQUFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQUFBQUFRQVFmcktBQXNFQVFBQUFRQkJrTXNBQ3dFQkFFR3F5d0FMUVFJQUFBQUFBQUFEQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd0FBQUFBQUFBTURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREFFSDZ6QUFMQkFFQUFBRUFRWkROQUFzQkFRQkJtczBBQ3dZQ0FBQUFBQUlBUWJITkFBczZBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TUFBQUFBQUFBREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdCQjhNNEFDNVlCVGs5VlRrTkZSVU5MVDFWVVRrVkRWRVZVUlVOU1NVSkZURlZUU0VWVVJVRkVVMFZCVWtOSVVrZEZRMVJKVmtsVVdVeEZUa1JCVWxaRlQxUkpSbGxRVkVsUFRsTkRTRk5GUVZsVFZFRlVRMGhIUlU5U1JFbFNSVU5VVDFKVVVrTklVRUZTUVUxRlZFVlNWVkpEUlVKVFExSkpRa1ZCVWtSUFYwNUJRMFZKVGtST1MwTkxWVUpUUTFKSlFrVklWRlJRTDBGRVZGQXYnLCAnYmFzZTY0JylcbiJdLCJuYW1lcyI6WyJCdWZmZXIiLCJyZXF1aXJlIiwibW9kdWxlIiwiZXhwb3J0cyIsImZyb20iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/llhttp/llhttp-wasm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/llhttp/llhttp_simd-wasm.js":
/*!************************************************************!*\
  !*** ./node_modules/undici/lib/llhttp/llhttp_simd-wasm.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { Buffer } = __webpack_require__(/*! node:buffer */ \"node:buffer\");\nmodule.exports = Buffer.from(\"AGFzbQEAAAABJwdgAX8Bf2ADf39/AX9gAX8AYAJ/fwBgBH9/f38Bf2AAAGADf39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQAEA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAAy0sBQYAAAIAAAAAAAACAQIAAgICAAADAAAAAAMDAwMBAQEBAQEBAQEAAAIAAAAEBQFwARISBQMBAAIGCAF/AUGA1AQLB9EFIgZtZW1vcnkCAAtfaW5pdGlhbGl6ZQAIGV9faW5kaXJlY3RfZnVuY3Rpb25fdGFibGUBAAtsbGh0dHBfaW5pdAAJGGxsaHR0cF9zaG91bGRfa2VlcF9hbGl2ZQAvDGxsaHR0cF9hbGxvYwALBm1hbGxvYwAxC2xsaHR0cF9mcmVlAAwEZnJlZQAMD2xsaHR0cF9nZXRfdHlwZQANFWxsaHR0cF9nZXRfaHR0cF9tYWpvcgAOFWxsaHR0cF9nZXRfaHR0cF9taW5vcgAPEWxsaHR0cF9nZXRfbWV0aG9kABAWbGxodHRwX2dldF9zdGF0dXNfY29kZQAREmxsaHR0cF9nZXRfdXBncmFkZQASDGxsaHR0cF9yZXNldAATDmxsaHR0cF9leGVjdXRlABQUbGxodHRwX3NldHRpbmdzX2luaXQAFQ1sbGh0dHBfZmluaXNoABYMbGxodHRwX3BhdXNlABcNbGxodHRwX3Jlc3VtZQAYG2xsaHR0cF9yZXN1bWVfYWZ0ZXJfdXBncmFkZQAZEGxsaHR0cF9nZXRfZXJybm8AGhdsbGh0dHBfZ2V0X2Vycm9yX3JlYXNvbgAbF2xsaHR0cF9zZXRfZXJyb3JfcmVhc29uABwUbGxodHRwX2dldF9lcnJvcl9wb3MAHRFsbGh0dHBfZXJybm9fbmFtZQAeEmxsaHR0cF9tZXRob2RfbmFtZQAfEmxsaHR0cF9zdGF0dXNfbmFtZQAgGmxsaHR0cF9zZXRfbGVu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PgtBhwEMPQtBiAEMPAtBiQEMOwtBigEMOgtBiwEMOQtBjAEMOAtBjQEMNwtBjgEMNgtBjwEMNQtBkAEMNAtBkQEMMwtBkgEMMgtBkwEMMQtBlAEMMAtBlQEMLwtBlgEMLgtBlwEMLQtBmAEMLAtBmQEMKwtBmgEMKgtBmwEMKQtBnAEMKAtBnQEMJwtBngEMJgtBnwEMJQtBoAEMJAtBoQEMIwtBogEMIgtBowEMIQtBpAEMIAtBpQEMHwtBpgEMHgtBpwEMHQtBqAEMHAtBqQEMGwtBqgEMGgtBqwEMGQtBrAEMGAtBrQEMFwtBrgEMFgtBAQwVC0GvAQwUC0GwAQwTC0GxAQwSC0GzAQwRC0GyAQwQC0G0AQwPC0G1AQwOC0G2AQwNC0G3AQwMC0G4AQwLC0G5AQwKC0G6AQwJC0G7AQwIC0HGAQwHC0G8AQwGC0G9AQwFC0G+AQwEC0G/AQwDC0HAAQwCC0HCAQwBC0HBAQshAwNAAkACQAJAAkACQAJAAkACQAJAIAICfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJ/AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAgJ/AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACfwJAAkACfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAC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iQEhAwykAgtBASABLQAAQd8ARw1nGiABQQFqIQEMXgtBigEhAyABIARGDaICIAIoAgAiACAEIAFraiEFIAEgAGtBAWohBgNAIAEtAAAgAEGMzwBqLQAARw1kIABBAUYN+gEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMogILQYsBIQMgASAERg2hAiACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEGOzwBqLQAARw1kIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyiAgsgAkEANgIAIAZBAWohAUECDGULQYwBIQMgASAERg2gAiACKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEHwzwBqLQAARw1jIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyhAgsgAkEANgIAIAZBAWohAUEfDGQLQY0BIQMgASAERg2fAiACKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEHyzwBqLQAARw1iIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAygAgsgAkEANgIAIAZBAWohAUEJDGMLIAEgBEYEQEGOASEDDJ8CCwJAAkAgAS0AAEHJAGsOBwBiYmJiYgFiCyABQQFqIQFB+AAhAwyGAgsgAUEBaiEBQfkAIQMMhQILQY8BIQMgASAERg2dAiACKAIAIgAgBCABa2ohBSABIABrQQVqIQYCQANAIAEtAAAgAEGRzwBqLQAARw1gIABBBUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyeAgsgAkEANgIAIAZBAWohAUEYDGELQZABIQMgASAERg2cAiACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEGXzwBqLQAARw1fIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAydAgsgAkEANgIAIAZBAWohAUEXDGALQZEBIQMgASAERg2bAiACKAIAIgAgBCABa2ohBSABIABrQQZqIQYCQANAIAEtAAAgAEGazwBqLQAARw1eIABBBkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAycAgsgAkEANgIAIAZBAWohAUEVDF8LQZIBIQMgASAERg2aAiACKAIAIgAgBCABa2ohBSABIABrQQVqIQYCQANAIAEtAAAgAEGhzwBqLQAARw1dIABBBUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAybAgsgAkEANgIAIAZBAWohAUEeDF4LIAEgBEYEQEGTASEDDJoCCyABLQAAQcwARw1bIAFBAWohAUEKDF0LIAEgBEYEQEGUASEDDJkCCwJAAkAgAS0AAEHBAGsODwBcXFxcXFxcXFxcXFxcAVwLIAFBAWohAUH+ACEDDIACCyABQQFqIQFB/wAhAwz/AQsgASAERgRAQZUBIQMMmAILAkACQCABLQAAQcEAaw4DAFsBWwsgAUEBaiEBQf0AIQMM/wELIAFBAWohAUGAASEDDP4BC0GWASEDIAEgBEYNlgIgAigCACIAIAQgAWtqIQUgASAAa0EBaiEGAkADQCABLQAAIABBp88Aai0AAEcNWSAAQQFGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMlwILIAJBADYCACAGQQFqIQFBCwxaCyABIARGBEBBlwEhAwyWAgsCQAJAAkACQCABLQAAQS1rDiMAW1tbW1tbW1tbW1tbW1tbW1tbW1tbW1sBW1tbW1sCW1tbA1sLIAFBAWohAUH7ACEDDP8BCyABQQFqIQFB/AAhAwz+AQsgAUEBaiEBQYEBIQMM/QELIAFBAWohAUGCASEDDPwBC0GYASEDIAEgBEYNlAIgAigCACIAIAQgAWtqIQUgASAAa0EEaiEGAkADQCABLQAAIABBqc8Aai0AAEcNVyAAQQRGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMlQILIAJBADYCACAGQQFqIQFBGQxYC0GZASEDIAEgBEYNkwIgAigCACIAIAQgAWtqIQUgASAAa0EFaiEGAkADQCABLQAAIABBrs8Aai0AAEcNViAAQQVGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMlAILIAJBADYCACAGQQFqIQFBBgxXC0GaASEDIAEgBEYNkgIgAigCACIAIAQgAWtqIQUgASAAa0EBaiEGAkADQCABLQAAIABBtM8Aai0AAEcNVSAAQQFGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMkwILIAJBADYCACAGQQFqIQFBHAxWC0GbASEDIAEgBEYNkQIgAigCACIAIAQgAWtqIQUgASAAa0EBaiEGAkADQCABLQAAIABBts8Aai0AAEcNVCAAQQFGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMkgILIAJBADYCACAGQQFqIQFBJwxVCyABIARGBEBBnAEhAwyRAgsCQAJAIAEtAABB1ABrDgIAAVQLIAFBAWohAUGGASEDDPgBCyABQQFqIQFBhwEhAwz3AQtBnQEhAyABIARGDY8CIAIoAgAiACAEIAFraiEFIAEgAGtBAWohBgJAA0AgAS0AACAAQbjPAGotAABHDVIgAEEBRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADJACCyACQQA2AgAgBkEBaiEBQSYMUwtBngEhAyABIARGDY4CIAIoAgAiACAEIAFraiEFIAEgAGtBAWohBgJAA0AgAS0AACAAQbrPAGotAABHDVEgAEEBRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADI8CCyACQQA2AgAgBkEBaiEBQQMMUgtBnwEhAyABIARGDY0CIAIoAgAiACAEIAFraiEFIAEgAGtBAmohBgJAA0AgAS0AACAAQe3PAGotAABHDVAgAEECRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADI4CCyACQQA2AgAgBkEBaiEBQQwMUQtBoAEhAyABIARGDYwCIAIoAgAiACAEIAFraiEFIAEgAGtBA2ohBgJAA0AgAS0AACAAQbzPAGotAABHDU8gAEEDRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADI0CCyACQQA2AgAgBkEBaiEBQQ0MUAsgASAERgRAQaEBIQMMjAILAkACQCABLQAAQcYAaw4LAE9PT09PT09PTwFPCyABQQFqIQFBiwEhAwzzAQsgAUEBaiEBQYwBIQMM8gELIAEgBEYEQEGiASEDDIsCCyABLQAAQdAARw1MIAFBAWohAQxGCyABIARGBEBBowEhAwyKAgsCQAJAIAEtAABByQBrDgcBTU1NTU0ATQsgAUEBaiEBQY4BIQMM8QELIAFBAWohAUEiDE0LQaQBIQMgASAERg2IAiACKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEHAzwBqLQAARw1LIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyJAgsgAkEANgIAIAZBAWohAUEdDEwLIAEgBEYEQEGlASEDDIgCCwJAAkAgAS0AAEHSAGsOAwBLAUsLIAFBAWohAUGQASEDDO8BCyABQQFqIQFBBAxLCyABIARGBEBBpgEhAwyHAgsCQAJAAkACQAJAIAEtAABBwQBrDhUATU1NTU1NTU1NTQFNTQJNTQNNTQRNCyABQQFqIQFBiAEhAwzxAQsgAUEBaiEBQYkBIQMM8AELIAFBAWohAUGKASEDDO8BCyABQQFqIQFBjwEhAwzuAQsgAUEBaiEBQZEBIQMM7QELQacBIQMgASAERg2FAiACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEHtzwBqLQAARw1IIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyGAgsgAkEANgIAIAZBAWohAUERDEkLQagBIQMgASAERg2EAiACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEHCzwBqLQAARw1HIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyFAgsgAkEANgIAIAZBAWohAUEsDEgLQakBIQMgASAERg2DAiACKAIAIgAgBCABa2ohBSABIABrQQRqIQYCQANAIAEtAAAgAEHFzwBqLQAARw1GIABBBEYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyEAgsgAkEANgIAIAZBAWohAUErDEcLQaoBIQMgASAERg2CAiACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEHKzwBqLQAARw1FIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyDAgsgAkEANgIAIAZBAWohAUEUDEYLIAEgBEYEQEGrASEDDIICCwJAAkACQAJAIAEtAABBwgBrDg8AAQJHR0dHR0dHR0dHRwNHCyABQQFqIQFBkwEhAwzrAQsgAUEBaiEBQZQBIQMM6gELIAFBAWohAUGVASEDDOkBCyABQQFqIQFBlgEhAwzoAQsgASAERgRAQawBIQMMgQILIAEtAABBxQBHDUIgAUEBaiEBDD0LQa0BIQMgASAERg3/ASACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEHNzwBqLQAARw1CIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyAAgsgAkEANgIAIAZBAWohAUEODEMLIAEgBEYEQEGuASEDDP8BCyABLQAAQdAARw1AIAFBAWohAUElDEILQa8BIQMgASAERg39ASACKAIAIgAgBCABa2ohBSABIABrQQhqIQYCQANAIAEtAAAgAEHQzwBqLQAARw1AIABBCEYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAz+AQsgAkEANgIAIAZBAWohAUEqDEELIAEgBEYEQEGwASEDDP0BCwJAAkAgAS0AAEHVAGsOCwBAQEBAQEBAQEABQAsgAUEBaiEBQZoBIQMM5AELIAFBAWohAUGbASEDDOMBCyABIARGBEBBsQEhAwz8AQsCQAJAIAEtAABBwQBrDhQAPz8/Pz8/Pz8/Pz8/Pz8/Pz8/AT8LIAFBAWohAUGZASEDDOMBCyABQQFqIQFBnAEhAwziAQtBsgEhAyABIARGDfoBIAIoAgAiACAEIAFraiEFIAEgAGtBA2ohBgJAA0AgAS0AACAAQdnPAGotAABHDT0gAEEDRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADPsBCyACQQA2AgAgBkEBaiEBQSEMPgtBswEhAyABIARGDfkBIAIoAgAiACAEIAFraiEFIAEgAGtBBmohBgJAA0AgAS0AACAAQd3PAGotAABHDTwgAEEGRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAiAFNgIADPoBCyACQQA2AgAgBkEBaiEBQRoMPQsgASAERgRAQbQBIQMM+QELAkACQAJAIAEtAABBxQBrDhEAPT09PT09PT09AT09PT09Aj0LIAFBAWohAUGdASEDDOEBCyABQQFqIQFBngEhAwzgAQsgAUEBaiEBQZ8BIQMM3wELQbUBIQMgASAERg33ASACKAIAIgAgBCABa2ohBSABIABrQQVqIQYCQANAIAEtAAAgAEHkzwBqLQAARw06IABBBUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAz4AQsgAkEANgIAIAZBAWohAUEoDDsLQbYBIQMgASAERg32ASACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEHqzwBqLQAARw05IABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAz3AQsgAkEANgIAIAZBAWohAUEHDDoLIAEgBEYEQEG3ASEDDPYBCwJAAkAgAS0AAEHFAGsODgA5OTk5OTk5OTk5OTkBOQsgAUEBaiEBQaEBIQMM3QELIAFBAWohAUGiASEDDNwBC0G4ASEDIAEgBEYN9AEgAigCACIAIAQgAWtqIQUgASAAa0ECaiEGAkADQCABLQAAIABB7c8Aai0AAEcNNyAAQQJGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAM9QELIAJBADYCACAGQQFqIQFBEgw4C0G5ASEDIAEgBEYN8wEgAigCACIAIAQgAWtqIQUgASAAa0EBaiEGAkADQCABLQAAIABB8M8Aai0AAEcNNiAAQQFGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAM9AELIAJBADYCACAGQQFqIQFBIAw3C0G6ASEDIAEgBEYN8gEgAigCACIAIAQgAWtqIQUgASAAa0EBaiEGAkADQCABLQAAIABB8s8Aai0AAEcNNSAAQQFGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAM8wELIAJBADYCACAGQQFqIQFBDww2CyABIARGBEBBuwEhAwzyAQsCQAJAIAEtAABByQBrDgcANTU1NTUBNQsgAUEBaiEBQaUBIQMM2QELIAFBAWohAUGmASEDDNgBC0G8ASEDIAEgBEYN8AEgAigCACIAIAQgAWtqIQUgASAAa0EHaiEGAkADQCABLQAAIABB9M8Aai0AAEcNMyAAQQdGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAM8QELIAJBADYCACAGQQFqIQFBGww0CyABIARGBEBBvQEhAwzwAQsCQAJAAkAgAS0AAEHCAGsOEgA0NDQ0NDQ0NDQBNDQ0NDQ0AjQLIAFBAWohAUGkASEDDNgBCyABQQFqIQFBpwEhAwzXAQsgAUEBaiEBQagBIQMM1gELIAEgBEYEQEG+ASEDDO8BCyABLQAAQc4ARw0wIAFBAWohAQwsCyABIARGBEBBvwEhAwzuAQsCQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCABLQAAQcEAaw4VAAECAz8EBQY/Pz8HCAkKCz8MDQ4PPwsgAUEBaiEBQegAIQMM4wELIAFBAWohAUHpACEDDOIBCyABQQFqIQFB7gAhAwzhAQsgAUEBaiEBQfIAIQMM4AELIAFBAWohAUHzACEDDN8BCyABQQFqIQFB9gAhAwzeAQsgAUEBaiEBQfcAIQMM3QELIAFBAWohAUH6ACEDDNwBCyABQQFqIQFBgwEhAwzbAQsgAUEBaiEBQYQBIQMM2gELIAFBAWohAUGFASEDDNkBCyABQQFqIQFBkgEhAwzYAQsgAUEBaiEBQZgBIQMM1wELIAFBAWohAUGgASEDDNYBCyABQQFqIQFBowEhAwzVAQsgAUEBaiEBQaoBIQMM1AELIAEgBEcEQCACQRA2AgggAiABNgIEQasBIQMM1AELQcABIQMM7AELQQAhAAJAIAIoAjgiA0UNACADKAI0IgNFDQAgAiADEQAAIQALIABFDV4gAEEVRw0HIAJB0QA2AhwgAiABNgIUIAJBsBc2AhAgAkEVNgIMQQAhAwzrAQsgAUEBaiABIARHDQgaQcIBIQMM6gELA0ACQCABLQAAQQprDgQIAAALAAsgBCABQQFqIgFHDQALQcMBIQMM6QELIAEgBEcEQCACQRE2AgggAiABNgIEQQEhAwzQAQtBxAEhAwzoAQsgASAERgRAQcUBIQMM6AELAkACQCABLQAAQQprDgQBKCgAKAsgAUEBagwJCyABQQFqDAULIAEgBEYEQEHGASEDDOcBCwJAAkAgAS0AAEEKaw4XAQsLAQsLCwsLCwsLCwsLCwsLCwsLCwALCyABQQFqIQELQbABIQMMzQELIAEgBEYEQEHIASEDDOYBCyABLQAAQSBHDQkgAkEAOwEyIAFBAWohAUGzASEDDMwBCwNAIAEhAAJAIAEgBEcEQCABLQAAQTBrQf8BcSIDQQpJDQEMJwtBxwEhAwzmAQsCQCACLwEyIgFBmTNLDQAgAiABQQpsIgU7ATIgBUH+/wNxIANB//8Dc0sNACAAQQFqIQEgAiADIAVqIgM7ATIgA0H//wNxQegHSQ0BCwtBACEDIAJBADYCHCACQcEJNgIQIAJBDTYCDCACIABBAWo2AhQM5AELIAJBADYCHCACIAE2AhQgAkHwDDYCECACQRs2AgxBACEDDOMBCyACKAIEIQAgAkEANgIEIAIgACABECYiAA0BIAFBAWoLIQFBrQEhAwzIAQsgAkHBATYCHCACIAA2AgwgAiABQQFqNgIUQQAhAwzgAQsgAigCBCEAIAJBADYCBCACIAAgARAmIgANASABQQFqCyEBQa4BIQMMxQELIAJBwgE2AhwgAiAANgIMIAIgAUEBajYCFEEAIQMM3QELIAJBADYCHCACIAE2AhQgAkGXCzYCECACQQ02AgxBACEDDNwBCyACQQA2AhwgAiABNgIUIAJB4xA2AhAgAkEJNgIMQQAhAwzbAQsgAkECOgAoDKwBC0EAIQMgAkEANgIcIAJBrws2AhAgAkECNgIMIAIgAUEBajYCFAzZAQtBAiEDDL8BC0ENIQMMvgELQSYhAwy9AQtBFSEDDLwBC0EWIQMMuwELQRghAwy6AQtBHCEDDLkBC0EdIQMMuAELQSAhAwy3AQtBISEDDLYBC0EjIQMMtQELQcYAIQMMtAELQS4hAwyzAQtBPSEDDLIBC0HLACEDDLEBC0HOACEDDLABC0HYACEDDK8BC0HZACEDDK4BC0HbACEDDK0BC0HxACEDDKwBC0H0ACEDDKsBC0GNASEDDKoBC0GXASEDDKkBC0GpASEDDKgBC0GvASEDDKcBC0GxASEDDKYBCyACQQA2AgALQQAhAyACQQA2AhwgAiABNgIUIAJB8Rs2AhAgAkEGNgIMDL0BCyACQQA2AgAgBkEBaiEBQSQLOgApIAIoAgQhACACQQA2AgQgAiAAIAEQJyIARQRAQeUAIQMMowELIAJB+QA2AhwgAiABNgIUIAIgADYCDEEAIQMMuwELIABBFUcEQCACQQA2AhwgAiABNgIUIAJBzA42AhAgAkEgNgIMQQAhAwy7AQsgAkH4ADYCHCACIAE2AhQgAkHKGDYCECACQRU2AgxBACEDDLoBCyACQQA2AhwgAiABNgIUIAJBjhs2AhAgAkEGNgIMQQAhAwy5AQsgAkEANgIcIAIgATYCFCACQf4RNgIQIAJBBzYCDEEAIQMMuAELIAJBADYCHCACIAE2AhQgAkGMHDYCECACQQc2AgxBACEDDLcBCyACQQA2AhwgAiABNgIUIAJBww82AhAgAkEHNgIMQQAhAwy2AQsgAkEANgIcIAIgATYCFCACQcMPNgIQIAJBBzYCDEEAIQMMtQELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0RIAJB5QA2AhwgAiABNgIUIAIgADYCDEEAIQMMtAELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0gIAJB0wA2AhwgAiABNgIUIAIgADYCDEEAIQMMswELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0iIAJB0gA2AhwgAiABNgIUIAIgADYCDEEAIQMMsgELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0OIAJB5QA2AhwgAiABNgIUIAIgADYCDEEAIQMMsQELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0dIAJB0wA2AhwgAiABNgIUIAIgADYCDEEAIQMMsAELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0fIAJB0gA2AhwgAiABNgIUIAIgADYCDEEAIQMMrwELIABBP0cNASABQQFqCyEBQQUhAwyUAQtBACEDIAJBADYCHCACIAE2AhQgAkH9EjYCECACQQc2AgwMrAELIAJBADYCHCACIAE2AhQgAkHcCDYCECACQQc2AgxBACEDDKsBCyACKAIEIQAgAkEANgIEIAIgACABECUiAEUNByACQeUANgIcIAIgATYCFCACIAA2AgxBACEDDKoBCyACKAIEIQAgAkEANgIEIAIgACABECUiAEUNFiACQdMANgIcIAIgATYCFCACIAA2AgxBACEDDKkBCyACKAIEIQAgAkEANgIEIAIgACABECUiAEUNGCACQdIANgIcIAIgATYCFCACIAA2AgxBACEDDKgBCyACQQA2AhwgAiABNgIUIAJBxgo2AhAgAkEHNgIMQQAhAwynAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDQMgAkHlADYCHCACIAE2AhQgAiAANgIMQQAhAwymAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDRIgAkHTADYCHCACIAE2AhQgAiAANgIMQQAhAwylAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDRQgAkHSADYCHCACIAE2AhQgAiAANgIMQQAhAwykAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDQAgAkHlADYCHCACIAE2AhQgAiAANgIMQQAhAwyjAQtB1QAhAwyJAQsgAEEVRwRAIAJBADYCHCACIAE2AhQgAkG5DTYCECACQRo2AgxB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AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIABB5ABrDvQDY2IAAWFhYWFhYQIDBAVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhBgcICQoLDA0OD2FhYWFhEGFhYWFhYWFhYWFhEWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYRITFBUWFxgZGhthYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhHB0eHyAhIiMkJSYnKCkqKywtLi8wMTIzNDU2YTc4OTphYWFhYWFhYTthYWE8YWFhYT0+P2FhYWFhYWFhQGFhQWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYUJDREVGR0hJSktMTU5PUFFSU2FhYWFhYWFhVFVWV1hZWlthXF1hYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFeYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhX2BhC0HhJw8LQaQhDwtByywPC0H+MQ8LQcAkDwtBqyQPC0GNKA8LQeImDwtBgDAPC0G5Lw8LQdckDwtB7x8PC0HhHw8LQfofDwtB8iAPC0GoLw8LQa4yDwtBiDAPC0HsJw8LQYIiDwtBjh0PC0HQLg8LQcojDwtBxTIPC0HfHA8LQdIcDwtBxCAPC0HXIA8LQaIfDwtB7S4PC0GrMA8LQdQlDwtBzC4PC0H6Lg8LQfwrDwtB0jAPC0HxHQ8LQbsgDwtB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AAADAEGUCAsFBAAAAAUAQaQICwkGAAAABwAAAAgAQdwIC4otSW52YWxpZCBjaGFyIGluIHVybCBxdWVyeQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2JvZHkAQ29udGVudC1MZW5ndGggb3ZlcmZsb3cAQ2h1bmsgc2l6ZSBvdmVyZmxvdwBSZXNwb25zZSBvdmVyZmxvdwBJbnZhbGlkIG1ldGhvZCBmb3IgSFRUUC94LnggcmVxdWVzdABJbnZhbGlkIG1ldGhvZCBmb3IgUlRTUC94LnggcmVxdWVzdABFeHBlY3RlZCBTT1VSQ0UgbWV0aG9kIGZvciBJQ0UveC54IHJlcXVlc3QASW52YWxpZCBjaGFyIGluIHVybCBmcmFnbWVudCBzdGFydABFeHBlY3RlZCBkb3QAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9zdGF0dXMASW52YWxpZCByZXNwb25zZSBzdGF0dXMASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucwBVc2VyIGNhbGxiYWNrIGVycm9yAGBvbl9yZXNldGAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2hlYWRlcmAgY2FsbGJhY2sgZXJyb3IAYG9uX21lc3NhZ2VfYmVnaW5gIGNhbGxiYWNrIGVycm9yAGBvbl9jaHVua19leHRlbnNpb25fdmFsdWVgIGNhbGxiYWNrIGVycm9yAGBvbl9zdGF0dXNfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl92ZXJzaW9uX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fdXJsX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXNzYWdlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWV0aG9kX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX25hbWVgIGNhbGxiYWNrIGVycm9yAFVuZXhwZWN0ZWQgY2hhciBpbiB1cmwgc2VydmVyAEludmFsaWQgaGVhZGVyIHZhbHVlIGNoYXIASW52YWxpZCBoZWFkZXIgZmllbGQgY2hhcgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3ZlcnNpb24ASW52YWxpZCBtaW5vciB2ZXJzaW9uAEludmFsaWQgbWFqb3IgdmVyc2lvbgBFeHBlY3RlZCBzcGFjZSBhZnRlciB2ZXJzaW9uAEV4cGVjdGVkIENSTEYgYWZ0ZXIgdmVyc2lvbgBJbnZhbGlkIEhUVFAgdmVyc2lvbgBJbnZhbGlkIGhlYWRlciB0b2tlbgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3VybABJbnZhbGlkIGNoYXJhY3RlcnMgaW4gdXJsAFVuZXhwZWN0ZWQgc3RhcnQgY2hhciBpbiB1cmwARG91YmxlIEAgaW4gdXJsAEVtcHR5IENvbnRlbnQtTGVuZ3RoAEludmFsaWQgY2hhcmFjdGVyIGluIENvbnRlbnQtTGVuZ3RoAER1cGxpY2F0ZSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXIgaW4gdXJsIHBhdGgAQ29udGVudC1MZW5ndGggY2FuJ3QgYmUgcHJlc2VudCB3aXRoIFRyYW5zZmVyLUVuY29kaW5nAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIHNpemUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfdmFsdWUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9jaHVua19leHRlbnNpb25fdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyB2YWx1ZQBNaXNzaW5nIGV4cGVjdGVkIExGIGFmdGVyIGhlYWRlciB2YWx1ZQBJbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AgaGVhZGVyIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGUgdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBxdW90ZWQgdmFsdWUAUGF1c2VkIGJ5IG9uX2hlYWRlcnNfY29tcGxldGUASW52YWxpZCBFT0Ygc3RhdGUAb25fcmVzZXQgcGF1c2UAb25fY2h1bmtfaGVhZGVyIHBhdXNlAG9uX21lc3NhZ2VfYmVnaW4gcGF1c2UAb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlIHBhdXNlAG9uX3N0YXR1c19jb21wbGV0ZSBwYXVzZQBvbl92ZXJzaW9uX2NvbXBsZXRlIHBhdXNlAG9uX3VybF9jb21wbGV0ZSBwYXVzZQBvbl9jaHVua19jb21wbGV0ZSBwYXVzZQBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGUgcGF1c2UAb25fbWVzc2FnZV9jb21wbGV0ZSBwYXVzZQBvbl9tZXRob2RfY29tcGxldGUgcGF1c2UAb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlIHBhdXNlAG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lIHBhdXNlAFVuZXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgc3RhcnQgbGluZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgbmFtZQBQYXVzZSBvbiBDT05ORUNUL1VwZ3JhZGUAUGF1c2Ugb24gUFJJL1VwZ3JhZGUARXhwZWN0ZWQgSFRUUC8yIENvbm5lY3Rpb24gUHJlZmFjZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX21ldGhvZABFeHBlY3RlZCBzcGFjZSBhZnRlciBtZXRob2QAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfZmllbGQAUGF1c2VkAEludmFsaWQgd29yZCBlbmNvdW50ZXJlZABJbnZhbGlkIG1ldGhvZCBlbmNvdW50ZXJlZABVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNjaGVtYQBSZXF1ZXN0IGhhcyBpbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AAU1dJVENIX1BST1hZAFVTRV9QUk9YWQBNS0FDVElWSVRZAFVOUFJPQ0VTU0FCTEVfRU5USVRZAENPUFkATU9WRURfUEVSTUFORU5UTFkAVE9PX0VBUkxZAE5PVElGWQBGQUlMRURfREVQRU5ERU5DWQBCQURfR0FURVdBWQBQTEFZAFBVVABDSEVDS09VVABHQVRFV0FZX1RJTUVPVVQAUkVRVUVTVF9USU1FT1VUAE5FVFdPUktfQ09OTkVDVF9USU1FT1VUAENPTk5FQ1RJT05fVElNRU9VVABMT0dJTl9USU1FT1VUAE5FVFdPUktfUkVBRF9USU1FT1VUAFBPU1QATUlTRElSRUNURURfUkVRVUVTVABDTElFTlRfQ0xPU0VEX1JFUVVFU1QAQ0xJRU5UX0NMT1NFRF9MT0FEX0JBTEFOQ0VEX1JFUVVFU1QAQkFEX1JFUVVFU1QASFRUUF9SRVFVRVNUX1NFTlRfVE9fSFRUUFNfUE9SVABSRVBPUlQASU1fQV9URUFQT1QAUkVTRVRfQ09OVEVOVABOT19DT05URU5UAFBBUlRJQUxfQ09OVEVOVABIUEVfSU5WQUxJRF9DT05TVEFOVABIUEVfQ0JfUkVTRVQAR0VUAEhQRV9TVFJJQ1QAQ09ORkxJQ1QAVEVNUE9SQVJZX1JFRElSRUNUAFBFUk1BTkVOVF9SRURJUkVDVABDT05ORUNUAE1VTFRJX1NUQVRVUwBIUEVfSU5WQUxJRF9TVEFUVVMAVE9PX01BTllfUkVRVUVTVFMARUFSTFlfSElOVFMAVU5BVkFJTEFCTEVfRk9SX0xFR0FMX1JFQVNPTlMAT1BUSU9OUwBTV0lUQ0hJTkdfUFJPVE9DT0xTAFZBUklBTlRfQUxTT19ORUdPVElBVEVTAE1VTFRJUExFX0NIT0lDRVMASU5URVJOQUxfU0VSVkVSX0VSUk9SAFdFQl9TRVJWRVJfVU5LTk9XTl9FUlJPUgBSQUlMR1VOX0VSUk9SAElERU5USVRZX1BST1ZJREVSX0FVVEhFTlRJQ0FUSU9OX0VSUk9SAFNTTF9DRVJUSUZJQ0FURV9FUlJPUgBJTlZBTElEX1hfRk9SV0FSREVEX0ZPUgBTRVRfUEFSQU1FVEVSAEdFVF9QQVJBTUVURVIASFBFX1VTRVIAU0VFX09USEVSAEhQRV9DQl9DSFVOS19IRUFERVIATUtDQUxFTkRBUgBTRVRVUABXRUJfU0VSVkVSX0lTX0RPV04AVEVBUkRPV04ASFBFX0NMT1NFRF9DT05ORUNUSU9OAEhFVVJJU1RJQ19FWFBJUkFUSU9OAERJU0NPTk5FQ1RFRF9PUEVSQVRJT04ATk9OX0FVVEhPUklUQVRJVkVfSU5GT1JNQVRJT04ASFBFX0lOVkFMSURfVkVSU0lPTgBIUEVfQ0JfTUVTU0FHRV9CRUdJTgBTSVRFX0lTX0ZST1pFTgBIUEVfSU5WQUxJRF9IRUFERVJfVE9LRU4ASU5WQUxJRF9UT0tFTgBGT1JCSURERU4ARU5IQU5DRV9ZT1VSX0NBTE0ASFBFX0lOVkFMSURfVVJMAEJMT0NLRURfQllfUEFSRU5UQUxfQ09OVFJPTABNS0NPTABBQ0wASFBFX0lOVEVSTkFMAFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0VfVU5PRkZJQ0lBTABIUEVfT0sAVU5MSU5LAFVOTE9DSwBQUkkAUkVUUllfV0lUSABIUEVfSU5WQUxJRF9DT05URU5UX0xFTkdUSABIUEVfVU5FWFBFQ1RFRF9DT05URU5UX0xFTkdUSABGTFVTSABQUk9QUEFUQ0gATS1TRUFSQ0gAVVJJX1RPT19MT05HAFBST0NFU1NJTkcATUlTQ0VMTEFORU9VU19QRVJTSVNURU5UX1dBUk5JTkcATUlTQ0VMTEFORU9VU19XQVJOSU5HAEhQRV9JTlZBTElEX1RSQU5TRkVSX0VOQ09ESU5HAEV4cGVjdGVkIENSTEYASFBFX0lOVkFMSURfQ0hVTktfU0laRQBNT1ZFAENPTlRJTlVFAEhQRV9DQl9TVEFUVVNfQ09NUExFVEUASFBFX0NCX0hFQURFUlNfQ09NUExFVEUASFBFX0NCX1ZFUlNJT05fQ09NUExFVEUASFBFX0NCX1VSTF9DT01QTEVURQBIUEVfQ0JfQ0hVTktfQ09NUExFVEUASFBFX0NCX0hFQURFUl9WQUxVRV9DT01QTEVURQBIUEVfQ0JfQ0hVTktfRVhURU5TSU9OX1ZBTFVFX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19FWFRFTlNJT05fTkFNRV9DT01QTEVURQBIUEVfQ0JfTUVTU0FHRV9DT01QTEVURQBIUEVfQ0JfTUVUSE9EX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJfRklFTERfQ09NUExFVEUAREVMRVRFAEhQRV9JTlZBTElEX0VPRl9TVEFURQBJTlZBTElEX1NTTF9DRVJUSUZJQ0FURQBQQVVTRQBOT19SRVNQT05TRQBVTlNVUFBPUlRFRF9NRURJQV9UWVBFAEdPTkUATk9UX0FDQ0VQVEFCTEUAU0VSVklDRV9VTkFWQUlMQUJMRQBSQU5HRV9OT1RfU0FUSVNGSUFCTEUAT1JJR0lOX0lTX1VOUkVBQ0hBQkxFAFJFU1BPTlNFX0lTX1NUQUxFAFBVUkdFAE1FUkdFAFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0UAUkVRVUVTVF9IRUFERVJfVE9PX0xBUkdFAFBBWUxPQURfVE9PX0xBUkdFAElOU1VGRklDSUVOVF9TVE9SQUdFAEhQRV9QQVVTRURfVVBHUkFERQBIUEVfUEFVU0VEX0gyX1VQR1JBREUAU09VUkNFAEFOTk9VTkNFAFRSQUNFAEhQRV9VTkVYUEVDVEVEX1NQQUNFAERFU0NSSUJFAFVOU1VCU0NSSUJFAFJFQ09SRABIUEVfSU5WQUxJRF9NRVRIT0QATk9UX0ZPVU5EAFBST1BGSU5EAFVOQklORABSRUJJTkQAVU5BVVRIT1JJWkVEAE1FVEhPRF9OT1RfQUxMT1dFRABIVFRQX1ZFUlNJT05fTk9UX1NVUFBPUlRFRABBTFJFQURZX1JFUE9SVEVEAEFDQ0VQVEVEAE5PVF9JTVBMRU1FTlRFRABMT09QX0RFVEVDVEVEAEhQRV9DUl9FWFBFQ1RFRABIUEVfTEZfRVhQRUNURUQAQ1JFQVRFRABJTV9VU0VEAEhQRV9QQVVTRUQAVElNRU9VVF9PQ0NVUkVEAFBBWU1FTlRfUkVRVUlSRUQAUFJFQ09ORElUSU9OX1JFUVVJUkVEAFBST1hZX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEAE5FVFdPUktfQVVUSEVOVElDQVRJT05fUkVRVUlSRUQATEVOR1RIX1JFUVVJUkVEAFNTTF9DRVJUSUZJQ0FURV9SRVFVSVJFRABVUEdSQURFX1JFUVVJUkVEAFBBR0VfRVhQSVJFRABQUkVDT05ESVRJT05fRkFJTEVEAEVYUEVDVEFUSU9OX0ZBSUxFRABSRVZBTElEQVRJT05fRkFJTEVEAFNTTF9IQU5EU0hBS0VfRkFJTEVEAExPQ0tFRABUUkFOU0ZPUk1BVElPTl9BUFBMSUVEAE5PVF9NT0RJRklFRABOT1RfRVhURU5ERUQAQkFORFdJRFRIX0xJTUlUX0VYQ0VFREVEAFNJVEVfSVNfT1ZFUkxPQURFRABIRUFEAEV4cGVjdGVkIEhUVFAvAABeEwAAJhMAADAQAADwFwAAnRMAABUSAAA5FwAA8BIAAAoQAAB1EgAArRIAAIITAABPFAAAfxAAAKAVAAAjFAAAiRIAAIsUAABNFQAA1BEAAM8UAAAQGAAAyRYAANwWAADBEQAA4BcAALsUAAB0FAAAfBUAAOUUAAAIFwAAHxAAAGUVAACjFAAAKBUAAAIVAACZFQAALBAAAIsZAABPDwAA1A4AAGoQAADOEAAAAhcAAIkOAABuEwAAHBMAAGYUAABWFwAAwRMAAM0TAABsEwAAaBcAAGYXAABfFwAAIhMAAM4PAABpDgAA2A4AAGMWAADLEwAAqg4AACgXAAAmFwAAxRMAAF0WAADoEQAAZxMAAGUTAADyFgAAcxMAAB0XAAD5FgAA8xEAAM8OAADOFQAADBIAALMRAAClEQAAYRAAADIXAAC7EwBB+TULAQEAQZA2C+ABAQECAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAQf03CwEBAEGROAteAgMCAgICAgAAAgIAAgIAAgICAgICAgICAgAEAAAAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAgICAAIAAgBB/TkLAQEAQZE6C14CAAICAgICAAACAgACAgACAgICAgICAgICAAMABAAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAAgACAEHwOwsNbG9zZWVlcC1hbGl2ZQBBiTwLAQEAQaA8C+ABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAQYk+CwEBAEGgPgvnAQEBAQEBAQEBAQEBAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBY2h1bmtlZABBsMAAC18BAQABAQEBAQAAAQEAAQEAAQEBAQEBAQEBAQAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQBBkMIACyFlY3Rpb25lbnQtbGVuZ3Rob25yb3h5LWNvbm5lY3Rpb24AQcDCAAstcmFuc2Zlci1lbmNvZGluZ3BncmFkZQ0KDQoNClNNDQoNClRUUC9DRS9UU1AvAEH5wgALBQECAAEDAEGQwwAL4AEEAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQBB+cQACwUBAgABAwBBkMUAC+ABBAEBBQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAQfnGAAsEAQAAAQBBkccAC98BAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQBB+sgACwQBAAACAEGQyQALXwMEAAAEBAQEBAQEBAQEBAUEBAQEBAQEBAQEBAQABAAGBwQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEAEH6ygALBAEAAAEAQZDLAAsBAQBBqssAC0ECAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwBB+swACwQBAAABAEGQzQALAQEAQZrNAAsGAgAAAAACAEGxzQALOgMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAQfDOAAuWAU5PVU5DRUVDS09VVE5FQ1RFVEVDUklCRUxVU0hFVEVBRFNFQVJDSFJHRUNUSVZJVFlMRU5EQVJWRU9USUZZUFRJT05TQ0hTRUFZU1RBVENIR0VPUkRJUkVDVE9SVFJDSFBBUkFNRVRFUlVSQ0VCU0NSSUJFQVJET1dOQUNFSU5ETktDS1VCU0NSSUJFSFRUUC9BRFRQLw==\", \"base64\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9sbGh0dHAvbGxodHRwX3NpbWQtd2FzbS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU0sRUFBRUEsTUFBQUEsRUFBUSxHQUFHQyxtQkFBT0EsQ0FBQztBQUUzQkMsT0FBT0MsT0FBTyxHQUFHSCxPQUFPSSxJQUFJLENBQUMsZzIrREFBZzIrRCIsInNvdXJjZXMiOlsid2VicGFjazovL21vY2t1cGZsb3cvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9sbGh0dHAvbGxodHRwX3NpbWQtd2FzbS5qcz9jN2ZmIiwid2VicGFjazovL21vY2t1cGZsb3cvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9sbGh0dHAvbGxodHRwX3NpbWQtd2FzbS5qcz9jN2ZmKiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyBCdWZmZXIgfSA9IHJlcXVpcmUoJ25vZGU6YnVmZmVyJylcblxubW9kdWxlLmV4cG9ydHMgPSBCdWZmZXIuZnJvbSgnQUdGemJRRUFBQUFCSndkZ0FYOEJmMkFEZjM5L0FYOWdBWDhBWUFKL2Z3QmdCSDkvZjM4QmYyQUFBR0FEZjM5L0FBTExBUWdEWlc1MkdIZGhjMjFmYjI1ZmFHVmhaR1Z5YzE5amIyMXdiR1YwWlFBRUEyVnVkaFYzWVhOdFgyOXVYMjFsYzNOaFoyVmZZbVZuYVc0QUFBTmxibllMZDJGemJWOXZibDkxY213QUFRTmxibllPZDJGemJWOXZibDl6ZEdGMGRYTUFBUU5sYm5ZVWQyRnpiVjl2Ymw5b1pXRmtaWEpmWm1sbGJHUUFBUU5sYm5ZVWQyRnpiVjl2Ymw5b1pXRmtaWEpmZG1Gc2RXVUFBUU5sYm5ZTWQyRnpiVjl2Ymw5aWIyUjVBQUVEWlc1MkdIZGhjMjFmYjI1ZmJXVnpjMkZuWlY5amIyMXdiR1YwWlFBQUF5MHNCUVlBQUFJQUFBQUFBQUFDQVFJQUFnSUNBQUFEQUFBQUFBTURBd01CQVFFQkFRRUJBUUVBQUFJQUFBQUVCUUZ3QVJJU0JRTUJBQUlHQ0FGL0FVR0ExQVFMQjlFRklnWnRaVzF2Y25rQ0FBdGZhVzVwZEdsaGJHbDZaUUFJR1Y5ZmFXNWthWEpsWTNSZlpuVnVZM1JwYjI1ZmRHRmliR1VCQUF0c2JHaDBkSEJmYVc1cGRBQUpHR3hzYUhSMGNGOXphRzkxYkdSZmEyVmxjRjloYkdsMlpRQXZER3hzYUhSMGNGOWhiR3h2WXdBTEJtMWhiR3h2WXdBeEMyeHNhSFIwY0Y5bWNtVmxBQXdFWm5KbFpRQU1EMnhzYUhSMGNGOW5aWFJmZEhsd1pRQU5GV3hzYUhSMGNGOW5aWFJmYUhSMGNGOXRZV3B2Y2dBT0ZXeHNhSFIwY0Y5blpYUmZhSFIwY0Y5dGFXNXZjZ0FQRVd4c2FIUjBjRjluWlhSZmJXVjBhRzlrQUJBV2JHeG9kSFJ3WDJkbGRGOXpkR0YwZFhOZlkyOWtaUUFSRW14c2FIUjBjRjluWlhSZmRYQm5jbUZrWlFBU0RHeHNhSFIwY0Y5eVpYTmxkQUFURG14c2FIUjBjRjlsZUdWamRYUmxBQlFVYkd4b2RIUndYM05sZEhScGJtZHpYMmx1YVhRQUZRMXNiR2gwZEhCZlptbHVhWE5vQUJZTWJHeG9kSFJ3WDNCaGRYTmxBQmNOYkd4b2RIUndYM0psYzNWdFpRQVlHMnhzYUhSMGNGOXlaWE4xYldWZllXWjBaWEpmZFhCbmNtRmtaUUFaRUd4c2FIUjBjRjluWlhSZlpYSnlibThBR2hkc2JHaDBkSEJmWjJWMFgyVnljbTl5WDNKbFlYTnZiZ0FiRjJ4c2FIUjBjRjl6WlhSZlpYSnliM0pmY21WaGMyOXVBQndVYkd4b2RIUndYMmRsZEY5bGNuSnZjbDl3YjNNQUhSRnNiR2gwZEhCZlpYSnlibTlmYm1GdFpRQWVFbXhzYUhSMGNGOXRaWFJvYjJSZmJtRnRaUUFmRW14c2FIUjBjRjl6ZEdGMGRYTmZibUZ0WlFBZ0dteHNhSFIwY0Y5elpYUmZiR1Z1YVdWdWRGOW9aV0ZrWlhKekFDRWhiR3hvZEhSd1gzTmxkRjlzWlc1cFpXNTBYMk5vZFc1clpXUmZiR1Z1WjNSb0FDSWRiR3hvZEhSd1gzTmxkRjlzWlc1cFpXNTBYMnRsWlhCZllXeHBkbVVBSXlSc2JHaDBkSEJmYzJWMFgyeGxibWxsYm5SZmRISmhibk5tWlhKZlpXNWpiMlJwYm1jQUpCaHNiR2gwZEhCZmJXVnpjMkZuWlY5dVpXVmtjMTlsYjJZQUxna1hBUUJCQVFzUkFRSURCQVVLQmdjckxTd3FLU2dsSnlZSzc3TUNMQllBUVlqUUFDZ0NBQVJBQUF0QmlOQUFRUUUyQWdBTEZBQWdBQkF3SUFBZ0FqWUNPQ0FBSUFFNkFDZ0xGQUFnQUNBQUx3RXlJQUF0QUM0Z0FCQXZFQUFMSGdFQmYwSEFBQkF5SWdFUU1DQUJRWUFJTmdJNElBRWdBRG9BS0NBQkM0OE1BUWQvQWtBZ0FFVU5BQ0FBUVFocklnRWdBRUVFYXlnQ0FDSUFRWGh4SWdScUlRVUNRQ0FBUVFGeERRQWdBRUVEY1VVTkFTQUJJQUVvQWdBaUFHc2lBVUdjMEFBb0FnQkpEUUVnQUNBRWFpRUVBa0FDUUVHZzBBQW9BZ0FnQVVjRVFDQUFRZjhCVFFSQUlBQkJBM1loQXlBQktBSUlJZ0FnQVNnQ0RDSUNSZ1JBUVl6UUFFR00wQUFvQWdCQmZpQURkM0UyQWdBTUJRc2dBaUFBTmdJSUlBQWdBallDREF3RUN5QUJLQUlZSVFZZ0FTQUJLQUlNSWdCSEJFQWdBQ0FCS0FJSUlnSTJBZ2dnQWlBQU5nSU1EQU1MSUFGQkZHb2lBeWdDQUNJQ1JRUkFJQUVvQWhBaUFrVU5BaUFCUVJCcUlRTUxBMEFnQXlFSElBSWlBRUVVYWlJREtBSUFJZ0lOQUNBQVFSQnFJUU1nQUNnQ0VDSUNEUUFMSUFkQkFEWUNBQXdDQ3lBRktBSUVJZ0JCQTNGQkEwY05BaUFGSUFCQmZuRTJBZ1JCbE5BQUlBUTJBZ0FnQlNBRU5nSUFJQUVnQkVFQmNqWUNCQXdEQzBFQUlRQUxJQVpGRFFBQ1FDQUJLQUljSWdKQkFuUkJ2TklBYWlJREtBSUFJQUZHQkVBZ0F5QUFOZ0lBSUFBTkFVR1EwQUJCa05BQUtBSUFRWDRnQW5keE5nSUFEQUlMSUFaQkVFRVVJQVlvQWhBZ0FVWWJhaUFBTmdJQUlBQkZEUUVMSUFBZ0JqWUNHQ0FCS0FJUUlnSUVRQ0FBSUFJMkFoQWdBaUFBTmdJWUN5QUJRUlJxS0FJQUlnSkZEUUFnQUVFVWFpQUNOZ0lBSUFJZ0FEWUNHQXNnQVNBRlR3MEFJQVVvQWdRaUFFRUJjVVVOQUFKQUFrQUNRQUpBSUFCQkFuRkZCRUJCcE5BQUtBSUFJQVZHQkVCQnBOQUFJQUUyQWdCQm1OQUFRWmpRQUNnQ0FDQUVhaUlBTmdJQUlBRWdBRUVCY2pZQ0JDQUJRYURRQUNnQ0FFY05Ca0dVMEFCQkFEWUNBRUdnMEFCQkFEWUNBQXdHQzBHZzBBQW9BZ0FnQlVZRVFFR2cwQUFnQVRZQ0FFR1UwQUJCbE5BQUtBSUFJQVJxSWdBMkFnQWdBU0FBUVFGeU5nSUVJQUFnQVdvZ0FEWUNBQXdHQ3lBQVFYaHhJQVJxSVFRZ0FFSC9BVTBFUUNBQVFRTjJJUU1nQlNnQ0NDSUFJQVVvQWd3aUFrWUVRRUdNMEFCQmpOQUFLQUlBUVg0Z0EzZHhOZ0lBREFVTElBSWdBRFlDQ0NBQUlBSTJBZ3dNQkFzZ0JTZ0NHQ0VHSUFVZ0JTZ0NEQ0lBUndSQVFaelFBQ2dDQUJvZ0FDQUZLQUlJSWdJMkFnZ2dBaUFBTmdJTURBTUxJQVZCRkdvaUF5Z0NBQ0lDUlFSQUlBVW9BaEFpQWtVTkFpQUZRUkJxSVFNTEEwQWdBeUVISUFJaUFFRVVhaUlES0FJQUlnSU5BQ0FBUVJCcUlRTWdBQ2dDRUNJQ0RRQUxJQWRCQURZQ0FBd0NDeUFGSUFCQmZuRTJBZ1FnQVNBRWFpQUVOZ0lBSUFFZ0JFRUJjallDQkF3REMwRUFJUUFMSUFaRkRRQUNRQ0FGS0FJY0lnSkJBblJCdk5JQWFpSURLQUlBSUFWR0JFQWdBeUFBTmdJQUlBQU5BVUdRMEFCQmtOQUFLQUlBUVg0Z0FuZHhOZ0lBREFJTElBWkJFRUVVSUFZb0FoQWdCVVliYWlBQU5nSUFJQUJGRFFFTElBQWdCallDR0NBRktBSVFJZ0lFUUNBQUlBSTJBaEFnQWlBQU5nSVlDeUFGUVJScUtBSUFJZ0pGRFFBZ0FFRVVhaUFDTmdJQUlBSWdBRFlDR0FzZ0FTQUVhaUFFTmdJQUlBRWdCRUVCY2pZQ0JDQUJRYURRQUNnQ0FFY05BRUdVMEFBZ0JEWUNBQXdCQ3lBRVFmOEJUUVJBSUFSQmVIRkJ0TkFBYWlFQUFuOUJqTkFBS0FJQUlnSkJBU0FFUVFOMmRDSURjVVVFUUVHTTBBQWdBaUFEY2pZQ0FDQUFEQUVMSUFBb0FnZ0xJZ0lnQVRZQ0RDQUFJQUUyQWdnZ0FTQUFOZ0lNSUFFZ0FqWUNDQXdCQzBFZklRSWdCRUgvLy84SFRRUkFJQVJCSmlBRVFRaDJaeUlBYTNaQkFYRWdBRUVCZEd0QlBtb2hBZ3NnQVNBQ05nSWNJQUZDQURjQ0VDQUNRUUowUWJ6U0FHb2hBQUpBUVpEUUFDZ0NBQ0lEUVFFZ0FuUWlCM0ZGQkVBZ0FDQUJOZ0lBUVpEUUFDQURJQWR5TmdJQUlBRWdBRFlDR0NBQklBRTJBZ2dnQVNBQk5nSU1EQUVMSUFSQkdTQUNRUUYyYTBFQUlBSkJIMGNiZENFQ0lBQW9BZ0FoQUFKQUEwQWdBQ0lES0FJRVFYaHhJQVJHRFFFZ0FrRWRkaUVBSUFKQkFYUWhBaUFESUFCQkJIRnFRUkJxSWdjb0FnQWlBQTBBQ3lBSElBRTJBZ0FnQVNBRE5nSVlJQUVnQVRZQ0RDQUJJQUUyQWdnTUFRc2dBeWdDQ0NJQUlBRTJBZ3dnQXlBQk5nSUlJQUZCQURZQ0dDQUJJQU0yQWd3Z0FTQUFOZ0lJQzBHczBBQkJyTkFBS0FJQVFRRnJJZ0JCZnlBQUd6WUNBQXNMQndBZ0FDMEFLQXNIQUNBQUxRQXFDd2NBSUFBdEFDc0xCd0FnQUMwQUtRc0hBQ0FBTHdFeUN3Y0FJQUF0QUM0TFFBRUVmeUFBS0FJWUlRRWdBQzBBTFNFQ0lBQXRBQ2doQXlBQUtBSTRJUVFnQUJBd0lBQWdCRFlDT0NBQUlBTTZBQ2dnQUNBQ09nQXRJQUFnQVRZQ0dBdTc0Z0VDQjM4RGZpQUJJQUpxSVFRQ1FDQUFJZ0lvQWd3aUFBMEFJQUlvQWdRRVFDQUNJQUUyQWdRTEl3QkJFR3NpQ0NRQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDZndKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUlBSW9BaHdpQTBFQmF3N2RBZG9CQWRrQkFnTUVCUVlIQ0FrS0N3d05EdGdCRHhEWEFSRVMxZ0VURkJVV0Z4Z1pHaHZnQWQ4QkhCMGUxUUVmSUNFaUl5UWwxQUVtSnlncEtpc3Mwd0hTQVMwdTBRSFFBUzh3TVRJek5EVTJOemc1T2pzOFBUNC9RRUZDUTBSRlJ0c0JSMGhKU3M4QnpnRkx6UUZNekFGTlRrOVFVVkpUVkZWV1YxaFpXbHRjWFY1ZllHRmlZMlJsWm1kb2FXcHJiRzF1YjNCeGNuTjBkWFozZUhsNmUzeDlmbitBQVlFQmdnR0RBWVFCaFFHR0FZY0JpQUdKQVlvQml3R01BWTBCamdHUEFaQUJrUUdTQVpNQmxBR1ZBWllCbHdHWUFaa0JtZ0diQVp3Qm5RR2VBWjhCb0FHaEFhSUJvd0drQWFVQnBnR25BYWdCcVFHcUFhc0JyQUd0QWE0QnJ3R3dBYkVCc2dHekFiUUJ0UUcyQWJjQnl3SEtBYmdCeVFHNUFjZ0J1Z0c3QWJ3QnZRRytBYjhCd0FIQkFjSUJ3d0hFQWNVQnhnRUEzQUVMUVFBTXhnRUxRUTRNeFFFTFFRME14QUVMUVE4TXd3RUxRUkFNd2dFTFFSTU13UUVMUVJRTXdBRUxRUlVNdndFTFFSWU12Z0VMUVJnTXZRRUxRUmtNdkFFTFFSb011d0VMUVJzTXVnRUxRUndNdVFFTFFSME11QUVMUVFnTXR3RUxRUjRNdGdFTFFTQU10UUVMUVI4TXRBRUxRUWNNc3dFTFFTRU1zZ0VMUVNJTXNRRUxRU01Nc0FFTFFTUU1yd0VMUVJJTXJnRUxRUkVNclFFTFFTVU1yQUVMUVNZTXF3RUxRU2NNcWdFTFFTZ01xUUVMUWNNQkRLZ0JDMEVxREtjQkMwRXJES1lCQzBFc0RLVUJDMEV0REtRQkMwRXVES01CQzBFdkRLSUJDMEhFQVF5aEFRdEJNQXlnQVF0Qk5BeWZBUXRCREF5ZUFRdEJNUXlkQVF0Qk1neWNBUXRCTXd5YkFRdEJPUXlhQVF0Qk5ReVpBUXRCeFFFTW1BRUxRUXNNbHdFTFFUb01sZ0VMUVRZTWxRRUxRUW9NbEFFTFFUY01rd0VMUVRnTWtnRUxRVHdNa1FFTFFUc01rQUVMUVQwTWp3RUxRUWtNamdFTFFTa01qUUVMUVQ0TWpBRUxRVDhNaXdFTFFjQUFESW9CQzBIQkFBeUpBUXRCd2dBTWlBRUxRY01BREljQkMwSEVBQXlHQVF0QnhRQU1oUUVMUWNZQURJUUJDMEVYRElNQkMwSEhBQXlDQVF0QnlBQU1nUUVMUWNrQURJQUJDMEhLQUF4L0MwSExBQXgrQzBITkFBeDlDMEhNQUF4OEMwSE9BQXg3QzBIUEFBeDZDMEhRQUF4NUMwSFJBQXg0QzBIU0FBeDNDMEhUQUF4MkMwSFVBQXgxQzBIV0FBeDBDMEhWQUF4ekMwRUdESElMUWRjQURIRUxRUVVNY0F0QjJBQU1id3RCQkF4dUMwSFpBQXh0QzBIYUFBeHNDMEhiQUF4ckMwSGNBQXhxQzBFRERHa0xRZDBBREdnTFFkNEFER2NMUWQ4QURHWUxRZUVBREdVTFFlQUFER1FMUWVJQURHTUxRZU1BREdJTFFRSU1ZUXRCNUFBTVlBdEI1UUFNWHd0QjVnQU1YZ3RCNXdBTVhRdEI2QUFNWEF0QjZRQU1Xd3RCNmdBTVdndEI2d0FNV1F0QjdBQU1XQXRCN1FBTVZ3dEI3Z0FNVmd0Qjd3QU1WUXRCOEFBTVZBdEI4UUFNVXd0QjhnQU1VZ3RCOHdBTVVRdEI5QUFNVUF0QjlRQU1Ud3RCOWdBTVRndEI5d0FNVFF0QitBQU1UQXRCK1FBTVN3dEIrZ0FNU2d0Qit3QU1TUXRCL0FBTVNBdEIvUUFNUnd0Qi9nQU1SZ3RCL3dBTVJRdEJnQUVNUkF0QmdRRU1Rd3RCZ2dFTVFndEJnd0VNUVF0QmhBRU1RQXRCaFFFTVB3dEJoZ0VNUGd0Qmh3RU1QUXRCaUFFTVBBdEJpUUVNT3d0QmlnRU1PZ3RCaXdFTU9RdEJqQUVNT0F0QmpRRU1Od3RCamdFTU5ndEJqd0VNTlF0QmtBRU1OQXRCa1FFTU13dEJrZ0VNTWd0Qmt3RU1NUXRCbEFFTU1BdEJsUUVNTHd0QmxnRU1MZ3RCbHdFTUxRdEJtQUVNTEF0Qm1RRU1Ld3RCbWdFTUtndEJtd0VNS1F0Qm5BRU1LQXRCblFFTUp3dEJuZ0VNSmd0Qm53RU1KUXRCb0FFTUpBdEJvUUVNSXd0Qm9nRU1JZ3RCb3dFTUlRdEJwQUVNSUF0QnBRRU1Id3RCcGdFTUhndEJwd0VNSFF0QnFBRU1IQXRCcVFFTUd3dEJxZ0VNR2d0QnF3RU1HUXRCckFFTUdBdEJyUUVNRnd0QnJnRU1GZ3RCQVF3VkMwR3ZBUXdVQzBHd0FRd1RDMEd4QVF3U0MwR3pBUXdSQzBHeUFRd1FDMEcwQVF3UEMwRzFBUXdPQzBHMkFRd05DMEczQVF3TUMwRzRBUXdMQzBHNUFRd0tDMEc2QVF3SkMwRzdBUXdJQzBIR0FRd0hDMEc4QVF3R0MwRzlBUXdGQzBHK0FRd0VDMEcvQVF3REMwSEFBUXdDQzBIQ0FRd0JDMEhCQVFzaEF3TkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFJQUlDZndKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUovQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FnQWdKL0FrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDZndKQUFrQUNmd0pBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDZndKQUFrQUNRQUpBQW44Q1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FDQUREc1lCQUFFQ0F3UUZCZ2NJQ1FvTERBME9EeEFSRWhNVUZSWVhHQmthR3h3ZEh5QWhJeVVtS0NvckxDOHdNVEl6TkRVMk56azZPenc5bEFOQVFrUkZSa2xMVGs5UVVWSlRWRlZXV0ZwYlhGMWVYMkJoWW1Oa1pXWm5hR3BzYjNCeGMzVjJlSGw2ZTN4L2dBR0JBWUlCZ3dHRUFZVUJoZ0dIQVlnQmlRR0tBWXNCakFHTkFZNEJqd0dRQVpFQmtnR1RBWlFCbFFHV0FaY0JtQUdaQVpvQm13R2NBWjBCbmdHZkFhQUJvUUdpQWFNQnBBR2xBYVlCcHdHb0Fha0JxZ0dyQWF3QnJRR3VBYThCc0FHeEFiSUJzd0cwQWJVQnRnRzNBYmdCdVFHNkFic0J2QUc5QWI0QnZ3SEFBY0VCd2dIREFjUUJ4UUhHQWNjQnlBSEpBY3NCekFITkFjNEJ6d0dLQTRrRGlBT0hBNFFEZ3dPQUEvc0MrZ0w1QXZnQzl3TDBBdk1DOGdMTEFzRUNzQUxaQVFzZ0FTQUVSdzN3QWtIZEFTRURETE1EQ3lBQklBUkhEY2dCUWNNQklRTU1zZ01MSUFFZ0JFY05lMEgzQUNFRERMRURDeUFCSUFSSERYQkI3d0FoQXd5d0F3c2dBU0FFUncxcFFlb0FJUU1NcndNTElBRWdCRWNOWlVIb0FDRURESzREQ3lBQklBUkhEV0pCNWdBaEF3eXRBd3NnQVNBRVJ3MGFRUmdoQXd5c0F3c2dBU0FFUncwVlFSSWhBd3lyQXdzZ0FTQUVSdzFDUWNVQUlRTU1xZ01MSUFFZ0JFY05ORUUvSVFNTXFRTUxJQUVnQkVjTk1rRThJUU1NcUFNTElBRWdCRWNOSzBFeElRTU1wd01MSUFJdEFDNUJBVVlObndNTXdRSUxRUUFoQUFKQUFrQUNRQ0FDTFFBcVJRMEFJQUl0QUN0RkRRQWdBaThCTUNJRFFRSnhSUTBCREFJTElBSXZBVEFpQTBFQmNVVU5BUXRCQVNFQUlBSXRBQ2hCQVVZTkFDQUNMd0V5SWdWQjVBQnJRZVFBU1EwQUlBVkJ6QUZHRFFBZ0JVR3dBa1lOQUNBRFFjQUFjUTBBUVFBaEFDQURRWWdFY1VHQUJFWU5BQ0FEUVNoeFFRQkhJUUFMSUFKQkFEc0JNQ0FDUVFBNkFDOGdBRVVOM3dJZ0FrSUFOd01nRE9BQ0MwRUFJUUFDUUNBQ0tBSTRJZ05GRFFBZ0F5Z0NMQ0lEUlEwQUlBSWdBeEVBQUNFQUN5QUFSUTNNQVNBQVFSVkhEZDBDSUFKQkJEWUNIQ0FDSUFFMkFoUWdBa0d3R0RZQ0VDQUNRUlUyQWd4QkFDRURES1FEQ3lBQklBUkdCRUJCQmlFRERLUURDeUFCUVFGcUlRRkJBQ0VBQWtBZ0FpZ0NPQ0lEUlEwQUlBTW9BbFFpQTBVTkFDQUNJQU1SQUFBaEFBc2dBQTNaQWd3Y0N5QUNRZ0EzQXlCQkVpRURESWtEQ3lBQklBUkhEUlpCSFNFRERLRURDeUFCSUFSSEJFQWdBVUVCYWlFQlFSQWhBd3lJQXd0QkJ5RURES0FEQ3lBQ0lBSXBBeUFpQ2lBRUlBRnJyU0lMZlNJTVFnQWdDaUFNV2hzM0F5QWdDaUFMV0EzVUFrRUlJUU1NbndNTElBRWdCRWNFUUNBQ1FRazJBZ2dnQWlBQk5nSUVRUlFoQXd5R0F3dEJDU0VEREo0REN5QUNLUU1nUWdCU0RjY0JJQUlnQWk4Qk1FR0FBWEk3QVRBTVFnc2dBU0FFUncwL1FkQUFJUU1NbkFNTElBRWdCRVlFUUVFTElRTU1uQU1MSUFGQkFXb2hBVUVBSVFBQ1FDQUNLQUk0SWdORkRRQWdBeWdDVUNJRFJRMEFJQUlnQXhFQUFDRUFDeUFBRGM4Q0RNWUJDMEVBSVFBQ1FDQUNLQUk0SWdORkRRQWdBeWdDU0NJRFJRMEFJQUlnQXhFQUFDRUFDeUFBUlEzR0FTQUFRUlZIRGMwQ0lBSkJDellDSENBQ0lBRTJBaFFnQWtHQ0dUWUNFQ0FDUVJVMkFneEJBQ0VEREpvREMwRUFJUUFDUUNBQ0tBSTRJZ05GRFFBZ0F5Z0NTQ0lEUlEwQUlBSWdBeEVBQUNFQUN5QUFSUTBNSUFCQkZVY055Z0lnQWtFYU5nSWNJQUlnQVRZQ0ZDQUNRWUlaTmdJUUlBSkJGVFlDREVFQUlRTU1tUU1MUVFBaEFBSkFJQUlvQWpnaUEwVU5BQ0FES0FKTUlnTkZEUUFnQWlBREVRQUFJUUFMSUFCRkRjUUJJQUJCRlVjTnh3SWdBa0VMTmdJY0lBSWdBVFlDRkNBQ1FaRVhOZ0lRSUFKQkZUWUNERUVBSVFNTW1BTUxJQUVnQkVZRVFFRVBJUU1NbUFNTElBRXRBQUFpQUVFN1JnMEhJQUJCRFVjTnhBSWdBVUVCYWlFQkRNTUJDMEVBSVFBQ1FDQUNLQUk0SWdORkRRQWdBeWdDVENJRFJRMEFJQUlnQXhFQUFDRUFDeUFBUlEzREFTQUFRUlZIRGNJQ0lBSkJEellDSENBQ0lBRTJBaFFnQWtHUkZ6WUNFQ0FDUVJVMkFneEJBQ0VEREpZREN3TkFJQUV0QUFCQjhEVnFMUUFBSWdCQkFVY0VRQ0FBUVFKSERjRUNJQUlvQWdRaEFFRUFJUU1nQWtFQU5nSUVJQUlnQUNBQlFRRnFJZ0VRTFNJQURjSUNETVVCQ3lBRUlBRkJBV29pQVVjTkFBdEJFaUVEREpVREMwRUFJUUFDUUNBQ0tBSTRJZ05GRFFBZ0F5Z0NUQ0lEUlEwQUlBSWdBeEVBQUNFQUN5QUFSUTNGQVNBQVFSVkhEYjBDSUFKQkd6WUNIQ0FDSUFFMkFoUWdBa0dSRnpZQ0VDQUNRUlUyQWd4QkFDRURESlFEQ3lBQklBUkdCRUJCRmlFRERKUURDeUFDUVFvMkFnZ2dBaUFCTmdJRVFRQWhBQUpBSUFJb0FqZ2lBMFVOQUNBREtBSklJZ05GRFFBZ0FpQURFUUFBSVFBTElBQkZEY0lCSUFCQkZVY051UUlnQWtFVk5nSWNJQUlnQVRZQ0ZDQUNRWUlaTmdJUUlBSkJGVFlDREVFQUlRTU1rd01MSUFFZ0JFY0VRQU5BSUFFdEFBQkI4RGRxTFFBQUlnQkJBa2NFUUFKQUlBQkJBV3NPQk1RQ3ZRSUF2Z0s5QWdzZ0FVRUJhaUVCUVFnaEF3ejhBZ3NnQkNBQlFRRnFJZ0ZIRFFBTFFSVWhBd3lUQXd0QkZTRURESklEQ3dOQUlBRXRBQUJCOERscUxRQUFJZ0JCQWtjRVFDQUFRUUZyRGdURkFyY0N3d0s0QXJjQ0N5QUVJQUZCQVdvaUFVY05BQXRCR0NFRERKRURDeUFCSUFSSEJFQWdBa0VMTmdJSUlBSWdBVFlDQkVFSElRTU0rQUlMUVJraEF3eVFBd3NnQVVFQmFpRUJEQUlMSUFFZ0JFWUVRRUVhSVFNTWp3TUxBa0FnQVMwQUFFRU5hdzRVdFFHL0FiOEJ2d0cvQWI4QnZ3Ry9BYjhCdndHL0FiOEJ2d0cvQWI4QnZ3Ry9BYjhCdndFQXZ3RUxRUUFoQXlBQ1FRQTJBaHdnQWtHdkN6WUNFQ0FDUVFJMkFnd2dBaUFCUVFGcU5nSVVESTREQ3lBQklBUkdCRUJCR3lFRERJNERDeUFCTFFBQUlnQkJPMGNFUUNBQVFRMUhEYkVDSUFGQkFXb2hBUXk2QVFzZ0FVRUJhaUVCQzBFaUlRTU04d0lMSUFFZ0JFWUVRRUVjSVFNTWpBTUxRZ0FoQ2dKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQWdBUzBBQUVFd2F3NDN3UUxBQWdBQkFnTUVCUVlIMEFIUUFkQUIwQUhRQWRBQjBBRUlDUW9MREEzUUFkQUIwQUhRQWRBQjBBSFFBZEFCMEFIUUFkQUIwQUhRQWRBQjBBSFFBZEFCMEFIUUFkQUIwQUhRQWRBQjBBSFFBZEFCRGc4UUVSSVQwQUVMUWdJaENnekFBZ3RDQXlFS0RMOENDMElFSVFvTXZnSUxRZ1VoQ2d5OUFndENCaUVLREx3Q0MwSUhJUW9NdXdJTFFnZ2hDZ3k2QWd0Q0NTRUtETGtDQzBJS0lRb011QUlMUWdzaENneTNBZ3RDRENFS0RMWUNDMElOSVFvTXRRSUxRZzRoQ2d5MEFndENEeUVLRExNQ0MwSUtJUW9Nc2dJTFFnc2hDZ3l4QWd0Q0RDRUtETEFDQzBJTklRb01yd0lMUWc0aENneXVBZ3RDRHlFS0RLMENDMElBSVFvQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFJQUV0QUFCQk1Hc09OOEFDdndJQUFRSURCQVVHQjc0Q3ZnSytBcjRDdmdLK0FyNENDQWtLQ3d3TnZnSytBcjRDdmdLK0FyNEN2Z0srQXI0Q3ZnSytBcjRDdmdLK0FyNEN2Z0srQXI0Q3ZnSytBcjRDdmdLK0FyNEN2Z0srQWc0UEVCRVNFNzRDQzBJQ0lRb012d0lMUWdNaENneStBZ3RDQkNFS0RMMENDMElGSVFvTXZBSUxRZ1loQ2d5N0FndENCeUVLRExvQ0MwSUlJUW9NdVFJTFFna2hDZ3k0QWd0Q0NpRUtETGNDQzBJTElRb010Z0lMUWd3aENneTFBZ3RDRFNFS0RMUUNDMElPSVFvTXN3SUxRZzhoQ2d5eUFndENDaUVLRExFQ0MwSUxJUW9Nc0FJTFFnd2hDZ3l2QWd0Q0RTRUtESzRDQzBJT0lRb01yUUlMUWc4aENneXNBZ3NnQWlBQ0tRTWdJZ29nQkNBQmE2MGlDMzBpREVJQUlBb2dERm9iTndNZ0lBb2dDMWdOcHdKQkh5RURESWtEQ3lBQklBUkhCRUFnQWtFSk5nSUlJQUlnQVRZQ0JFRWxJUU1NOEFJTFFTQWhBd3lJQXd0QkFTRUZJQUl2QVRBaUEwRUljVVVFUUNBQ0tRTWdRZ0JTSVFVTEFrQWdBaTBBTGdSQVFRRWhBQ0FDTFFBcFFRVkdEUUVnQTBIQUFIRkZJQVZ4UlEwQkMwRUFJUUFnQTBIQUFIRU5BRUVDSVFBZ0EwRUljUTBBSUFOQmdBUnhCRUFDUUNBQ0xRQW9RUUZIRFFBZ0FpMEFMVUVLY1EwQVFRVWhBQXdDQzBFRUlRQU1BUXNnQTBFZ2NVVUVRQUpBSUFJdEFDaEJBVVlOQUNBQ0x3RXlJZ0JCNUFCclFlUUFTUTBBSUFCQnpBRkdEUUFnQUVHd0FrWU5BRUVFSVFBZ0EwRW9jVVVOQWlBRFFZZ0VjVUdBQkVZTkFndEJBQ0VBREFFTFFRQkJBeUFDS1FNZ1VCc2hBQXNnQUVFQmF3NEZ2Z0lBc0FFQnBBS2hBZ3RCRVNFRERPMENDeUFDUVFFNkFDOE1oQU1MSUFFZ0JFY05uUUpCSkNFRERJUURDeUFCSUFSSERSeEJ4Z0FoQXd5REF3dEJBQ0VBQWtBZ0FpZ0NPQ0lEUlEwQUlBTW9Ba1FpQTBVTkFDQUNJQU1SQUFBaEFBc2dBRVVOSnlBQVFSVkhEWmdDSUFKQjBBQTJBaHdnQWlBQk5nSVVJQUpCa1JnMkFoQWdBa0VWTmdJTVFRQWhBd3lDQXdzZ0FTQUVSZ1JBUVNnaEF3eUNBd3RCQUNFRElBSkJBRFlDQkNBQ1FRdzJBZ2dnQWlBQklBRVFLaUlBUlEyVUFpQUNRU2MyQWh3Z0FpQUJOZ0lVSUFJZ0FEWUNEQXlCQXdzZ0FTQUVSZ1JBUVNraEF3eUJBd3NnQVMwQUFDSUFRU0JHRFJNZ0FFRUpSdzJWQWlBQlFRRnFJUUVNRkFzZ0FTQUVSd1JBSUFGQkFXb2hBUXdXQzBFcUlRTU0vd0lMSUFFZ0JFWUVRRUVySVFNTS93SUxJQUV0QUFBaUFFRUpSeUFBUVNCSGNRMlFBaUFDTFFBc1FRaEhEZDBDSUFKQkFEb0FMQXpkQWdzZ0FTQUVSZ1JBUVN3aEF3eitBZ3NnQVMwQUFFRUtSdzJPQWlBQlFRRnFJUUVNc0FFTElBRWdCRWNOaWdKQkx5RUREUHdDQ3dOQUlBRXRBQUFpQUVFZ1J3UkFJQUJCQ21zT0JJUUNpQUtJQW9RQ2hnSUxJQVFnQVVFQmFpSUJSdzBBQzBFeElRTU0rd0lMUVRJaEF5QUJJQVJHRGZvQ0lBSW9BZ0FpQUNBRUlBRnJhaUVISUFFZ0FHdEJBMm9oQmdKQUEwQWdBRUh3TzJvdEFBQWdBUzBBQUNJRlFTQnlJQVVnQlVIQkFHdEIvd0Z4UVJwSkcwSC9BWEZIRFFFZ0FFRURSZ1JBUVFZaEFRemlBZ3NnQUVFQmFpRUFJQVFnQVVFQmFpSUJSdzBBQ3lBQ0lBYzJBZ0FNK3dJTElBSkJBRFlDQUF5R0FndEJNeUVESUFRZ0FTSUFSZzM1QWlBRUlBRnJJQUlvQWdBaUFXb2hCeUFBSUFGclFRaHFJUVlDUUFOQUlBRkI5RHRxTFFBQUlBQXRBQUFpQlVFZ2NpQUZJQVZCd1FCclFmOEJjVUVhU1J0Qi93RnhSdzBCSUFGQkNFWUVRRUVGSVFFTTRRSUxJQUZCQVdvaEFTQUVJQUJCQVdvaUFFY05BQXNnQWlBSE5nSUFEUG9DQ3lBQ1FRQTJBZ0FnQUNFQkRJVUNDMEUwSVFNZ0JDQUJJZ0JHRGZnQ0lBUWdBV3NnQWlnQ0FDSUJhaUVISUFBZ0FXdEJCV29oQmdKQUEwQWdBVUhRd2dCcUxRQUFJQUF0QUFBaUJVRWdjaUFGSUFWQndRQnJRZjhCY1VFYVNSdEIvd0Z4UncwQklBRkJCVVlFUUVFSElRRU00QUlMSUFGQkFXb2hBU0FFSUFCQkFXb2lBRWNOQUFzZ0FpQUhOZ0lBRFBrQ0N5QUNRUUEyQWdBZ0FDRUJESVFDQ3lBQklBUkhCRUFEUUNBQkxRQUFRWUErYWkwQUFDSUFRUUZIQkVBZ0FFRUNSZzBKRElFQ0N5QUVJQUZCQVdvaUFVY05BQXRCTUNFRERQZ0NDMEV3SVFNTTl3SUxJQUVnQkVjRVFBTkFJQUV0QUFBaUFFRWdSd1JBSUFCQkNtc09CUDhCL2dIK0FmOEIvZ0VMSUFRZ0FVRUJhaUlCUncwQUMwRTRJUU1NOXdJTFFUZ2hBd3oyQWdzRFFDQUJMUUFBSWdCQklFY2dBRUVKUjNFTjlnRWdCQ0FCUVFGcUlnRkhEUUFMUVR3aEF3ejFBZ3NEUUNBQkxRQUFJZ0JCSUVjRVFBSkFJQUJCQ21zT0JQa0JCQVQ1QVFBTElBQkJMRVlOOVFFTUF3c2dCQ0FCUVFGcUlnRkhEUUFMUVQ4aEF3ejBBZ3RCd0FBaEF5QUJJQVJHRGZNQ0lBSW9BZ0FpQUNBRUlBRnJhaUVGSUFFZ0FHdEJCbW9oQmdKQUEwQWdBRUdBUUdzdEFBQWdBUzBBQUVFZ2NrY05BU0FBUVFaR0Rkc0NJQUJCQVdvaEFDQUVJQUZCQVdvaUFVY05BQXNnQWlBRk5nSUFEUFFDQ3lBQ1FRQTJBZ0FMUVRZaEF3elpBZ3NnQVNBRVJnUkFRY0VBSVFNTThnSUxJQUpCRERZQ0NDQUNJQUUyQWdRZ0FpMEFMRUVCYXc0RSt3SHVBZXdCNndIVUFnc2dBVUVCYWlFQkRQb0JDeUFCSUFSSEJFQURRQUpBSUFFdEFBQWlBRUVnY2lBQUlBQkJ3UUJyUWY4QmNVRWFTUnRCL3dGeElnQkJDVVlOQUNBQVFTQkdEUUFDUUFKQUFrQUNRQ0FBUWVNQWF3NFRBQU1EQXdNREF3TUJBd01EQXdNREF3TURBZ01MSUFGQkFXb2hBVUV4SVFNTTNBSUxJQUZCQVdvaEFVRXlJUU1NMndJTElBRkJBV29oQVVFeklRTU0yZ0lMRFA0QkN5QUVJQUZCQVdvaUFVY05BQXRCTlNFRERQQUNDMEUxSVFNTTd3SUxJQUVnQkVjRVFBTkFJQUV0QUFCQmdEeHFMUUFBUVFGSERmY0JJQVFnQVVFQmFpSUJSdzBBQzBFOUlRTU03d0lMUVQwaEF3enVBZ3RCQUNFQUFrQWdBaWdDT0NJRFJRMEFJQU1vQWtBaUEwVU5BQ0FDSUFNUkFBQWhBQXNnQUVVTkFTQUFRUlZIRGVZQklBSkJ3Z0EyQWh3Z0FpQUJOZ0lVSUFKQjR4ZzJBaEFnQWtFVk5nSU1RUUFoQXd6dEFnc2dBVUVCYWlFQkMwRThJUU1NMGdJTElBRWdCRVlFUUVIQ0FDRURET3NDQ3dKQUEwQUNRQ0FCTFFBQVFRbHJEaGdBQXN3Q3pBTFJBc3dDekFMTUFzd0N6QUxNQXN3Q3pBTE1Bc3dDekFMTUFzd0N6QUxNQXN3Q3pBTE1BZ0RNQWdzZ0JDQUJRUUZxSWdGSERRQUxRY0lBSVFNTTZ3SUxJQUZCQVdvaEFTQUNMUUF0UVFGeFJRMytBUXRCTENFREROQUNDeUFCSUFSSERkNEJRY1FBSVFNTTZBSUxBMEFnQVMwQUFFR1F3QUJxTFFBQVFRRkhEWndCSUFRZ0FVRUJhaUlCUncwQUMwSEZBQ0VERE9jQ0N5QUJMUUFBSWdCQklFWU4vZ0VnQUVFNlJ3M0FBaUFDS0FJRUlRQkJBQ0VESUFKQkFEWUNCQ0FDSUFBZ0FSQXBJZ0FOM2dFTTNRRUxRY2NBSVFNZ0JDQUJJZ0JHRGVVQ0lBUWdBV3NnQWlnQ0FDSUJhaUVISUFBZ0FXdEJCV29oQmdOQUlBRkJrTUlBYWkwQUFDQUFMUUFBSWdWQklISWdCU0FGUWNFQWEwSC9BWEZCR2trYlFmOEJjVWNOdndJZ0FVRUZSZzNDQWlBQlFRRnFJUUVnQkNBQVFRRnFJZ0JIRFFBTElBSWdCellDQUF6bEFndEJ5QUFoQXlBRUlBRWlBRVlONUFJZ0JDQUJheUFDS0FJQUlnRnFJUWNnQUNBQmEwRUphaUVHQTBBZ0FVR1d3Z0JxTFFBQUlBQXRBQUFpQlVFZ2NpQUZJQVZCd1FCclFmOEJjVUVhU1J0Qi93RnhSdzIrQWtFQ0lBRkJDVVlOd2dJYUlBRkJBV29oQVNBRUlBQkJBV29pQUVjTkFBc2dBaUFITmdJQURPUUNDeUFCSUFSR0JFQkJ5UUFoQXd6a0Fnc0NRQUpBSUFFdEFBQWlBRUVnY2lBQUlBQkJ3UUJyUWY4QmNVRWFTUnRCL3dGeFFlNEFhdzRIQUw4Q3Z3Sy9BcjhDdndJQnZ3SUxJQUZCQVdvaEFVRStJUU1NeXdJTElBRkJBV29oQVVFL0lRTU15Z0lMUWNvQUlRTWdCQ0FCSWdCR0RlSUNJQVFnQVdzZ0FpZ0NBQ0lCYWlFR0lBQWdBV3RCQVdvaEJ3TkFJQUZCb01JQWFpMEFBQ0FBTFFBQUlnVkJJSElnQlNBRlFjRUFhMEgvQVhGQkdra2JRZjhCY1VjTnZBSWdBVUVCUmcyK0FpQUJRUUZxSVFFZ0JDQUFRUUZxSWdCSERRQUxJQUlnQmpZQ0FBemlBZ3RCeXdBaEF5QUVJQUVpQUVZTjRRSWdCQ0FCYXlBQ0tBSUFJZ0ZxSVFjZ0FDQUJhMEVPYWlFR0EwQWdBVUdpd2dCcUxRQUFJQUF0QUFBaUJVRWdjaUFGSUFWQndRQnJRZjhCY1VFYVNSdEIvd0Z4UncyN0FpQUJRUTVHRGI0Q0lBRkJBV29oQVNBRUlBQkJBV29pQUVjTkFBc2dBaUFITmdJQURPRUNDMEhNQUNFRElBUWdBU0lBUmczZ0FpQUVJQUZySUFJb0FnQWlBV29oQnlBQUlBRnJRUTlxSVFZRFFDQUJRY0RDQUdvdEFBQWdBQzBBQUNJRlFTQnlJQVVnQlVIQkFHdEIvd0Z4UVJwSkcwSC9BWEZIRGJvQ1FRTWdBVUVQUmcyK0Fob2dBVUVCYWlFQklBUWdBRUVCYWlJQVJ3MEFDeUFDSUFjMkFnQU00QUlMUWMwQUlRTWdCQ0FCSWdCR0RkOENJQVFnQVdzZ0FpZ0NBQ0lCYWlFSElBQWdBV3RCQldvaEJnTkFJQUZCME1JQWFpMEFBQ0FBTFFBQUlnVkJJSElnQlNBRlFjRUFhMEgvQVhGQkdra2JRZjhCY1VjTnVRSkJCQ0FCUVFWR0RiMENHaUFCUVFGcUlRRWdCQ0FBUVFGcUlnQkhEUUFMSUFJZ0J6WUNBQXpmQWdzZ0FTQUVSZ1JBUWM0QUlRTU0zd0lMQWtBQ1FBSkFBa0FnQVMwQUFDSUFRU0J5SUFBZ0FFSEJBR3RCL3dGeFFScEpHMEgvQVhGQjR3QnJEaE1BdkFLOEFyd0N2QUs4QXJ3Q3ZBSzhBcndDdkFLOEFyd0NBYndDdkFLOEFnSUR2QUlMSUFGQkFXb2hBVUhCQUNFRERNZ0NDeUFCUVFGcUlRRkJ3Z0FoQXd6SEFnc2dBVUVCYWlFQlFjTUFJUU1NeGdJTElBRkJBV29oQVVIRUFDRURETVVDQ3lBQklBUkhCRUFnQWtFTk5nSUlJQUlnQVRZQ0JFSEZBQ0VERE1VQ0MwSFBBQ0VERE4wQ0N3SkFBa0FnQVMwQUFFRUthdzRFQVpBQmtBRUFrQUVMSUFGQkFXb2hBUXRCS0NFRERNTUNDeUFCSUFSR0JFQkIwUUFoQXd6Y0Fnc2dBUzBBQUVFZ1J3MEFJQUZCQVdvaEFTQUNMUUF0UVFGeFJRM1FBUXRCRnlFRERNRUNDeUFCSUFSSERjc0JRZElBSVFNTTJRSUxRZE1BSVFNZ0FTQUVSZzNZQWlBQ0tBSUFJZ0FnQkNBQmEyb2hCaUFCSUFCclFRRnFJUVVEUUNBQkxRQUFJQUJCMXNJQWFpMEFBRWNOeHdFZ0FFRUJSZzNLQVNBQVFRRnFJUUFnQkNBQlFRRnFJZ0ZIRFFBTElBSWdCallDQUF6WUFnc2dBU0FFUmdSQVFkVUFJUU1NMkFJTElBRXRBQUJCQ2tjTndnRWdBVUVCYWlFQkRNb0JDeUFCSUFSR0JFQkIxZ0FoQXd6WEFnc0NRQUpBSUFFdEFBQkJDbXNPQkFEREFjTUJBY01CQ3lBQlFRRnFJUUVNeWdFTElBRkJBV29oQVVIS0FDRURETDBDQzBFQUlRQUNRQ0FDS0FJNElnTkZEUUFnQXlnQ1BDSURSUTBBSUFJZ0F4RUFBQ0VBQ3lBQURiOEJRYzBBSVFNTXZBSUxJQUl0QUNsQklrWU56d0lNaVFFTElBUWdBU0lGUmdSQVFkc0FJUU1NMUFJTFFRQWhBRUVCSVFGQkFTRUdRUUFoQXdKQUFuOENRQUpBQWtBQ1FBSkFBa0FDUUNBRkxRQUFRVEJyRGdyRkFjUUJBQUVDQXdRRkJnakRBUXRCQWd3R0MwRUREQVVMUVFRTUJBdEJCUXdEQzBFR0RBSUxRUWNNQVF0QkNBc2hBMEVBSVFGQkFDRUdETDBCQzBFSklRTkJBU0VBUVFBaEFVRUFJUVlNdkFFTElBRWdCRVlFUUVIZEFDRURETk1DQ3lBQkxRQUFRUzVIRGJnQklBRkJBV29oQVF5SUFRc2dBU0FFUncyMkFVSGZBQ0VERE5FQ0N5QUJJQVJIQkVBZ0FrRU9OZ0lJSUFJZ0FUWUNCRUhRQUNFRERMZ0NDMEhnQUNFREROQUNDMEhoQUNFRElBRWdCRVlOendJZ0FpZ0NBQ0lBSUFRZ0FXdHFJUVVnQVNBQWEwRURhaUVHQTBBZ0FTMEFBQ0FBUWVMQ0FHb3RBQUJIRGJFQklBQkJBMFlOc3dFZ0FFRUJhaUVBSUFRZ0FVRUJhaUlCUncwQUN5QUNJQVUyQWdBTXp3SUxRZUlBSVFNZ0FTQUVSZzNPQWlBQ0tBSUFJZ0FnQkNBQmEyb2hCU0FCSUFCclFRSnFJUVlEUUNBQkxRQUFJQUJCNXNJQWFpMEFBRWNOc0FFZ0FFRUNSZzJ2QVNBQVFRRnFJUUFnQkNBQlFRRnFJZ0ZIRFFBTElBSWdCVFlDQUF6T0FndEI0d0FoQXlBQklBUkdEYzBDSUFJb0FnQWlBQ0FFSUFGcmFpRUZJQUVnQUd0QkEyb2hCZ05BSUFFdEFBQWdBRUhwd2dCcUxRQUFSdzJ2QVNBQVFRTkdEYTBCSUFCQkFXb2hBQ0FFSUFGQkFXb2lBVWNOQUFzZ0FpQUZOZ0lBRE0wQ0N5QUJJQVJHQkVCQjVRQWhBd3pOQWdzZ0FVRUJhaUVCUVFBaEFBSkFJQUlvQWpnaUEwVU5BQ0FES0FJd0lnTkZEUUFnQWlBREVRQUFJUUFMSUFBTnFnRkIxZ0FoQXd5ekFnc2dBU0FFUndSQUEwQWdBUzBBQUNJQVFTQkhCRUFDUUFKQUFrQWdBRUhJQUdzT0N3QUJzd0d6QWJNQnN3R3pBYk1Cc3dHekFRS3pBUXNnQVVFQmFpRUJRZElBSVFNTXR3SUxJQUZCQVdvaEFVSFRBQ0VERExZQ0N5QUJRUUZxSVFGQjFBQWhBd3kxQWdzZ0JDQUJRUUZxSWdGSERRQUxRZVFBSVFNTXpBSUxRZVFBSVFNTXl3SUxBMEFnQVMwQUFFSHd3Z0JxTFFBQUlnQkJBVWNFUUNBQVFRSnJEZ09uQWFZQnBRR2tBUXNnQkNBQlFRRnFJZ0ZIRFFBTFFlWUFJUU1NeWdJTElBRkJBV29nQVNBRVJ3MENHa0huQUNFRERNa0NDd05BSUFFdEFBQkI4TVFBYWkwQUFDSUFRUUZIQkVBQ1FDQUFRUUpyRGdTaUFhRUJvQUVBbndFTFFkY0FJUU1Nc1FJTElBUWdBVUVCYWlJQlJ3MEFDMEhvQUNFRERNZ0NDeUFCSUFSR0JFQkI2UUFoQXd6SUFnc0NRQ0FCTFFBQUlnQkJDbXNPR3JjQm13R2JBYlFCbXdHYkFac0Jtd0diQVpzQm13R2JBWnNCbXdHYkFac0Jtd0diQVpzQm13R2JBWnNCcEFHYkFac0JBSmtCQ3lBQlFRRnFDeUVCUVFZaEF3eXRBZ3NEUUNBQkxRQUFRZkRHQUdvdEFBQkJBVWNOZlNBRUlBRkJBV29pQVVjTkFBdEI2Z0FoQXd6RkFnc2dBVUVCYWlBQklBUkhEUUlhUWVzQUlRTU14QUlMSUFFZ0JFWUVRRUhzQUNFRERNUUNDeUFCUVFGcURBRUxJQUVnQkVZRVFFSHRBQ0VERE1NQ0N5QUJRUUZxQ3lFQlFRUWhBd3lvQWdzZ0FTQUVSZ1JBUWU0QUlRTU13UUlMQWtBQ1FBSkFJQUV0QUFCQjhNZ0FhaTBBQUVFQmF3NEhrQUdQQVk0QkFId0JBbzBCQ3lBQlFRRnFJUUVNQ3dzZ0FVRUJhZ3lUQVF0QkFDRURJQUpCQURZQ0hDQUNRWnNTTmdJUUlBSkJCellDRENBQ0lBRkJBV28yQWhRTXdBSUxBa0FEUUNBQkxRQUFRZkRJQUdvdEFBQWlBRUVFUndSQUFrQUNRQ0FBUVFGckRnZVVBWk1Ca2dHTkFRQUVBWTBCQzBIYUFDRURES29DQ3lBQlFRRnFJUUZCM0FBaEF3eXBBZ3NnQkNBQlFRRnFJZ0ZIRFFBTFFlOEFJUU1Nd0FJTElBRkJBV29Na1FFTElBUWdBU0lBUmdSQVFmQUFJUU1NdndJTElBQXRBQUJCTDBjTkFTQUFRUUZxSVFFTUJ3c2dCQ0FCSWdCR0JFQkI4UUFoQXd5K0Fnc2dBQzBBQUNJQlFTOUdCRUFnQUVFQmFpRUJRZDBBSVFNTXBRSUxJQUZCQ21zaUEwRVdTdzBBSUFBaEFVRUJJQU4wUVltQWdBSnhEZmtCQzBFQUlRTWdBa0VBTmdJY0lBSWdBRFlDRkNBQ1FZd2NOZ0lRSUFKQkJ6WUNEQXk4QWdzZ0FTQUVSd1JBSUFGQkFXb2hBVUhlQUNFRERLTUNDMEh5QUNFRERMc0NDeUFCSUFSR0JFQkI5QUFoQXd5N0Fnc0NRQ0FCTFFBQVFmRE1BR290QUFCQkFXc09BL2NCY3dDQ0FRdEI0UUFoQXd5aEFnc2dBU0FFUndSQUEwQWdBUzBBQUVId3lnQnFMUUFBSWdCQkEwY0VRQUpBSUFCQkFXc09BdmtCQUlVQkMwSGZBQ0VEREtNQ0N5QUVJQUZCQVdvaUFVY05BQXRCOHdBaEF3eTZBZ3RCOHdBaEF3eTVBZ3NnQVNBRVJ3UkFJQUpCRHpZQ0NDQUNJQUUyQWdSQjRBQWhBd3lnQWd0QjlRQWhBd3k0QWdzZ0FTQUVSZ1JBUWZZQUlRTU11QUlMSUFKQkR6WUNDQ0FDSUFFMkFnUUxRUU1oQXd5ZEFnc0RRQ0FCTFFBQVFTQkhEWTRDSUFRZ0FVRUJhaUlCUncwQUMwSDNBQ0VERExVQ0N5QUJJQVJHQkVCQitBQWhBd3kxQWdzZ0FTMEFBRUVnUncxNklBRkJBV29oQVF4YkMwRUFJUUFDUUNBQ0tBSTRJZ05GRFFBZ0F5Z0NPQ0lEUlEwQUlBSWdBeEVBQUNFQUN5QUFEWGdNZ0FJTElBRWdCRVlFUUVINkFDRURETE1DQ3lBQkxRQUFRY3dBUncxMElBRkJBV29oQVVFVERIWUxRZnNBSVFNZ0FTQUVSZzJ4QWlBQ0tBSUFJZ0FnQkNBQmEyb2hCU0FCSUFCclFRVnFJUVlEUUNBQkxRQUFJQUJCOE00QWFpMEFBRWNOY3lBQVFRVkdEWFVnQUVFQmFpRUFJQVFnQVVFQmFpSUJSdzBBQ3lBQ0lBVTJBZ0FNc1FJTElBRWdCRVlFUUVIOEFDRURETEVDQ3dKQUFrQWdBUzBBQUVIREFHc09EQUIwZEhSMGRIUjBkSFIwQVhRTElBRkJBV29oQVVIbUFDRURESmdDQ3lBQlFRRnFJUUZCNXdBaEF3eVhBZ3RCL1FBaEF5QUJJQVJHRGE4Q0lBSW9BZ0FpQUNBRUlBRnJhaUVGSUFFZ0FHdEJBbW9oQmdKQUEwQWdBUzBBQUNBQVFlM1BBR290QUFCSERYSWdBRUVDUmcwQklBQkJBV29oQUNBRUlBRkJBV29pQVVjTkFBc2dBaUFGTmdJQURMQUNDeUFDUVFBMkFnQWdCa0VCYWlFQlFSQU1jd3RCL2dBaEF5QUJJQVJHRGE0Q0lBSW9BZ0FpQUNBRUlBRnJhaUVGSUFFZ0FHdEJCV29oQmdKQUEwQWdBUzBBQUNBQVFmYk9BR290QUFCSERYRWdBRUVGUmcwQklBQkJBV29oQUNBRUlBRkJBV29pQVVjTkFBc2dBaUFGTmdJQURLOENDeUFDUVFBMkFnQWdCa0VCYWlFQlFSWU1jZ3RCL3dBaEF5QUJJQVJHRGEwQ0lBSW9BZ0FpQUNBRUlBRnJhaUVGSUFFZ0FHdEJBMm9oQmdKQUEwQWdBUzBBQUNBQVFmek9BR290QUFCSERYQWdBRUVEUmcwQklBQkJBV29oQUNBRUlBRkJBV29pQVVjTkFBc2dBaUFGTmdJQURLNENDeUFDUVFBMkFnQWdCa0VCYWlFQlFRVU1jUXNnQVNBRVJnUkFRWUFCSVFNTXJRSUxJQUV0QUFCQjJRQkhEVzRnQVVFQmFpRUJRUWdNY0FzZ0FTQUVSZ1JBUVlFQklRTU1yQUlMQWtBQ1FDQUJMUUFBUWM0QWF3NERBRzhCYndzZ0FVRUJhaUVCUWVzQUlRTU1rd0lMSUFGQkFXb2hBVUhzQUNFRERKSUNDeUFCSUFSR0JFQkJnZ0VoQXd5ckFnc0NRQUpBSUFFdEFBQkJ5QUJyRGdnQWJtNXVibTV1QVc0TElBRkJBV29oQVVIcUFDRURESklDQ3lBQlFRRnFJUUZCN1FBaEF3eVJBZ3RCZ3dFaEF5QUJJQVJHRGFrQ0lBSW9BZ0FpQUNBRUlBRnJhaUVGSUFFZ0FHdEJBbW9oQmdKQUEwQWdBUzBBQUNBQVFZRFBBR290QUFCSERXd2dBRUVDUmcwQklBQkJBV29oQUNBRUlBRkJBV29pQVVjTkFBc2dBaUFGTmdJQURLb0NDeUFDUVFBMkFnQWdCa0VCYWlFQlFRQU1iUXRCaEFFaEF5QUJJQVJHRGFnQ0lBSW9BZ0FpQUNBRUlBRnJhaUVGSUFFZ0FHdEJCR29oQmdKQUEwQWdBUzBBQUNBQVFZUFBBR290QUFCSERXc2dBRUVFUmcwQklBQkJBV29oQUNBRUlBRkJBV29pQVVjTkFBc2dBaUFGTmdJQURLa0NDeUFDUVFBMkFnQWdCa0VCYWlFQlFTTU1iQXNnQVNBRVJnUkFRWVVCSVFNTXFBSUxBa0FDUUNBQkxRQUFRY3dBYXc0SUFHdHJhMnRyYXdGckN5QUJRUUZxSVFGQjd3QWhBd3lQQWdzZ0FVRUJhaUVCUWZBQUlRTU1qZ0lMSUFFZ0JFWUVRRUdHQVNFRERLY0NDeUFCTFFBQVFjVUFSdzFvSUFGQkFXb2hBUXhnQzBHSEFTRURJQUVnQkVZTnBRSWdBaWdDQUNJQUlBUWdBV3RxSVFVZ0FTQUFhMEVEYWlFR0FrQURRQ0FCTFFBQUlBQkJpTThBYWkwQUFFY05hQ0FBUVFOR0RRRWdBRUVCYWlFQUlBUWdBVUVCYWlJQlJ3MEFDeUFDSUFVMkFnQU1wZ0lMSUFKQkFEWUNBQ0FHUVFGcUlRRkJMUXhwQzBHSUFTRURJQUVnQkVZTnBBSWdBaWdDQUNJQUlBUWdBV3RxSVFVZ0FTQUFhMEVJYWlFR0FrQURRQ0FCTFFBQUlBQkIwTThBYWkwQUFFY05aeUFBUVFoR0RRRWdBRUVCYWlFQUlBUWdBVUVCYWlJQlJ3MEFDeUFDSUFVMkFnQU1wUUlMSUFKQkFEWUNBQ0FHUVFGcUlRRkJLUXhvQ3lBQklBUkdCRUJCaVFFaEF3eWtBZ3RCQVNBQkxRQUFRZDhBUncxbkdpQUJRUUZxSVFFTVhndEJpZ0VoQXlBQklBUkdEYUlDSUFJb0FnQWlBQ0FFSUFGcmFpRUZJQUVnQUd0QkFXb2hCZ05BSUFFdEFBQWdBRUdNendCcUxRQUFSdzFrSUFCQkFVWU4rZ0VnQUVFQmFpRUFJQVFnQVVFQmFpSUJSdzBBQ3lBQ0lBVTJBZ0FNb2dJTFFZc0JJUU1nQVNBRVJnMmhBaUFDS0FJQUlnQWdCQ0FCYTJvaEJTQUJJQUJyUVFKcUlRWUNRQU5BSUFFdEFBQWdBRUdPendCcUxRQUFSdzFrSUFCQkFrWU5BU0FBUVFGcUlRQWdCQ0FCUVFGcUlnRkhEUUFMSUFJZ0JUWUNBQXlpQWdzZ0FrRUFOZ0lBSUFaQkFXb2hBVUVDREdVTFFZd0JJUU1nQVNBRVJnMmdBaUFDS0FJQUlnQWdCQ0FCYTJvaEJTQUJJQUJyUVFGcUlRWUNRQU5BSUFFdEFBQWdBRUh3endCcUxRQUFSdzFqSUFCQkFVWU5BU0FBUVFGcUlRQWdCQ0FCUVFGcUlnRkhEUUFMSUFJZ0JUWUNBQXloQWdzZ0FrRUFOZ0lBSUFaQkFXb2hBVUVmREdRTFFZMEJJUU1nQVNBRVJnMmZBaUFDS0FJQUlnQWdCQ0FCYTJvaEJTQUJJQUJyUVFGcUlRWUNRQU5BSUFFdEFBQWdBRUh5endCcUxRQUFSdzFpSUFCQkFVWU5BU0FBUVFGcUlRQWdCQ0FCUVFGcUlnRkhEUUFMSUFJZ0JUWUNBQXlnQWdzZ0FrRUFOZ0lBSUFaQkFXb2hBVUVKREdNTElBRWdCRVlFUUVHT0FTRURESjhDQ3dKQUFrQWdBUzBBQUVISkFHc09Cd0JpWW1KaVlnRmlDeUFCUVFGcUlRRkIrQUFoQXd5R0Fnc2dBVUVCYWlFQlFma0FJUU1NaFFJTFFZOEJJUU1nQVNBRVJnMmRBaUFDS0FJQUlnQWdCQ0FCYTJvaEJTQUJJQUJyUVFWcUlRWUNRQU5BSUFFdEFBQWdBRUdSendCcUxRQUFSdzFnSUFCQkJVWU5BU0FBUVFGcUlRQWdCQ0FCUVFGcUlnRkhEUUFMSUFJZ0JUWUNBQXllQWdzZ0FrRUFOZ0lBSUFaQkFXb2hBVUVZREdFTFFaQUJJUU1nQVNBRVJnMmNBaUFDS0FJQUlnQWdCQ0FCYTJvaEJTQUJJQUJyUVFKcUlRWUNRQU5BSUFFdEFBQWdBRUdYendCcUxRQUFSdzFmSUFCQkFrWU5BU0FBUVFGcUlRQWdCQ0FCUVFGcUlnRkhEUUFMSUFJZ0JUWUNBQXlkQWdzZ0FrRUFOZ0lBSUFaQkFXb2hBVUVYREdBTFFaRUJJUU1nQVNBRVJnMmJBaUFDS0FJQUlnQWdCQ0FCYTJvaEJTQUJJQUJyUVFacUlRWUNRQU5BSUFFdEFBQWdBRUdhendCcUxRQUFSdzFlSUFCQkJrWU5BU0FBUVFGcUlRQWdCQ0FCUVFGcUlnRkhEUUFMSUFJZ0JUWUNBQXljQWdzZ0FrRUFOZ0lBSUFaQkFXb2hBVUVWREY4TFFaSUJJUU1nQVNBRVJnMmFBaUFDS0FJQUlnQWdCQ0FCYTJvaEJTQUJJQUJyUVFWcUlRWUNRQU5BSUFFdEFBQWdBRUdoendCcUxRQUFSdzFkSUFCQkJVWU5BU0FBUVFGcUlRQWdCQ0FCUVFGcUlnRkhEUUFMSUFJZ0JUWUNBQXliQWdzZ0FrRUFOZ0lBSUFaQkFXb2hBVUVlREY0TElBRWdCRVlFUUVHVEFTRURESm9DQ3lBQkxRQUFRY3dBUncxYklBRkJBV29oQVVFS0RGMExJQUVnQkVZRVFFR1VBU0VEREprQ0N3SkFBa0FnQVMwQUFFSEJBR3NPRHdCY1hGeGNYRnhjWEZ4Y1hGeGNBVndMSUFGQkFXb2hBVUgrQUNFRERJQUNDeUFCUVFGcUlRRkIvd0FoQXd6L0FRc2dBU0FFUmdSQVFaVUJJUU1NbUFJTEFrQUNRQ0FCTFFBQVFjRUFhdzREQUZzQld3c2dBVUVCYWlFQlFmMEFJUU1NL3dFTElBRkJBV29oQVVHQUFTRUREUDRCQzBHV0FTRURJQUVnQkVZTmxnSWdBaWdDQUNJQUlBUWdBV3RxSVFVZ0FTQUFhMEVCYWlFR0FrQURRQ0FCTFFBQUlBQkJwODhBYWkwQUFFY05XU0FBUVFGR0RRRWdBRUVCYWlFQUlBUWdBVUVCYWlJQlJ3MEFDeUFDSUFVMkFnQU1sd0lMSUFKQkFEWUNBQ0FHUVFGcUlRRkJDd3hhQ3lBQklBUkdCRUJCbHdFaEF3eVdBZ3NDUUFKQUFrQUNRQ0FCTFFBQVFTMXJEaU1BVzF0YlcxdGJXMXRiVzF0YlcxdGJXMXRiVzF0Ylcxc0JXMXRiVzFzQ1cxdGJBMXNMSUFGQkFXb2hBVUg3QUNFRERQOEJDeUFCUVFGcUlRRkIvQUFoQXd6K0FRc2dBVUVCYWlFQlFZRUJJUU1NL1FFTElBRkJBV29oQVVHQ0FTRUREUHdCQzBHWUFTRURJQUVnQkVZTmxBSWdBaWdDQUNJQUlBUWdBV3RxSVFVZ0FTQUFhMEVFYWlFR0FrQURRQ0FCTFFBQUlBQkJxYzhBYWkwQUFFY05WeUFBUVFSR0RRRWdBRUVCYWlFQUlBUWdBVUVCYWlJQlJ3MEFDeUFDSUFVMkFnQU1sUUlMSUFKQkFEWUNBQ0FHUVFGcUlRRkJHUXhZQzBHWkFTRURJQUVnQkVZTmt3SWdBaWdDQUNJQUlBUWdBV3RxSVFVZ0FTQUFhMEVGYWlFR0FrQURRQ0FCTFFBQUlBQkJyczhBYWkwQUFFY05WaUFBUVFWR0RRRWdBRUVCYWlFQUlBUWdBVUVCYWlJQlJ3MEFDeUFDSUFVMkFnQU1sQUlMSUFKQkFEWUNBQ0FHUVFGcUlRRkJCZ3hYQzBHYUFTRURJQUVnQkVZTmtnSWdBaWdDQUNJQUlBUWdBV3RxSVFVZ0FTQUFhMEVCYWlFR0FrQURRQ0FCTFFBQUlBQkJ0TThBYWkwQUFFY05WU0FBUVFGR0RRRWdBRUVCYWlFQUlBUWdBVUVCYWlJQlJ3MEFDeUFDSUFVMkFnQU1rd0lMSUFKQkFEWUNBQ0FHUVFGcUlRRkJIQXhXQzBHYkFTRURJQUVnQkVZTmtRSWdBaWdDQUNJQUlBUWdBV3RxSVFVZ0FTQUFhMEVCYWlFR0FrQURRQ0FCTFFBQUlBQkJ0czhBYWkwQUFFY05WQ0FBUVFGR0RRRWdBRUVCYWlFQUlBUWdBVUVCYWlJQlJ3MEFDeUFDSUFVMkFnQU1rZ0lMSUFKQkFEWUNBQ0FHUVFGcUlRRkJKd3hWQ3lBQklBUkdCRUJCbkFFaEF3eVJBZ3NDUUFKQUlBRXRBQUJCMUFCckRnSUFBVlFMSUFGQkFXb2hBVUdHQVNFRERQZ0JDeUFCUVFGcUlRRkJod0VoQXd6M0FRdEJuUUVoQXlBQklBUkdEWThDSUFJb0FnQWlBQ0FFSUFGcmFpRUZJQUVnQUd0QkFXb2hCZ0pBQTBBZ0FTMEFBQ0FBUWJqUEFHb3RBQUJIRFZJZ0FFRUJSZzBCSUFCQkFXb2hBQ0FFSUFGQkFXb2lBVWNOQUFzZ0FpQUZOZ0lBREpBQ0N5QUNRUUEyQWdBZ0JrRUJhaUVCUVNZTVV3dEJuZ0VoQXlBQklBUkdEWTRDSUFJb0FnQWlBQ0FFSUFGcmFpRUZJQUVnQUd0QkFXb2hCZ0pBQTBBZ0FTMEFBQ0FBUWJyUEFHb3RBQUJIRFZFZ0FFRUJSZzBCSUFCQkFXb2hBQ0FFSUFGQkFXb2lBVWNOQUFzZ0FpQUZOZ0lBREk4Q0N5QUNRUUEyQWdBZ0JrRUJhaUVCUVFNTVVndEJud0VoQXlBQklBUkdEWTBDSUFJb0FnQWlBQ0FFSUFGcmFpRUZJQUVnQUd0QkFtb2hCZ0pBQTBBZ0FTMEFBQ0FBUWUzUEFHb3RBQUJIRFZBZ0FFRUNSZzBCSUFCQkFXb2hBQ0FFSUFGQkFXb2lBVWNOQUFzZ0FpQUZOZ0lBREk0Q0N5QUNRUUEyQWdBZ0JrRUJhaUVCUVF3TVVRdEJvQUVoQXlBQklBUkdEWXdDSUFJb0FnQWlBQ0FFSUFGcmFpRUZJQUVnQUd0QkEyb2hCZ0pBQTBBZ0FTMEFBQ0FBUWJ6UEFHb3RBQUJIRFU4Z0FFRURSZzBCSUFCQkFXb2hBQ0FFSUFGQkFXb2lBVWNOQUFzZ0FpQUZOZ0lBREkwQ0N5QUNRUUEyQWdBZ0JrRUJhaUVCUVEwTVVBc2dBU0FFUmdSQVFhRUJJUU1NakFJTEFrQUNRQ0FCTFFBQVFjWUFhdzRMQUU5UFQwOVBUMDlQVHdGUEN5QUJRUUZxSVFGQml3RWhBd3p6QVFzZ0FVRUJhaUVCUVl3QklRTU04Z0VMSUFFZ0JFWUVRRUdpQVNFRERJc0NDeUFCTFFBQVFkQUFSdzFNSUFGQkFXb2hBUXhHQ3lBQklBUkdCRUJCb3dFaEF3eUtBZ3NDUUFKQUlBRXRBQUJCeVFCckRnY0JUVTFOVFUwQVRRc2dBVUVCYWlFQlFZNEJJUU1NOFFFTElBRkJBV29oQVVFaURFMExRYVFCSVFNZ0FTQUVSZzJJQWlBQ0tBSUFJZ0FnQkNBQmEyb2hCU0FCSUFCclFRRnFJUVlDUUFOQUlBRXRBQUFnQUVIQXp3QnFMUUFBUncxTElBQkJBVVlOQVNBQVFRRnFJUUFnQkNBQlFRRnFJZ0ZIRFFBTElBSWdCVFlDQUF5SkFnc2dBa0VBTmdJQUlBWkJBV29oQVVFZERFd0xJQUVnQkVZRVFFR2xBU0VERElnQ0N3SkFBa0FnQVMwQUFFSFNBR3NPQXdCTEFVc0xJQUZCQVdvaEFVR1FBU0VERE84QkN5QUJRUUZxSVFGQkJBeExDeUFCSUFSR0JFQkJwZ0VoQXd5SEFnc0NRQUpBQWtBQ1FBSkFJQUV0QUFCQndRQnJEaFVBVFUxTlRVMU5UVTFOVFFGTlRRSk5UUU5OVFFSTkN5QUJRUUZxSVFGQmlBRWhBd3p4QVFzZ0FVRUJhaUVCUVlrQklRTU04QUVMSUFGQkFXb2hBVUdLQVNFRERPOEJDeUFCUVFGcUlRRkJqd0VoQXd6dUFRc2dBVUVCYWlFQlFaRUJJUU1NN1FFTFFhY0JJUU1nQVNBRVJnMkZBaUFDS0FJQUlnQWdCQ0FCYTJvaEJTQUJJQUJyUVFKcUlRWUNRQU5BSUFFdEFBQWdBRUh0endCcUxRQUFSdzFJSUFCQkFrWU5BU0FBUVFGcUlRQWdCQ0FCUVFGcUlnRkhEUUFMSUFJZ0JUWUNBQXlHQWdzZ0FrRUFOZ0lBSUFaQkFXb2hBVUVSREVrTFFhZ0JJUU1nQVNBRVJnMkVBaUFDS0FJQUlnQWdCQ0FCYTJvaEJTQUJJQUJyUVFKcUlRWUNRQU5BSUFFdEFBQWdBRUhDendCcUxRQUFSdzFISUFCQkFrWU5BU0FBUVFGcUlRQWdCQ0FCUVFGcUlnRkhEUUFMSUFJZ0JUWUNBQXlGQWdzZ0FrRUFOZ0lBSUFaQkFXb2hBVUVzREVnTFFha0JJUU1nQVNBRVJnMkRBaUFDS0FJQUlnQWdCQ0FCYTJvaEJTQUJJQUJyUVFScUlRWUNRQU5BSUFFdEFBQWdBRUhGendCcUxRQUFSdzFHSUFCQkJFWU5BU0FBUVFGcUlRQWdCQ0FCUVFGcUlnRkhEUUFMSUFJZ0JUWUNBQXlFQWdzZ0FrRUFOZ0lBSUFaQkFXb2hBVUVyREVjTFFhb0JJUU1nQVNBRVJnMkNBaUFDS0FJQUlnQWdCQ0FCYTJvaEJTQUJJQUJyUVFKcUlRWUNRQU5BSUFFdEFBQWdBRUhLendCcUxRQUFSdzFGSUFCQkFrWU5BU0FBUVFGcUlRQWdCQ0FCUVFGcUlnRkhEUUFMSUFJZ0JUWUNBQXlEQWdzZ0FrRUFOZ0lBSUFaQkFXb2hBVUVVREVZTElBRWdCRVlFUUVHckFTRURESUlDQ3dKQUFrQUNRQUpBSUFFdEFBQkJ3Z0JyRGc4QUFRSkhSMGRIUjBkSFIwZEhSd05IQ3lBQlFRRnFJUUZCa3dFaEF3enJBUXNnQVVFQmFpRUJRWlFCSVFNTTZnRUxJQUZCQVdvaEFVR1ZBU0VERE9rQkN5QUJRUUZxSVFGQmxnRWhBd3pvQVFzZ0FTQUVSZ1JBUWF3QklRTU1nUUlMSUFFdEFBQkJ4UUJIRFVJZ0FVRUJhaUVCREQwTFFhMEJJUU1nQVNBRVJnMy9BU0FDS0FJQUlnQWdCQ0FCYTJvaEJTQUJJQUJyUVFKcUlRWUNRQU5BSUFFdEFBQWdBRUhOendCcUxRQUFSdzFDSUFCQkFrWU5BU0FBUVFGcUlRQWdCQ0FCUVFGcUlnRkhEUUFMSUFJZ0JUWUNBQXlBQWdzZ0FrRUFOZ0lBSUFaQkFXb2hBVUVPREVNTElBRWdCRVlFUUVHdUFTRUREUDhCQ3lBQkxRQUFRZEFBUncxQUlBRkJBV29oQVVFbERFSUxRYThCSVFNZ0FTQUVSZzM5QVNBQ0tBSUFJZ0FnQkNBQmEyb2hCU0FCSUFCclFRaHFJUVlDUUFOQUlBRXRBQUFnQUVIUXp3QnFMUUFBUncxQUlBQkJDRVlOQVNBQVFRRnFJUUFnQkNBQlFRRnFJZ0ZIRFFBTElBSWdCVFlDQUF6K0FRc2dBa0VBTmdJQUlBWkJBV29oQVVFcURFRUxJQUVnQkVZRVFFR3dBU0VERFAwQkN3SkFBa0FnQVMwQUFFSFZBR3NPQ3dCQVFFQkFRRUJBUUVBQlFBc2dBVUVCYWlFQlFab0JJUU1NNUFFTElBRkJBV29oQVVHYkFTRURET01CQ3lBQklBUkdCRUJCc1FFaEF3ejhBUXNDUUFKQUlBRXRBQUJCd1FCckRoUUFQejgvUHo4L1B6OC9QejgvUHo4L1B6OC9BVDhMSUFGQkFXb2hBVUdaQVNFRERPTUJDeUFCUVFGcUlRRkJuQUVoQXd6aUFRdEJzZ0VoQXlBQklBUkdEZm9CSUFJb0FnQWlBQ0FFSUFGcmFpRUZJQUVnQUd0QkEyb2hCZ0pBQTBBZ0FTMEFBQ0FBUWRuUEFHb3RBQUJIRFQwZ0FFRURSZzBCSUFCQkFXb2hBQ0FFSUFGQkFXb2lBVWNOQUFzZ0FpQUZOZ0lBRFBzQkN5QUNRUUEyQWdBZ0JrRUJhaUVCUVNFTVBndEJzd0VoQXlBQklBUkdEZmtCSUFJb0FnQWlBQ0FFSUFGcmFpRUZJQUVnQUd0QkJtb2hCZ0pBQTBBZ0FTMEFBQ0FBUWQzUEFHb3RBQUJIRFR3Z0FFRUdSZzBCSUFCQkFXb2hBQ0FFSUFGQkFXb2lBVWNOQUFzZ0FpQUZOZ0lBRFBvQkN5QUNRUUEyQWdBZ0JrRUJhaUVCUVJvTVBRc2dBU0FFUmdSQVFiUUJJUU1NK1FFTEFrQUNRQUpBSUFFdEFBQkJ4UUJyRGhFQVBUMDlQVDA5UFQwOUFUMDlQVDA5QWowTElBRkJBV29oQVVHZEFTRURET0VCQ3lBQlFRRnFJUUZCbmdFaEF3emdBUXNnQVVFQmFpRUJRWjhCSVFNTTN3RUxRYlVCSVFNZ0FTQUVSZzMzQVNBQ0tBSUFJZ0FnQkNBQmEyb2hCU0FCSUFCclFRVnFJUVlDUUFOQUlBRXRBQUFnQUVIa3p3QnFMUUFBUncwNklBQkJCVVlOQVNBQVFRRnFJUUFnQkNBQlFRRnFJZ0ZIRFFBTElBSWdCVFlDQUF6NEFRc2dBa0VBTmdJQUlBWkJBV29oQVVFb0REc0xRYllCSVFNZ0FTQUVSZzMyQVNBQ0tBSUFJZ0FnQkNBQmEyb2hCU0FCSUFCclFRSnFJUVlDUUFOQUlBRXRBQUFnQUVIcXp3QnFMUUFBUncwNUlBQkJBa1lOQVNBQVFRRnFJUUFnQkNBQlFRRnFJZ0ZIRFFBTElBSWdCVFlDQUF6M0FRc2dBa0VBTmdJQUlBWkJBV29oQVVFSEREb0xJQUVnQkVZRVFFRzNBU0VERFBZQkN3SkFBa0FnQVMwQUFFSEZBR3NPRGdBNU9UazVPVGs1T1RrNU9Ua0JPUXNnQVVFQmFpRUJRYUVCSVFNTTNRRUxJQUZCQVdvaEFVR2lBU0VERE53QkMwRzRBU0VESUFFZ0JFWU45QUVnQWlnQ0FDSUFJQVFnQVd0cUlRVWdBU0FBYTBFQ2FpRUdBa0FEUUNBQkxRQUFJQUJCN2M4QWFpMEFBRWNOTnlBQVFRSkdEUUVnQUVFQmFpRUFJQVFnQVVFQmFpSUJSdzBBQ3lBQ0lBVTJBZ0FNOVFFTElBSkJBRFlDQUNBR1FRRnFJUUZCRWd3NEMwRzVBU0VESUFFZ0JFWU44d0VnQWlnQ0FDSUFJQVFnQVd0cUlRVWdBU0FBYTBFQmFpRUdBa0FEUUNBQkxRQUFJQUJCOE04QWFpMEFBRWNOTmlBQVFRRkdEUUVnQUVFQmFpRUFJQVFnQVVFQmFpSUJSdzBBQ3lBQ0lBVTJBZ0FNOUFFTElBSkJBRFlDQUNBR1FRRnFJUUZCSUF3M0MwRzZBU0VESUFFZ0JFWU44Z0VnQWlnQ0FDSUFJQVFnQVd0cUlRVWdBU0FBYTBFQmFpRUdBa0FEUUNBQkxRQUFJQUJCOHM4QWFpMEFBRWNOTlNBQVFRRkdEUUVnQUVFQmFpRUFJQVFnQVVFQmFpSUJSdzBBQ3lBQ0lBVTJBZ0FNOHdFTElBSkJBRFlDQUNBR1FRRnFJUUZCRHd3MkN5QUJJQVJHQkVCQnV3RWhBd3p5QVFzQ1FBSkFJQUV0QUFCQnlRQnJEZ2NBTlRVMU5UVUJOUXNnQVVFQmFpRUJRYVVCSVFNTTJRRUxJQUZCQVdvaEFVR21BU0VERE5nQkMwRzhBU0VESUFFZ0JFWU44QUVnQWlnQ0FDSUFJQVFnQVd0cUlRVWdBU0FBYTBFSGFpRUdBa0FEUUNBQkxRQUFJQUJCOU04QWFpMEFBRWNOTXlBQVFRZEdEUUVnQUVFQmFpRUFJQVFnQVVFQmFpSUJSdzBBQ3lBQ0lBVTJBZ0FNOFFFTElBSkJBRFlDQUNBR1FRRnFJUUZCR3d3MEN5QUJJQVJHQkVCQnZRRWhBd3p3QVFzQ1FBSkFBa0FnQVMwQUFFSENBR3NPRWdBME5EUTBORFEwTkRRQk5EUTBORFEwQWpRTElBRkJBV29oQVVHa0FTRURETmdCQ3lBQlFRRnFJUUZCcHdFaEF3elhBUXNnQVVFQmFpRUJRYWdCSVFNTTFnRUxJQUVnQkVZRVFFRytBU0VERE84QkN5QUJMUUFBUWM0QVJ3MHdJQUZCQVdvaEFRd3NDeUFCSUFSR0JFQkJ2d0VoQXd6dUFRc0NRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUNBQkxRQUFRY0VBYXc0VkFBRUNBejhFQlFZL1B6OEhDQWtLQ3o4TURRNFBQd3NnQVVFQmFpRUJRZWdBSVFNTTR3RUxJQUZCQVdvaEFVSHBBQ0VERE9JQkN5QUJRUUZxSVFGQjdnQWhBd3poQVFzZ0FVRUJhaUVCUWZJQUlRTU00QUVMSUFGQkFXb2hBVUh6QUNFREROOEJDeUFCUVFGcUlRRkI5Z0FoQXd6ZUFRc2dBVUVCYWlFQlFmY0FJUU1NM1FFTElBRkJBV29oQVVINkFDRURETndCQ3lBQlFRRnFJUUZCZ3dFaEF3emJBUXNnQVVFQmFpRUJRWVFCSVFNTTJnRUxJQUZCQVdvaEFVR0ZBU0VERE5rQkN5QUJRUUZxSVFGQmtnRWhBd3pZQVFzZ0FVRUJhaUVCUVpnQklRTU0xd0VMSUFGQkFXb2hBVUdnQVNFREROWUJDeUFCUVFGcUlRRkJvd0VoQXd6VkFRc2dBVUVCYWlFQlFhb0JJUU1NMUFFTElBRWdCRWNFUUNBQ1FSQTJBZ2dnQWlBQk5nSUVRYXNCSVFNTTFBRUxRY0FCSVFNTTdBRUxRUUFoQUFKQUlBSW9BamdpQTBVTkFDQURLQUkwSWdORkRRQWdBaUFERVFBQUlRQUxJQUJGRFY0Z0FFRVZSdzBISUFKQjBRQTJBaHdnQWlBQk5nSVVJQUpCc0JjMkFoQWdBa0VWTmdJTVFRQWhBd3pyQVFzZ0FVRUJhaUFCSUFSSERRZ2FRY0lCSVFNTTZnRUxBMEFDUUNBQkxRQUFRUXByRGdRSUFBQUxBQXNnQkNBQlFRRnFJZ0ZIRFFBTFFjTUJJUU1NNlFFTElBRWdCRWNFUUNBQ1FSRTJBZ2dnQWlBQk5nSUVRUUVoQXd6UUFRdEJ4QUVoQXd6b0FRc2dBU0FFUmdSQVFjVUJJUU1NNkFFTEFrQUNRQ0FCTFFBQVFRcHJEZ1FCS0NnQUtBc2dBVUVCYWd3SkN5QUJRUUZxREFVTElBRWdCRVlFUUVIR0FTRURET2NCQ3dKQUFrQWdBUzBBQUVFS2F3NFhBUXNMQVFzTEN3c0xDd3NMQ3dzTEN3c0xDd3NMQ3dBTEN5QUJRUUZxSVFFTFFiQUJJUU1NelFFTElBRWdCRVlFUUVISUFTRURET1lCQ3lBQkxRQUFRU0JIRFFrZ0FrRUFPd0V5SUFGQkFXb2hBVUd6QVNFRERNd0JDd05BSUFFaEFBSkFJQUVnQkVjRVFDQUJMUUFBUVRCclFmOEJjU0lEUVFwSkRRRU1Kd3RCeHdFaEF3em1BUXNDUUNBQ0x3RXlJZ0ZCbVROTERRQWdBaUFCUVFwc0lnVTdBVElnQlVIKy93TnhJQU5CLy84RGMwc05BQ0FBUVFGcUlRRWdBaUFESUFWcUlnTTdBVElnQTBILy93TnhRZWdIU1EwQkN3dEJBQ0VESUFKQkFEWUNIQ0FDUWNFSk5nSVFJQUpCRFRZQ0RDQUNJQUJCQVdvMkFoUU01QUVMSUFKQkFEWUNIQ0FDSUFFMkFoUWdBa0h3RERZQ0VDQUNRUnMyQWd4QkFDRURET01CQ3lBQ0tBSUVJUUFnQWtFQU5nSUVJQUlnQUNBQkVDWWlBQTBCSUFGQkFXb0xJUUZCclFFaEF3eklBUXNnQWtIQkFUWUNIQ0FDSUFBMkFnd2dBaUFCUVFGcU5nSVVRUUFoQXd6Z0FRc2dBaWdDQkNFQUlBSkJBRFlDQkNBQ0lBQWdBUkFtSWdBTkFTQUJRUUZxQ3lFQlFhNEJJUU1NeFFFTElBSkJ3Z0UyQWh3Z0FpQUFOZ0lNSUFJZ0FVRUJhallDRkVFQUlRTU0zUUVMSUFKQkFEWUNIQ0FDSUFFMkFoUWdBa0dYQ3pZQ0VDQUNRUTAyQWd4QkFDRURETndCQ3lBQ1FRQTJBaHdnQWlBQk5nSVVJQUpCNHhBMkFoQWdBa0VKTmdJTVFRQWhBd3piQVFzZ0FrRUNPZ0FvREt3QkMwRUFJUU1nQWtFQU5nSWNJQUpCcndzMkFoQWdBa0VDTmdJTUlBSWdBVUVCYWpZQ0ZBelpBUXRCQWlFRERMOEJDMEVOSVFNTXZnRUxRU1loQXd5OUFRdEJGU0VEREx3QkMwRVdJUU1NdXdFTFFSZ2hBd3k2QVF0QkhDRURETGtCQzBFZElRTU11QUVMUVNBaEF3eTNBUXRCSVNFRERMWUJDMEVqSVFNTXRRRUxRY1lBSVFNTXRBRUxRUzRoQXd5ekFRdEJQU0VERExJQkMwSExBQ0VERExFQkMwSE9BQ0VERExBQkMwSFlBQ0VEREs4QkMwSFpBQ0VEREs0QkMwSGJBQ0VEREswQkMwSHhBQ0VEREt3QkMwSDBBQ0VEREtzQkMwR05BU0VEREtvQkMwR1hBU0VEREtrQkMwR3BBU0VEREtnQkMwR3ZBU0VEREtjQkMwR3hBU0VEREtZQkN5QUNRUUEyQWdBTFFRQWhBeUFDUVFBMkFod2dBaUFCTmdJVUlBSkI4UnMyQWhBZ0FrRUdOZ0lNREwwQkN5QUNRUUEyQWdBZ0JrRUJhaUVCUVNRTE9nQXBJQUlvQWdRaEFDQUNRUUEyQWdRZ0FpQUFJQUVRSnlJQVJRUkFRZVVBSVFNTW93RUxJQUpCK1FBMkFod2dBaUFCTmdJVUlBSWdBRFlDREVFQUlRTU11d0VMSUFCQkZVY0VRQ0FDUVFBMkFod2dBaUFCTmdJVUlBSkJ6QTQyQWhBZ0FrRWdOZ0lNUVFBaEF3eTdBUXNnQWtINEFEWUNIQ0FDSUFFMkFoUWdBa0hLR0RZQ0VDQUNRUlUyQWd4QkFDRURETG9CQ3lBQ1FRQTJBaHdnQWlBQk5nSVVJQUpCamhzMkFoQWdBa0VHTmdJTVFRQWhBd3k1QVFzZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUWY0Uk5nSVFJQUpCQnpZQ0RFRUFJUU1NdUFFTElBSkJBRFlDSENBQ0lBRTJBaFFnQWtHTUhEWUNFQ0FDUVFjMkFneEJBQ0VERExjQkN5QUNRUUEyQWh3Z0FpQUJOZ0lVSUFKQnd3ODJBaEFnQWtFSE5nSU1RUUFoQXd5MkFRc2dBa0VBTmdJY0lBSWdBVFlDRkNBQ1FjTVBOZ0lRSUFKQkJ6WUNERUVBSVFNTXRRRUxJQUlvQWdRaEFDQUNRUUEyQWdRZ0FpQUFJQUVRSlNJQVJRMFJJQUpCNVFBMkFod2dBaUFCTmdJVUlBSWdBRFlDREVFQUlRTU10QUVMSUFJb0FnUWhBQ0FDUVFBMkFnUWdBaUFBSUFFUUpTSUFSUTBnSUFKQjB3QTJBaHdnQWlBQk5nSVVJQUlnQURZQ0RFRUFJUU1Nc3dFTElBSW9BZ1FoQUNBQ1FRQTJBZ1FnQWlBQUlBRVFKU0lBUlEwaUlBSkIwZ0EyQWh3Z0FpQUJOZ0lVSUFJZ0FEWUNERUVBSVFNTXNnRUxJQUlvQWdRaEFDQUNRUUEyQWdRZ0FpQUFJQUVRSlNJQVJRME9JQUpCNVFBMkFod2dBaUFCTmdJVUlBSWdBRFlDREVFQUlRTU1zUUVMSUFJb0FnUWhBQ0FDUVFBMkFnUWdBaUFBSUFFUUpTSUFSUTBkSUFKQjB3QTJBaHdnQWlBQk5nSVVJQUlnQURZQ0RFRUFJUU1Nc0FFTElBSW9BZ1FoQUNBQ1FRQTJBZ1FnQWlBQUlBRVFKU0lBUlEwZklBSkIwZ0EyQWh3Z0FpQUJOZ0lVSUFJZ0FEWUNERUVBSVFNTXJ3RUxJQUJCUDBjTkFTQUJRUUZxQ3lFQlFRVWhBd3lVQVF0QkFDRURJQUpCQURZQ0hDQUNJQUUyQWhRZ0FrSDlFallDRUNBQ1FRYzJBZ3dNckFFTElBSkJBRFlDSENBQ0lBRTJBaFFnQWtIY0NEWUNFQ0FDUVFjMkFneEJBQ0VEREtzQkN5QUNLQUlFSVFBZ0FrRUFOZ0lFSUFJZ0FDQUJFQ1VpQUVVTkJ5QUNRZVVBTmdJY0lBSWdBVFlDRkNBQ0lBQTJBZ3hCQUNFRERLb0JDeUFDS0FJRUlRQWdBa0VBTmdJRUlBSWdBQ0FCRUNVaUFFVU5GaUFDUWRNQU5nSWNJQUlnQVRZQ0ZDQUNJQUEyQWd4QkFDRURES2tCQ3lBQ0tBSUVJUUFnQWtFQU5nSUVJQUlnQUNBQkVDVWlBRVVOR0NBQ1FkSUFOZ0ljSUFJZ0FUWUNGQ0FDSUFBMkFneEJBQ0VEREtnQkN5QUNRUUEyQWh3Z0FpQUJOZ0lVSUFKQnhnbzJBaEFnQWtFSE5nSU1RUUFoQXd5bkFRc2dBaWdDQkNFQUlBSkJBRFlDQkNBQ0lBQWdBUkFsSWdCRkRRTWdBa0hsQURZQ0hDQUNJQUUyQWhRZ0FpQUFOZ0lNUVFBaEF3eW1BUXNnQWlnQ0JDRUFJQUpCQURZQ0JDQUNJQUFnQVJBbElnQkZEUklnQWtIVEFEWUNIQ0FDSUFFMkFoUWdBaUFBTmdJTVFRQWhBd3lsQVFzZ0FpZ0NCQ0VBSUFKQkFEWUNCQ0FDSUFBZ0FSQWxJZ0JGRFJRZ0FrSFNBRFlDSENBQ0lBRTJBaFFnQWlBQU5nSU1RUUFoQXd5a0FRc2dBaWdDQkNFQUlBSkJBRFlDQkNBQ0lBQWdBUkFsSWdCRkRRQWdBa0hsQURZQ0hDQUNJQUUyQWhRZ0FpQUFOZ0lNUVFBaEF3eWpBUXRCMVFBaEF3eUpBUXNnQUVFVlJ3UkFJQUpCQURZQ0hDQUNJQUUyQWhRZ0FrRzVEVFlDRUNBQ1FSbzJBZ3hCQUNFRERLSUJDeUFDUWVRQU5nSWNJQUlnQVRZQ0ZDQUNRZU1YTmdJUUlBSkJGVFlDREVFQUlRTU1vUUVMSUFKQkFEWUNBQ0FHUVFGcUlRRWdBaTBBS1NJQVFTTnJRUXRKRFFRQ1FDQUFRUVpMRFFCQkFTQUFkRUhLQUhGRkRRQU1CUXRCQUNFRElBSkJBRFlDSENBQ0lBRTJBaFFnQWtIM0NUWUNFQ0FDUVFnMkFnd01vQUVMSUFKQkFEWUNBQ0FHUVFGcUlRRWdBaTBBS1VFaFJnMERJQUpCQURZQ0hDQUNJQUUyQWhRZ0FrR2JDallDRUNBQ1FRZzJBZ3hCQUNFRERKOEJDeUFDUVFBMkFnQUxRUUFoQXlBQ1FRQTJBaHdnQWlBQk5nSVVJQUpCa0RNMkFoQWdBa0VJTmdJTURKMEJDeUFDUVFBMkFnQWdCa0VCYWlFQklBSXRBQ2xCSTBrTkFDQUNRUUEyQWh3Z0FpQUJOZ0lVSUFKQjB3azJBaEFnQWtFSU5nSU1RUUFoQXd5Y0FRdEIwUUFoQXd5Q0FRc2dBUzBBQUVFd2F5SUFRZjhCY1VFS1NRUkFJQUlnQURvQUtpQUJRUUZxSVFGQnp3QWhBd3lDQVFzZ0FpZ0NCQ0VBSUFKQkFEWUNCQ0FDSUFBZ0FSQW9JZ0JGRFlZQklBSkIzZ0EyQWh3Z0FpQUJOZ0lVSUFJZ0FEWUNERUVBSVFNTW1nRUxJQUlvQWdRaEFDQUNRUUEyQWdRZ0FpQUFJQUVRS0NJQVJRMkdBU0FDUWR3QU5nSWNJQUlnQVRZQ0ZDQUNJQUEyQWd4QkFDRURESmtCQ3lBQ0tBSUVJUUFnQWtFQU5nSUVJQUlnQUNBRkVDZ2lBRVVFUUNBRklRRU1od0VMSUFKQjJnQTJBaHdnQWlBRk5nSVVJQUlnQURZQ0RBeVlBUXRCQUNFQlFRRWhBd3NnQWlBRE9nQXJJQVZCQVdvaEF3SkFBa0FDUUNBQ0xRQXRRUkJ4RFFBQ1FBSkFBa0FnQWkwQUtnNERBUUFDQkFzZ0JrVU5Bd3dDQ3lBQURRRU1BZ3NnQVVVTkFRc2dBaWdDQkNFQUlBSkJBRFlDQkNBQ0lBQWdBeEFvSWdCRkJFQWdBeUVCREFJTElBSkIyQUEyQWh3Z0FpQUROZ0lVSUFJZ0FEWUNERUVBSVFNTW1BRUxJQUlvQWdRaEFDQUNRUUEyQWdRZ0FpQUFJQU1RS0NJQVJRUkFJQU1oQVF5SEFRc2dBa0haQURZQ0hDQUNJQU0yQWhRZ0FpQUFOZ0lNUVFBaEF3eVhBUXRCekFBaEF3eDlDeUFBUVJWSEJFQWdBa0VBTmdJY0lBSWdBVFlDRkNBQ1FaUU5OZ0lRSUFKQklUWUNERUVBSVFNTWxnRUxJQUpCMXdBMkFod2dBaUFCTmdJVUlBSkJ5UmMyQWhBZ0FrRVZOZ0lNUVFBaEF3eVZBUXRCQUNFRElBSkJBRFlDSENBQ0lBRTJBaFFnQWtHQUVUWUNFQ0FDUVFrMkFnd01sQUVMSUFJb0FnUWhBQ0FDUVFBMkFnUWdBaUFBSUFFUUpTSUFSUTBBSUFKQjB3QTJBaHdnQWlBQk5nSVVJQUlnQURZQ0RFRUFJUU1Na3dFTFFja0FJUU1NZVFzZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUWNFb05nSVFJQUpCQnpZQ0RDQUNRUUEyQWdCQkFDRURESkVCQ3lBQ0tBSUVJUUJCQUNFRElBSkJBRFlDQkNBQ0lBQWdBUkFsSWdCRkRRQWdBa0hTQURZQ0hDQUNJQUUyQWhRZ0FpQUFOZ0lNREpBQkMwSElBQ0VEREhZTElBSkJBRFlDQUNBRklRRUxJQUpCZ0JJN0FTb2dBVUVCYWlFQlFRQWhBQUpBSUFJb0FqZ2lBMFVOQUNBREtBSXdJZ05GRFFBZ0FpQURFUUFBSVFBTElBQU5BUXRCeHdBaEF3eHpDeUFBUVJWR0JFQWdBa0hSQURZQ0hDQUNJQUUyQWhRZ0FrSGpGellDRUNBQ1FSVTJBZ3hCQUNFRERJd0JDMEVBSVFNZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUWJrTk5nSVFJQUpCR2pZQ0RBeUxBUXRCQUNFRElBSkJBRFlDSENBQ0lBRTJBaFFnQWtHZ0dUWUNFQ0FDUVI0MkFnd01pZ0VMSUFFdEFBQkJPa1lFUUNBQ0tBSUVJUUJCQUNFRElBSkJBRFlDQkNBQ0lBQWdBUkFwSWdCRkRRRWdBa0hEQURZQ0hDQUNJQUEyQWd3Z0FpQUJRUUZxTmdJVURJb0JDMEVBSVFNZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUWJFUk5nSVFJQUpCQ2pZQ0RBeUpBUXNnQVVFQmFpRUJRVHNoQXd4dkN5QUNRY01BTmdJY0lBSWdBRFlDRENBQ0lBRkJBV28yQWhRTWh3RUxRUUFoQXlBQ1FRQTJBaHdnQWlBQk5nSVVJQUpCOEE0MkFoQWdBa0VjTmdJTURJWUJDeUFDSUFJdkFUQkJFSEk3QVRBTVpnc0NRQ0FDTHdFd0lnQkJDSEZGRFFBZ0FpMEFLRUVCUncwQUlBSXRBQzFCQ0hGRkRRTUxJQUlnQUVIMyt3TnhRWUFFY2pzQk1Bd0VDeUFCSUFSSEJFQUNRQU5BSUFFdEFBQkJNR3NpQUVIL0FYRkJDazhFUUVFMUlRTU1iZ3NnQWlrRElDSUtRcG16NXN5WnMrYk1HVllOQVNBQ0lBcENDbjRpQ2pjRElDQUtJQUN0UXY4Qmd5SUxRbitGVmcwQklBSWdDaUFMZkRjRElDQUVJQUZCQVdvaUFVY05BQXRCT1NFRERJVUJDeUFDS0FJRUlRQkJBQ0VESUFKQkFEWUNCQ0FDSUFBZ0FVRUJhaUlCRUNvaUFBME1ESGNMUVRraEF3eURBUXNnQWkwQU1FRWdjUTBHUWNVQklRTU1hUXRCQUNFRElBSkJBRFlDQkNBQ0lBRWdBUkFxSWdCRkRRUWdBa0U2TmdJY0lBSWdBRFlDRENBQ0lBRkJBV28yQWhRTWdRRUxJQUl0QUNoQkFVY05BQ0FDTFFBdFFRaHhSUTBCQzBFM0lRTU1aZ3NnQWlnQ0JDRUFRUUFoQXlBQ1FRQTJBZ1FnQWlBQUlBRVFLaUlBQkVBZ0FrRTdOZ0ljSUFJZ0FEWUNEQ0FDSUFGQkFXbzJBaFFNZndzZ0FVRUJhaUVCREc0TElBSkJDRG9BTEF3RUN5QUJRUUZxSVFFTWJRdEJBQ0VESUFKQkFEWUNIQ0FDSUFFMkFoUWdBa0hrRWpZQ0VDQUNRUVEyQWd3TWV3c2dBaWdDQkNFQVFRQWhBeUFDUVFBMkFnUWdBaUFBSUFFUUtpSUFSUTFzSUFKQk56WUNIQ0FDSUFFMkFoUWdBaUFBTmdJTURIb0xJQUlnQWk4Qk1FRWdjanNCTUF0Qk1DRURERjhMSUFKQk5qWUNIQ0FDSUFFMkFoUWdBaUFBTmdJTURIY0xJQUJCTEVjTkFTQUJRUUZxSVFCQkFTRUJBa0FDUUFKQUFrQUNRQ0FDTFFBc1FRVnJEZ1FEQVFJRUFBc2dBQ0VCREFRTFFRSWhBUXdCQzBFRUlRRUxJQUpCQVRvQUxDQUNJQUl2QVRBZ0FYSTdBVEFnQUNFQkRBRUxJQUlnQWk4Qk1FRUljanNCTUNBQUlRRUxRVGtoQXd4Y0N5QUNRUUE2QUN3TFFUUWhBd3hhQ3lBQklBUkdCRUJCTFNFRERITUxBa0FDUUFOQUFrQWdBUzBBQUVFS2F3NEVBZ0FBQXdBTElBUWdBVUVCYWlJQlJ3MEFDMEV0SVFNTWRBc2dBaWdDQkNFQVFRQWhBeUFDUVFBMkFnUWdBaUFBSUFFUUtpSUFSUTBDSUFKQkxEWUNIQ0FDSUFFMkFoUWdBaUFBTmdJTURITUxJQUlvQWdRaEFFRUFJUU1nQWtFQU5nSUVJQUlnQUNBQkVDb2lBRVVFUUNBQlFRRnFJUUVNQWdzZ0FrRXNOZ0ljSUFJZ0FEWUNEQ0FDSUFGQkFXbzJBaFFNY2dzZ0FTMEFBRUVOUmdSQUlBSW9BZ1FoQUVFQUlRTWdBa0VBTmdJRUlBSWdBQ0FCRUNvaUFFVUVRQ0FCUVFGcUlRRU1BZ3NnQWtFc05nSWNJQUlnQURZQ0RDQUNJQUZCQVdvMkFoUU1jZ3NnQWkwQUxVRUJjUVJBUWNRQklRTU1XUXNnQWlnQ0JDRUFRUUFoQXlBQ1FRQTJBZ1FnQWlBQUlBRVFLaUlBRFFFTVpRdEJMeUVEREZjTElBSkJMallDSENBQ0lBRTJBaFFnQWlBQU5nSU1ERzhMUVFBaEF5QUNRUUEyQWh3Z0FpQUJOZ0lVSUFKQjhCUTJBaEFnQWtFRE5nSU1ERzRMUVFFaEF3SkFBa0FDUUFKQUlBSXRBQ3hCQldzT0JBTUJBZ0FFQ3lBQ0lBSXZBVEJCQ0hJN0FUQU1Bd3RCQWlFRERBRUxRUVFoQXdzZ0FrRUJPZ0FzSUFJZ0FpOEJNQ0FEY2pzQk1BdEJLaUVEREZNTFFRQWhBeUFDUVFBMkFod2dBaUFCTmdJVUlBSkI0UTgyQWhBZ0FrRUtOZ0lNREdzTFFRRWhBd0pBQWtBQ1FBSkFBa0FDUUNBQ0xRQXNRUUpyRGdjRkJBUURBUUlBQkFzZ0FpQUNMd0V3UVFoeU93RXdEQU1MUVFJaEF3d0JDMEVFSVFNTElBSkJBVG9BTENBQ0lBSXZBVEFnQTNJN0FUQUxRU3NoQXd4U0MwRUFJUU1nQWtFQU5nSWNJQUlnQVRZQ0ZDQUNRYXNTTmdJUUlBSkJDellDREF4cUMwRUFJUU1nQWtFQU5nSWNJQUlnQVRZQ0ZDQUNRZjBOTmdJUUlBSkJIVFlDREF4cEN5QUJJQVJIQkVBRFFDQUJMUUFBUVNCSERVZ2dCQ0FCUVFGcUlnRkhEUUFMUVNVaEF3eHBDMEVsSVFNTWFBc2dBaTBBTFVFQmNRUkFRY01CSVFNTVR3c2dBaWdDQkNFQVFRQWhBeUFDUVFBMkFnUWdBaUFBSUFFUUtTSUFCRUFnQWtFbU5nSWNJQUlnQURZQ0RDQUNJQUZCQVdvMkFoUU1hQXNnQVVFQmFpRUJERndMSUFGQkFXb2hBU0FDTHdFd0lnQkJnQUZ4QkVCQkFDRUFBa0FnQWlnQ09DSURSUTBBSUFNb0FsUWlBMFVOQUNBQ0lBTVJBQUFoQUFzZ0FFVU5CaUFBUVJWSERSOGdBa0VGTmdJY0lBSWdBVFlDRkNBQ1Fma1hOZ0lRSUFKQkZUWUNERUVBSVFNTVp3c0NRQ0FBUWFBRWNVR2dCRWNOQUNBQ0xRQXRRUUp4RFFCQkFDRURJQUpCQURZQ0hDQUNJQUUyQWhRZ0FrR1dFellDRUNBQ1FRUTJBZ3dNWndzZ0FnSi9JQUl2QVRCQkZIRkJGRVlFUUVFQklBSXRBQ2hCQVVZTkFSb2dBaThCTWtIbEFFWU1BUXNnQWkwQUtVRUZSZ3M2QUM1QkFDRUFBa0FnQWlnQ09DSURSUTBBSUFNb0FpUWlBMFVOQUNBQ0lBTVJBQUFoQUFzQ1FBSkFBa0FDUUFKQUlBQU9GZ0lCQUFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFNRUN5QUNRUUU2QUM0TElBSWdBaThCTUVIQUFISTdBVEFMUVNjaEF3eFBDeUFDUVNNMkFod2dBaUFCTmdJVUlBSkJwUlkyQWhBZ0FrRVZOZ0lNUVFBaEF3eG5DMEVBSVFNZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUWRVTE5nSVFJQUpCRVRZQ0RBeG1DMEVBSVFBQ1FDQUNLQUk0SWdORkRRQWdBeWdDTENJRFJRMEFJQUlnQXhFQUFDRUFDeUFBRFFFTFFRNGhBd3hMQ3lBQVFSVkdCRUFnQWtFQ05nSWNJQUlnQVRZQ0ZDQUNRYkFZTmdJUUlBSkJGVFlDREVFQUlRTU1aQXRCQUNFRElBSkJBRFlDSENBQ0lBRTJBaFFnQWtHbkRqWUNFQ0FDUVJJMkFnd01Zd3RCQUNFRElBSkJBRFlDSENBQ0lBRTJBaFFnQWtHcUhEWUNFQ0FDUVE4MkFnd01ZZ3NnQWlnQ0JDRUFRUUFoQXlBQ1FRQTJBZ1FnQWlBQUlBRWdDcWRxSWdFUUt5SUFSUTBBSUFKQkJUWUNIQ0FDSUFFMkFoUWdBaUFBTmdJTURHRUxRUThoQXd4SEMwRUFJUU1nQWtFQU5nSWNJQUlnQVRZQ0ZDQUNRYzBUTmdJUUlBSkJERFlDREF4ZkMwSUJJUW9MSUFGQkFXb2hBUUpBSUFJcEF5QWlDMEwvLy8vLy8vLy8vdzlZQkVBZ0FpQUxRZ1NHSUFxRU53TWdEQUVMUVFBaEF5QUNRUUEyQWh3Z0FpQUJOZ0lVSUFKQnJRazJBaEFnQWtFTU5nSU1ERjRMUVNRaEF3eEVDMEVBSVFNZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUWMwVE5nSVFJQUpCRERZQ0RBeGNDeUFDS0FJRUlRQkJBQ0VESUFKQkFEWUNCQ0FDSUFBZ0FSQXNJZ0JGQkVBZ0FVRUJhaUVCREZJTElBSkJGellDSENBQ0lBQTJBZ3dnQWlBQlFRRnFOZ0lVREZzTElBSW9BZ1FoQUVFQUlRTWdBa0VBTmdJRUFrQWdBaUFBSUFFUUxDSUFSUVJBSUFGQkFXb2hBUXdCQ3lBQ1FSWTJBaHdnQWlBQU5nSU1JQUlnQVVFQmFqWUNGQXhiQzBFZklRTU1RUXRCQUNFRElBSkJBRFlDSENBQ0lBRTJBaFFnQWtHYUR6WUNFQ0FDUVNJMkFnd01XUXNnQWlnQ0JDRUFRUUFoQXlBQ1FRQTJBZ1FnQWlBQUlBRVFMU0lBUlFSQUlBRkJBV29oQVF4UUN5QUNRUlEyQWh3Z0FpQUFOZ0lNSUFJZ0FVRUJhallDRkF4WUN5QUNLQUlFSVFCQkFDRURJQUpCQURZQ0JBSkFJQUlnQUNBQkVDMGlBRVVFUUNBQlFRRnFJUUVNQVFzZ0FrRVROZ0ljSUFJZ0FEWUNEQ0FDSUFGQkFXbzJBaFFNV0F0QkhpRURERDRMUVFBaEF5QUNRUUEyQWh3Z0FpQUJOZ0lVSUFKQnhndzJBaEFnQWtFak5nSU1ERllMSUFJb0FnUWhBRUVBSVFNZ0FrRUFOZ0lFSUFJZ0FDQUJFQzBpQUVVRVFDQUJRUUZxSVFFTVRnc2dBa0VSTmdJY0lBSWdBRFlDRENBQ0lBRkJBV28yQWhRTVZRc2dBa0VRTmdJY0lBSWdBVFlDRkNBQ0lBQTJBZ3dNVkF0QkFDRURJQUpCQURZQ0hDQUNJQUUyQWhRZ0FrSEdERFlDRUNBQ1FTTTJBZ3dNVXd0QkFDRURJQUpCQURZQ0hDQUNJQUUyQWhRZ0FrSEFGVFlDRUNBQ1FRSTJBZ3dNVWdzZ0FpZ0NCQ0VBUVFBaEF5QUNRUUEyQWdRQ1FDQUNJQUFnQVJBdElnQkZCRUFnQVVFQmFpRUJEQUVMSUFKQkRqWUNIQ0FDSUFBMkFnd2dBaUFCUVFGcU5nSVVERklMUVJzaEF3dzRDMEVBSVFNZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUWNZTU5nSVFJQUpCSXpZQ0RBeFFDeUFDS0FJRUlRQkJBQ0VESUFKQkFEWUNCQUpBSUFJZ0FDQUJFQ3dpQUVVRVFDQUJRUUZxSVFFTUFRc2dBa0VOTmdJY0lBSWdBRFlDRENBQ0lBRkJBV28yQWhRTVVBdEJHaUVERERZTFFRQWhBeUFDUVFBMkFod2dBaUFCTmdJVUlBSkJtZzgyQWhBZ0FrRWlOZ0lNREU0TElBSW9BZ1FoQUVFQUlRTWdBa0VBTmdJRUFrQWdBaUFBSUFFUUxDSUFSUVJBSUFGQkFXb2hBUXdCQ3lBQ1FRdzJBaHdnQWlBQU5nSU1JQUlnQVVFQmFqWUNGQXhPQzBFWklRTU1OQXRCQUNFRElBSkJBRFlDSENBQ0lBRTJBaFFnQWtHYUR6WUNFQ0FDUVNJMkFnd01UQXNnQUVFVlJ3UkFRUUFoQXlBQ1FRQTJBaHdnQWlBQk5nSVVJQUpCZ3d3MkFoQWdBa0VUTmdJTURFd0xJQUpCQ2pZQ0hDQUNJQUUyQWhRZ0FrSGtGallDRUNBQ1FSVTJBZ3hCQUNFRERFc0xJQUlvQWdRaEFFRUFJUU1nQWtFQU5nSUVJQUlnQUNBQklBcW5haUlCRUNzaUFBUkFJQUpCQnpZQ0hDQUNJQUUyQWhRZ0FpQUFOZ0lNREVzTFFSTWhBd3d4Q3lBQVFSVkhCRUJCQUNFRElBSkJBRFlDSENBQ0lBRTJBaFFnQWtIYURUWUNFQ0FDUVJRMkFnd01TZ3NnQWtFZU5nSWNJQUlnQVRZQ0ZDQUNRZmtYTmdJUUlBSkJGVFlDREVFQUlRTU1TUXRCQUNFQUFrQWdBaWdDT0NJRFJRMEFJQU1vQWl3aUEwVU5BQ0FDSUFNUkFBQWhBQXNnQUVVTlFTQUFRUlZHQkVBZ0FrRUROZ0ljSUFJZ0FUWUNGQ0FDUWJBWU5nSVFJQUpCRlRZQ0RFRUFJUU1NU1F0QkFDRURJQUpCQURZQ0hDQUNJQUUyQWhRZ0FrR25EallDRUNBQ1FSSTJBZ3dNU0F0QkFDRURJQUpCQURZQ0hDQUNJQUUyQWhRZ0FrSGFEVFlDRUNBQ1FSUTJBZ3dNUnd0QkFDRURJQUpCQURZQ0hDQUNJQUUyQWhRZ0FrR25EallDRUNBQ1FSSTJBZ3dNUmdzZ0FrRUFPZ0F2SUFJdEFDMUJCSEZGRFQ4TElBSkJBRG9BTHlBQ1FRRTZBRFJCQUNFRERDc0xRUUFoQXlBQ1FRQTJBaHdnQWtIa0VUWUNFQ0FDUVFjMkFnd2dBaUFCUVFGcU5nSVVERU1MQWtBRFFBSkFJQUV0QUFCQkNtc09CQUFDQWdBQ0N5QUVJQUZCQVdvaUFVY05BQXRCM1FFaEF3eERDd0pBQWtBZ0FpMEFORUVCUncwQVFRQWhBQUpBSUFJb0FqZ2lBMFVOQUNBREtBSllJZ05GRFFBZ0FpQURFUUFBSVFBTElBQkZEUUFnQUVFVlJ3MEJJQUpCM0FFMkFod2dBaUFCTmdJVUlBSkIxUlkyQWhBZ0FrRVZOZ0lNUVFBaEF3eEVDMEhCQVNFRERDb0xJQUpCQURZQ0hDQUNJQUUyQWhRZ0FrSHBDellDRUNBQ1FSODJBZ3hCQUNFRERFSUxBa0FDUUNBQ0xRQW9RUUZyRGdJRUFRQUxRY0FCSVFNTUtRdEJ1UUVoQXd3b0N5QUNRUUk2QUM5QkFDRUFBa0FnQWlnQ09DSURSUTBBSUFNb0FnQWlBMFVOQUNBQ0lBTVJBQUFoQUFzZ0FFVUVRRUhDQVNFRERDZ0xJQUJCRlVjRVFDQUNRUUEyQWh3Z0FpQUJOZ0lVSUFKQnBBdzJBaEFnQWtFUU5nSU1RUUFoQXd4QkN5QUNRZHNCTmdJY0lBSWdBVFlDRkNBQ1Fmb1dOZ0lRSUFKQkZUWUNERUVBSVFNTVFBc2dBU0FFUmdSQVFkb0JJUU1NUUFzZ0FTMEFBRUhJQUVZTkFTQUNRUUU2QUNnTFFhd0JJUU1NSlF0QnZ3RWhBd3drQ3lBQklBUkhCRUFnQWtFUU5nSUlJQUlnQVRZQ0JFRytBU0VERENRTFFka0JJUU1NUEFzZ0FTQUVSZ1JBUWRnQklRTU1QQXNnQVMwQUFFSElBRWNOQkNBQlFRRnFJUUZCdlFFaEF3d2lDeUFCSUFSR0JFQkIxd0VoQXd3N0N3SkFBa0FnQVMwQUFFSEZBR3NPRUFBRkJRVUZCUVVGQlFVRkJRVUZCUUVGQ3lBQlFRRnFJUUZCdXdFaEF3d2lDeUFCUVFGcUlRRkJ2QUVoQXd3aEMwSFdBU0VESUFFZ0JFWU5PU0FDS0FJQUlnQWdCQ0FCYTJvaEJTQUJJQUJyUVFKcUlRWUNRQU5BSUFFdEFBQWdBRUdEMEFCcUxRQUFSdzBESUFCQkFrWU5BU0FBUVFGcUlRQWdCQ0FCUVFGcUlnRkhEUUFMSUFJZ0JUWUNBQXc2Q3lBQ0tBSUVJUUFnQWtJQU53TUFJQUlnQUNBR1FRRnFJZ0VRSnlJQVJRUkFRY1lCSVFNTUlRc2dBa0hWQVRZQ0hDQUNJQUUyQWhRZ0FpQUFOZ0lNUVFBaEF3dzVDMEhVQVNFRElBRWdCRVlOT0NBQ0tBSUFJZ0FnQkNBQmEyb2hCU0FCSUFCclFRRnFJUVlDUUFOQUlBRXRBQUFnQUVHQjBBQnFMUUFBUncwQ0lBQkJBVVlOQVNBQVFRRnFJUUFnQkNBQlFRRnFJZ0ZIRFFBTElBSWdCVFlDQUF3NUN5QUNRWUVFT3dFb0lBSW9BZ1FoQUNBQ1FnQTNBd0FnQWlBQUlBWkJBV29pQVJBbklnQU5Bd3dDQ3lBQ1FRQTJBZ0FMUVFBaEF5QUNRUUEyQWh3Z0FpQUJOZ0lVSUFKQjJCczJBaEFnQWtFSU5nSU1ERFlMUWJvQklRTU1IQXNnQWtIVEFUWUNIQ0FDSUFFMkFoUWdBaUFBTmdJTVFRQWhBd3cwQzBFQUlRQUNRQ0FDS0FJNElnTkZEUUFnQXlnQ09DSURSUTBBSUFJZ0F4RUFBQ0VBQ3lBQVJRMEFJQUJCRlVZTkFTQUNRUUEyQWh3Z0FpQUJOZ0lVSUFKQnpBNDJBaEFnQWtFZ05nSU1RUUFoQXd3ekMwSGtBQ0VEREJrTElBSkIrQUEyQWh3Z0FpQUJOZ0lVSUFKQnloZzJBaEFnQWtFVk5nSU1RUUFoQXd3eEMwSFNBU0VESUFRZ0FTSUFSZzB3SUFRZ0FXc2dBaWdDQUNJQmFpRUZJQUFnQVd0QkJHb2hCZ0pBQTBBZ0FDMEFBQ0FCUWZ6UEFHb3RBQUJIRFFFZ0FVRUVSZzBESUFGQkFXb2hBU0FFSUFCQkFXb2lBRWNOQUFzZ0FpQUZOZ0lBRERFTElBSkJBRFlDSENBQ0lBQTJBaFFnQWtHUU16WUNFQ0FDUVFnMkFnd2dBa0VBTmdJQVFRQWhBd3d3Q3lBQklBUkhCRUFnQWtFT05nSUlJQUlnQVRZQ0JFRzNBU0VEREJjTFFkRUJJUU1NTHdzZ0FrRUFOZ0lBSUFaQkFXb2hBUXRCdUFFaEF3d1VDeUFCSUFSR0JFQkIwQUVoQXd3dEN5QUJMUUFBUVRCcklnQkIvd0Z4UVFwSkJFQWdBaUFBT2dBcUlBRkJBV29oQVVHMkFTRUREQlFMSUFJb0FnUWhBQ0FDUVFBMkFnUWdBaUFBSUFFUUtDSUFSUTBVSUFKQnp3RTJBaHdnQWlBQk5nSVVJQUlnQURZQ0RFRUFJUU1NTEFzZ0FTQUVSZ1JBUWM0QklRTU1MQXNDUUNBQkxRQUFRUzVHQkVBZ0FVRUJhaUVCREFFTElBSW9BZ1FoQUNBQ1FRQTJBZ1FnQWlBQUlBRVFLQ0lBUlEwVklBSkJ6UUUyQWh3Z0FpQUJOZ0lVSUFJZ0FEWUNERUVBSVFNTUxBdEJ0UUVoQXd3U0N5QUVJQUVpQlVZRVFFSE1BU0VERENzTFFRQWhBRUVCSVFGQkFTRUdRUUFoQXdKQUFrQUNRQUpBQWtBQ2Z3SkFBa0FDUUFKQUFrQUNRQUpBSUFVdEFBQkJNR3NPQ2dvSkFBRUNBd1FGQmdnTEMwRUNEQVlMUVFNTUJRdEJCQXdFQzBFRkRBTUxRUVlNQWd0QkJ3d0JDMEVJQ3lFRFFRQWhBVUVBSVFZTUFndEJDU0VEUVFFaEFFRUFJUUZCQUNFR0RBRUxRUUFoQVVFQklRTUxJQUlnQXpvQUt5QUZRUUZxSVFNQ1FBSkFJQUl0QUMxQkVIRU5BQUpBQWtBQ1FDQUNMUUFxRGdNQkFBSUVDeUFHUlEwRERBSUxJQUFOQVF3Q0N5QUJSUTBCQ3lBQ0tBSUVJUUFnQWtFQU5nSUVJQUlnQUNBREVDZ2lBRVVFUUNBRElRRU1Bd3NnQWtISkFUWUNIQ0FDSUFNMkFoUWdBaUFBTmdJTVFRQWhBd3d0Q3lBQ0tBSUVJUUFnQWtFQU5nSUVJQUlnQUNBREVDZ2lBRVVFUUNBRElRRU1HQXNnQWtIS0FUWUNIQ0FDSUFNMkFoUWdBaUFBTmdJTVFRQWhBd3dzQ3lBQ0tBSUVJUUFnQWtFQU5nSUVJQUlnQUNBRkVDZ2lBRVVFUUNBRklRRU1GZ3NnQWtITEFUWUNIQ0FDSUFVMkFoUWdBaUFBTmdJTURDc0xRYlFCSVFNTUVRdEJBQ0VBQWtBZ0FpZ0NPQ0lEUlEwQUlBTW9BandpQTBVTkFDQUNJQU1SQUFBaEFBc0NRQ0FBQkVBZ0FFRVZSZzBCSUFKQkFEWUNIQ0FDSUFFMkFoUWdBa0dVRFRZQ0VDQUNRU0UyQWd4QkFDRUREQ3NMUWJJQklRTU1FUXNnQWtISUFUWUNIQ0FDSUFFMkFoUWdBa0hKRnpZQ0VDQUNRUlUyQWd4QkFDRUREQ2tMSUFKQkFEWUNBQ0FHUVFGcUlRRkI5UUFoQXd3UEN5QUNMUUFwUVFWR0JFQkI0d0FoQXd3UEMwSGlBQ0VEREE0TElBQWhBU0FDUVFBMkFnQUxJQUpCQURvQUxFRUpJUU1NREFzZ0FrRUFOZ0lBSUFkQkFXb2hBVUhBQUNFRERBc0xRUUVMT2dBc0lBSkJBRFlDQUNBR1FRRnFJUUVMUVNraEF3d0lDMEU0SVFNTUJ3c0NRQ0FCSUFSSEJFQURRQ0FCTFFBQVFZQSthaTBBQUNJQVFRRkhCRUFnQUVFQ1J3MERJQUZCQVdvaEFRd0ZDeUFFSUFGQkFXb2lBVWNOQUF0QlBpRUREQ0VMUVQ0aEF3d2dDd3NnQWtFQU9nQXNEQUVMUVFzaEF3d0VDMEU2SVFNTUF3c2dBVUVCYWlFQlFTMGhBd3dDQ3lBQ0lBRTZBQ3dnQWtFQU5nSUFJQVpCQVdvaEFVRU1JUU1NQVFzZ0FrRUFOZ0lBSUFaQkFXb2hBVUVLSVFNTUFBc0FDMEVBSVFNZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUWMwUU5nSVFJQUpCQ1RZQ0RBd1hDMEVBSVFNZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUWVrS05nSVFJQUpCQ1RZQ0RBd1dDMEVBSVFNZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUWJjUU5nSVFJQUpCQ1RZQ0RBd1ZDMEVBSVFNZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUVp3Uk5nSVFJQUpCQ1RZQ0RBd1VDMEVBSVFNZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUWMwUU5nSVFJQUpCQ1RZQ0RBd1RDMEVBSVFNZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUWVrS05nSVFJQUpCQ1RZQ0RBd1NDMEVBSVFNZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUWJjUU5nSVFJQUpCQ1RZQ0RBd1JDMEVBSVFNZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUVp3Uk5nSVFJQUpCQ1RZQ0RBd1FDMEVBSVFNZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUVpjVk5nSVFJQUpCRHpZQ0RBd1BDMEVBSVFNZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUVpjVk5nSVFJQUpCRHpZQ0RBd09DMEVBSVFNZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUWNBU05nSVFJQUpCQ3pZQ0RBd05DMEVBSVFNZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUVpVSk5nSVFJQUpCQ3pZQ0RBd01DMEVBSVFNZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUWVFUE5nSVFJQUpCQ2pZQ0RBd0xDMEVBSVFNZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUWZzUE5nSVFJQUpCQ2pZQ0RBd0tDMEVBSVFNZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUWZFWk5nSVFJQUpCQWpZQ0RBd0pDMEVBSVFNZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUWNRVU5nSVFJQUpCQWpZQ0RBd0lDMEVBSVFNZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUWZJVk5nSVFJQUpCQWpZQ0RBd0hDeUFDUVFJMkFod2dBaUFCTmdJVUlBSkJuQm8yQWhBZ0FrRVdOZ0lNUVFBaEF3d0dDMEVCSVFNTUJRdEIxQUFoQXlBQklBUkdEUVFnQ0VFSWFpRUpJQUlvQWdBaEJRSkFBa0FnQVNBRVJ3UkFJQVZCMk1JQWFpRUhJQVFnQldvZ0FXc2hBQ0FGUVg5elFRcHFJZ1VnQVdvaEJnTkFJQUV0QUFBZ0J5MEFBRWNFUUVFQ0lRY01Bd3NnQlVVRVFFRUFJUWNnQmlFQkRBTUxJQVZCQVdzaEJTQUhRUUZxSVFjZ0JDQUJRUUZxSWdGSERRQUxJQUFoQlNBRUlRRUxJQWxCQVRZQ0FDQUNJQVUyQWdBTUFRc2dBa0VBTmdJQUlBa2dCellDQUFzZ0NTQUJOZ0lFSUFnb0Fnd2hBQ0FJS0FJSURnTUJCQUlBQ3dBTElBSkJBRFlDSENBQ1FiVWFOZ0lRSUFKQkZ6WUNEQ0FDSUFCQkFXbzJBaFJCQUNFRERBSUxJQUpCQURZQ0hDQUNJQUEyQWhRZ0FrSEtHallDRUNBQ1FRazJBZ3hCQUNFRERBRUxJQUVnQkVZRVFFRWlJUU1NQVFzZ0FrRUpOZ0lJSUFJZ0FUWUNCRUVoSVFNTElBaEJFR29rQUNBRFJRUkFJQUlvQWd3aEFBd0JDeUFDSUFNMkFoeEJBQ0VBSUFJb0FnUWlBVVVOQUNBQ0lBRWdCQ0FDS0FJSUVRRUFJZ0ZGRFFBZ0FpQUVOZ0lVSUFJZ0FUWUNEQ0FCSVFBTElBQUx2Z0lCQW44Z0FFRUFPZ0FBSUFCQjNBQnFJZ0ZCQVd0QkFEb0FBQ0FBUVFBNkFBSWdBRUVBT2dBQklBRkJBMnRCQURvQUFDQUJRUUpyUVFBNkFBQWdBRUVBT2dBRElBRkJCR3RCQURvQUFFRUFJQUJyUVFOeElnRWdBR29pQUVFQU5nSUFRZHdBSUFGclFYeHhJZ0lnQUdvaUFVRUVhMEVBTmdJQUFrQWdBa0VKU1EwQUlBQkJBRFlDQ0NBQVFRQTJBZ1FnQVVFSWEwRUFOZ0lBSUFGQkRHdEJBRFlDQUNBQ1FSbEpEUUFnQUVFQU5nSVlJQUJCQURZQ0ZDQUFRUUEyQWhBZ0FFRUFOZ0lNSUFGQkVHdEJBRFlDQUNBQlFSUnJRUUEyQWdBZ0FVRVlhMEVBTmdJQUlBRkJIR3RCQURZQ0FDQUNJQUJCQkhGQkdISWlBbXNpQVVFZ1NRMEFJQUFnQW1vaEFBTkFJQUJDQURjREdDQUFRZ0EzQXhBZ0FFSUFOd01JSUFCQ0FEY0RBQ0FBUVNCcUlRQWdBVUVnYXlJQlFSOUxEUUFMQ3d0V0FRRi9Ba0FnQUNnQ0RBMEFBa0FDUUFKQUFrQWdBQzBBTHc0REFRQURBZ3NnQUNnQ09DSUJSUTBBSUFFb0Fpd2lBVVVOQUNBQUlBRVJBQUFpQVEwREMwRUFEd3NBQ3lBQVFjTVdOZ0lRUVE0aEFRc2dBUXNhQUNBQUtBSU1SUVJBSUFCQjBSczJBaEFnQUVFVk5nSU1Dd3NVQUNBQUtBSU1RUlZHQkVBZ0FFRUFOZ0lNQ3dzVUFDQUFLQUlNUVJaR0JFQWdBRUVBTmdJTUN3c0hBQ0FBS0FJTUN3Y0FJQUFvQWhBTENRQWdBQ0FCTmdJUUN3Y0FJQUFvQWhRTEZ3QWdBRUVrVHdSQUFBc2dBRUVDZEVHZ00yb29BZ0FMRndBZ0FFRXVUd1JBQUFzZ0FFRUNkRUd3Tkdvb0FnQUx2d2tCQVg5QjZ5Z2hBUUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBSUFCQjVBQnJEdlFEWTJJQUFXRmhZV0ZoWVFJREJBVmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoQmdjSUNRb0xEQTBPRDJGaFlXRmhFR0ZoWVdGaFlXRmhZV0ZoRVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVJJVEZCVVdGeGdaR2h0aFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaEhCMGVIeUFoSWlNa0pTWW5LQ2txS3l3dExpOHdNVEl6TkRVMllUYzRPVHBoWVdGaFlXRmhZVHRoWVdFOFlXRmhZVDArUDJGaFlXRmhZV0ZoUUdGaFFXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZVUpEUkVWR1IwaEpTa3RNVFU1UFVGRlNVMkZoWVdGaFlXRmhWRlZXVjFoWldsdGhYRjFoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGZVlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFgyQmhDMEhoSnc4TFFhUWhEd3RCeXl3UEMwSCtNUThMUWNBa0R3dEJxeVFQQzBHTktBOExRZUltRHd0QmdEQVBDMEc1THc4TFFkY2tEd3RCN3g4UEMwSGhIdzhMUWZvZkR3dEI4aUFQQzBHb0x3OExRYTR5RHd0QmlEQVBDMEhzSnc4TFFZSWlEd3RCamgwUEMwSFFMZzhMUWNvakR3dEJ4VElQQzBIZkhBOExRZEljRHd0QnhDQVBDMEhYSUE4TFFhSWZEd3RCN1M0UEMwR3JNQThMUWRRbER3dEJ6QzRQQzBINkxnOExRZndyRHd0QjBqQVBDMEh4SFE4TFFic2dEd3RCOXlzUEMwR1FNUThMUWRjeER3dEJvaTBQQzBIVUp3OExRZUFyRHd0Qm55d1BDMEhyTVE4TFFkVWZEd3RCeWpFUEMwSGVKUThMUWRRZUR3dEI5QndQQzBHbk1nOExRYkVkRHd0Qm9CMFBDMEc1TVE4TFFid3dEd3RCa2lFUEMwR3pKZzhMUWVrc0R3dEJyQjRQQzBIVUt3OExRZmNtRHd0QmdDWVBDMEd3SVE4TFFmNGVEd3RCalNNUEMwR0pMUThMUWZjaUR3dEJvREVQQzBHdUh3OExRY1lsRHd0QjZCNFBDMEdUSWc4TFFjSXZEd3RCd3gwUEMwR0xMQThMUWVFZER3dEJqUzhQQzBIcUlROExRYlF0RHd0QjBpOFBDMEhmTWc4TFFkSXlEd3RCOERBUEMwR3BJZzhMUWZrakR3dEJtUjRQQzBHMUxBOExRWnN3RHd0QmtqSVBDMEcyS3c4TFFjSWlEd3RCK0RJUEMwR2VKUThMUWRBaUR3dEJ1aDRQQzBHQkhnOExBQXRCMWlFaEFRc2dBUXNXQUNBQUlBQXRBQzFCL2dGeElBRkJBRWR5T2dBdEN4a0FJQUFnQUMwQUxVSDlBWEVnQVVFQVIwRUJkSEk2QUMwTEdRQWdBQ0FBTFFBdFFmc0JjU0FCUVFCSFFRSjBjam9BTFFzWkFDQUFJQUF0QUMxQjl3RnhJQUZCQUVkQkEzUnlPZ0F0Q3o0QkFuOENRQ0FBS0FJNElnTkZEUUFnQXlnQ0JDSURSUTBBSUFBZ0FTQUNJQUZySUFNUkFRQWlCRUYvUncwQUlBQkJ4aEUyQWhCQkdDRUVDeUFFQ3o0QkFuOENRQ0FBS0FJNElnTkZEUUFnQXlnQ0NDSURSUTBBSUFBZ0FTQUNJQUZySUFNUkFRQWlCRUYvUncwQUlBQkI5Z28yQWhCQkdDRUVDeUFFQ3o0QkFuOENRQ0FBS0FJNElnTkZEUUFnQXlnQ0RDSURSUTBBSUFBZ0FTQUNJQUZySUFNUkFRQWlCRUYvUncwQUlBQkI3Um8yQWhCQkdDRUVDeUFFQ3o0QkFuOENRQ0FBS0FJNElnTkZEUUFnQXlnQ0VDSURSUTBBSUFBZ0FTQUNJQUZySUFNUkFRQWlCRUYvUncwQUlBQkJsUkEyQWhCQkdDRUVDeUFFQ3o0QkFuOENRQ0FBS0FJNElnTkZEUUFnQXlnQ0ZDSURSUTBBSUFBZ0FTQUNJQUZySUFNUkFRQWlCRUYvUncwQUlBQkJxaHMyQWhCQkdDRUVDeUFFQ3o0QkFuOENRQ0FBS0FJNElnTkZEUUFnQXlnQ0dDSURSUTBBSUFBZ0FTQUNJQUZySUFNUkFRQWlCRUYvUncwQUlBQkI3Uk0yQWhCQkdDRUVDeUFFQ3o0QkFuOENRQ0FBS0FJNElnTkZEUUFnQXlnQ0tDSURSUTBBSUFBZ0FTQUNJQUZySUFNUkFRQWlCRUYvUncwQUlBQkI5Z2cyQWhCQkdDRUVDeUFFQ3o0QkFuOENRQ0FBS0FJNElnTkZEUUFnQXlnQ0hDSURSUTBBSUFBZ0FTQUNJQUZySUFNUkFRQWlCRUYvUncwQUlBQkJ3aGsyQWhCQkdDRUVDeUFFQ3o0QkFuOENRQ0FBS0FJNElnTkZEUUFnQXlnQ0lDSURSUTBBSUFBZ0FTQUNJQUZySUFNUkFRQWlCRUYvUncwQUlBQkJsQlEyQWhCQkdDRUVDeUFFQzFrQkFuOENRQ0FBTFFBb1FRRkdEUUFnQUM4Qk1pSUJRZVFBYTBIa0FFa05BQ0FCUWN3QlJnMEFJQUZCc0FKR0RRQWdBQzhCTUNJQVFjQUFjUTBBUVFFaEFpQUFRWWdFY1VHQUJFWU5BQ0FBUVNoeFJTRUNDeUFDQzR3QkFRSi9Ba0FDUUFKQUlBQXRBQ3BGRFFBZ0FDMEFLMFVOQUNBQUx3RXdJZ0ZCQW5GRkRRRU1BZ3NnQUM4Qk1DSUJRUUZ4UlEwQkMwRUJJUUlnQUMwQUtFRUJSZzBBSUFBdkFUSWlBRUhrQUd0QjVBQkpEUUFnQUVITUFVWU5BQ0FBUWJBQ1JnMEFJQUZCd0FCeERRQkJBQ0VDSUFGQmlBUnhRWUFFUmcwQUlBRkJLSEZCQUVjaEFnc2dBZ3R6QUNBQVFSQnEvUXdBQUFBQUFBQUFBQUFBQUFBQUFBQUEvUXNEQUNBQS9Rd0FBQUFBQUFBQUFBQUFBQUFBQUFBQS9Rc0RBQ0FBUVRCcS9Rd0FBQUFBQUFBQUFBQUFBQUFBQUFBQS9Rc0RBQ0FBUVNCcS9Rd0FBQUFBQUFBQUFBQUFBQUFBQUFBQS9Rc0RBQ0FBUWQwQk5nSWNDd1lBSUFBUU1ndWFMUUVMZnlNQVFSQnJJZ29rQUVHazBBQW9BZ0FpQ1VVRVFFSGswd0FvQWdBaUJVVUVRRUh3MHdCQ2Z6Y0NBRUhvMHdCQ2dJQ0VnSUNBd0FBM0FnQkI1Tk1BSUFwQkNHcEJjSEZCMktyVnFnVnpJZ1UyQWdCQitOTUFRUUEyQWdCQnlOTUFRUUEyQWdBTFFjelRBRUdBMUFRMkFnQkJuTkFBUVlEVUJEWUNBRUd3MEFBZ0JUWUNBRUdzMEFCQmZ6WUNBRUhRMHdCQmdLd0ROZ0lBQTBBZ0FVSEkwQUJxSUFGQnZOQUFhaUlDTmdJQUlBSWdBVUcwMEFCcUlnTTJBZ0FnQVVIQTBBQnFJQU0yQWdBZ0FVSFEwQUJxSUFGQnhOQUFhaUlETmdJQUlBTWdBallDQUNBQlFkalFBR29nQVVITTBBQnFJZ0kyQWdBZ0FpQUROZ0lBSUFGQjFOQUFhaUFDTmdJQUlBRkJJR29pQVVHQUFrY05BQXRCak5RRVFjR3JBellDQUVHbzBBQkI5Tk1BS0FJQU5nSUFRWmpRQUVIQXF3TTJBZ0JCcE5BQVFZalVCRFlDQUVITS93ZEJPRFlDQUVHSTFBUWhDUXNDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FDQUFRZXdCVFFSQVFZelFBQ2dDQUNJR1FSQWdBRUVUYWtGd2NTQUFRUXRKR3lJRVFRTjJJZ0IySWdGQkEzRUVRQUpBSUFGQkFYRWdBSEpCQVhNaUFrRURkQ0lBUWJUUUFHb2lBU0FBUWJ6UUFHb29BZ0FpQUNnQ0NDSURSZ1JBUVl6UUFDQUdRWDRnQW5keE5nSUFEQUVMSUFFZ0F6WUNDQ0FESUFFMkFnd0xJQUJCQ0dvaEFTQUFJQUpCQTNRaUFrRURjallDQkNBQUlBSnFJZ0FnQUNnQ0JFRUJjallDQkF3UkMwR1UwQUFvQWdBaUNDQUVUdzBCSUFFRVFBSkFRUUlnQUhRaUFrRUFJQUpyY2lBQklBQjBjV2dpQUVFRGRDSUNRYlRRQUdvaUFTQUNRYnpRQUdvb0FnQWlBaWdDQ0NJRFJnUkFRWXpRQUNBR1FYNGdBSGR4SWdZMkFnQU1BUXNnQVNBRE5nSUlJQU1nQVRZQ0RBc2dBaUFFUVFOeU5nSUVJQUJCQTNRaUFDQUVheUVGSUFBZ0Ftb2dCVFlDQUNBQ0lBUnFJZ1FnQlVFQmNqWUNCQ0FJQkVBZ0NFRjRjVUcwMEFCcUlRQkJvTkFBS0FJQUlRTUNmMEVCSUFoQkEzWjBJZ0VnQm5GRkJFQkJqTkFBSUFFZ0JuSTJBZ0FnQUF3QkN5QUFLQUlJQ3lJQklBTTJBZ3dnQUNBRE5nSUlJQU1nQURZQ0RDQURJQUUyQWdnTElBSkJDR29oQVVHZzBBQWdCRFlDQUVHVTBBQWdCVFlDQUF3UkMwR1EwQUFvQWdBaUMwVU5BU0FMYUVFQ2RFRzgwZ0JxS0FJQUlnQW9BZ1JCZUhFZ0JHc2hCU0FBSVFJRFFBSkFJQUlvQWhBaUFVVUVRQ0FDUVJScUtBSUFJZ0ZGRFFFTElBRW9BZ1JCZUhFZ0JHc2lBeUFGU1NFQ0lBTWdCU0FDR3lFRklBRWdBQ0FDR3lFQUlBRWhBZ3dCQ3dzZ0FDZ0NHQ0VKSUFBb0Fnd2lBeUFBUndSQVFaelFBQ2dDQUJvZ0F5QUFLQUlJSWdFMkFnZ2dBU0FETmdJTURCQUxJQUJCRkdvaUFpZ0NBQ0lCUlFSQUlBQW9BaEFpQVVVTkF5QUFRUkJxSVFJTEEwQWdBaUVISUFFaUEwRVVhaUlDS0FJQUlnRU5BQ0FEUVJCcUlRSWdBeWdDRUNJQkRRQUxJQWRCQURZQ0FBd1BDMEYvSVFRZ0FFRy9mMHNOQUNBQVFSTnFJZ0ZCY0hFaEJFR1EwQUFvQWdBaUNFVU5BRUVBSUFScklRVUNRQUpBQWtBQ2YwRUFJQVJCZ0FKSkRRQWFRUjhnQkVILy8vOEhTdzBBR2lBRVFTWWdBVUVJZG1jaUFHdDJRUUZ4SUFCQkFYUnJRVDVxQ3lJR1FRSjBRYnpTQUdvb0FnQWlBa1VFUUVFQUlRRkJBQ0VEREFFTFFRQWhBU0FFUVJrZ0JrRUJkbXRCQUNBR1FSOUhHM1FoQUVFQUlRTURRQUpBSUFJb0FnUkJlSEVnQkdzaUJ5QUZUdzBBSUFJaEF5QUhJZ1VOQUVFQUlRVWdBaUVCREFNTElBRWdBa0VVYWlnQ0FDSUhJQWNnQWlBQVFSMTJRUVJ4YWtFUWFpZ0NBQ0lDUmhzZ0FTQUhHeUVCSUFCQkFYUWhBQ0FDRFFBTEN5QUJJQU55UlFSQVFRQWhBMEVDSUFaMElnQkJBQ0FBYTNJZ0NIRWlBRVVOQXlBQWFFRUNkRUc4MGdCcUtBSUFJUUVMSUFGRkRRRUxBMEFnQVNnQ0JFRjRjU0FFYXlJQ0lBVkpJUUFnQWlBRklBQWJJUVVnQVNBRElBQWJJUU1nQVNnQ0VDSUFCSDhnQUFVZ0FVRVVhaWdDQUFzaUFRMEFDd3NnQTBVTkFDQUZRWlRRQUNnQ0FDQUVhMDhOQUNBREtBSVlJUWNnQXlBREtBSU1JZ0JIQkVCQm5OQUFLQUlBR2lBQUlBTW9BZ2dpQVRZQ0NDQUJJQUEyQWd3TURnc2dBMEVVYWlJQ0tBSUFJZ0ZGQkVBZ0F5Z0NFQ0lCUlEwRElBTkJFR29oQWdzRFFDQUNJUVlnQVNJQVFSUnFJZ0lvQWdBaUFRMEFJQUJCRUdvaEFpQUFLQUlRSWdFTkFBc2dCa0VBTmdJQURBMExRWlRRQUNnQ0FDSURJQVJQQkVCQm9OQUFLQUlBSVFFQ1FDQURJQVJySWdKQkVFOEVRQ0FCSUFScUlnQWdBa0VCY2pZQ0JDQUJJQU5xSUFJMkFnQWdBU0FFUVFOeU5nSUVEQUVMSUFFZ0EwRURjallDQkNBQklBTnFJZ0FnQUNnQ0JFRUJjallDQkVFQUlRQkJBQ0VDQzBHVTBBQWdBallDQUVHZzBBQWdBRFlDQUNBQlFRaHFJUUVNRHd0Qm1OQUFLQUlBSWdNZ0JFc0VRQ0FFSUFscUlnQWdBeUFFYXlJQlFRRnlOZ0lFUWFUUUFDQUFOZ0lBUVpqUUFDQUJOZ0lBSUFrZ0JFRURjallDQkNBSlFRaHFJUUVNRHd0QkFDRUJJQVFDZjBIazB3QW9BZ0FFUUVIczB3QW9BZ0FNQVF0QjhOTUFRbjgzQWdCQjZOTUFRb0NBaElDQWdNQUFOd0lBUWVUVEFDQUtRUXhxUVhCeFFkaXExYW9GY3pZQ0FFSDQwd0JCQURZQ0FFSEkwd0JCQURZQ0FFR0FnQVFMSWdBZ0JFSEhBR29pQldvaUJrRUFJQUJySWdkeElnSlBCRUJCL05NQVFUQTJBZ0FNRHdzQ1FFSEUwd0FvQWdBaUFVVU5BRUc4MHdBb0FnQWlDQ0FDYWlFQUlBQWdBVTBnQUNBSVMzRU5BRUVBSVFGQi9OTUFRVEEyQWdBTUR3dEJ5Tk1BTFFBQVFRUnhEUVFDUUFKQUlBa0VRRUhNMHdBaEFRTkFJQUVvQWdBaUFDQUpUUVJBSUFBZ0FTZ0NCR29nQ1VzTkF3c2dBU2dDQ0NJQkRRQUxDMEVBRURNaUFFRi9SZzBGSUFJaEJrSG8wd0FvQWdBaUFVRUJheUlESUFCeEJFQWdBaUFBYXlBQUlBTnFRUUFnQVd0eGFpRUdDeUFFSUFaUERRVWdCa0grLy8vL0Iwc05CVUhFMHdBb0FnQWlBd1JBUWJ6VEFDZ0NBQ0lISUFacUlRRWdBU0FIVFEwR0lBRWdBMHNOQmdzZ0JoQXpJZ0VnQUVjTkFRd0hDeUFHSUFOcklBZHhJZ1pCL3YvLy93ZExEUVFnQmhBeklRQWdBQ0FCS0FJQUlBRW9BZ1JxUmcwRElBQWhBUXNDUUNBR0lBUkJ5QUJxVHcwQUlBRkJmMFlOQUVIczB3QW9BZ0FpQUNBRklBWnJha0VBSUFCcmNTSUFRZjcvLy84SFN3UkFJQUVoQUF3SEN5QUFFRE5CZjBjRVFDQUFJQVpxSVFZZ0FTRUFEQWNMUVFBZ0Jtc1FNeG9NQkFzZ0FTSUFRWDlIRFFVTUF3dEJBQ0VEREF3TFFRQWhBQXdLQ3lBQVFYOUhEUUlMUWNqVEFFSEkwd0FvQWdCQkJISTJBZ0FMSUFKQi92Ly8vd2RMRFFFZ0FoQXpJUUJCQUJBeklRRWdBRUYvUmcwQklBRkJmMFlOQVNBQUlBRlBEUUVnQVNBQWF5SUdJQVJCT0dwTkRRRUxRYnpUQUVHODB3QW9BZ0FnQm1vaUFUWUNBRUhBMHdBb0FnQWdBVWtFUUVIQTB3QWdBVFlDQUFzQ1FBSkFBa0JCcE5BQUtBSUFJZ0lFUUVITTB3QWhBUU5BSUFBZ0FTZ0NBQ0lESUFFb0FnUWlCV3BHRFFJZ0FTZ0NDQ0lCRFFBTERBSUxRWnpRQUNnQ0FDSUJRUUJISUFBZ0FVOXhSUVJBUVp6UUFDQUFOZ0lBQzBFQUlRRkIwTk1BSUFZMkFnQkJ6Tk1BSUFBMkFnQkJyTkFBUVg4MkFnQkJzTkFBUWVUVEFDZ0NBRFlDQUVIWTB3QkJBRFlDQUFOQUlBRkJ5TkFBYWlBQlFielFBR29pQWpZQ0FDQUNJQUZCdE5BQWFpSUROZ0lBSUFGQndOQUFhaUFETmdJQUlBRkIwTkFBYWlBQlFjVFFBR29pQXpZQ0FDQURJQUkyQWdBZ0FVSFkwQUJxSUFGQnpOQUFhaUlDTmdJQUlBSWdBellDQUNBQlFkVFFBR29nQWpZQ0FDQUJRU0JxSWdGQmdBSkhEUUFMUVhnZ0FHdEJEM0VpQVNBQWFpSUNJQVpCT0dzaUF5QUJheUlCUVFGeU5nSUVRYWpRQUVIMDB3QW9BZ0EyQWdCQm1OQUFJQUUyQWdCQnBOQUFJQUkyQWdBZ0FDQURha0U0TmdJRURBSUxJQUFnQWswTkFDQUNJQU5KRFFBZ0FTZ0NERUVJY1EwQVFYZ2dBbXRCRDNFaUFDQUNhaUlEUVpqUUFDZ0NBQ0FHYWlJSElBQnJJZ0JCQVhJMkFnUWdBU0FGSUFacU5nSUVRYWpRQUVIMDB3QW9BZ0EyQWdCQm1OQUFJQUEyQWdCQnBOQUFJQU0yQWdBZ0FpQUhha0U0TmdJRURBRUxJQUJCbk5BQUtBSUFTUVJBUVp6UUFDQUFOZ0lBQ3lBQUlBWnFJUU5Cek5NQUlRRUNRQUpBQWtBRFFDQURJQUVvQWdCSEJFQWdBU2dDQ0NJQkRRRU1BZ3NMSUFFdEFBeEJDSEZGRFFFTFFjelRBQ0VCQTBBZ0FTZ0NBQ0lESUFKTkJFQWdBeUFCS0FJRWFpSUZJQUpMRFFNTElBRW9BZ2doQVF3QUN3QUxJQUVnQURZQ0FDQUJJQUVvQWdRZ0JtbzJBZ1FnQUVGNElBQnJRUTl4YWlJSklBUkJBM0kyQWdRZ0EwRjRJQU5yUVE5eGFpSUdJQVFnQ1dvaUJHc2hBU0FDSUFaR0JFQkJwTkFBSUFRMkFnQkJtTkFBUVpqUUFDZ0NBQ0FCYWlJQU5nSUFJQVFnQUVFQmNqWUNCQXdJQzBHZzBBQW9BZ0FnQmtZRVFFR2cwQUFnQkRZQ0FFR1UwQUJCbE5BQUtBSUFJQUZxSWdBMkFnQWdCQ0FBUVFGeU5nSUVJQUFnQkdvZ0FEWUNBQXdJQ3lBR0tBSUVJZ1ZCQTNGQkFVY05CaUFGUVhoeElRZ2dCVUgvQVUwRVFDQUZRUU4ySVFNZ0JpZ0NDQ0lBSUFZb0Fnd2lBa1lFUUVHTTBBQkJqTkFBS0FJQVFYNGdBM2R4TmdJQURBY0xJQUlnQURZQ0NDQUFJQUkyQWd3TUJnc2dCaWdDR0NFSElBWWdCaWdDRENJQVJ3UkFJQUFnQmlnQ0NDSUNOZ0lJSUFJZ0FEWUNEQXdGQ3lBR1FSUnFJZ0lvQWdBaUJVVUVRQ0FHS0FJUUlnVkZEUVFnQmtFUWFpRUNDd05BSUFJaEF5QUZJZ0JCRkdvaUFpZ0NBQ0lGRFFBZ0FFRVFhaUVDSUFBb0FoQWlCUTBBQ3lBRFFRQTJBZ0FNQkF0QmVDQUFhMEVQY1NJQklBQnFJZ2NnQmtFNGF5SURJQUZySWdGQkFYSTJBZ1FnQUNBRGFrRTROZ0lFSUFJZ0JVRTNJQVZyUVE5eGFrRS9heUlESUFNZ0FrRVFha2tiSWdOQkl6WUNCRUdvMEFCQjlOTUFLQUlBTmdJQVFaalFBQ0FCTmdJQVFhVFFBQ0FITmdJQUlBTkJFR3BCMU5NQUtRSUFOd0lBSUFOQnpOTUFLUUlBTndJSVFkVFRBQ0FEUVFocU5nSUFRZERUQUNBR05nSUFRY3pUQUNBQU5nSUFRZGpUQUVFQU5nSUFJQU5CSkdvaEFRTkFJQUZCQnpZQ0FDQUZJQUZCQkdvaUFVc05BQXNnQWlBRFJnMEFJQU1nQXlnQ0JFRitjVFlDQkNBRElBTWdBbXNpQlRZQ0FDQUNJQVZCQVhJMkFnUWdCVUgvQVUwRVFDQUZRWGh4UWJUUUFHb2hBQUovUVl6UUFDZ0NBQ0lCUVFFZ0JVRURkblFpQTNGRkJFQkJqTkFBSUFFZ0EzSTJBZ0FnQUF3QkN5QUFLQUlJQ3lJQklBSTJBZ3dnQUNBQ05nSUlJQUlnQURZQ0RDQUNJQUUyQWdnTUFRdEJIeUVCSUFWQi8vLy9CMDBFUUNBRlFTWWdCVUVJZG1jaUFHdDJRUUZ4SUFCQkFYUnJRVDVxSVFFTElBSWdBVFlDSENBQ1FnQTNBaEFnQVVFQ2RFRzgwZ0JxSVFCQmtOQUFLQUlBSWdOQkFTQUJkQ0lHY1VVRVFDQUFJQUkyQWdCQmtOQUFJQU1nQm5JMkFnQWdBaUFBTmdJWUlBSWdBallDQ0NBQ0lBSTJBZ3dNQVFzZ0JVRVpJQUZCQVhaclFRQWdBVUVmUnh0MElRRWdBQ2dDQUNFREFrQURRQ0FESWdBb0FnUkJlSEVnQlVZTkFTQUJRUjEySVFNZ0FVRUJkQ0VCSUFBZ0EwRUVjV3BCRUdvaUJpZ0NBQ0lERFFBTElBWWdBallDQUNBQ0lBQTJBaGdnQWlBQ05nSU1JQUlnQWpZQ0NBd0JDeUFBS0FJSUlnRWdBallDRENBQUlBSTJBZ2dnQWtFQU5nSVlJQUlnQURZQ0RDQUNJQUUyQWdnTFFaalFBQ2dDQUNJQklBUk5EUUJCcE5BQUtBSUFJZ0FnQkdvaUFpQUJJQVJySWdGQkFYSTJBZ1JCbU5BQUlBRTJBZ0JCcE5BQUlBSTJBZ0FnQUNBRVFRTnlOZ0lFSUFCQkNHb2hBUXdJQzBFQUlRRkIvTk1BUVRBMkFnQU1Cd3RCQUNFQUN5QUhSUTBBQWtBZ0JpZ0NIQ0lDUVFKMFFielNBR29pQXlnQ0FDQUdSZ1JBSUFNZ0FEWUNBQ0FBRFFGQmtOQUFRWkRRQUNnQ0FFRitJQUozY1RZQ0FBd0NDeUFIUVJCQkZDQUhLQUlRSUFaR0cyb2dBRFlDQUNBQVJRMEJDeUFBSUFjMkFoZ2dCaWdDRUNJQ0JFQWdBQ0FDTmdJUUlBSWdBRFlDR0FzZ0JrRVVhaWdDQUNJQ1JRMEFJQUJCRkdvZ0FqWUNBQ0FDSUFBMkFoZ0xJQUVnQ0dvaEFTQUdJQWhxSWdZb0FnUWhCUXNnQmlBRlFYNXhOZ0lFSUFFZ0JHb2dBVFlDQUNBRUlBRkJBWEkyQWdRZ0FVSC9BVTBFUUNBQlFYaHhRYlRRQUdvaEFBSi9RWXpRQUNnQ0FDSUNRUUVnQVVFRGRuUWlBWEZGQkVCQmpOQUFJQUVnQW5JMkFnQWdBQXdCQ3lBQUtBSUlDeUlCSUFRMkFnd2dBQ0FFTmdJSUlBUWdBRFlDRENBRUlBRTJBZ2dNQVF0Qkh5RUZJQUZCLy8vL0IwMEVRQ0FCUVNZZ0FVRUlkbWNpQUd0MlFRRnhJQUJCQVhSclFUNXFJUVVMSUFRZ0JUWUNIQ0FFUWdBM0FoQWdCVUVDZEVHODBnQnFJUUJCa05BQUtBSUFJZ0pCQVNBRmRDSURjVVVFUUNBQUlBUTJBZ0JCa05BQUlBSWdBM0kyQWdBZ0JDQUFOZ0lZSUFRZ0JEWUNDQ0FFSUFRMkFnd01BUXNnQVVFWklBVkJBWFpyUVFBZ0JVRWZSeHQwSVFVZ0FDZ0NBQ0VBQWtBRFFDQUFJZ0lvQWdSQmVIRWdBVVlOQVNBRlFSMTJJUUFnQlVFQmRDRUZJQUlnQUVFRWNXcEJFR29pQXlnQ0FDSUFEUUFMSUFNZ0JEWUNBQ0FFSUFJMkFoZ2dCQ0FFTmdJTUlBUWdCRFlDQ0F3QkN5QUNLQUlJSWdBZ0JEWUNEQ0FDSUFRMkFnZ2dCRUVBTmdJWUlBUWdBallDRENBRUlBQTJBZ2dMSUFsQkNHb2hBUXdDQ3dKQUlBZEZEUUFDUUNBREtBSWNJZ0ZCQW5SQnZOSUFhaUlDS0FJQUlBTkdCRUFnQWlBQU5nSUFJQUFOQVVHUTBBQWdDRUYrSUFGM2NTSUlOZ0lBREFJTElBZEJFRUVVSUFjb0FoQWdBMFliYWlBQU5nSUFJQUJGRFFFTElBQWdCellDR0NBREtBSVFJZ0VFUUNBQUlBRTJBaEFnQVNBQU5nSVlDeUFEUVJScUtBSUFJZ0ZGRFFBZ0FFRVVhaUFCTmdJQUlBRWdBRFlDR0FzQ1FDQUZRUTlOQkVBZ0F5QUVJQVZxSWdCQkEzSTJBZ1FnQUNBRGFpSUFJQUFvQWdSQkFYSTJBZ1FNQVFzZ0F5QUVhaUlDSUFWQkFYSTJBZ1FnQXlBRVFRTnlOZ0lFSUFJZ0JXb2dCVFlDQUNBRlFmOEJUUVJBSUFWQmVIRkJ0TkFBYWlFQUFuOUJqTkFBS0FJQUlnRkJBU0FGUVFOMmRDSUZjVVVFUUVHTTBBQWdBU0FGY2pZQ0FDQUFEQUVMSUFBb0FnZ0xJZ0VnQWpZQ0RDQUFJQUkyQWdnZ0FpQUFOZ0lNSUFJZ0FUWUNDQXdCQzBFZklRRWdCVUgvLy84SFRRUkFJQVZCSmlBRlFRaDJaeUlBYTNaQkFYRWdBRUVCZEd0QlBtb2hBUXNnQWlBQk5nSWNJQUpDQURjQ0VDQUJRUUowUWJ6U0FHb2hBRUVCSUFGMElnUWdDSEZGQkVBZ0FDQUNOZ0lBUVpEUUFDQUVJQWh5TmdJQUlBSWdBRFlDR0NBQ0lBSTJBZ2dnQWlBQ05nSU1EQUVMSUFWQkdTQUJRUUYyYTBFQUlBRkJIMGNiZENFQklBQW9BZ0FoQkFKQUEwQWdCQ0lBS0FJRVFYaHhJQVZHRFFFZ0FVRWRkaUVFSUFGQkFYUWhBU0FBSUFSQkJIRnFRUkJxSWdZb0FnQWlCQTBBQ3lBR0lBSTJBZ0FnQWlBQU5nSVlJQUlnQWpZQ0RDQUNJQUkyQWdnTUFRc2dBQ2dDQ0NJQklBSTJBZ3dnQUNBQ05nSUlJQUpCQURZQ0dDQUNJQUEyQWd3Z0FpQUJOZ0lJQ3lBRFFRaHFJUUVNQVFzQ1FDQUpSUTBBQWtBZ0FDZ0NIQ0lCUVFKMFFielNBR29pQWlnQ0FDQUFSZ1JBSUFJZ0F6WUNBQ0FERFFGQmtOQUFJQXRCZmlBQmQzRTJBZ0FNQWdzZ0NVRVFRUlFnQ1NnQ0VDQUFSaHRxSUFNMkFnQWdBMFVOQVFzZ0F5QUpOZ0lZSUFBb0FoQWlBUVJBSUFNZ0FUWUNFQ0FCSUFNMkFoZ0xJQUJCRkdvb0FnQWlBVVVOQUNBRFFSUnFJQUUyQWdBZ0FTQUROZ0lZQ3dKQUlBVkJEMDBFUUNBQUlBUWdCV29pQVVFRGNqWUNCQ0FBSUFGcUlnRWdBU2dDQkVFQmNqWUNCQXdCQ3lBQUlBUnFJZ2NnQlVFQmNqWUNCQ0FBSUFSQkEzSTJBZ1FnQlNBSGFpQUZOZ0lBSUFnRVFDQUlRWGh4UWJUUUFHb2hBVUdnMEFBb0FnQWhBd0ovUVFFZ0NFRURkblFpQWlBR2NVVUVRRUdNMEFBZ0FpQUdjallDQUNBQkRBRUxJQUVvQWdnTElnSWdBellDRENBQklBTTJBZ2dnQXlBQk5nSU1JQU1nQWpZQ0NBdEJvTkFBSUFjMkFnQkJsTkFBSUFVMkFnQUxJQUJCQ0dvaEFRc2dDa0VRYWlRQUlBRUxRd0FnQUVVRVFEOEFRUkIwRHdzQ1FDQUFRZi8vQTNFTkFDQUFRUUJJRFFBZ0FFRVFka0FBSWdCQmYwWUVRRUg4MHdCQk1EWUNBRUYvRHdzZ0FFRVFkQThMQUFzTDNEOGlBRUdBQ0FzSkFRQUFBQUlBQUFBREFFR1VDQXNGQkFBQUFBVUFRYVFJQ3drR0FBQUFCd0FBQUFnQVFkd0lDNG90U1c1MllXeHBaQ0JqYUdGeUlHbHVJSFZ5YkNCeGRXVnllUUJUY0dGdUlHTmhiR3hpWVdOcklHVnljbTl5SUdsdUlHOXVYMkp2WkhrQVEyOXVkR1Z1ZEMxTVpXNW5kR2dnYjNabGNtWnNiM2NBUTJoMWJtc2djMmw2WlNCdmRtVnlabXh2ZHdCU1pYTndiMjV6WlNCdmRtVnlabXh2ZHdCSmJuWmhiR2xrSUcxbGRHaHZaQ0JtYjNJZ1NGUlVVQzk0TG5nZ2NtVnhkV1Z6ZEFCSmJuWmhiR2xrSUcxbGRHaHZaQ0JtYjNJZ1VsUlRVQzk0TG5nZ2NtVnhkV1Z6ZEFCRmVIQmxZM1JsWkNCVFQxVlNRMFVnYldWMGFHOWtJR1p2Y2lCSlEwVXZlQzU0SUhKbGNYVmxjM1FBU1c1MllXeHBaQ0JqYUdGeUlHbHVJSFZ5YkNCbWNtRm5iV1Z1ZENCemRHRnlkQUJGZUhCbFkzUmxaQ0JrYjNRQVUzQmhiaUJqWVd4c1ltRmpheUJsY25KdmNpQnBiaUJ2Ymw5emRHRjBkWE1BU1c1MllXeHBaQ0J5WlhOd2IyNXpaU0J6ZEdGMGRYTUFTVzUyWVd4cFpDQmphR0Z5WVdOMFpYSWdhVzRnWTJoMWJtc2daWGgwWlc1emFXOXVjd0JWYzJWeUlHTmhiR3hpWVdOcklHVnljbTl5QUdCdmJsOXlaWE5sZEdBZ1kyRnNiR0poWTJzZ1pYSnliM0lBWUc5dVgyTm9kVzVyWDJobFlXUmxjbUFnWTJGc2JHSmhZMnNnWlhKeWIzSUFZRzl1WDIxbGMzTmhaMlZmWW1WbmFXNWdJR05oYkd4aVlXTnJJR1Z5Y205eUFHQnZibDlqYUhWdWExOWxlSFJsYm5OcGIyNWZkbUZzZFdWZ0lHTmhiR3hpWVdOcklHVnljbTl5QUdCdmJsOXpkR0YwZFhOZlkyOXRjR3hsZEdWZ0lHTmhiR3hpWVdOcklHVnljbTl5QUdCdmJsOTJaWEp6YVc5dVgyTnZiWEJzWlhSbFlDQmpZV3hzWW1GamF5Qmxjbkp2Y2dCZ2IyNWZkWEpzWDJOdmJYQnNaWFJsWUNCallXeHNZbUZqYXlCbGNuSnZjZ0JnYjI1ZlkyaDFibXRmWTI5dGNHeGxkR1ZnSUdOaGJHeGlZV05ySUdWeWNtOXlBR0J2Ymw5b1pXRmtaWEpmZG1Gc2RXVmZZMjl0Y0d4bGRHVmdJR05oYkd4aVlXTnJJR1Z5Y205eUFHQnZibDl0WlhOellXZGxYMk52YlhCc1pYUmxZQ0JqWVd4c1ltRmpheUJsY25KdmNnQmdiMjVmYldWMGFHOWtYMk52YlhCc1pYUmxZQ0JqWVd4c1ltRmpheUJsY25KdmNnQmdiMjVmYUdWaFpHVnlYMlpwWld4a1gyTnZiWEJzWlhSbFlDQmpZV3hzWW1GamF5Qmxjbkp2Y2dCZ2IyNWZZMmgxYm10ZlpYaDBaVzV6YVc5dVgyNWhiV1ZnSUdOaGJHeGlZV05ySUdWeWNtOXlBRlZ1Wlhod1pXTjBaV1FnWTJoaGNpQnBiaUIxY213Z2MyVnlkbVZ5QUVsdWRtRnNhV1FnYUdWaFpHVnlJSFpoYkhWbElHTm9ZWElBU1c1MllXeHBaQ0JvWldGa1pYSWdabWxsYkdRZ1kyaGhjZ0JUY0dGdUlHTmhiR3hpWVdOcklHVnljbTl5SUdsdUlHOXVYM1psY25OcGIyNEFTVzUyWVd4cFpDQnRhVzV2Y2lCMlpYSnphVzl1QUVsdWRtRnNhV1FnYldGcWIzSWdkbVZ5YzJsdmJnQkZlSEJsWTNSbFpDQnpjR0ZqWlNCaFpuUmxjaUIyWlhKemFXOXVBRVY0Y0dWamRHVmtJRU5TVEVZZ1lXWjBaWElnZG1WeWMybHZiZ0JKYm5aaGJHbGtJRWhVVkZBZ2RtVnljMmx2YmdCSmJuWmhiR2xrSUdobFlXUmxjaUIwYjJ0bGJnQlRjR0Z1SUdOaGJHeGlZV05ySUdWeWNtOXlJR2x1SUc5dVgzVnliQUJKYm5aaGJHbGtJR05vWVhKaFkzUmxjbk1nYVc0Z2RYSnNBRlZ1Wlhod1pXTjBaV1FnYzNSaGNuUWdZMmhoY2lCcGJpQjFjbXdBUkc5MVlteGxJRUFnYVc0Z2RYSnNBRVZ0Y0hSNUlFTnZiblJsYm5RdFRHVnVaM1JvQUVsdWRtRnNhV1FnWTJoaGNtRmpkR1Z5SUdsdUlFTnZiblJsYm5RdFRHVnVaM1JvQUVSMWNHeHBZMkYwWlNCRGIyNTBaVzUwTFV4bGJtZDBhQUJKYm5aaGJHbGtJR05vWVhJZ2FXNGdkWEpzSUhCaGRHZ0FRMjl1ZEdWdWRDMU1aVzVuZEdnZ1kyRnVKM1FnWW1VZ2NISmxjMlZ1ZENCM2FYUm9JRlJ5WVc1elptVnlMVVZ1WTI5a2FXNW5BRWx1ZG1Gc2FXUWdZMmhoY21GamRHVnlJR2x1SUdOb2RXNXJJSE5wZW1VQVUzQmhiaUJqWVd4c1ltRmpheUJsY25KdmNpQnBiaUJ2Ymw5b1pXRmtaWEpmZG1Gc2RXVUFVM0JoYmlCallXeHNZbUZqYXlCbGNuSnZjaUJwYmlCdmJsOWphSFZ1YTE5bGVIUmxibk5wYjI1ZmRtRnNkV1VBU1c1MllXeHBaQ0JqYUdGeVlXTjBaWElnYVc0Z1kyaDFibXNnWlhoMFpXNXphVzl1Y3lCMllXeDFaUUJOYVhOemFXNW5JR1Y0Y0dWamRHVmtJRXhHSUdGbWRHVnlJR2hsWVdSbGNpQjJZV3gxWlFCSmJuWmhiR2xrSUdCVWNtRnVjMlpsY2kxRmJtTnZaR2x1WjJBZ2FHVmhaR1Z5SUhaaGJIVmxBRWx1ZG1Gc2FXUWdZMmhoY21GamRHVnlJR2x1SUdOb2RXNXJJR1Y0ZEdWdWMybHZibk1nY1hWdmRHVWdkbUZzZFdVQVNXNTJZV3hwWkNCamFHRnlZV04wWlhJZ2FXNGdZMmgxYm1zZ1pYaDBaVzV6YVc5dWN5QnhkVzkwWldRZ2RtRnNkV1VBVUdGMWMyVmtJR0o1SUc5dVgyaGxZV1JsY25OZlkyOXRjR3hsZEdVQVNXNTJZV3hwWkNCRlQwWWdjM1JoZEdVQWIyNWZjbVZ6WlhRZ2NHRjFjMlVBYjI1ZlkyaDFibXRmYUdWaFpHVnlJSEJoZFhObEFHOXVYMjFsYzNOaFoyVmZZbVZuYVc0Z2NHRjFjMlVBYjI1ZlkyaDFibXRmWlhoMFpXNXphVzl1WDNaaGJIVmxJSEJoZFhObEFHOXVYM04wWVhSMWMxOWpiMjF3YkdWMFpTQndZWFZ6WlFCdmJsOTJaWEp6YVc5dVgyTnZiWEJzWlhSbElIQmhkWE5sQUc5dVgzVnliRjlqYjIxd2JHVjBaU0J3WVhWelpRQnZibDlqYUhWdWExOWpiMjF3YkdWMFpTQndZWFZ6WlFCdmJsOW9aV0ZrWlhKZmRtRnNkV1ZmWTI5dGNHeGxkR1VnY0dGMWMyVUFiMjVmYldWemMyRm5aVjlqYjIxd2JHVjBaU0J3WVhWelpRQnZibDl0WlhSb2IyUmZZMjl0Y0d4bGRHVWdjR0YxYzJVQWIyNWZhR1ZoWkdWeVgyWnBaV3hrWDJOdmJYQnNaWFJsSUhCaGRYTmxBRzl1WDJOb2RXNXJYMlY0ZEdWdWMybHZibDl1WVcxbElIQmhkWE5sQUZWdVpYaHdaV04wWldRZ2MzQmhZMlVnWVdaMFpYSWdjM1JoY25RZ2JHbHVaUUJUY0dGdUlHTmhiR3hpWVdOcklHVnljbTl5SUdsdUlHOXVYMk5vZFc1clgyVjRkR1Z1YzJsdmJsOXVZVzFsQUVsdWRtRnNhV1FnWTJoaGNtRmpkR1Z5SUdsdUlHTm9kVzVySUdWNGRHVnVjMmx2Ym5NZ2JtRnRaUUJRWVhWelpTQnZiaUJEVDA1T1JVTlVMMVZ3WjNKaFpHVUFVR0YxYzJVZ2IyNGdVRkpKTDFWd1ozSmhaR1VBUlhod1pXTjBaV1FnU0ZSVVVDOHlJRU52Ym01bFkzUnBiMjRnVUhKbFptRmpaUUJUY0dGdUlHTmhiR3hpWVdOcklHVnljbTl5SUdsdUlHOXVYMjFsZEdodlpBQkZlSEJsWTNSbFpDQnpjR0ZqWlNCaFpuUmxjaUJ0WlhSb2IyUUFVM0JoYmlCallXeHNZbUZqYXlCbGNuSnZjaUJwYmlCdmJsOW9aV0ZrWlhKZlptbGxiR1FBVUdGMWMyVmtBRWx1ZG1Gc2FXUWdkMjl5WkNCbGJtTnZkVzUwWlhKbFpBQkpiblpoYkdsa0lHMWxkR2h2WkNCbGJtTnZkVzUwWlhKbFpBQlZibVY0Y0dWamRHVmtJR05vWVhJZ2FXNGdkWEpzSUhOamFHVnRZUUJTWlhGMVpYTjBJR2hoY3lCcGJuWmhiR2xrSUdCVWNtRnVjMlpsY2kxRmJtTnZaR2x1WjJBQVUxZEpWRU5JWDFCU1QxaFpBRlZUUlY5UVVrOVlXUUJOUzBGRFZFbFdTVlJaQUZWT1VGSlBRMFZUVTBGQ1RFVmZSVTVVU1ZSWkFFTlBVRmtBVFU5V1JVUmZVRVZTVFVGT1JVNVVURmtBVkU5UFgwVkJVa3haQUU1UFZFbEdXUUJHUVVsTVJVUmZSRVZRUlU1RVJVNURXUUJDUVVSZlIwRlVSVmRCV1FCUVRFRlpBRkJWVkFCRFNFVkRTMDlWVkFCSFFWUkZWMEZaWDFSSlRVVlBWVlFBVWtWUlZVVlRWRjlVU1UxRlQxVlVBRTVGVkZkUFVrdGZRMDlPVGtWRFZGOVVTVTFGVDFWVUFFTlBUazVGUTFSSlQwNWZWRWxOUlU5VlZBQk1UMGRKVGw5VVNVMUZUMVZVQUU1RlZGZFBVa3RmVWtWQlJGOVVTVTFGVDFWVUFGQlBVMVFBVFVsVFJFbFNSVU5VUlVSZlVrVlJWVVZUVkFCRFRFbEZUbFJmUTB4UFUwVkVYMUpGVVZWRlUxUUFRMHhKUlU1VVgwTk1UMU5GUkY5TVQwRkVYMEpCVEVGT1EwVkVYMUpGVVZWRlUxUUFRa0ZFWDFKRlVWVkZVMVFBU0ZSVVVGOVNSVkZWUlZOVVgxTkZUbFJmVkU5ZlNGUlVVRk5mVUU5U1ZBQlNSVkJQVWxRQVNVMWZRVjlVUlVGUVQxUUFVa1ZUUlZSZlEwOU9WRVZPVkFCT1QxOURUMDVVUlU1VUFGQkJVbFJKUVV4ZlEwOU9WRVZPVkFCSVVFVmZTVTVXUVV4SlJGOURUMDVUVkVGT1ZBQklVRVZmUTBKZlVrVlRSVlFBUjBWVUFFaFFSVjlUVkZKSlExUUFRMDlPUmt4SlExUUFWRVZOVUU5U1FWSlpYMUpGUkVsU1JVTlVBRkJGVWsxQlRrVk9WRjlTUlVSSlVrVkRWQUJEVDA1T1JVTlVBRTFWVEZSSlgxTlVRVlJWVXdCSVVFVmZTVTVXUVV4SlJGOVRWRUZVVlZNQVZFOVBYMDFCVGxsZlVrVlJWVVZUVkZNQVJVRlNURmxmU0VsT1ZGTUFWVTVCVmtGSlRFRkNURVZmUms5U1gweEZSMEZNWDFKRlFWTlBUbE1BVDFCVVNVOU9Vd0JUVjBsVVEwaEpUa2RmVUZKUFZFOURUMHhUQUZaQlVrbEJUbFJmUVV4VFQxOU9SVWRQVkVsQlZFVlRBRTFWVEZSSlVFeEZYME5JVDBsRFJWTUFTVTVVUlZKT1FVeGZVMFZTVmtWU1gwVlNVazlTQUZkRlFsOVRSVkpXUlZKZlZVNUxUazlYVGw5RlVsSlBVZ0JTUVVsTVIxVk9YMFZTVWs5U0FFbEVSVTVVU1ZSWlgxQlNUMVpKUkVWU1gwRlZWRWhGVGxSSlEwRlVTVTlPWDBWU1VrOVNBRk5UVEY5RFJWSlVTVVpKUTBGVVJWOUZVbEpQVWdCSlRsWkJURWxFWDFoZlJrOVNWMEZTUkVWRVgwWlBVZ0JUUlZSZlVFRlNRVTFGVkVWU0FFZEZWRjlRUVZKQlRVVlVSVklBU0ZCRlgxVlRSVklBVTBWRlgwOVVTRVZTQUVoUVJWOURRbDlEU0ZWT1MxOUlSVUZFUlZJQVRVdERRVXhGVGtSQlVnQlRSVlJWVUFCWFJVSmZVMFZTVmtWU1gwbFRYMFJQVjA0QVZFVkJVa1JQVjA0QVNGQkZYME5NVDFORlJGOURUMDVPUlVOVVNVOU9BRWhGVlZKSlUxUkpRMTlGV0ZCSlVrRlVTVTlPQUVSSlUwTlBUazVGUTFSRlJGOVBVRVZTUVZSSlQwNEFUazlPWDBGVlZFaFBVa2xVUVZSSlZrVmZTVTVHVDFKTlFWUkpUMDRBU0ZCRlgwbE9Wa0ZNU1VSZlZrVlNVMGxQVGdCSVVFVmZRMEpmVFVWVFUwRkhSVjlDUlVkSlRnQlRTVlJGWDBsVFgwWlNUMXBGVGdCSVVFVmZTVTVXUVV4SlJGOUlSVUZFUlZKZlZFOUxSVTRBU1U1V1FVeEpSRjlVVDB0RlRnQkdUMUpDU1VSRVJVNEFSVTVJUVU1RFJWOVpUMVZTWDBOQlRFMEFTRkJGWDBsT1ZrRk1TVVJmVlZKTUFFSk1UME5MUlVSZlFsbGZVRUZTUlU1VVFVeGZRMDlPVkZKUFRBQk5TME5QVEFCQlEwd0FTRkJGWDBsT1ZFVlNUa0ZNQUZKRlVWVkZVMVJmU0VWQlJFVlNYMFpKUlV4RVUxOVVUMDlmVEVGU1IwVmZWVTVQUmtaSlEwbEJUQUJJVUVWZlQwc0FWVTVNU1U1TEFGVk9URTlEU3dCUVVra0FVa1ZVVWxsZlYwbFVTQUJJVUVWZlNVNVdRVXhKUkY5RFQwNVVSVTVVWDB4RlRrZFVTQUJJVUVWZlZVNUZXRkJGUTFSRlJGOURUMDVVUlU1VVgweEZUa2RVU0FCR1RGVlRTQUJRVWs5UVVFRlVRMGdBVFMxVFJVRlNRMGdBVlZKSlgxUlBUMTlNVDA1SEFGQlNUME5GVTFOSlRrY0FUVWxUUTBWTVRFRk9SVTlWVTE5UVJWSlRTVk5VUlU1VVgxZEJVazVKVGtjQVRVbFRRMFZNVEVGT1JVOVZVMTlYUVZKT1NVNUhBRWhRUlY5SlRsWkJURWxFWDFSU1FVNVRSa1ZTWDBWT1EwOUVTVTVIQUVWNGNHVmpkR1ZrSUVOU1RFWUFTRkJGWDBsT1ZrRk1TVVJmUTBoVlRrdGZVMGxhUlFCTlQxWkZBRU5QVGxSSlRsVkZBRWhRUlY5RFFsOVRWRUZVVlZOZlEwOU5VRXhGVkVVQVNGQkZYME5DWDBoRlFVUkZVbE5mUTA5TlVFeEZWRVVBU0ZCRlgwTkNYMVpGVWxOSlQwNWZRMDlOVUV4RlZFVUFTRkJGWDBOQ1gxVlNURjlEVDAxUVRFVlVSUUJJVUVWZlEwSmZRMGhWVGt0ZlEwOU5VRXhGVkVVQVNGQkZYME5DWDBoRlFVUkZVbDlXUVV4VlJWOURUMDFRVEVWVVJRQklVRVZmUTBKZlEwaFZUa3RmUlZoVVJVNVRTVTlPWDFaQlRGVkZYME5QVFZCTVJWUkZBRWhRUlY5RFFsOURTRlZPUzE5RldGUkZUbE5KVDA1ZlRrRk5SVjlEVDAxUVRFVlVSUUJJVUVWZlEwSmZUVVZUVTBGSFJWOURUMDFRVEVWVVJRQklVRVZmUTBKZlRVVlVTRTlFWDBOUFRWQk1SVlJGQUVoUVJWOURRbDlJUlVGRVJWSmZSa2xGVEVSZlEwOU5VRXhGVkVVQVJFVk1SVlJGQUVoUVJWOUpUbFpCVEVsRVgwVlBSbDlUVkVGVVJRQkpUbFpCVEVsRVgxTlRURjlEUlZKVVNVWkpRMEZVUlFCUVFWVlRSUUJPVDE5U1JWTlFUMDVUUlFCVlRsTlZVRkJQVWxSRlJGOU5SVVJKUVY5VVdWQkZBRWRQVGtVQVRrOVVYMEZEUTBWUVZFRkNURVVBVTBWU1ZrbERSVjlWVGtGV1FVbE1RVUpNUlFCU1FVNUhSVjlPVDFSZlUwRlVTVk5HU1VGQ1RFVUFUMUpKUjBsT1gwbFRYMVZPVWtWQlEwaEJRa3hGQUZKRlUxQlBUbE5GWDBsVFgxTlVRVXhGQUZCVlVrZEZBRTFGVWtkRkFGSkZVVlZGVTFSZlNFVkJSRVZTWDBaSlJVeEVVMTlVVDA5ZlRFRlNSMFVBVWtWUlZVVlRWRjlJUlVGRVJWSmZWRTlQWDB4QlVrZEZBRkJCV1V4UFFVUmZWRTlQWDB4QlVrZEZBRWxPVTFWR1JrbERTVVZPVkY5VFZFOVNRVWRGQUVoUVJWOVFRVlZUUlVSZlZWQkhVa0ZFUlFCSVVFVmZVRUZWVTBWRVgwZ3lYMVZRUjFKQlJFVUFVMDlWVWtORkFFRk9UazlWVGtORkFGUlNRVU5GQUVoUVJWOVZUa1ZZVUVWRFZFVkVYMU5RUVVORkFFUkZVME5TU1VKRkFGVk9VMVZDVTBOU1NVSkZBRkpGUTA5U1JBQklVRVZmU1U1V1FVeEpSRjlOUlZSSVQwUUFUazlVWDBaUFZVNUVBRkJTVDFCR1NVNUVBRlZPUWtsT1JBQlNSVUpKVGtRQVZVNUJWVlJJVDFKSldrVkVBRTFGVkVoUFJGOU9UMVJmUVV4TVQxZEZSQUJJVkZSUVgxWkZVbE5KVDA1ZlRrOVVYMU5WVUZCUFVsUkZSQUJCVEZKRlFVUlpYMUpGVUU5U1ZFVkVBRUZEUTBWUVZFVkVBRTVQVkY5SlRWQk1SVTFGVGxSRlJBQk1UMDlRWDBSRlZFVkRWRVZFQUVoUVJWOURVbDlGV0ZCRlExUkZSQUJJVUVWZlRFWmZSVmhRUlVOVVJVUUFRMUpGUVZSRlJBQkpUVjlWVTBWRUFFaFFSVjlRUVZWVFJVUUFWRWxOUlU5VlZGOVBRME5WVWtWRUFGQkJXVTFGVGxSZlVrVlJWVWxTUlVRQVVGSkZRMDlPUkVsVVNVOU9YMUpGVVZWSlVrVkVBRkJTVDFoWlgwRlZWRWhGVGxSSlEwRlVTVTlPWDFKRlVWVkpVa1ZFQUU1RlZGZFBVa3RmUVZWVVNFVk9WRWxEUVZSSlQwNWZVa1ZSVlVsU1JVUUFURVZPUjFSSVgxSkZVVlZKVWtWRUFGTlRURjlEUlZKVVNVWkpRMEZVUlY5U1JWRlZTVkpGUkFCVlVFZFNRVVJGWDFKRlVWVkpVa1ZFQUZCQlIwVmZSVmhRU1ZKRlJBQlFVa1ZEVDA1RVNWUkpUMDVmUmtGSlRFVkVBRVZZVUVWRFZFRlVTVTlPWDBaQlNVeEZSQUJTUlZaQlRFbEVRVlJKVDA1ZlJrRkpURVZFQUZOVFRGOUlRVTVFVTBoQlMwVmZSa0ZKVEVWRUFFeFBRMHRGUkFCVVVrRk9VMFpQVWsxQlZFbFBUbDlCVUZCTVNVVkVBRTVQVkY5TlQwUkpSa2xGUkFCT1QxUmZSVmhVUlU1RVJVUUFRa0ZPUkZkSlJGUklYMHhKVFVsVVgwVllRMFZGUkVWRUFGTkpWRVZmU1ZOZlQxWkZVa3hQUVVSRlJBQklSVUZFQUVWNGNHVmpkR1ZrSUVoVVZGQXZBQUJlRXdBQUpoTUFBREFRQUFEd0Z3QUFuUk1BQUJVU0FBQTVGd0FBOEJJQUFBb1FBQUIxRWdBQXJSSUFBSUlUQUFCUEZBQUFmeEFBQUtBVkFBQWpGQUFBaVJJQUFJc1VBQUJORlFBQTFCRUFBTThVQUFBUUdBQUF5UllBQU53V0FBREJFUUFBNEJjQUFMc1VBQUIwRkFBQWZCVUFBT1VVQUFBSUZ3QUFIeEFBQUdVVkFBQ2pGQUFBS0JVQUFBSVZBQUNaRlFBQUxCQUFBSXNaQUFCUER3QUExQTRBQUdvUUFBRE9FQUFBQWhjQUFJa09BQUJ1RXdBQUhCTUFBR1lVQUFCV0Z3QUF3Uk1BQU0wVEFBQnNFd0FBYUJjQUFHWVhBQUJmRndBQUloTUFBTTRQQUFCcERnQUEyQTRBQUdNV0FBRExFd0FBcWc0QUFDZ1hBQUFtRndBQXhSTUFBRjBXQUFEb0VRQUFaeE1BQUdVVEFBRHlGZ0FBY3hNQUFCMFhBQUQ1RmdBQTh4RUFBTThPQUFET0ZRQUFEQklBQUxNUkFBQ2xFUUFBWVJBQUFESVhBQUM3RXdCQitUVUxBUUVBUVpBMkMrQUJBUUVDQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFBRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUFRZjAzQ3dFQkFFR1JPQXRlQWdNQ0FnSUNBZ0FBQWdJQUFnSUFBZ0lDQWdJQ0FnSUNBZ0FFQUFBQUFBQUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQUFBQUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUFJQUFnQkIvVGtMQVFFQVFaRTZDMTRDQUFJQ0FnSUNBQUFDQWdBQ0FnQUNBZ0lDQWdJQ0FnSUNBQU1BQkFBQUFBSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FBQUFBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBQWdBQ0FFSHdPd3NOYkc5elpXVmxjQzFoYkdsMlpRQkJpVHdMQVFFQVFhQThDK0FCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUFBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVBUVlrK0N3RUJBRUdnUGd2bkFRRUJBUUVCQVFFQkFRRUJBUUlCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQUFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQlkyaDFibXRsWkFCQnNNQUFDMThCQVFBQkFRRUJBUUFBQVFFQUFRRUFBUUVCQVFFQkFRRUJBUUFBQUFBQUFBQUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRQUFBQUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQUFFQUFRQkJrTUlBQ3lGbFkzUnBiMjVsYm5RdGJHVnVaM1JvYjI1eWIzaDVMV052Ym01bFkzUnBiMjRBUWNEQ0FBc3RjbUZ1YzJabGNpMWxibU52WkdsdVozQm5jbUZrWlEwS0RRb05DbE5ORFFvTkNsUlVVQzlEUlM5VVUxQXZBRUg1d2dBTEJRRUNBQUVEQUVHUXd3QUw0QUVFQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRQUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUJCK2NRQUN3VUJBZ0FCQXdCQmtNVUFDK0FCQkFFQkJRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUFBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVBUWZuR0FBc0VBUUFBQVFCQmtjY0FDOThCQVFFQUFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFBRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRQUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUJCK3NnQUN3UUJBQUFDQUVHUXlRQUxYd01FQUFBRUJBUUVCQVFFQkFRRUJBVUVCQVFFQkFRRUJBUUVCQVFBQkFBR0J3UUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBQUVBQVFBQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFBQUFBRUFFSDZ5Z0FMQkFFQUFBRUFRWkRMQUFzQkFRQkJxc3NBQzBFQ0FBQUFBQUFBQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01BQUFBQUFBQURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3QkIrc3dBQ3dRQkFBQUJBRUdRelFBTEFRRUFRWnJOQUFzR0FnQUFBQUFDQUVHeHpRQUxPZ01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBQUFBQUFBQUF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNQVFmRE9BQXVXQVU1UFZVNURSVVZEUzA5VlZFNUZRMVJGVkVWRFVrbENSVXhWVTBoRlZFVkJSRk5GUVZKRFNGSkhSVU5VU1ZaSlZGbE1SVTVFUVZKV1JVOVVTVVpaVUZSSlQwNVRRMGhUUlVGWlUxUkJWRU5JUjBWUFVrUkpVa1ZEVkU5U1ZGSkRTRkJCVWtGTlJWUkZVbFZTUTBWQ1UwTlNTVUpGUVZKRVQxZE9RVU5GU1U1RVRrdERTMVZDVTBOU1NVSkZTRlJVVUM5QlJGUlFMdz09JywgJ2Jhc2U2NCcpXG4iXSwibmFtZXMiOlsiQnVmZmVyIiwicmVxdWlyZSIsIm1vZHVsZSIsImV4cG9ydHMiLCJmcm9tIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/llhttp/llhttp_simd-wasm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/llhttp/utils.js":
/*!*************************************************!*\
  !*** ./node_modules/undici/lib/llhttp/utils.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.enumToMap = void 0;\nfunction enumToMap(obj) {\n    const res = {};\n    Object.keys(obj).forEach((key)=>{\n        const value = obj[key];\n        if (typeof value === \"number\") {\n            res[key] = value;\n        }\n    });\n    return res;\n}\nexports.enumToMap = enumToMap;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9sbGh0dHAvdXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGlCQUFpQixHQUFHLEtBQUs7QUFDekIsU0FBU0UsVUFBVUMsR0FBRztJQUNsQixNQUFNQyxNQUFNLENBQUM7SUFDYk4sT0FBT08sSUFBSSxDQUFDRixLQUFLRyxPQUFPLENBQUVDLENBQUFBO1FBQ3RCLE1BQU1OLFFBQVFFLEdBQUcsQ0FBQ0ksSUFBSTtRQUN0QixJQUFJLE9BQU9OLFVBQVUsVUFBVTtZQUMzQkcsR0FBRyxDQUFDRyxJQUFJLEdBQUdOO1FBQ2Y7SUFDSjtJQUNBLE9BQU9HO0FBQ1g7QUFDQUosaUJBQWlCLEdBQUdFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbW9ja3VwZmxvdy8uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL2xsaHR0cC91dGlscy5qcz9jY2VjIiwid2VicGFjazovL21vY2t1cGZsb3cvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9sbGh0dHAvdXRpbHMuanM/Y2NlYyoiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmVudW1Ub01hcCA9IHZvaWQgMDtcbmZ1bmN0aW9uIGVudW1Ub01hcChvYmopIHtcbiAgICBjb25zdCByZXMgPSB7fTtcbiAgICBPYmplY3Qua2V5cyhvYmopLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IG9ialtrZXldO1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcmVzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXM7XG59XG5leHBvcnRzLmVudW1Ub01hcCA9IGVudW1Ub01hcDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImVudW1Ub01hcCIsIm9iaiIsInJlcyIsImtleXMiLCJmb3JFYWNoIiwia2V5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/llhttp/utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/mock/mock-agent.js":
/*!****************************************************!*\
  !*** ./node_modules/undici/lib/mock/mock-agent.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { kClients } = __webpack_require__(/*! ../core/symbols */ \"(ssr)/./node_modules/undici/lib/core/symbols.js\");\nconst Agent = __webpack_require__(/*! ../dispatcher/agent */ \"(ssr)/./node_modules/undici/lib/dispatcher/agent.js\");\nconst { kAgent, kMockAgentSet, kMockAgentGet, kDispatches, kIsMockActive, kNetConnect, kGetNetConnect, kOptions, kFactory } = __webpack_require__(/*! ./mock-symbols */ \"(ssr)/./node_modules/undici/lib/mock/mock-symbols.js\");\nconst MockClient = __webpack_require__(/*! ./mock-client */ \"(ssr)/./node_modules/undici/lib/mock/mock-client.js\");\nconst MockPool = __webpack_require__(/*! ./mock-pool */ \"(ssr)/./node_modules/undici/lib/mock/mock-pool.js\");\nconst { matchValue, buildMockOptions } = __webpack_require__(/*! ./mock-utils */ \"(ssr)/./node_modules/undici/lib/mock/mock-utils.js\");\nconst { InvalidArgumentError, UndiciError } = __webpack_require__(/*! ../core/errors */ \"(ssr)/./node_modules/undici/lib/core/errors.js\");\nconst Dispatcher = __webpack_require__(/*! ../dispatcher/dispatcher */ \"(ssr)/./node_modules/undici/lib/dispatcher/dispatcher.js\");\nconst Pluralizer = __webpack_require__(/*! ./pluralizer */ \"(ssr)/./node_modules/undici/lib/mock/pluralizer.js\");\nconst PendingInterceptorsFormatter = __webpack_require__(/*! ./pending-interceptors-formatter */ \"(ssr)/./node_modules/undici/lib/mock/pending-interceptors-formatter.js\");\nclass MockAgent extends Dispatcher {\n    constructor(opts){\n        super(opts);\n        this[kNetConnect] = true;\n        this[kIsMockActive] = true;\n        // Instantiate Agent and encapsulate\n        if (opts?.agent && typeof opts.agent.dispatch !== \"function\") {\n            throw new InvalidArgumentError(\"Argument opts.agent must implement Agent\");\n        }\n        const agent = opts?.agent ? opts.agent : new Agent(opts);\n        this[kAgent] = agent;\n        this[kClients] = agent[kClients];\n        this[kOptions] = buildMockOptions(opts);\n    }\n    get(origin) {\n        let dispatcher = this[kMockAgentGet](origin);\n        if (!dispatcher) {\n            dispatcher = this[kFactory](origin);\n            this[kMockAgentSet](origin, dispatcher);\n        }\n        return dispatcher;\n    }\n    dispatch(opts, handler) {\n        // Call MockAgent.get to perform additional setup before dispatching as normal\n        this.get(opts.origin);\n        return this[kAgent].dispatch(opts, handler);\n    }\n    async close() {\n        await this[kAgent].close();\n        this[kClients].clear();\n    }\n    deactivate() {\n        this[kIsMockActive] = false;\n    }\n    activate() {\n        this[kIsMockActive] = true;\n    }\n    enableNetConnect(matcher) {\n        if (typeof matcher === \"string\" || typeof matcher === \"function\" || matcher instanceof RegExp) {\n            if (Array.isArray(this[kNetConnect])) {\n                this[kNetConnect].push(matcher);\n            } else {\n                this[kNetConnect] = [\n                    matcher\n                ];\n            }\n        } else if (typeof matcher === \"undefined\") {\n            this[kNetConnect] = true;\n        } else {\n            throw new InvalidArgumentError(\"Unsupported matcher. Must be one of String|Function|RegExp.\");\n        }\n    }\n    disableNetConnect() {\n        this[kNetConnect] = false;\n    }\n    // This is required to bypass issues caused by using global symbols - see:\n    // https://github.com/nodejs/undici/issues/1447\n    get isMockActive() {\n        return this[kIsMockActive];\n    }\n    [kMockAgentSet](origin, dispatcher) {\n        this[kClients].set(origin, dispatcher);\n    }\n    [kFactory](origin) {\n        const mockOptions = Object.assign({\n            agent: this\n        }, this[kOptions]);\n        return this[kOptions] && this[kOptions].connections === 1 ? new MockClient(origin, mockOptions) : new MockPool(origin, mockOptions);\n    }\n    [kMockAgentGet](origin) {\n        // First check if we can immediately find it\n        const client = this[kClients].get(origin);\n        if (client) {\n            return client;\n        }\n        // If the origin is not a string create a dummy parent pool and return to user\n        if (typeof origin !== \"string\") {\n            const dispatcher = this[kFactory](\"http://localhost:9999\");\n            this[kMockAgentSet](origin, dispatcher);\n            return dispatcher;\n        }\n        // If we match, create a pool and assign the same dispatches\n        for (const [keyMatcher, nonExplicitDispatcher] of Array.from(this[kClients])){\n            if (nonExplicitDispatcher && typeof keyMatcher !== \"string\" && matchValue(keyMatcher, origin)) {\n                const dispatcher = this[kFactory](origin);\n                this[kMockAgentSet](origin, dispatcher);\n                dispatcher[kDispatches] = nonExplicitDispatcher[kDispatches];\n                return dispatcher;\n            }\n        }\n    }\n    [kGetNetConnect]() {\n        return this[kNetConnect];\n    }\n    pendingInterceptors() {\n        const mockAgentClients = this[kClients];\n        return Array.from(mockAgentClients.entries()).flatMap(([origin, scope])=>scope[kDispatches].map((dispatch)=>({\n                    ...dispatch,\n                    origin\n                }))).filter(({ pending })=>pending);\n    }\n    assertNoPendingInterceptors({ pendingInterceptorsFormatter = new PendingInterceptorsFormatter() } = {}) {\n        const pending = this.pendingInterceptors();\n        if (pending.length === 0) {\n            return;\n        }\n        const pluralizer = new Pluralizer(\"interceptor\", \"interceptors\").pluralize(pending.length);\n        throw new UndiciError(`\n${pluralizer.count} ${pluralizer.noun} ${pluralizer.is} pending:\n\n${pendingInterceptorsFormatter.format(pending)}\n`.trim());\n    }\n}\nmodule.exports = MockAgent;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9tb2NrL21vY2stYWdlbnQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNLEVBQUVBLFFBQUFBLEVBQVUsR0FBR0MsbUJBQU9BLENBQUM7QUFDN0IsTUFBTUMsUUFBUUQsbUJBQU9BLENBQUM7QUFDdEIsTUFBTSxFQUNKRSxNQUFNLEVBQ05DLGFBQWEsRUFDYkMsYUFBYSxFQUNiQyxXQUFXLEVBQ1hDLGFBQWEsRUFDYkMsV0FBVyxFQUNYQyxjQUFjLEVBQ2RDLFFBQVEsRUFDUkMsUUFBQUEsRUFDRCxHQUFHVixtQkFBT0EsQ0FBQztBQUNaLE1BQU1XLGFBQWFYLG1CQUFPQSxDQUFDO0FBQzNCLE1BQU1ZLFdBQVdaLG1CQUFPQSxDQUFDO0FBQ3pCLE1BQU0sRUFBRWEsVUFBVSxFQUFFQyxnQkFBQUEsRUFBa0IsR0FBR2QsbUJBQU9BLENBQUM7QUFDakQsTUFBTSxFQUFFZSxvQkFBb0IsRUFBRUMsV0FBQUEsRUFBYSxHQUFHaEIsbUJBQU9BLENBQUM7QUFDdEQsTUFBTWlCLGFBQWFqQixtQkFBT0EsQ0FBQztBQUMzQixNQUFNa0IsYUFBYWxCLG1CQUFPQSxDQUFDO0FBQzNCLE1BQU1tQiwrQkFBK0JuQixtQkFBT0EsQ0FBQztBQUU3QyxNQUFNb0Isa0JBQWtCSDtJQUN0QkksWUFBYUMsSUFBSSxDQUFFO1FBQ2pCLEtBQUssQ0FBQ0E7UUFFTixJQUFJLENBQUNmLFlBQVksR0FBRztRQUNwQixJQUFJLENBQUNELGNBQWMsR0FBRztRQUV0QjtRQUNBLElBQUtnQixNQUFNQyxTQUFTLE9BQU9ELEtBQUtDLEtBQUssQ0FBQ0MsUUFBUSxLQUFLLFlBQWE7WUFDOUQsTUFBTSxJQUFJVCxxQkFBcUI7UUFDakM7UUFDQSxNQUFNUSxRQUFRRCxNQUFNQyxRQUFRRCxLQUFLQyxLQUFLLEdBQUcsSUFBSXRCLE1BQU1xQjtRQUNuRCxJQUFJLENBQUNwQixPQUFPLEdBQUdxQjtRQUVmLElBQUksQ0FBQ3hCLFNBQVMsR0FB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QztnQkFDNUJBLFVBQVUsQ0FBQ3RCLFlBQVksR0FBRzJDLHFCQUFxQixDQUFDM0MsWUFBWTtnQkFDNUQsT0FBT3NCO1lBQ1Q7UUFDRjtJQUNGO0lBRUEsQ0FBQ25CLGVBQWMsR0FBSztRQUNsQixPQUFPLElBQUksQ0FBQ0QsWUFBWTtJQUMxQjtJQUVBMkMsc0JBQXVCO1FBQ3JCLE1BQU1DLG1CQUFtQixJQUFJLENBQUNwRCxTQUFTO1FBRXZDLE9BQU9xQyxNQUFNYSxJQUFJLENBQUNFLGlCQUFpQkMsT0FBTyxJQUN2Q0MsT0FBTyxDQUFDLENBQUMsQ0FBQzNCLFFBQVE0QixNQUFNLEdBQUtBLEtBQUssQ0FBQ2pELFlBQVksQ0FBQ2tELEdBQUcsQ0FBQy9CLENBQUFBLFdBQWE7b0JBQUUsR0FBR0EsUUFBUTtvQkFBRUU7Z0JBQU8sS0FDdkY4QixNQUFNLENBQUMsQ0FBQyxFQUFFQyxPQUFBQSxFQUFTLEdBQUtBO0lBQzdCO0lBRUFDLDRCQUE2QixFQUFFQywrQkFBK0IsSUFBSXhDLDhCQUE2QixFQUFHLEdBQUcsQ0FBQyxDQUFDLEVBQUU7UUFDdkcsTUFBTXNDLFVBQVUsSUFBSSxDQUFDUCxtQkFBbUI7UUFFeEMsSUFBSU8sUUFBUUcsTUFBTSxLQUFLLEdBQUc7WUFDeEI7UUFDRjtRQUVBLE1BQU1DLGFBQWEsSUFBSTNDLFdBQVcsZUFBZSxnQkFBZ0I0QyxTQUFTLENBQUNMLFFBQVFHLE1BQU07UUFFekYsTUFBTSxJQUFJNUMsWUFBWTtBQUMxQixFQUFFNkMsV0FBV0UsS0FBSyxJQUFJRixXQUFXRyxJQUFJLElBQUlILFdBQVdJLEVBQUU7O0FBRXRELEVBQUVOLDZCQUE2Qk8sTUFBTSxDQUFDVCxTQUFRO0FBQzlDLENBQUMsQ0FBQ1UsSUFBSTtJQUNKO0FBQ0Y7QUFFQUMsT0FBT0MsT0FBTyxHQUFHakQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tb2NrdXBmbG93Ly4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvbW9jay9tb2NrLWFnZW50LmpzPzlhZGYiLCJ3ZWJwYWNrOi8vbW9ja3VwZmxvdy8uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL21vY2svbW9jay1hZ2VudC5qcz85YWRmKiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyBrQ2xpZW50cyB9ID0gcmVxdWlyZSgnLi4vY29yZS9zeW1ib2xzJylcbmNvbnN0IEFnZW50ID0gcmVxdWlyZSgnLi4vZGlzcGF0Y2hlci9hZ2VudCcpXG5jb25zdCB7XG4gIGtBZ2VudCxcbiAga01vY2tBZ2VudFNldCxcbiAga01vY2tBZ2VudEdldCxcbiAga0Rpc3BhdGNoZXMsXG4gIGtJc01vY2tBY3RpdmUsXG4gIGtOZXRDb25uZWN0LFxuICBrR2V0TmV0Q29ubmVjdCxcbiAga09wdGlvbnMsXG4gIGtGYWN0b3J5XG59ID0gcmVxdWlyZSgnLi9tb2NrLXN5bWJvbHMnKVxuY29uc3QgTW9ja0NsaWVudCA9IHJlcXVpcmUoJy4vbW9jay1jbGllbnQnKVxuY29uc3QgTW9ja1Bvb2wgPSByZXF1aXJlKCcuL21vY2stcG9vbCcpXG5jb25zdCB7IG1hdGNoVmFsdWUsIGJ1aWxkTW9ja09wdGlvbnMgfSA9IHJlcXVpcmUoJy4vbW9jay11dGlscycpXG5jb25zdCB7IEludmFsaWRBcmd1bWVudEVycm9yLCBVbmRpY2lFcnJvciB9ID0gcmVxdWlyZSgnLi4vY29yZS9lcnJvcnMnKVxuY29uc3QgRGlzcGF0Y2hlciA9IHJlcXVpcmUoJy4uL2Rpc3BhdGNoZXIvZGlzcGF0Y2hlcicpXG5jb25zdCBQbHVyYWxpemVyID0gcmVxdWlyZSgnLi9wbHVyYWxpemVyJylcbmNvbnN0IFBlbmRpbmdJbnRlcmNlcHRvcnNGb3JtYXR0ZXIgPSByZXF1aXJlKCcuL3BlbmRpbmctaW50ZXJjZXB0b3JzLWZvcm1hdHRlcicpXG5cbmNsYXNzIE1vY2tBZ2VudCBleHRlbmRzIERpc3BhdGNoZXIge1xuICBjb25zdHJ1Y3RvciAob3B0cykge1xuICAgIHN1cGVyKG9wdHMpXG5cbiAgICB0aGlzW2tOZXRDb25uZWN0XSA9IHRydWVcbiAgICB0aGlzW2tJc01vY2tBY3RpdmVdID0gdHJ1ZVxuXG4gICAgLy8gSW5zdGFudGlhdGUgQWdlbnQgYW5kIGVuY2Fwc3VsYXRlXG4gICAgaWYgKChvcHRzPy5hZ2VudCAmJiB0eXBlb2Ygb3B0cy5hZ2VudC5kaXNwYXRjaCAhPT0gJ2Z1bmN0aW9uJykpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignQXJndW1lbnQgb3B0cy5hZ2VudCBtdXN0IGltcGxlbWVudCBBZ2VudCcpXG4gICAgfVxuICAgIGNvbnN0IGFnZW50ID0gb3B0cz8uYWdlbnQgPyBvcHRzLmFnZW50IDogbmV3IEFnZW50KG9wdHMpXG4gICAgdGhpc1trQWdlbnRdID0gYWdlbnRcblxuICAgIHRoaXNba0NsaWVudHNdID0gYWdlbnRba0NsaWVudHNdXG4gICAgdGhpc1trT3B0aW9uc10gPSBidWlsZE1vY2tPcHRpb25zKG9wdHMpXG4gIH1cblxuICBnZXQgKG9yaWdpbikge1xuICAgIGxldCBkaXNwYXRjaGVyID0gdGhpc1trTW9ja0FnZW50R2V0XShvcmlnaW4pXG5cbiAgICBpZiAoIWRpc3BhdGNoZXIpIHtcbiAgICAgIGRpc3BhdGNoZXIgPSB0aGlzW2tGYWN0b3J5XShvcmlnaW4pXG4gICAgICB0aGlzW2tNb2NrQWdlbnRTZXRdKG9yaWdpbiwgZGlzcGF0Y2hlcilcbiAgICB9XG4gICAgcmV0dXJuIGRpc3BhdGNoZXJcbiAgfVxuXG4gIGRpc3BhdGNoIChvcHRzLCBoYW5kbGVyKSB7XG4gICAgLy8gQ2FsbCBNb2NrQWdlbnQuZ2V0IHRvIHBlcmZvcm0gYWRkaXRpb25hbCBzZXR1cCBiZWZvcmUgZGlzcGF0Y2hpbmcgYXMgbm9ybWFsXG4gICAgdGhpcy5nZXQob3B0cy5vcmlnaW4pXG4gICAgcmV0dXJuIHRoaXNba0FnZW50XS5kaXNwYXRjaChvcHRzLCBoYW5kbGVyKVxuICB9XG5cbiAgYXN5bmMgY2xvc2UgKCkge1xuICAgIGF3YWl0IHRoaXNba0FnZW50XS5jbG9zZSgpXG4gICAgdGhpc1trQ2xpZW50c10uY2xlYXIoKVxuICB9XG5cbiAgZGVhY3RpdmF0ZSAoKSB7XG4gICAgdGhpc1trSXNNb2NrQWN0aXZlXSA9IGZhbHNlXG4gIH1cblxuICBhY3RpdmF0ZSAoKSB7XG4gICAgdGhpc1trSXNNb2NrQWN0aXZlXSA9IHRydWVcbiAgfVxuXG4gIGVuYWJsZU5ldENvbm5lY3QgKG1hdGNoZXIpIHtcbiAgICBpZiAodHlwZW9mIG1hdGNoZXIgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBtYXRjaGVyID09PSAnZnVuY3Rpb24nIHx8IG1hdGNoZXIgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXNba05ldENvbm5lY3RdKSkge1xuICAgICAgICB0aGlzW2tOZXRDb25uZWN0XS5wdXNoKG1hdGNoZXIpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzW2tOZXRDb25uZWN0XSA9IFttYXRjaGVyXVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIG1hdGNoZXIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aGlzW2tOZXRDb25uZWN0XSA9IHRydWVcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdVbnN1cHBvcnRlZCBtYXRjaGVyLiBNdXN0IGJlIG9uZSBvZiBTdHJpbmd8RnVuY3Rpb258UmVnRXhwLicpXG4gICAgfVxuICB9XG5cbiAgZGlzYWJsZU5ldENvbm5lY3QgKCkge1xuICAgIHRoaXNba05ldENvbm5lY3RdID0gZmFsc2VcbiAgfVxuXG4gIC8vIFRoaXMgaXMgcmVxdWlyZWQgdG8gYnlwYXNzIGlzc3VlcyBjYXVzZWQgYnkgdXNpbmcgZ2xvYmFsIHN5bWJvbHMgLSBzZWU6XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvdW5kaWNpL2lzc3Vlcy8xNDQ3XG4gIGdldCBpc01vY2tBY3RpdmUgKCkge1xuICAgIHJldHVybiB0aGlzW2tJc01vY2tBY3RpdmVdXG4gIH1cblxuICBba01vY2tBZ2VudFNldF0gKG9yaWdpbiwgZGlzcGF0Y2hlcikge1xuICAgIHRoaXNba0NsaWVudHNdLnNldChvcmlnaW4sIGRpc3BhdGNoZXIpXG4gIH1cblxuICBba0ZhY3RvcnldIChvcmlnaW4pIHtcbiAgICBjb25zdCBtb2NrT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oeyBhZ2VudDogdGhpcyB9LCB0aGlzW2tPcHRpb25zXSlcbiAgICByZXR1cm4gdGhpc1trT3B0aW9uc10gJiYgdGhpc1trT3B0aW9uc10uY29ubmVjdGlvbnMgPT09IDFcbiAgICAgID8gbmV3IE1vY2tDbGllbnQob3JpZ2luLCBtb2NrT3B0aW9ucylcbiAgICAgIDogbmV3IE1vY2tQb29sKG9yaWdpbiwgbW9ja09wdGlvbnMpXG4gIH1cblxuICBba01vY2tBZ2VudEdldF0gKG9yaWdpbikge1xuICAgIC8vIEZpcnN0IGNoZWNrIGlmIHdlIGNhbiBpbW1lZGlhdGVseSBmaW5kIGl0XG4gICAgY29uc3QgY2xpZW50ID0gdGhpc1trQ2xpZW50c10uZ2V0KG9yaWdpbilcbiAgICBpZiAoY2xpZW50KSB7XG4gICAgICByZXR1cm4gY2xpZW50XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIG9yaWdpbiBpcyBub3QgYSBzdHJpbmcgY3JlYXRlIGEgZHVtbXkgcGFyZW50IHBvb2wgYW5kIHJldHVybiB0byB1c2VyXG4gICAgaWYgKHR5cGVvZiBvcmlnaW4gIT09ICdzdHJpbmcnKSB7XG4gICAgICBjb25zdCBkaXNwYXRjaGVyID0gdGhpc1trRmFjdG9yeV0oJ2h0dHA6Ly9sb2NhbGhvc3Q6OTk5OScpXG4gICAgICB0aGlzW2tNb2NrQWdlbnRTZXRdKG9yaWdpbiwgZGlzcGF0Y2hlcilcbiAgICAgIHJldHVybiBkaXNwYXRjaGVyXG4gICAgfVxuXG4gICAgLy8gSWYgd2UgbWF0Y2gsIGNyZWF0ZSBhIHBvb2wgYW5kIGFzc2lnbiB0aGUgc2FtZSBkaXNwYXRjaGVzXG4gICAgZm9yIChjb25zdCBba2V5TWF0Y2hlciwgbm9uRXhwbGljaXREaXNwYXRjaGVyXSBvZiBBcnJheS5mcm9tKHRoaXNba0NsaWVudHNdKSkge1xuICAgICAgaWYgKG5vbkV4cGxpY2l0RGlzcGF0Y2hlciAmJiB0eXBlb2Yga2V5TWF0Y2hlciAhPT0gJ3N0cmluZycgJiYgbWF0Y2hWYWx1ZShrZXlNYXRjaGVyLCBvcmlnaW4pKSB7XG4gICAgICAgIGNvbnN0IGRpc3BhdGNoZXIgPSB0aGlzW2tGYWN0b3J5XShvcmlnaW4pXG4gICAgICAgIHRoaXNba01vY2tBZ2VudFNldF0ob3JpZ2luLCBkaXNwYXRjaGVyKVxuICAgICAgICBkaXNwYXRjaGVyW2tEaXNwYXRjaGVzXSA9IG5vbkV4cGxpY2l0RGlzcGF0Y2hlcltrRGlzcGF0Y2hlc11cbiAgICAgICAgcmV0dXJuIGRpc3BhdGNoZXJcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBba0dldE5ldENvbm5lY3RdICgpIHtcbiAgICByZXR1cm4gdGhpc1trTmV0Q29ubmVjdF1cbiAgfVxuXG4gIHBlbmRpbmdJbnRlcmNlcHRvcnMgKCkge1xuICAgIGNvbnN0IG1vY2tBZ2VudENsaWVudHMgPSB0aGlzW2tDbGllbnRzXVxuXG4gICAgcmV0dXJuIEFycmF5LmZyb20obW9ja0FnZW50Q2xpZW50cy5lbnRyaWVzKCkpXG4gICAgICAuZmxhdE1hcCgoW29yaWdpbiwgc2NvcGVdKSA9PiBzY29wZVtrRGlzcGF0Y2hlc10ubWFwKGRpc3BhdGNoID0+ICh7IC4uLmRpc3BhdGNoLCBvcmlnaW4gfSkpKVxuICAgICAgLmZpbHRlcigoeyBwZW5kaW5nIH0pID0+IHBlbmRpbmcpXG4gIH1cblxuICBhc3NlcnROb1BlbmRpbmdJbnRlcmNlcHRvcnMgKHsgcGVuZGluZ0ludGVyY2VwdG9yc0Zvcm1hdHRlciA9IG5ldyBQZW5kaW5nSW50ZXJjZXB0b3JzRm9ybWF0dGVyKCkgfSA9IHt9KSB7XG4gICAgY29uc3QgcGVuZGluZyA9IHRoaXMucGVuZGluZ0ludGVyY2VwdG9ycygpXG5cbiAgICBpZiAocGVuZGluZy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IHBsdXJhbGl6ZXIgPSBuZXcgUGx1cmFsaXplcignaW50ZXJjZXB0b3InLCAnaW50ZXJjZXB0b3JzJykucGx1cmFsaXplKHBlbmRpbmcubGVuZ3RoKVxuXG4gICAgdGhyb3cgbmV3IFVuZGljaUVycm9yKGBcbiR7cGx1cmFsaXplci5jb3VudH0gJHtwbHVyYWxpemVyLm5vdW59ICR7cGx1cmFsaXplci5pc30gcGVuZGluZzpcblxuJHtwZW5kaW5nSW50ZXJjZXB0b3JzRm9ybWF0dGVyLmZvcm1hdChwZW5kaW5nKX1cbmAudHJpbSgpKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gTW9ja0FnZW50XG4iXSwibmFtZXMiOlsia0NsaWVudHMiLCJyZXF1aXJlIiwiQWdlbnQiLCJrQWdlbnQiLCJrTW9ja0FnZW50U2V0Iiwia01vY2tBZ2VudEdldCIsImtEaXNwYXRjaGVzIiwia0lzTW9ja0FjdGl2ZSIsImtOZXRDb25uZWN0Iiwia0dldE5ldENvbm5lY3QiLCJrT3B0aW9ucyIsImtGYWN0b3J5IiwiTW9ja0NsaWVudCIsIk1vY2tQb29sIiwibWF0Y2hWYWx1ZSIsImJ1aWxkTW9ja09wdGlvbnMiLCJJbnZhbGlkQXJndW1lbnRFcnJvciIsIlVuZGljaUVycm9yIiwiRGlzcGF0Y2hlciIsIlBsdXJhbGl6ZXIiLCJQZW5kaW5nSW50ZXJjZXB0b3JzRm9ybWF0dGVyIiwiTW9ja0FnZW50IiwiY29uc3RydWN0b3IiLCJvcHRzIiwiYWdlbnQiLCJkaXNwYXRjaCIsImdldCIsIm9yaWdpbiIsImRpc3BhdGNoZXIiLCJoYW5kbGVyIiwiY2xvc2UiLCJjbGVhciIsImRlYWN0aXZhdGUiLCJhY3RpdmF0ZSIsImVuYWJsZU5ldENvbm5lY3QiLCJtYXRjaGVyIiwiUmVnRXhwIiwiQXJyYXkiLCJpc0FycmF5IiwicHVzaCIsImRpc2FibGVOZXRDb25uZWN0IiwiaXNNb2NrQWN0aXZlIiwic2V0IiwibW9ja09wdGlvbnMiLCJPYmplY3QiLCJhc3NpZ24iLCJjb25uZWN0aW9ucyIsImNsaWVudCIsImtleU1hdGNoZXIiLCJub25FeHBsaWNpdERpc3BhdGNoZXIiLCJmcm9tIiwicGVuZGluZ0ludGVyY2VwdG9ycyIsIm1vY2tBZ2VudENsaWVudHMiLCJlbnRyaWVzIiwiZmxhdE1hcCIsInNjb3BlIiwibWFwIiwiZmlsdGVyIiwicGVuZGluZyIsImFzc2VydE5vUGVuZGluZ0ludGVyY2VwdG9ycyIsInBlbmRpbmdJbnRlcmNlcHRvcnNGb3JtYXR0ZXIiLCJsZW5ndGgiLCJwbHVyYWxpemVyIiwicGx1cmFsaXplIiwiY291bnQiLCJub3VuIiwiaXMiLCJmb3JtYXQiLCJ0cmltIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/mock/mock-agent.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/mock/mock-client.js":
/*!*****************************************************!*\
  !*** ./node_modules/undici/lib/mock/mock-client.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { promisify } = __webpack_require__(/*! node:util */ \"node:util\");\nconst Client = __webpack_require__(/*! ../dispatcher/client */ \"(ssr)/./node_modules/undici/lib/dispatcher/client.js\");\nconst { buildMockDispatch } = __webpack_require__(/*! ./mock-utils */ \"(ssr)/./node_modules/undici/lib/mock/mock-utils.js\");\nconst { kDispatches, kMockAgent, kClose, kOriginalClose, kOrigin, kOriginalDispatch, kConnected } = __webpack_require__(/*! ./mock-symbols */ \"(ssr)/./node_modules/undici/lib/mock/mock-symbols.js\");\nconst { MockInterceptor } = __webpack_require__(/*! ./mock-interceptor */ \"(ssr)/./node_modules/undici/lib/mock/mock-interceptor.js\");\nconst Symbols = __webpack_require__(/*! ../core/symbols */ \"(ssr)/./node_modules/undici/lib/core/symbols.js\");\nconst { InvalidArgumentError } = __webpack_require__(/*! ../core/errors */ \"(ssr)/./node_modules/undici/lib/core/errors.js\");\n/**\n * MockClient provides an API that extends the Client to influence the mockDispatches.\n */ class MockClient extends Client {\n    constructor(origin, opts){\n        super(origin, opts);\n        if (!opts || !opts.agent || typeof opts.agent.dispatch !== \"function\") {\n            throw new InvalidArgumentError(\"Argument opts.agent must implement Agent\");\n        }\n        this[kMockAgent] = opts.agent;\n        this[kOrigin] = origin;\n        this[kDispatches] = [];\n        this[kConnected] = 1;\n        this[kOriginalDispatch] = this.dispatch;\n        this[kOriginalClose] = this.close.bind(this);\n        this.dispatch = buildMockDispatch.call(this);\n        this.close = this[kClose];\n    }\n    get [Symbols.kConnected]() {\n        return this[kConnected];\n    }\n    /**\n   * Sets up the base interceptor for mocking replies from undici.\n   */ intercept(opts) {\n        return new MockInterceptor(opts, this[kDispatches]);\n    }\n    async [kClose]() {\n        await promisify(this[kOriginalClose])();\n        this[kConnected] = 0;\n        this[kMockAgent][Symbols.kClients].delete(this[kOrigin]);\n    }\n}\nmodule.exports = MockClient;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9tb2NrL21vY2stY2xpZW50LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTSxFQUFFQSxTQUFBQSxFQUFXLEdBQUdDLG1CQUFPQSxDQUFDO0FBQzlCLE1BQU1DLFNBQVNELG1CQUFPQSxDQUFDO0FBQ3ZCLE1BQU0sRUFBRUUsaUJBQUFBLEVBQW1CLEdBQUdGLG1CQUFPQSxDQUFDO0FBQ3RDLE1BQU0sRUFDSkcsV0FBVyxFQUNYQyxVQUFVLEVBQ1ZDLE1BQU0sRUFDTkMsY0FBYyxFQUNkQyxPQUFPLEVBQ1BDLGlCQUFpQixFQUNqQkMsVUFBQUEsRUFDRCxHQUFHVCxtQkFBT0EsQ0FBQztBQUNaLE1BQU0sRUFBRVUsZUFBQUEsRUFBaUIsR0FBR1YsbUJBQU9BLENBQUM7QUFDcEMsTUFBTVcsVUFBVVgsbUJBQU9BLENBQUM7QUFDeEIsTUFBTSxFQUFFWSxvQkFBQUEsRUFBc0IsR0FBR1osbUJBQU9BLENBQUM7QUFFekM7O0NBRUEsR0FDQSxNQUFNYSxtQkFBbUJaO0lBQ3ZCYSxZQUFhQyxNQUFNLEVBQUVDLElBQUksQ0FBRTtRQUN6QixLQUFLLENBQUNELFFBQVFDO1FBRWQsSUFBSSxDQUFDQSxRQUFRLENBQUNBLEtBQUtDLEtBQUssSUFBSSxPQUFPRCxLQUFLQyxLQUFLLENBQUNDLFFBQVEsS0FBSyxZQUFZO1lBQ3JFLE1BQU0sSUFBSU4scUJBQXFCO1FBQ2pDO1FBRUEsSUFBSSxDQUFDUixXQUFXLEdBQUdZLEtBQUtDLEtBQUs7UUFDN0IsSUFBSSxDQUFDVixRQUFRLEdBQUdRO1FBQ2hCLElBQUksQ0FBQ1osWUFBWSxHQUFHLEVBQUU7UUFDdEIsSUFBSSxDQUFDTSxXQUFXLEdBQUc7UUFDbkIsSUFBSSxDQUFDRCxrQkFBa0IsR0FBRyxJQUFJLENBQUNVLFFBQVE7UUFDdkMsSUFBSSxDQUFDWixlQUFlLEdBQUcsSUFBSSxDQUFDYSxLQUFLLENBQUNDLElBQUksQ0FBQyxJQUFJO1FBRTNDLElBQUksQ0FBQ0YsUUFBUSxHQUFHaEIsa0JBQWtCbUIsSUFBSSxDQUFDLElBQUk7UUFDM0MsSUFBSSxDQUFDRixLQUFLLEdBQUcsSUFBSSxDQUFDZCxPQUFPO0lBQzNCO0lBRUEsS0FBS00sUUFBUUYsVUFBVSxJQUFLO1FBQzFCLE9BQU8sSUFBSSxDQUFDQSxXQUFXO0lBQ3pCO0lBRUE7O0dBRUYsR0FDRWEsVUFBV04sSUFBSSxFQUFFO1FBQ2YsT0FBTyxJQUFJTixnQkFBZ0JNLE1BQU0sSUFBSSxDQUFDYixZQUFZO0lBQ3BEO0lBRUEsT0FBT0UsT0FBTSxHQUFLO1FBQ2hCLE1BQU1OLFVBQVUsSUFBSSxDQUFDTyxlQUFlO1FBQ3BDLElBQUksQ0FBQ0csV0FBVyxHQUFHO1FBQ25CLElBQUksQ0FBQ0wsV0FBVyxDQUFDTyxRQUFRWSxRQUFRLENBQUMsQ0FBQ0MsTUFBTSxDQUFDLElBQUksQ0FBQ2pCLFFBQVE7SUFDekQ7QUFDRjtBQUVBa0IsT0FBT0MsT0FBTyxHQUFHYiIsInNvdXJjZXMiOlsid2VicGFjazovL21vY2t1cGZsb3cvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9tb2NrL21vY2stY2xpZW50LmpzP2M3NmQiLCJ3ZWJwYWNrOi8vbW9ja3VwZmxvdy8uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL21vY2svbW9jay1jbGllbnQuanM/Yzc2ZCoiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgcHJvbWlzaWZ5IH0gPSByZXF1aXJlKCdub2RlOnV0aWwnKVxuY29uc3QgQ2xpZW50ID0gcmVxdWlyZSgnLi4vZGlzcGF0Y2hlci9jbGllbnQnKVxuY29uc3QgeyBidWlsZE1vY2tEaXNwYXRjaCB9ID0gcmVxdWlyZSgnLi9tb2NrLXV0aWxzJylcbmNvbnN0IHtcbiAga0Rpc3BhdGNoZXMsXG4gIGtNb2NrQWdlbnQsXG4gIGtDbG9zZSxcbiAga09yaWdpbmFsQ2xvc2UsXG4gIGtPcmlnaW4sXG4gIGtPcmlnaW5hbERpc3BhdGNoLFxuICBrQ29ubmVjdGVkXG59ID0gcmVxdWlyZSgnLi9tb2NrLXN5bWJvbHMnKVxuY29uc3QgeyBNb2NrSW50ZXJjZXB0b3IgfSA9IHJlcXVpcmUoJy4vbW9jay1pbnRlcmNlcHRvcicpXG5jb25zdCBTeW1ib2xzID0gcmVxdWlyZSgnLi4vY29yZS9zeW1ib2xzJylcbmNvbnN0IHsgSW52YWxpZEFyZ3VtZW50RXJyb3IgfSA9IHJlcXVpcmUoJy4uL2NvcmUvZXJyb3JzJylcblxuLyoqXG4gKiBNb2NrQ2xpZW50IHByb3ZpZGVzIGFuIEFQSSB0aGF0IGV4dGVuZHMgdGhlIENsaWVudCB0byBpbmZsdWVuY2UgdGhlIG1vY2tEaXNwYXRjaGVzLlxuICovXG5jbGFzcyBNb2NrQ2xpZW50IGV4dGVuZHMgQ2xpZW50IHtcbiAgY29uc3RydWN0b3IgKG9yaWdpbiwgb3B0cykge1xuICAgIHN1cGVyKG9yaWdpbiwgb3B0cylcblxuICAgIGlmICghb3B0cyB8fCAhb3B0cy5hZ2VudCB8fCB0eXBlb2Ygb3B0cy5hZ2VudC5kaXNwYXRjaCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdBcmd1bWVudCBvcHRzLmFnZW50IG11c3QgaW1wbGVtZW50IEFnZW50JylcbiAgICB9XG5cbiAgICB0aGlzW2tNb2NrQWdlbnRdID0gb3B0cy5hZ2VudFxuICAgIHRoaXNba09yaWdpbl0gPSBvcmlnaW5cbiAgICB0aGlzW2tEaXNwYXRjaGVzXSA9IFtdXG4gICAgdGhpc1trQ29ubmVjdGVkXSA9IDFcbiAgICB0aGlzW2tPcmlnaW5hbERpc3BhdGNoXSA9IHRoaXMuZGlzcGF0Y2hcbiAgICB0aGlzW2tPcmlnaW5hbENsb3NlXSA9IHRoaXMuY2xvc2UuYmluZCh0aGlzKVxuXG4gICAgdGhpcy5kaXNwYXRjaCA9IGJ1aWxkTW9ja0Rpc3BhdGNoLmNhbGwodGhpcylcbiAgICB0aGlzLmNsb3NlID0gdGhpc1trQ2xvc2VdXG4gIH1cblxuICBnZXQgW1N5bWJvbHMua0Nvbm5lY3RlZF0gKCkge1xuICAgIHJldHVybiB0aGlzW2tDb25uZWN0ZWRdXG4gIH1cblxuICAvKipcbiAgICogU2V0cyB1cCB0aGUgYmFzZSBpbnRlcmNlcHRvciBmb3IgbW9ja2luZyByZXBsaWVzIGZyb20gdW5kaWNpLlxuICAgKi9cbiAgaW50ZXJjZXB0IChvcHRzKSB7XG4gICAgcmV0dXJuIG5ldyBNb2NrSW50ZXJjZXB0b3Iob3B0cywgdGhpc1trRGlzcGF0Y2hlc10pXG4gIH1cblxuICBhc3luYyBba0Nsb3NlXSAoKSB7XG4gICAgYXdhaXQgcHJvbWlzaWZ5KHRoaXNba09yaWdpbmFsQ2xvc2VdKSgpXG4gICAgdGhpc1trQ29ubmVjdGVkXSA9IDBcbiAgICB0aGlzW2tNb2NrQWdlbnRdW1N5bWJvbHMua0NsaWVudHNdLmRlbGV0ZSh0aGlzW2tPcmlnaW5dKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gTW9ja0NsaWVudFxuIl0sIm5hbWVzIjpbInByb21pc2lmeSIsInJlcXVpcmUiLCJDbGllbnQiLCJidWlsZE1vY2tEaXNwYXRjaCIsImtEaXNwYXRjaGVzIiwia01vY2tBZ2VudCIsImtDbG9zZSIsImtPcmlnaW5hbENsb3NlIiwia09yaWdpbiIsImtPcmlnaW5hbERpc3BhdGNoIiwia0Nvbm5lY3RlZCIsIk1vY2tJbnRlcmNlcHRvciIsIlN5bWJvbHMiLCJJbnZhbGlkQXJndW1lbnRFcnJvciIsIk1vY2tDbGllbnQiLCJjb25zdHJ1Y3RvciIsIm9yaWdpbiIsIm9wdHMiLCJhZ2VudCIsImRpc3BhdGNoIiwiY2xvc2UiLCJiaW5kIiwiY2FsbCIsImludGVyY2VwdCIsImtDbGllbnRzIiwiZGVsZXRlIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/mock/mock-client.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/mock/mock-errors.js":
/*!*****************************************************!*\
  !*** ./node_modules/undici/lib/mock/mock-errors.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { UndiciError } = __webpack_require__(/*! ../core/errors */ \"(ssr)/./node_modules/undici/lib/core/errors.js\");\nclass MockNotMatchedError extends UndiciError {\n    constructor(message){\n        super(message);\n        Error.captureStackTrace(this, MockNotMatchedError);\n        this.name = \"MockNotMatchedError\";\n        this.message = message || \"The request does not match any registered mock dispatches\";\n        this.code = \"UND_MOCK_ERR_MOCK_NOT_MATCHED\";\n    }\n}\nmodule.exports = {\n    MockNotMatchedError\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9tb2NrL21vY2stZXJyb3JzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTSxFQUFFQSxXQUFBQSxFQUFhLEdBQUdDLG1CQUFPQSxDQUFDO0FBRWhDLE1BQU1DLDRCQUE0QkY7SUFDaENHLFlBQWFDLE9BQU8sQ0FBRTtRQUNwQixLQUFLLENBQUNBO1FBQ05DLE1BQU1DLGlCQUFpQixDQUFDLElBQUksRUFBRUo7UUFDOUIsSUFBSSxDQUFDSyxJQUFJLEdBQUc7UUFDWixJQUFJLENBQUNILE9BQU8sR0FBR0EsV0FBVztRQUMxQixJQUFJLENBQUNJLElBQUksR0FBRztJQUNkO0FBQ0Y7QUFFQUMsT0FBT0MsT0FBTyxHQUFHO0lBQ2ZSO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tb2NrdXBmbG93Ly4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvbW9jay9tb2NrLWVycm9ycy5qcz84NTBjIiwid2VicGFjazovL21vY2t1cGZsb3cvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9tb2NrL21vY2stZXJyb3JzLmpzPzg1MGMqIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IFVuZGljaUVycm9yIH0gPSByZXF1aXJlKCcuLi9jb3JlL2Vycm9ycycpXG5cbmNsYXNzIE1vY2tOb3RNYXRjaGVkRXJyb3IgZXh0ZW5kcyBVbmRpY2lFcnJvciB7XG4gIGNvbnN0cnVjdG9yIChtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSlcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBNb2NrTm90TWF0Y2hlZEVycm9yKVxuICAgIHRoaXMubmFtZSA9ICdNb2NrTm90TWF0Y2hlZEVycm9yJ1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgJ1RoZSByZXF1ZXN0IGRvZXMgbm90IG1hdGNoIGFueSByZWdpc3RlcmVkIG1vY2sgZGlzcGF0Y2hlcydcbiAgICB0aGlzLmNvZGUgPSAnVU5EX01PQ0tfRVJSX01PQ0tfTk9UX01BVENIRUQnXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIE1vY2tOb3RNYXRjaGVkRXJyb3Jcbn1cbiJdLCJuYW1lcyI6WyJVbmRpY2lFcnJvciIsInJlcXVpcmUiLCJNb2NrTm90TWF0Y2hlZEVycm9yIiwiY29uc3RydWN0b3IiLCJtZXNzYWdlIiwiRXJyb3IiLCJjYXB0dXJlU3RhY2tUcmFjZSIsIm5hbWUiLCJjb2RlIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/mock/mock-errors.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/mock/mock-interceptor.js":
/*!**********************************************************!*\
  !*** ./node_modules/undici/lib/mock/mock-interceptor.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { getResponseData, buildKey, addMockDispatch } = __webpack_require__(/*! ./mock-utils */ \"(ssr)/./node_modules/undici/lib/mock/mock-utils.js\");\nconst { kDispatches, kDispatchKey, kDefaultHeaders, kDefaultTrailers, kContentLength, kMockDispatch } = __webpack_require__(/*! ./mock-symbols */ \"(ssr)/./node_modules/undici/lib/mock/mock-symbols.js\");\nconst { InvalidArgumentError } = __webpack_require__(/*! ../core/errors */ \"(ssr)/./node_modules/undici/lib/core/errors.js\");\nconst { buildURL } = __webpack_require__(/*! ../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\");\n/**\n * Defines the scope API for an interceptor reply\n */ class MockScope {\n    constructor(mockDispatch){\n        this[kMockDispatch] = mockDispatch;\n    }\n    /**\n   * Delay a reply by a set amount in ms.\n   */ delay(waitInMs) {\n        if (typeof waitInMs !== \"number\" || !Number.isInteger(waitInMs) || waitInMs <= 0) {\n            throw new InvalidArgumentError(\"waitInMs must be a valid integer > 0\");\n        }\n        this[kMockDispatch].delay = waitInMs;\n        return this;\n    }\n    /**\n   * For a defined reply, never mark as consumed.\n   */ persist() {\n        this[kMockDispatch].persist = true;\n        return this;\n    }\n    /**\n   * Allow one to define a reply for a set amount of matching requests.\n   */ times(repeatTimes) {\n        if (typeof repeatTimes !== \"number\" || !Number.isInteger(repeatTimes) || repeatTimes <= 0) {\n            throw new InvalidArgumentError(\"repeatTimes must be a valid integer > 0\");\n        }\n        this[kMockDispatch].times = repeatTimes;\n        return this;\n    }\n}\n/**\n * Defines an interceptor for a Mock\n */ class MockInterceptor {\n    constructor(opts, mockDispatches){\n        if (typeof opts !== \"object\") {\n            throw new InvalidArgumentError(\"opts must be an object\");\n        }\n        if (typeof opts.path === \"undefined\") {\n            throw new InvalidArgumentError(\"opts.path must be defined\");\n        }\n        if (typeof opts.method === \"undefined\") {\n            opts.method = \"GET\";\n        }\n        // See https://github.com/nodejs/undici/issues/1245\n        // As per RFC 3986, clients are not supposed to send URI\n        // fragments to servers when they retrieve a document,\n        if (typeof opts.path === \"string\") {\n            if (opts.query) {\n                opts.path = buildURL(opts.path, opts.query);\n            } else {\n                // Matches https://github.com/nodejs/undici/blob/main/lib/web/fetch/index.js#L1811\n                const parsedURL = new URL(opts.path, \"data://\");\n                opts.path = parsedURL.pathname + parsedURL.search;\n            }\n        }\n        if (typeof opts.method === \"string\") {\n            opts.method = opts.method.toUpperCase();\n        }\n        this[kDispatchKey] = buildKey(opts);\n        this[kDispatches] = mockDispatches;\n        this[kDefaultHeaders] = {};\n        this[kDefaultTrailers] = {};\n        this[kContentLength] = false;\n    }\n    createMockScopeDispatchData({ statusCode, data, responseOptions }) {\n        const responseData = getResponseData(data);\n        const contentLength = this[kContentLength] ? {\n            \"content-length\": responseData.length\n        } : {};\n        const headers = {\n            ...this[kDefaultHeaders],\n            ...contentLength,\n            ...responseOptions.headers\n        };\n        const trailers = {\n            ...this[kDefaultTrailers],\n            ...responseOptions.trailers\n        };\n        return {\n            statusCode,\n            data,\n            headers,\n            trailers\n        };\n    }\n    validateReplyParameters(replyParameters) {\n        if (typeof replyParameters.statusCode === \"undefined\") {\n            throw new InvalidArgumentError(\"statusCode must be defined\");\n        }\n        if (typeof replyParameters.responseOptions !== \"object\" || replyParameters.responseOptions === null) {\n            throw new InvalidArgumentError(\"responseOptions must be an object\");\n        }\n    }\n    /**\n   * Mock an undici request with a defined reply.\n   */ reply(replyOptionsCallbackOrStatusCode) {\n        // Values of reply aren't available right now as they\n        // can only be available when the reply callback is invoked.\n        if (typeof replyOptionsCallbackOrStatusCode === \"function\") {\n            // We'll first wrap the provided callback in another function,\n            // this function will properly resolve the data from the callback\n            // when invoked.\n            const wrappedDefaultsCallback = (opts)=>{\n                // Our reply options callback contains the parameter for statusCode, data and options.\n                const resolvedData = replyOptionsCallbackOrStatusCode(opts);\n                // Check if it is in the right format\n                if (typeof resolvedData !== \"object\" || resolvedData === null) {\n                    throw new InvalidArgumentError(\"reply options callback must return an object\");\n                }\n                const replyParameters = {\n                    data: \"\",\n                    responseOptions: {},\n                    ...resolvedData\n                };\n                this.validateReplyParameters(replyParameters);\n                // Since the values can be obtained immediately we return them\n                // from this higher order function that will be resolved later.\n                return {\n                    ...this.createMockScopeDispatchData(replyParameters)\n                };\n            };\n            // Add usual dispatch data, but this time set the data parameter to function that will eventually provide data.\n            const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], wrappedDefaultsCallback);\n            return new MockScope(newMockDispatch);\n        }\n        // We can have either one or three parameters, if we get here,\n        // we should have 1-3 parameters. So we spread the arguments of\n        // this function to obtain the parameters, since replyData will always\n        // just be the statusCode.\n        const replyParameters = {\n            statusCode: replyOptionsCallbackOrStatusCode,\n            data: arguments[1] === undefined ? \"\" : arguments[1],\n            responseOptions: arguments[2] === undefined ? {} : arguments[2]\n        };\n        this.validateReplyParameters(replyParameters);\n        // Send in-already provided data like usual\n        const dispatchData = this.createMockScopeDispatchData(replyParameters);\n        const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], dispatchData);\n        return new MockScope(newMockDispatch);\n    }\n    /**\n   * Mock an undici request with a defined error.\n   */ replyWithError(error) {\n        if (typeof error === \"undefined\") {\n            throw new InvalidArgumentError(\"error must be defined\");\n        }\n        const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], {\n            error\n        });\n        return new MockScope(newMockDispatch);\n    }\n    /**\n   * Set default reply headers on the interceptor for subsequent replies\n   */ defaultReplyHeaders(headers) {\n        if (typeof headers === \"undefined\") {\n            throw new InvalidArgumentError(\"headers must be defined\");\n        }\n        this[kDefaultHeaders] = headers;\n        return this;\n    }\n    /**\n   * Set default reply trailers on the interceptor for subsequent replies\n   */ defaultReplyTrailers(trailers) {\n        if (typeof trailers === \"undefined\") {\n            throw new InvalidArgumentError(\"trailers must be defined\");\n        }\n        this[kDefaultTrailers] = trailers;\n        return this;\n    }\n    /**\n   * Set reply content length header for replies on the interceptor\n   */ replyContentLength() {\n        this[kContentLength] = true;\n        return this;\n    }\n}\nmodule.exports.MockInterceptor = MockInterceptor;\nmodule.exports.MockScope = MockScope;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9tb2NrL21vY2staW50ZXJjZXB0b3IuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNLEVBQUVBLGVBQWUsRUFBRUMsUUFBUSxFQUFFQyxlQUFBQSxFQUFpQixHQUFHQyxtQkFBT0EsQ0FBQztBQUMvRCxNQUFNLEVBQ0pDLFdBQVcsRUFDWEMsWUFBWSxFQUNaQyxlQUFlLEVBQ2ZDLGdCQUFnQixFQUNoQkMsY0FBYyxFQUNkQyxhQUFBQSxFQUNELEdBQUdOLG1CQUFPQSxDQUFDO0FBQ1osTUFBTSxFQUFFTyxvQkFBQUEsRUFBc0IsR0FBR1AsbUJBQU9BLENBQUM7QUFDekMsTUFBTSxFQUFFUSxRQUFBQSxFQUFVLEdBQUdSLG1CQUFPQSxDQUFDO0FBRTdCOztDQUVBLEdBQ0EsTUFBTVM7SUFDSkMsWUFBYUMsWUFBWSxDQUFFO1FBQ3pCLElBQUksQ0FBQ0wsY0FBYyxHQUFHSztJQUN4QjtJQUVBOztHQUVGLEdBQ0VDLE1BQU9DLFFBQVEsRUFBRTtRQUNmLElBQUksT0FBT0EsYUFBYSxZQUFZLENBQUNDLE9BQU9DLFNBQVMsQ0FBQ0YsYUFBYUEsWUFBWSxHQUFHO1lBQ2hGLE1BQU0sSUFBSU4scUJBQXFCO1FBQ2pDO1FBRUEsSUFBSSxDQUFDRCxjQUFjLENBQUNNLEtBQUssR0FBR0M7UUFDNUIsT0FBTyxJQUFJO0lBQ2I7SUFFQTs7R0FFRixHQUNFRyxVQUFXO1FBQ1QsSUFBSSxDQUFDVixjQUFjLENBQUNVLE9BQU8sR0FBRztRQUM5QixPQUFPLElBQUk7SUFDYjtJQUVBOztHQUVGLEdBQ0VDLE1BQU9DLFdBQVcsRUFBRTtRQUNsQixJQUFJLE9BQU9BLGdCQUFnQixZQUFZLENBQUNKLE9BQU9DLFNBQVMsQ0FBQ0csZ0JBQWdCQSxlQUFlLEdBQUc7WUFDekYsTUFBTSxJQUFJWCxxQkFBcUI7UUFDakM7UUFFQSxJQUFJLENBQUNELGNBQWMsQ0FBQ1csS0FBSyxHQUFHQztRQUM1QixPQUFPLElBQUk7SUFDYjtB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LEdBQUdrQztRQUN6QixPQUFPLElBQUk7SUFDYjtJQUVBOztHQUVGLEdBQ0VlLHFCQUFzQjtRQUNwQixJQUFJLENBQUNoRCxlQUFlLEdBQUc7UUFDdkIsT0FBTyxJQUFJO0lBQ2I7QUFDRjtBQUVBaUQsOEJBQThCLEdBQUduQztBQUNqQ21DLHdCQUF3QixHQUFHN0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tb2NrdXBmbG93Ly4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvbW9jay9tb2NrLWludGVyY2VwdG9yLmpzP2JjZTQiLCJ3ZWJwYWNrOi8vbW9ja3VwZmxvdy8uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL21vY2svbW9jay1pbnRlcmNlcHRvci5qcz9iY2U0KiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyBnZXRSZXNwb25zZURhdGEsIGJ1aWxkS2V5LCBhZGRNb2NrRGlzcGF0Y2ggfSA9IHJlcXVpcmUoJy4vbW9jay11dGlscycpXG5jb25zdCB7XG4gIGtEaXNwYXRjaGVzLFxuICBrRGlzcGF0Y2hLZXksXG4gIGtEZWZhdWx0SGVhZGVycyxcbiAga0RlZmF1bHRUcmFpbGVycyxcbiAga0NvbnRlbnRMZW5ndGgsXG4gIGtNb2NrRGlzcGF0Y2hcbn0gPSByZXF1aXJlKCcuL21vY2stc3ltYm9scycpXG5jb25zdCB7IEludmFsaWRBcmd1bWVudEVycm9yIH0gPSByZXF1aXJlKCcuLi9jb3JlL2Vycm9ycycpXG5jb25zdCB7IGJ1aWxkVVJMIH0gPSByZXF1aXJlKCcuLi9jb3JlL3V0aWwnKVxuXG4vKipcbiAqIERlZmluZXMgdGhlIHNjb3BlIEFQSSBmb3IgYW4gaW50ZXJjZXB0b3IgcmVwbHlcbiAqL1xuY2xhc3MgTW9ja1Njb3BlIHtcbiAgY29uc3RydWN0b3IgKG1vY2tEaXNwYXRjaCkge1xuICAgIHRoaXNba01vY2tEaXNwYXRjaF0gPSBtb2NrRGlzcGF0Y2hcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWxheSBhIHJlcGx5IGJ5IGEgc2V0IGFtb3VudCBpbiBtcy5cbiAgICovXG4gIGRlbGF5ICh3YWl0SW5Ncykge1xuICAgIGlmICh0eXBlb2Ygd2FpdEluTXMgIT09ICdudW1iZXInIHx8ICFOdW1iZXIuaXNJbnRlZ2VyKHdhaXRJbk1zKSB8fCB3YWl0SW5NcyA8PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ3dhaXRJbk1zIG11c3QgYmUgYSB2YWxpZCBpbnRlZ2VyID4gMCcpXG4gICAgfVxuXG4gICAgdGhpc1trTW9ja0Rpc3BhdGNoXS5kZWxheSA9IHdhaXRJbk1zXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBGb3IgYSBkZWZpbmVkIHJlcGx5LCBuZXZlciBtYXJrIGFzIGNvbnN1bWVkLlxuICAgKi9cbiAgcGVyc2lzdCAoKSB7XG4gICAgdGhpc1trTW9ja0Rpc3BhdGNoXS5wZXJzaXN0ID0gdHJ1ZVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogQWxsb3cgb25lIHRvIGRlZmluZSBhIHJlcGx5IGZvciBhIHNldCBhbW91bnQgb2YgbWF0Y2hpbmcgcmVxdWVzdHMuXG4gICAqL1xuICB0aW1lcyAocmVwZWF0VGltZXMpIHtcbiAgICBpZiAodHlwZW9mIHJlcGVhdFRpbWVzICE9PSAnbnVtYmVyJyB8fCAhTnVtYmVyLmlzSW50ZWdlcihyZXBlYXRUaW1lcykgfHwgcmVwZWF0VGltZXMgPD0gMCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdyZXBlYXRUaW1lcyBtdXN0IGJlIGEgdmFsaWQgaW50ZWdlciA+IDAnKVxuICAgIH1cblxuICAgIHRoaXNba01vY2tEaXNwYXRjaF0udGltZXMgPSByZXBlYXRUaW1lc1xuICAgIHJldHVybiB0aGlzXG4gIH1cbn1cblxuLyoqXG4gKiBEZWZpbmVzIGFuIGludGVyY2VwdG9yIGZvciBhIE1vY2tcbiAqL1xuY2xhc3MgTW9ja0ludGVyY2VwdG9yIHtcbiAgY29uc3RydWN0b3IgKG9wdHMsIG1vY2tEaXNwYXRjaGVzKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdvcHRzIG11c3QgYmUgYW4gb2JqZWN0JylcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvcHRzLnBhdGggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ29wdHMucGF0aCBtdXN0IGJlIGRlZmluZWQnKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdHMubWV0aG9kID09PSAndW5kZWZpbmVkJykge1xuICAgICAgb3B0cy5tZXRob2QgPSAnR0VUJ1xuICAgIH1cbiAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy91bmRpY2kvaXNzdWVzLzEyNDVcbiAgICAvLyBBcyBwZXIgUkZDIDM5ODYsIGNsaWVudHMgYXJlIG5vdCBzdXBwb3NlZCB0byBzZW5kIFVSSVxuICAgIC8vIGZyYWdtZW50cyB0byBzZXJ2ZXJzIHdoZW4gdGhleSByZXRyaWV2ZSBhIGRvY3VtZW50LFxuICAgIGlmICh0eXBlb2Ygb3B0cy5wYXRoID09PSAnc3RyaW5nJykge1xuICAgICAgaWYgKG9wdHMucXVlcnkpIHtcbiAgICAgICAgb3B0cy5wYXRoID0gYnVpbGRVUkwob3B0cy5wYXRoLCBvcHRzLnF1ZXJ5KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTWF0Y2hlcyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL3VuZGljaS9ibG9iL21haW4vbGliL3dlYi9mZXRjaC9pbmRleC5qcyNMMTgxMVxuICAgICAgICBjb25zdCBwYXJzZWRVUkwgPSBuZXcgVVJMKG9wdHMucGF0aCwgJ2RhdGE6Ly8nKVxuICAgICAgICBvcHRzLnBhdGggPSBwYXJzZWRVUkwucGF0aG5hbWUgKyBwYXJzZWRVUkwuc2VhcmNoXG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0cy5tZXRob2QgPT09ICdzdHJpbmcnKSB7XG4gICAgICBvcHRzLm1ldGhvZCA9IG9wdHMubWV0aG9kLnRvVXBwZXJDYXNlKClcbiAgICB9XG5cbiAgICB0aGlzW2tEaXNwYXRjaEtleV0gPSBidWlsZEtleShvcHRzKVxuICAgIHRoaXNba0Rpc3BhdGNoZXNdID0gbW9ja0Rpc3BhdGNoZXNcbiAgICB0aGlzW2tEZWZhdWx0SGVhZGVyc10gPSB7fVxuICAgIHRoaXNba0RlZmF1bHRUcmFpbGVyc10gPSB7fVxuICAgIHRoaXNba0NvbnRlbnRMZW5ndGhdID0gZmFsc2VcbiAgfVxuXG4gIGNyZWF0ZU1vY2tTY29wZURpc3BhdGNoRGF0YSAoeyBzdGF0dXNDb2RlLCBkYXRhLCByZXNwb25zZU9wdGlvbnMgfSkge1xuICAgIGNvbnN0IHJlc3BvbnNlRGF0YSA9IGdldFJlc3BvbnNlRGF0YShkYXRhKVxuICAgIGNvbnN0IGNvbnRlbnRMZW5ndGggPSB0aGlzW2tDb250ZW50TGVuZ3RoXSA/IHsgJ2NvbnRlbnQtbGVuZ3RoJzogcmVzcG9uc2VEYXRhLmxlbmd0aCB9IDoge31cbiAgICBjb25zdCBoZWFkZXJzID0geyAuLi50aGlzW2tEZWZhdWx0SGVhZGVyc10sIC4uLmNvbnRlbnRMZW5ndGgsIC4uLnJlc3BvbnNlT3B0aW9ucy5oZWFkZXJzIH1cbiAgICBjb25zdCB0cmFpbGVycyA9IHsgLi4udGhpc1trRGVmYXVsdFRyYWlsZXJzXSwgLi4ucmVzcG9uc2VPcHRpb25zLnRyYWlsZXJzIH1cblxuICAgIHJldHVybiB7IHN0YXR1c0NvZGUsIGRhdGEsIGhlYWRlcnMsIHRyYWlsZXJzIH1cbiAgfVxuXG4gIHZhbGlkYXRlUmVwbHlQYXJhbWV0ZXJzIChyZXBseVBhcmFtZXRlcnMpIHtcbiAgICBpZiAodHlwZW9mIHJlcGx5UGFyYW1ldGVycy5zdGF0dXNDb2RlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdzdGF0dXNDb2RlIG11c3QgYmUgZGVmaW5lZCcpXG4gICAgfVxuICAgIGlmICh0eXBlb2YgcmVwbHlQYXJhbWV0ZXJzLnJlc3BvbnNlT3B0aW9ucyAhPT0gJ29iamVjdCcgfHwgcmVwbHlQYXJhbWV0ZXJzLnJlc3BvbnNlT3B0aW9ucyA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdyZXNwb25zZU9wdGlvbnMgbXVzdCBiZSBhbiBvYmplY3QnKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBNb2NrIGFuIHVuZGljaSByZXF1ZXN0IHdpdGggYSBkZWZpbmVkIHJlcGx5LlxuICAgKi9cbiAgcmVwbHkgKHJlcGx5T3B0aW9uc0NhbGxiYWNrT3JTdGF0dXNDb2RlKSB7XG4gICAgLy8gVmFsdWVzIG9mIHJlcGx5IGFyZW4ndCBhdmFpbGFibGUgcmlnaHQgbm93IGFzIHRoZXlcbiAgICAvLyBjYW4gb25seSBiZSBhdmFpbGFibGUgd2hlbiB0aGUgcmVwbHkgY2FsbGJhY2sgaXMgaW52b2tlZC5cbiAgICBpZiAodHlwZW9mIHJlcGx5T3B0aW9uc0NhbGxiYWNrT3JTdGF0dXNDb2RlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBXZSdsbCBmaXJzdCB3cmFwIHRoZSBwcm92aWRlZCBjYWxsYmFjayBpbiBhbm90aGVyIGZ1bmN0aW9uLFxuICAgICAgLy8gdGhpcyBmdW5jdGlvbiB3aWxsIHByb3Blcmx5IHJlc29sdmUgdGhlIGRhdGEgZnJvbSB0aGUgY2FsbGJhY2tcbiAgICAgIC8vIHdoZW4gaW52b2tlZC5cbiAgICAgIGNvbnN0IHdyYXBwZWREZWZhdWx0c0NhbGxiYWNrID0gKG9wdHMpID0+IHtcbiAgICAgICAgLy8gT3VyIHJlcGx5IG9wdGlvbnMgY2FsbGJhY2sgY29udGFpbnMgdGhlIHBhcmFtZXRlciBmb3Igc3RhdHVzQ29kZSwgZGF0YSBhbmQgb3B0aW9ucy5cbiAgICAgICAgY29uc3QgcmVzb2x2ZWREYXRhID0gcmVwbHlPcHRpb25zQ2FsbGJhY2tPclN0YXR1c0NvZGUob3B0cylcblxuICAgICAgICAvLyBDaGVjayBpZiBpdCBpcyBpbiB0aGUgcmlnaHQgZm9ybWF0XG4gICAgICAgIGlmICh0eXBlb2YgcmVzb2x2ZWREYXRhICE9PSAnb2JqZWN0JyB8fCByZXNvbHZlZERhdGEgPT09IG51bGwpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ3JlcGx5IG9wdGlvbnMgY2FsbGJhY2sgbXVzdCByZXR1cm4gYW4gb2JqZWN0JylcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJlcGx5UGFyYW1ldGVycyA9IHsgZGF0YTogJycsIHJlc3BvbnNlT3B0aW9uczoge30sIC4uLnJlc29sdmVkRGF0YSB9XG4gICAgICAgIHRoaXMudmFsaWRhdGVSZXBseVBhcmFtZXRlcnMocmVwbHlQYXJhbWV0ZXJzKVxuICAgICAgICAvLyBTaW5jZSB0aGUgdmFsdWVzIGNhbiBiZSBvYnRhaW5lZCBpbW1lZGlhdGVseSB3ZSByZXR1cm4gdGhlbVxuICAgICAgICAvLyBmcm9tIHRoaXMgaGlnaGVyIG9yZGVyIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSByZXNvbHZlZCBsYXRlci5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi50aGlzLmNyZWF0ZU1vY2tTY29wZURpc3BhdGNoRGF0YShyZXBseVBhcmFtZXRlcnMpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gQWRkIHVzdWFsIGRpc3BhdGNoIGRhdGEsIGJ1dCB0aGlzIHRpbWUgc2V0IHRoZSBkYXRhIHBhcmFtZXRlciB0byBmdW5jdGlvbiB0aGF0IHdpbGwgZXZlbnR1YWxseSBwcm92aWRlIGRhdGEuXG4gICAgICBjb25zdCBuZXdNb2NrRGlzcGF0Y2ggPSBhZGRNb2NrRGlzcGF0Y2godGhpc1trRGlzcGF0Y2hlc10sIHRoaXNba0Rpc3BhdGNoS2V5XSwgd3JhcHBlZERlZmF1bHRzQ2FsbGJhY2spXG4gICAgICByZXR1cm4gbmV3IE1vY2tTY29wZShuZXdNb2NrRGlzcGF0Y2gpXG4gICAgfVxuXG4gICAgLy8gV2UgY2FuIGhhdmUgZWl0aGVyIG9uZSBvciB0aHJlZSBwYXJhbWV0ZXJzLCBpZiB3ZSBnZXQgaGVyZSxcbiAgICAvLyB3ZSBzaG91bGQgaGF2ZSAxLTMgcGFyYW1ldGVycy4gU28gd2Ugc3ByZWFkIHRoZSBhcmd1bWVudHMgb2ZcbiAgICAvLyB0aGlzIGZ1bmN0aW9uIHRvIG9idGFpbiB0aGUgcGFyYW1ldGVycywgc2luY2UgcmVwbHlEYXRhIHdpbGwgYWx3YXlzXG4gICAgLy8ganVzdCBiZSB0aGUgc3RhdHVzQ29kZS5cbiAgICBjb25zdCByZXBseVBhcmFtZXRlcnMgPSB7XG4gICAgICBzdGF0dXNDb2RlOiByZXBseU9wdGlvbnNDYWxsYmFja09yU3RhdHVzQ29kZSxcbiAgICAgIGRhdGE6IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8gJycgOiBhcmd1bWVudHNbMV0sXG4gICAgICByZXNwb25zZU9wdGlvbnM6IGFyZ3VtZW50c1syXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMl1cbiAgICB9XG4gICAgdGhpcy52YWxpZGF0ZVJlcGx5UGFyYW1ldGVycyhyZXBseVBhcmFtZXRlcnMpXG5cbiAgICAvLyBTZW5kIGluLWFscmVhZHkgcHJvdmlkZWQgZGF0YSBsaWtlIHVzdWFsXG4gICAgY29uc3QgZGlzcGF0Y2hEYXRhID0gdGhpcy5jcmVhdGVNb2NrU2NvcGVEaXNwYXRjaERhdGEocmVwbHlQYXJhbWV0ZXJzKVxuICAgIGNvbnN0IG5ld01vY2tEaXNwYXRjaCA9IGFkZE1vY2tEaXNwYXRjaCh0aGlzW2tEaXNwYXRjaGVzXSwgdGhpc1trRGlzcGF0Y2hLZXldLCBkaXNwYXRjaERhdGEpXG4gICAgcmV0dXJuIG5ldyBNb2NrU2NvcGUobmV3TW9ja0Rpc3BhdGNoKVxuICB9XG5cbiAgLyoqXG4gICAqIE1vY2sgYW4gdW5kaWNpIHJlcXVlc3Qgd2l0aCBhIGRlZmluZWQgZXJyb3IuXG4gICAqL1xuICByZXBseVdpdGhFcnJvciAoZXJyb3IpIHtcbiAgICBpZiAodHlwZW9mIGVycm9yID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdlcnJvciBtdXN0IGJlIGRlZmluZWQnKVxuICAgIH1cblxuICAgIGNvbnN0IG5ld01vY2tEaXNwYXRjaCA9IGFkZE1vY2tEaXNwYXRjaCh0aGlzW2tEaXNwYXRjaGVzXSwgdGhpc1trRGlzcGF0Y2hLZXldLCB7IGVycm9yIH0pXG4gICAgcmV0dXJuIG5ldyBNb2NrU2NvcGUobmV3TW9ja0Rpc3BhdGNoKVxuICB9XG5cbiAgLyoqXG4gICAqIFNldCBkZWZhdWx0IHJlcGx5IGhlYWRlcnMgb24gdGhlIGludGVyY2VwdG9yIGZvciBzdWJzZXF1ZW50IHJlcGxpZXNcbiAgICovXG4gIGRlZmF1bHRSZXBseUhlYWRlcnMgKGhlYWRlcnMpIHtcbiAgICBpZiAodHlwZW9mIGhlYWRlcnMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2hlYWRlcnMgbXVzdCBiZSBkZWZpbmVkJylcbiAgICB9XG5cbiAgICB0aGlzW2tEZWZhdWx0SGVhZGVyc10gPSBoZWFkZXJzXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgZGVmYXVsdCByZXBseSB0cmFpbGVycyBvbiB0aGUgaW50ZXJjZXB0b3IgZm9yIHN1YnNlcXVlbnQgcmVwbGllc1xuICAgKi9cbiAgZGVmYXVsdFJlcGx5VHJhaWxlcnMgKHRyYWlsZXJzKSB7XG4gICAgaWYgKHR5cGVvZiB0cmFpbGVycyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcigndHJhaWxlcnMgbXVzdCBiZSBkZWZpbmVkJylcbiAgICB9XG5cbiAgICB0aGlzW2tEZWZhdWx0VHJhaWxlcnNdID0gdHJhaWxlcnNcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCByZXBseSBjb250ZW50IGxlbmd0aCBoZWFkZXIgZm9yIHJlcGxpZXMgb24gdGhlIGludGVyY2VwdG9yXG4gICAqL1xuICByZXBseUNvbnRlbnRMZW5ndGggKCkge1xuICAgIHRoaXNba0NvbnRlbnRMZW5ndGhdID0gdHJ1ZVxuICAgIHJldHVybiB0aGlzXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMuTW9ja0ludGVyY2VwdG9yID0gTW9ja0ludGVyY2VwdG9yXG5tb2R1bGUuZXhwb3J0cy5Nb2NrU2NvcGUgPSBNb2NrU2NvcGVcbiJdLCJuYW1lcyI6WyJnZXRSZXNwb25zZURhdGEiLCJidWlsZEtleSIsImFkZE1vY2tEaXNwYXRjaCIsInJlcXVpcmUiLCJrRGlzcGF0Y2hlcyIsImtEaXNwYXRjaEtleSIsImtEZWZhdWx0SGVhZGVycyIsImtEZWZhdWx0VHJhaWxlcnMiLCJrQ29udGVudExlbmd0aCIsImtNb2NrRGlzcGF0Y2giLCJJbnZhbGlkQXJndW1lbnRFcnJvciIsImJ1aWxkVVJMIiwiTW9ja1Njb3BlIiwiY29uc3RydWN0b3IiLCJtb2NrRGlzcGF0Y2giLCJkZWxheSIsIndhaXRJbk1zIiwiTnVtYmVyIiwiaXNJbnRlZ2VyIiwicGVyc2lzdCIsInRpbWVzIiwicmVwZWF0VGltZXMiLCJNb2NrSW50ZXJjZXB0b3IiLCJvcHRzIiwibW9ja0Rpc3BhdGNoZXMiLCJwYXRoIiwibWV0aG9kIiwicXVlcnkiLCJwYXJzZWRVUkwiLCJVUkwiLCJwYXRobmFtZSIsInNlYXJjaCIsInRvVXBwZXJDYXNlIiwiY3JlYXRlTW9ja1Njb3BlRGlzcGF0Y2hEYXRhIiwic3RhdHVzQ29kZSIsImRhdGEiLCJyZXNwb25zZU9wdGlvbnMiLCJyZXNwb25zZURhdGEiLCJjb250ZW50TGVuZ3RoIiwibGVuZ3RoIiwiaGVhZGVycyIsInRyYWlsZXJzIiwidmFsaWRhdGVSZXBseVBhcmFtZXRlcnMiLCJyZXBseVBhcmFtZXRlcnMiLCJyZXBseSIsInJlcGx5T3B0aW9uc0NhbGxiYWNrT3JTdGF0dXNDb2RlIiwid3JhcHBlZERlZmF1bHRzQ2FsbGJhY2siLCJyZXNvbHZlZERhdGEiLCJuZXdNb2NrRGlzcGF0Y2giLCJhcmd1bWVudHMiLCJ1bmRlZmluZWQiLCJkaXNwYXRjaERhdGEiLCJyZXBseVdpdGhFcnJvciIsImVycm9yIiwiZGVmYXVsdFJlcGx5SGVhZGVycyIsImRlZmF1bHRSZXBseVRyYWlsZXJzIiwicmVwbHlDb250ZW50TGVuZ3RoIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/mock/mock-interceptor.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/mock/mock-pool.js":
/*!***************************************************!*\
  !*** ./node_modules/undici/lib/mock/mock-pool.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { promisify } = __webpack_require__(/*! node:util */ \"node:util\");\nconst Pool = __webpack_require__(/*! ../dispatcher/pool */ \"(ssr)/./node_modules/undici/lib/dispatcher/pool.js\");\nconst { buildMockDispatch } = __webpack_require__(/*! ./mock-utils */ \"(ssr)/./node_modules/undici/lib/mock/mock-utils.js\");\nconst { kDispatches, kMockAgent, kClose, kOriginalClose, kOrigin, kOriginalDispatch, kConnected } = __webpack_require__(/*! ./mock-symbols */ \"(ssr)/./node_modules/undici/lib/mock/mock-symbols.js\");\nconst { MockInterceptor } = __webpack_require__(/*! ./mock-interceptor */ \"(ssr)/./node_modules/undici/lib/mock/mock-interceptor.js\");\nconst Symbols = __webpack_require__(/*! ../core/symbols */ \"(ssr)/./node_modules/undici/lib/core/symbols.js\");\nconst { InvalidArgumentError } = __webpack_require__(/*! ../core/errors */ \"(ssr)/./node_modules/undici/lib/core/errors.js\");\n/**\n * MockPool provides an API that extends the Pool to influence the mockDispatches.\n */ class MockPool extends Pool {\n    constructor(origin, opts){\n        super(origin, opts);\n        if (!opts || !opts.agent || typeof opts.agent.dispatch !== \"function\") {\n            throw new InvalidArgumentError(\"Argument opts.agent must implement Agent\");\n        }\n        this[kMockAgent] = opts.agent;\n        this[kOrigin] = origin;\n        this[kDispatches] = [];\n        this[kConnected] = 1;\n        this[kOriginalDispatch] = this.dispatch;\n        this[kOriginalClose] = this.close.bind(this);\n        this.dispatch = buildMockDispatch.call(this);\n        this.close = this[kClose];\n    }\n    get [Symbols.kConnected]() {\n        return this[kConnected];\n    }\n    /**\n   * Sets up the base interceptor for mocking replies from undici.\n   */ intercept(opts) {\n        return new MockInterceptor(opts, this[kDispatches]);\n    }\n    async [kClose]() {\n        await promisify(this[kOriginalClose])();\n        this[kConnected] = 0;\n        this[kMockAgent][Symbols.kClients].delete(this[kOrigin]);\n    }\n}\nmodule.exports = MockPool;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9tb2NrL21vY2stcG9vbC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU0sRUFBRUEsU0FBQUEsRUFBVyxHQUFHQyxtQkFBT0EsQ0FBQztBQUM5QixNQUFNQyxPQUFPRCxtQkFBT0EsQ0FBQztBQUNyQixNQUFNLEVBQUVFLGlCQUFBQSxFQUFtQixHQUFHRixtQkFBT0EsQ0FBQztBQUN0QyxNQUFNLEVBQ0pHLFdBQVcsRUFDWEMsVUFBVSxFQUNWQyxNQUFNLEVBQ05DLGNBQWMsRUFDZEMsT0FBTyxFQUNQQyxpQkFBaUIsRUFDakJDLFVBQUFBLEVBQ0QsR0FBR1QsbUJBQU9BLENBQUM7QUFDWixNQUFNLEVBQUVVLGVBQUFBLEVBQWlCLEdBQUdWLG1CQUFPQSxDQUFDO0FBQ3BDLE1BQU1XLFVBQVVYLG1CQUFPQSxDQUFDO0FBQ3hCLE1BQU0sRUFBRVksb0JBQUFBLEVBQXNCLEdBQUdaLG1CQUFPQSxDQUFDO0FBRXpDOztDQUVBLEdBQ0EsTUFBTWEsaUJBQWlCWjtJQUNyQmEsWUFBYUMsTUFBTSxFQUFFQyxJQUFJLENBQUU7UUFDekIsS0FBSyxDQUFDRCxRQUFRQztRQUVkLElBQUksQ0FBQ0EsUUFBUSxDQUFDQSxLQUFLQyxLQUFLLElBQUksT0FBT0QsS0FBS0MsS0FBSyxDQUFDQyxRQUFRLEtBQUssWUFBWTtZQUNyRSxNQUFNLElBQUlOLHFCQUFxQjtRQUNqQztRQUVBLElBQUksQ0FBQ1IsV0FBVyxHQUFHWSxLQUFLQyxLQUFLO1FBQzdCLElBQUksQ0FBQ1YsUUFBUSxHQUFHUTtRQUNoQixJQUFJLENBQUNaLFlBQVksR0FBRyxFQUFFO1FBQ3RCLElBQUksQ0FBQ00sV0FBVyxHQUFHO1FBQ25CLElBQUksQ0FBQ0Qsa0JBQWtCLEdBQUcsSUFBSSxDQUFDVSxRQUFRO1FBQ3ZDLElBQUksQ0FBQ1osZUFBZSxHQUFHLElBQUksQ0FBQ2EsS0FBSyxDQUFDQyxJQUFJLENBQUMsSUFBSTtRQUUzQyxJQUFJLENBQUNGLFFBQVEsR0FBR2hCLGtCQUFrQm1CLElBQUksQ0FBQyxJQUFJO1FBQzNDLElBQUksQ0FBQ0YsS0FBSyxHQUFHLElBQUksQ0FBQ2QsT0FBTztJQUMzQjtJQUVBLEtBQUtNLFFBQVFGLFVBQVUsSUFBSztRQUMxQixPQUFPLElBQUksQ0FBQ0EsV0FBVztJQUN6QjtJQUVBOztHQUVGLEdBQ0VhLFVBQVdOLElBQUksRUFBRTtRQUNmLE9BQU8sSUFBSU4sZ0JBQWdCTSxNQUFNLElBQUksQ0FBQ2IsWUFBWTtJQUNwRDtJQUVBLE9BQU9FLE9BQU0sR0FBSztRQUNoQixNQUFNTixVQUFVLElBQUksQ0FBQ08sZUFBZTtRQUNwQyxJQUFJLENBQUNHLFdBQVcsR0FBRztRQUNuQixJQUFJLENBQUNMLFdBQVcsQ0FBQ08sUUFBUVksUUFBUSxDQUFDLENBQUNDLE1BQU0sQ0FBQyxJQUFJLENBQUNqQixRQUFRO0lBQ3pEO0FBQ0Y7QUFFQWtCLE9BQU9DLE9BQU8sR0FBR2IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tb2NrdXBmbG93Ly4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvbW9jay9tb2NrLXBvb2wuanM/NGE2MCIsIndlYnBhY2s6Ly9tb2NrdXBmbG93Ly4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvbW9jay9tb2NrLXBvb2wuanM/NGE2MCoiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgcHJvbWlzaWZ5IH0gPSByZXF1aXJlKCdub2RlOnV0aWwnKVxuY29uc3QgUG9vbCA9IHJlcXVpcmUoJy4uL2Rpc3BhdGNoZXIvcG9vbCcpXG5jb25zdCB7IGJ1aWxkTW9ja0Rpc3BhdGNoIH0gPSByZXF1aXJlKCcuL21vY2stdXRpbHMnKVxuY29uc3Qge1xuICBrRGlzcGF0Y2hlcyxcbiAga01vY2tBZ2VudCxcbiAga0Nsb3NlLFxuICBrT3JpZ2luYWxDbG9zZSxcbiAga09yaWdpbixcbiAga09yaWdpbmFsRGlzcGF0Y2gsXG4gIGtDb25uZWN0ZWRcbn0gPSByZXF1aXJlKCcuL21vY2stc3ltYm9scycpXG5jb25zdCB7IE1vY2tJbnRlcmNlcHRvciB9ID0gcmVxdWlyZSgnLi9tb2NrLWludGVyY2VwdG9yJylcbmNvbnN0IFN5bWJvbHMgPSByZXF1aXJlKCcuLi9jb3JlL3N5bWJvbHMnKVxuY29uc3QgeyBJbnZhbGlkQXJndW1lbnRFcnJvciB9ID0gcmVxdWlyZSgnLi4vY29yZS9lcnJvcnMnKVxuXG4vKipcbiAqIE1vY2tQb29sIHByb3ZpZGVzIGFuIEFQSSB0aGF0IGV4dGVuZHMgdGhlIFBvb2wgdG8gaW5mbHVlbmNlIHRoZSBtb2NrRGlzcGF0Y2hlcy5cbiAqL1xuY2xhc3MgTW9ja1Bvb2wgZXh0ZW5kcyBQb29sIHtcbiAgY29uc3RydWN0b3IgKG9yaWdpbiwgb3B0cykge1xuICAgIHN1cGVyKG9yaWdpbiwgb3B0cylcblxuICAgIGlmICghb3B0cyB8fCAhb3B0cy5hZ2VudCB8fCB0eXBlb2Ygb3B0cy5hZ2VudC5kaXNwYXRjaCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdBcmd1bWVudCBvcHRzLmFnZW50IG11c3QgaW1wbGVtZW50IEFnZW50JylcbiAgICB9XG5cbiAgICB0aGlzW2tNb2NrQWdlbnRdID0gb3B0cy5hZ2VudFxuICAgIHRoaXNba09yaWdpbl0gPSBvcmlnaW5cbiAgICB0aGlzW2tEaXNwYXRjaGVzXSA9IFtdXG4gICAgdGhpc1trQ29ubmVjdGVkXSA9IDFcbiAgICB0aGlzW2tPcmlnaW5hbERpc3BhdGNoXSA9IHRoaXMuZGlzcGF0Y2hcbiAgICB0aGlzW2tPcmlnaW5hbENsb3NlXSA9IHRoaXMuY2xvc2UuYmluZCh0aGlzKVxuXG4gICAgdGhpcy5kaXNwYXRjaCA9IGJ1aWxkTW9ja0Rpc3BhdGNoLmNhbGwodGhpcylcbiAgICB0aGlzLmNsb3NlID0gdGhpc1trQ2xvc2VdXG4gIH1cblxuICBnZXQgW1N5bWJvbHMua0Nvbm5lY3RlZF0gKCkge1xuICAgIHJldHVybiB0aGlzW2tDb25uZWN0ZWRdXG4gIH1cblxuICAvKipcbiAgICogU2V0cyB1cCB0aGUgYmFzZSBpbnRlcmNlcHRvciBmb3IgbW9ja2luZyByZXBsaWVzIGZyb20gdW5kaWNpLlxuICAgKi9cbiAgaW50ZXJjZXB0IChvcHRzKSB7XG4gICAgcmV0dXJuIG5ldyBNb2NrSW50ZXJjZXB0b3Iob3B0cywgdGhpc1trRGlzcGF0Y2hlc10pXG4gIH1cblxuICBhc3luYyBba0Nsb3NlXSAoKSB7XG4gICAgYXdhaXQgcHJvbWlzaWZ5KHRoaXNba09yaWdpbmFsQ2xvc2VdKSgpXG4gICAgdGhpc1trQ29ubmVjdGVkXSA9IDBcbiAgICB0aGlzW2tNb2NrQWdlbnRdW1N5bWJvbHMua0NsaWVudHNdLmRlbGV0ZSh0aGlzW2tPcmlnaW5dKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gTW9ja1Bvb2xcbiJdLCJuYW1lcyI6WyJwcm9taXNpZnkiLCJyZXF1aXJlIiwiUG9vbCIsImJ1aWxkTW9ja0Rpc3BhdGNoIiwia0Rpc3BhdGNoZXMiLCJrTW9ja0FnZW50Iiwia0Nsb3NlIiwia09yaWdpbmFsQ2xvc2UiLCJrT3JpZ2luIiwia09yaWdpbmFsRGlzcGF0Y2giLCJrQ29ubmVjdGVkIiwiTW9ja0ludGVyY2VwdG9yIiwiU3ltYm9scyIsIkludmFsaWRBcmd1bWVudEVycm9yIiwiTW9ja1Bvb2wiLCJjb25zdHJ1Y3RvciIsIm9yaWdpbiIsIm9wdHMiLCJhZ2VudCIsImRpc3BhdGNoIiwiY2xvc2UiLCJiaW5kIiwiY2FsbCIsImludGVyY2VwdCIsImtDbGllbnRzIiwiZGVsZXRlIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/mock/mock-pool.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/mock/mock-symbols.js":
/*!******************************************************!*\
  !*** ./node_modules/undici/lib/mock/mock-symbols.js ***!
  \******************************************************/
/***/ ((module) => {

eval("\nmodule.exports = {\n    kAgent: Symbol(\"agent\"),\n    kOptions: Symbol(\"options\"),\n    kFactory: Symbol(\"factory\"),\n    kDispatches: Symbol(\"dispatches\"),\n    kDispatchKey: Symbol(\"dispatch key\"),\n    kDefaultHeaders: Symbol(\"default headers\"),\n    kDefaultTrailers: Symbol(\"default trailers\"),\n    kContentLength: Symbol(\"content length\"),\n    kMockAgent: Symbol(\"mock agent\"),\n    kMockAgentSet: Symbol(\"mock agent set\"),\n    kMockAgentGet: Symbol(\"mock agent get\"),\n    kMockDispatch: Symbol(\"mock dispatch\"),\n    kClose: Symbol(\"close\"),\n    kOriginalClose: Symbol(\"original agent close\"),\n    kOrigin: Symbol(\"origin\"),\n    kIsMockActive: Symbol(\"is mock active\"),\n    kNetConnect: Symbol(\"net connect\"),\n    kGetNetConnect: Symbol(\"get net connect\"),\n    kConnected: Symbol(\"connected\")\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9tb2NrL21vY2stc3ltYm9scy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBQSxPQUFPQyxPQUFPLEdBQUc7SUFDZkMsUUFBUUMsT0FBTztJQUNmQyxVQUFVRCxPQUFPO0lBQ2pCRSxVQUFVRixPQUFPO0lBQ2pCRyxhQUFhSCxPQUFPO0lBQ3BCSSxjQUFjSixPQUFPO0lBQ3JCSyxpQkFBaUJMLE9BQU87SUFDeEJNLGtCQUFrQk4sT0FBTztJQUN6Qk8sZ0JBQWdCUCxPQUFPO0lBQ3ZCUSxZQUFZUixPQUFPO0lBQ25CUyxlQUFlVCxPQUFPO0lBQ3RCVSxlQUFlVixPQUFPO0lBQ3RCVyxlQUFlWCxPQUFPO0lBQ3RCWSxRQUFRWixPQUFPO0lBQ2ZhLGdCQUFnQmIsT0FBTztJQUN2QmMsU0FBU2QsT0FBTztJQUNoQmUsZUFBZWYsT0FBTztJQUN0QmdCLGFBQWFoQixPQUFPO0lBQ3BCaUIsZ0JBQWdCakIsT0FBTztJQUN2QmtCLFlBQVlsQixPQUFPO0FBQ3JCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbW9ja3VwZmxvdy8uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL21vY2svbW9jay1zeW1ib2xzLmpzPzVhMWEiLCJ3ZWJwYWNrOi8vbW9ja3VwZmxvdy8uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL21vY2svbW9jay1zeW1ib2xzLmpzPzVhMWEqIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAga0FnZW50OiBTeW1ib2woJ2FnZW50JyksXG4gIGtPcHRpb25zOiBTeW1ib2woJ29wdGlvbnMnKSxcbiAga0ZhY3Rvcnk6IFN5bWJvbCgnZmFjdG9yeScpLFxuICBrRGlzcGF0Y2hlczogU3ltYm9sKCdkaXNwYXRjaGVzJyksXG4gIGtEaXNwYXRjaEtleTogU3ltYm9sKCdkaXNwYXRjaCBrZXknKSxcbiAga0RlZmF1bHRIZWFkZXJzOiBTeW1ib2woJ2RlZmF1bHQgaGVhZGVycycpLFxuICBrRGVmYXVsdFRyYWlsZXJzOiBTeW1ib2woJ2RlZmF1bHQgdHJhaWxlcnMnKSxcbiAga0NvbnRlbnRMZW5ndGg6IFN5bWJvbCgnY29udGVudCBsZW5ndGgnKSxcbiAga01vY2tBZ2VudDogU3ltYm9sKCdtb2NrIGFnZW50JyksXG4gIGtNb2NrQWdlbnRTZXQ6IFN5bWJvbCgnbW9jayBhZ2VudCBzZXQnKSxcbiAga01vY2tBZ2VudEdldDogU3ltYm9sKCdtb2NrIGFnZW50IGdldCcpLFxuICBrTW9ja0Rpc3BhdGNoOiBTeW1ib2woJ21vY2sgZGlzcGF0Y2gnKSxcbiAga0Nsb3NlOiBTeW1ib2woJ2Nsb3NlJyksXG4gIGtPcmlnaW5hbENsb3NlOiBTeW1ib2woJ29yaWdpbmFsIGFnZW50IGNsb3NlJyksXG4gIGtPcmlnaW46IFN5bWJvbCgnb3JpZ2luJyksXG4gIGtJc01vY2tBY3RpdmU6IFN5bWJvbCgnaXMgbW9jayBhY3RpdmUnKSxcbiAga05ldENvbm5lY3Q6IFN5bWJvbCgnbmV0IGNvbm5lY3QnKSxcbiAga0dldE5ldENvbm5lY3Q6IFN5bWJvbCgnZ2V0IG5ldCBjb25uZWN0JyksXG4gIGtDb25uZWN0ZWQ6IFN5bWJvbCgnY29ubmVjdGVkJylcbn1cbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwia0FnZW50IiwiU3ltYm9sIiwia09wdGlvbnMiLCJrRmFjdG9yeSIsImtEaXNwYXRjaGVzIiwia0Rpc3BhdGNoS2V5Iiwia0RlZmF1bHRIZWFkZXJzIiwia0RlZmF1bHRUcmFpbGVycyIsImtDb250ZW50TGVuZ3RoIiwia01vY2tBZ2VudCIsImtNb2NrQWdlbnRTZXQiLCJrTW9ja0FnZW50R2V0Iiwia01vY2tEaXNwYXRjaCIsImtDbG9zZSIsImtPcmlnaW5hbENsb3NlIiwia09yaWdpbiIsImtJc01vY2tBY3RpdmUiLCJrTmV0Q29ubmVjdCIsImtHZXROZXRDb25uZWN0Iiwia0Nvbm5lY3RlZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/mock/mock-symbols.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/mock/mock-utils.js":
/*!****************************************************!*\
  !*** ./node_modules/undici/lib/mock/mock-utils.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { MockNotMatchedError } = __webpack_require__(/*! ./mock-errors */ \"(ssr)/./node_modules/undici/lib/mock/mock-errors.js\");\nconst { kDispatches, kMockAgent, kOriginalDispatch, kOrigin, kGetNetConnect } = __webpack_require__(/*! ./mock-symbols */ \"(ssr)/./node_modules/undici/lib/mock/mock-symbols.js\");\nconst { buildURL } = __webpack_require__(/*! ../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\");\nconst { STATUS_CODES } = __webpack_require__(/*! node:http */ \"node:http\");\nconst { types: { isPromise } } = __webpack_require__(/*! node:util */ \"node:util\");\nfunction matchValue(match, value) {\n    if (typeof match === \"string\") {\n        return match === value;\n    }\n    if (match instanceof RegExp) {\n        return match.test(value);\n    }\n    if (typeof match === \"function\") {\n        return match(value) === true;\n    }\n    return false;\n}\nfunction lowerCaseEntries(headers) {\n    return Object.fromEntries(Object.entries(headers).map(([headerName, headerValue])=>{\n        return [\n            headerName.toLocaleLowerCase(),\n            headerValue\n        ];\n    }));\n}\n/**\n * @param {import('../../index').Headers|string[]|Record<string, string>} headers\n * @param {string} key\n */ function getHeaderByName(headers, key) {\n    if (Array.isArray(headers)) {\n        for(let i = 0; i < headers.length; i += 2){\n            if (headers[i].toLocaleLowerCase() === key.toLocaleLowerCase()) {\n                return headers[i + 1];\n            }\n        }\n        return undefined;\n    } else if (typeof headers.get === \"function\") {\n        return headers.get(key);\n    } else {\n        return lowerCaseEntries(headers)[key.toLocaleLowerCase()];\n    }\n}\n/** @param {string[]} headers */ function buildHeadersFromArray(headers) {\n    // fetch HeadersList\n    const clone = headers.slice();\n    const entries = [];\n    for(let index = 0; index < clone.length; index += 2){\n        entries.push([\n            clone[index],\n            clone[index + 1]\n        ]);\n    }\n    return Object.fromEntries(entries);\n}\nfunction matchHeaders(mockDispatch, headers) {\n    if (typeof mockDispatch.headers === \"function\") {\n        if (Array.isArray(headers)) {\n            // fetch HeadersList\n            headers = buildHeadersFromArray(headers);\n        }\n        return mockDispatch.headers(headers ? lowerCaseEntries(headers) : {});\n    }\n    if (typeof mockDispatch.headers === \"undefined\") {\n        return true;\n    }\n    if (typeof headers !== \"object\" || typeof mockDispatch.headers !== \"object\") {\n        return false;\n    }\n    for (const [matchHeaderName, matchHeaderValue] of Object.entries(mockDispatch.headers)){\n        const headerValue = getHeaderByName(headers, matchHeaderName);\n        if (!matchValue(matchHeaderValue, headerValue)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction safeUrl(path) {\n    if (typeof path !== \"string\") {\n        return path;\n    }\n    const pathSegments = path.split(\"?\");\n    if (pathSegments.length !== 2) {\n        return path;\n    }\n    const qp = new URLSearchParams(pathSegments.pop());\n    qp.sort();\n    return [\n        ...pathSegments,\n        qp.toString()\n    ].join(\"?\");\n}\nfunction matchKey(mockDispatch, { path, method, body, headers }) {\n    const pathMatch = matchValue(mockDispatch.path, path);\n    const methodMatch = matchValue(mockDispatch.method, method);\n    const bodyMatch = typeof mockDispatch.body !== \"undefined\" ? matchValue(mockDispatch.body, body) : true;\n    const headersMatch = matchHeaders(mockDispatch, headers);\n    return pathMatch && methodMatch && bodyMatch && headersMatch;\n}\nfunction getResponseData(data) {\n    if (Buffer.isBuffer(data)) {\n        return data;\n    } else if (typeof data === \"object\") {\n        return JSON.stringify(data);\n    } else {\n        return data.toString();\n    }\n}\nfunction getMockDispatch(mockDispatches, key) {\n    const basePath = key.query ? buildURL(key.path, key.query) : key.path;\n    const resolvedPath = typeof basePath === \"string\" ? safeUrl(basePath) : basePath;\n    // Match path\n    let matchedMockDispatches = mockDispatches.filter(({ consumed })=>!consumed).filter(({ path })=>matchValue(safeUrl(path), resolvedPath));\n    if (matchedMockDispatches.length === 0) {\n        throw new MockNotMatchedError(`Mock dispatch not matched for path '${resolvedPath}'`);\n    }\n    // Match method\n    matchedMockDispatches = matchedMockDispatches.filter(({ method })=>matchValue(method, key.method));\n    if (matchedMockDispatches.length === 0) {\n        throw new MockNotMatchedError(`Mock dispatch not matched for method '${key.method}' on path '${resolvedPath}'`);\n    }\n    // Match body\n    matchedMockDispatches = matchedMockDispatches.filter(({ body })=>typeof body !== \"undefined\" ? matchValue(body, key.body) : true);\n    if (matchedMockDispatches.length === 0) {\n        throw new MockNotMatchedError(`Mock dispatch not matched for body '${key.body}' on path '${resolvedPath}'`);\n    }\n    // Match headers\n    matchedMockDispatches = matchedMockDispatches.filter((mockDispatch)=>matchHeaders(mockDispatch, key.headers));\n    if (matchedMockDispatches.length === 0) {\n        const headers = typeof key.headers === \"object\" ? JSON.stringify(key.headers) : key.headers;\n        throw new MockNotMatchedError(`Mock dispatch not matched for headers '${headers}' on path '${resolvedPath}'`);\n    }\n    return matchedMockDispatches[0];\n}\nfunction addMockDispatch(mockDispatches, key, data) {\n    const baseData = {\n        timesInvoked: 0,\n        times: 1,\n        persist: false,\n        consumed: false\n    };\n    const replyData = typeof data === \"function\" ? {\n        callback: data\n    } : {\n        ...data\n    };\n    const newMockDispatch = {\n        ...baseData,\n        ...key,\n        pending: true,\n        data: {\n            error: null,\n            ...replyData\n        }\n    };\n    mockDispatches.push(newMockDispatch);\n    return newMockDispatch;\n}\nfunction deleteMockDispatch(mockDispatches, key) {\n    const index = mockDispatches.findIndex((dispatch)=>{\n        if (!dispatch.consumed) {\n            return false;\n        }\n        return matchKey(dispatch, key);\n    });\n    if (index !== -1) {\n        mockDispatches.splice(index, 1);\n    }\n}\nfunction buildKey(opts) {\n    const { path, method, body, headers, query } = opts;\n    return {\n        path,\n        method,\n        body,\n        headers,\n        query\n    };\n}\nfunction generateKeyValues(data) {\n    const keys = Object.keys(data);\n    const result = [];\n    for(let i = 0; i < keys.length; ++i){\n        const key = keys[i];\n        const value = data[key];\n        const name = Buffer.from(`${key}`);\n        if (Array.isArray(value)) {\n            for(let j = 0; j < value.length; ++j){\n                result.push(name, Buffer.from(`${value[j]}`));\n            }\n        } else {\n            result.push(name, Buffer.from(`${value}`));\n        }\n    }\n    return result;\n}\n/**\n * @see https://developer.mozilla.org/en-US/docs/Web/HTTP/Status\n * @param {number} statusCode\n */ function getStatusText(statusCode) {\n    return STATUS_CODES[statusCode] || \"unknown\";\n}\nasync function getResponse(body) {\n    const buffers = [];\n    for await (const data of body){\n        buffers.push(data);\n    }\n    return Buffer.concat(buffers).toString(\"utf8\");\n}\n/**\n * Mock dispatch function used to simulate undici dispatches\n */ function mockDispatch(opts, handler) {\n    // Get mock dispatch from built key\n    const key = buildKey(opts);\n    const mockDispatch = getMockDispatch(this[kDispatches], key);\n    mockDispatch.timesInvoked++;\n    // Here's where we resolve a callback if a callback is present for the dispatch data.\n    if (mockDispatch.data.callback) {\n        mockDispatch.data = {\n            ...mockDispatch.data,\n            ...mockDispatch.data.callback(opts)\n        };\n    }\n    // Parse mockDispatch data\n    const { data: { statusCode, data, headers, trailers, error }, delay, persist } = mockDispatch;\n    const { timesInvoked, times } = mockDispatch;\n    // If it's used up and not persistent, mark as consumed\n    mockDispatch.consumed = !persist && timesInvoked >= times;\n    mockDispatch.pending = timesInvoked < times;\n    // If specified, trigger dispatch error\n    if (error !== null) {\n        deleteMockDispatch(this[kDispatches], key);\n        handler.onError(error);\n        return true;\n    }\n    // Handle the request with a delay if necessary\n    if (typeof delay === \"number\" && delay > 0) {\n        setTimeout(()=>{\n            handleReply(this[kDispatches]);\n        }, delay);\n    } else {\n        handleReply(this[kDispatches]);\n    }\n    function handleReply(mockDispatches, _data = data) {\n        // fetch's HeadersList is a 1D string array\n        const optsHeaders = Array.isArray(opts.headers) ? buildHeadersFromArray(opts.headers) : opts.headers;\n        const body = typeof _data === \"function\" ? _data({\n            ...opts,\n            headers: optsHeaders\n        }) : _data;\n        // util.types.isPromise is likely needed for jest.\n        if (isPromise(body)) {\n            // If handleReply is asynchronous, throwing an error\n            // in the callback will reject the promise, rather than\n            // synchronously throw the error, which breaks some tests.\n            // Rather, we wait for the callback to resolve if it is a\n            // promise, and then re-run handleReply with the new body.\n            body.then((newData)=>handleReply(mockDispatches, newData));\n            return;\n        }\n        const responseData = getResponseData(body);\n        const responseHeaders = generateKeyValues(headers);\n        const responseTrailers = generateKeyValues(trailers);\n        handler.onConnect?.((err)=>handler.onError(err), null);\n        handler.onHeaders?.(statusCode, responseHeaders, resume, getStatusText(statusCode));\n        handler.onData?.(Buffer.from(responseData));\n        handler.onComplete?.(responseTrailers);\n        deleteMockDispatch(mockDispatches, key);\n    }\n    function resume() {}\n    return true;\n}\nfunction buildMockDispatch() {\n    const agent = this[kMockAgent];\n    const origin = this[kOrigin];\n    const originalDispatch = this[kOriginalDispatch];\n    return function dispatch(opts, handler) {\n        if (agent.isMockActive) {\n            try {\n                mockDispatch.call(this, opts, handler);\n            } catch (error) {\n                if (error instanceof MockNotMatchedError) {\n                    const netConnect = agent[kGetNetConnect]();\n                    if (netConnect === false) {\n                        throw new MockNotMatchedError(`${error.message}: subsequent request to origin ${origin} was not allowed (net.connect disabled)`);\n                    }\n                    if (checkNetConnect(netConnect, origin)) {\n                        originalDispatch.call(this, opts, handler);\n                    } else {\n                        throw new MockNotMatchedError(`${error.message}: subsequent request to origin ${origin} was not allowed (net.connect is not enabled for this origin)`);\n                    }\n                } else {\n                    throw error;\n                }\n            }\n        } else {\n            originalDispatch.call(this, opts, handler);\n        }\n    };\n}\nfunction checkNetConnect(netConnect, origin) {\n    const url = new URL(origin);\n    if (netConnect === true) {\n        return true;\n    } else if (Array.isArray(netConnect) && netConnect.some((matcher)=>matchValue(matcher, url.host))) {\n        return true;\n    }\n    return false;\n}\nfunction buildMockOptions(opts) {\n    if (opts) {\n        const { agent, ...mockOptions } = opts;\n        return mockOptions;\n    }\n}\nmodule.exports = {\n    getResponseData,\n    getMockDispatch,\n    addMockDispatch,\n    deleteMockDispatch,\n    buildKey,\n    generateKeyValues,\n    matchValue,\n    getResponse,\n    getStatusText,\n    mockDispatch,\n    buildMockDispatch,\n    checkNetConnect,\n    buildMockOptions,\n    getHeaderByName,\n    buildHeadersFromArray\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9tb2NrL21vY2stdXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNLEVBQUVBLG1CQUFBQSxFQUFxQixHQUFHQyxtQkFBT0EsQ0FBQztBQUN4QyxNQUFNLEVBQ0pDLFdBQVcsRUFDWEMsVUFBVSxFQUNWQyxpQkFBaUIsRUFDakJDLE9BQU8sRUFDUEMsY0FBQUEsRUFDRCxHQUFHTCxtQkFBT0EsQ0FBQztBQUNaLE1BQU0sRUFBRU0sUUFBQUEsRUFBVSxHQUFHTixtQkFBT0EsQ0FBQztBQUM3QixNQUFNLEVBQUVPLFlBQUFBLEVBQWMsR0FBR1AsbUJBQU9BLENBQUM7QUFDakMsTUFBTSxFQUNKUSxPQUFPLEVBQ0xDLFNBQUFBLEVBQ0YsRUFDRCxHQUFHVCxtQkFBT0EsQ0FBQztBQUVaLFNBQVNVLFdBQVlDLEtBQUssRUFBRUMsS0FBSztJQUMvQixJQUFJLE9BQU9ELFVBQVUsVUFBVTtRQUM3QixPQUFPQSxVQUFVQztJQUNuQjtJQUNBLElBQUlELGlCQUFpQkUsUUFBUTtRQUMzQixPQUFPRixNQUFNRyxJQUFJLENBQUNGO0lBQ3BCO0lBQ0EsSUFBSSxPQUFPRCxVQUFVLFlBQVk7UUFDL0IsT0FBT0EsTUFBTUMsV0FBVztJQUMxQjtJQUNBLE9BQU87QUFDVDtBQUVBLFNBQVNHLGlCQUFrQkMsT0FBTztJQUNoQyxPQUFPQyxPQUFPQyxXQUFXLENBQ3ZCRCxPQUFPRSxPQUFPLENBQUNILFNBQVNJLEdBQUcsQ0FBQyxDQUFDLENBQUNDLFlBQVlDLFlBQVk7UUFDcEQsT0FBTztZQUFDRCxXQUFXRSxpQkFBaUI7WUFBSUQ7U0FBWTtJQUN0RDtBQUVKO0FBRUE7OztDQUdBLEdBQ0EsU0FBU0UsZ0JBQWlCUixPQUFPLEVBQUVTLEdBQUc7SUFDcEMsSUFBSUMsTUFBTUMsT0FBTyxDQUFDWCxVQUFVO1FBQzFCLElBQUssSUFBSVksSUFBSSxHQUFHQSxJQUFJWixRQUFRYSxNQUFNLEVBQUVELEtBQUssRUFBRztZ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LGVBQWUsT0FBTzt3QkFDeEIsTUFBTSxJQUFJN0gsb0JBQW9CLEdBQUdrRixNQUFNNEMsT0FBTyxrQ0FBa0NMLE9BQU0sd0NBQXlDO29CQUNqSTtvQkFDQSxJQUFJTSxnQkFBZ0JGLFlBQVlKLFNBQVM7d0JBQ3ZDQyxpQkFBaUJFLElBQUksQ0FBQyxJQUFJLEVBQUVwQyxNQUFNWTtvQkFDcEMsT0FBTzt3QkFDTCxNQUFNLElBQUlwRyxvQkFBb0IsR0FBR2tGLE1BQU00QyxPQUFPLGtDQUFrQ0wsT0FBTSw4REFBK0Q7b0JBQ3ZKO2dCQUNGLE9BQU87b0JBQ0wsTUFBTXZDO2dCQUNSO1lBQ0Y7UUFDRixPQUFPO1lBQ0x3QyxpQkFBaUJFLElBQUksQ0FBQyxJQUFJLEVBQUVwQyxNQUFNWTtRQUNwQztJQUNGO0FBQ0Y7QUFFQSxTQUFTMkIsZ0JBQWlCRixVQUFVLEVBQUVKLE1BQU07SUFDMUMsTUFBTU8sTUFBTSxJQUFJQyxJQUFJUjtJQUNwQixJQUFJSSxlQUFlLE1BQU07UUFDdkIsT0FBTztJQUNULE9BQU8sSUFBSWxHLE1BQU1DLE9BQU8sQ0FBQ2lHLGVBQWVBLFdBQVdLLElBQUksQ0FBRUMsQ0FBQUEsVUFBWXhILFdBQVd3SCxTQUFTSCxJQUFJSSxJQUFJLElBQUk7UUFDbkcsT0FBTztJQUNUO0lBQ0EsT0FBTztBQUNUO0FBRUEsU0FBU0MsaUJBQWtCN0MsSUFBSTtJQUM3QixJQUFJQSxNQUFNO1FBQ1IsTUFBTSxFQUFFZ0MsS0FBSyxFQUFFLEdBQUdjLGFBQWEsR0FBRzlDO1FBQ2xDLE9BQU84QztJQUNUO0FBQ0Y7QUFFQUMsT0FBT0MsT0FBTyxHQUFHO0lBQ2Y3RTtJQUNBTTtJQUNBUTtJQUNBVTtJQUNBSTtJQUNBRTtJQUNBOUU7SUFDQXNGO0lBQ0FGO0lBQ0F4RDtJQUNBZ0Y7SUFDQVE7SUFDQU07SUFDQTVHO0lBQ0FRO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tb2NrdXBmbG93Ly4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvbW9jay9tb2NrLXV0aWxzLmpzP2U5YTkiLCJ3ZWJwYWNrOi8vbW9ja3VwZmxvdy8uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL21vY2svbW9jay11dGlscy5qcz9lOWE5KiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyBNb2NrTm90TWF0Y2hlZEVycm9yIH0gPSByZXF1aXJlKCcuL21vY2stZXJyb3JzJylcbmNvbnN0IHtcbiAga0Rpc3BhdGNoZXMsXG4gIGtNb2NrQWdlbnQsXG4gIGtPcmlnaW5hbERpc3BhdGNoLFxuICBrT3JpZ2luLFxuICBrR2V0TmV0Q29ubmVjdFxufSA9IHJlcXVpcmUoJy4vbW9jay1zeW1ib2xzJylcbmNvbnN0IHsgYnVpbGRVUkwgfSA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpXG5jb25zdCB7IFNUQVRVU19DT0RFUyB9ID0gcmVxdWlyZSgnbm9kZTpodHRwJylcbmNvbnN0IHtcbiAgdHlwZXM6IHtcbiAgICBpc1Byb21pc2VcbiAgfVxufSA9IHJlcXVpcmUoJ25vZGU6dXRpbCcpXG5cbmZ1bmN0aW9uIG1hdGNoVmFsdWUgKG1hdGNoLCB2YWx1ZSkge1xuICBpZiAodHlwZW9mIG1hdGNoID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBtYXRjaCA9PT0gdmFsdWVcbiAgfVxuICBpZiAobWF0Y2ggaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICByZXR1cm4gbWF0Y2gudGVzdCh2YWx1ZSlcbiAgfVxuICBpZiAodHlwZW9mIG1hdGNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIG1hdGNoKHZhbHVlKSA9PT0gdHJ1ZVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBsb3dlckNhc2VFbnRyaWVzIChoZWFkZXJzKSB7XG4gIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgT2JqZWN0LmVudHJpZXMoaGVhZGVycykubWFwKChbaGVhZGVyTmFtZSwgaGVhZGVyVmFsdWVdKSA9PiB7XG4gICAgICByZXR1cm4gW2hlYWRlck5hbWUudG9Mb2NhbGVMb3dlckNhc2UoKSwgaGVhZGVyVmFsdWVdXG4gICAgfSlcbiAgKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi8uLi9pbmRleCcpLkhlYWRlcnN8c3RyaW5nW118UmVjb3JkPHN0cmluZywgc3RyaW5nPn0gaGVhZGVyc1xuICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICovXG5mdW5jdGlvbiBnZXRIZWFkZXJCeU5hbWUgKGhlYWRlcnMsIGtleSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShoZWFkZXJzKSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaGVhZGVycy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgaWYgKGhlYWRlcnNbaV0udG9Mb2NhbGVMb3dlckNhc2UoKSA9PT0ga2V5LnRvTG9jYWxlTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgcmV0dXJuIGhlYWRlcnNbaSArIDFdXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuZGVmaW5lZFxuICB9IGVsc2UgaWYgKHR5cGVvZiBoZWFkZXJzLmdldCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBoZWFkZXJzLmdldChrZXkpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGxvd2VyQ2FzZUVudHJpZXMoaGVhZGVycylba2V5LnRvTG9jYWxlTG93ZXJDYXNlKCldXG4gIH1cbn1cblxuLyoqIEBwYXJhbSB7c3RyaW5nW119IGhlYWRlcnMgKi9cbmZ1bmN0aW9uIGJ1aWxkSGVhZGVyc0Zyb21BcnJheSAoaGVhZGVycykgeyAvLyBmZXRjaCBIZWFkZXJzTGlzdFxuICBjb25zdCBjbG9uZSA9IGhlYWRlcnMuc2xpY2UoKVxuICBjb25zdCBlbnRyaWVzID0gW11cbiAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGNsb25lLmxlbmd0aDsgaW5kZXggKz0gMikge1xuICAgIGVudHJpZXMucHVzaChbY2xvbmVbaW5kZXhdLCBjbG9uZVtpbmRleCArIDFdXSlcbiAgfVxuICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKGVudHJpZXMpXG59XG5cbmZ1bmN0aW9uIG1hdGNoSGVhZGVycyAobW9ja0Rpc3BhdGNoLCBoZWFkZXJzKSB7XG4gIGlmICh0eXBlb2YgbW9ja0Rpc3BhdGNoLmhlYWRlcnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShoZWFkZXJzKSkgeyAvLyBmZXRjaCBIZWFkZXJzTGlzdFxuICAgICAgaGVhZGVycyA9IGJ1aWxkSGVhZGVyc0Zyb21BcnJheShoZWFkZXJzKVxuICAgIH1cbiAgICByZXR1cm4gbW9ja0Rpc3BhdGNoLmhlYWRlcnMoaGVhZGVycyA/IGxvd2VyQ2FzZUVudHJpZXMoaGVhZGVycykgOiB7fSlcbiAgfVxuICBpZiAodHlwZW9mIG1vY2tEaXNwYXRjaC5oZWFkZXJzID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgaWYgKHR5cGVvZiBoZWFkZXJzICE9PSAnb2JqZWN0JyB8fCB0eXBlb2YgbW9ja0Rpc3BhdGNoLmhlYWRlcnMgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBmb3IgKGNvbnN0IFttYXRjaEhlYWRlck5hbWUsIG1hdGNoSGVhZGVyVmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKG1vY2tEaXNwYXRjaC5oZWFkZXJzKSkge1xuICAgIGNvbnN0IGhlYWRlclZhbHVlID0gZ2V0SGVhZGVyQnlOYW1lKGhlYWRlcnMsIG1hdGNoSGVhZGVyTmFtZSlcblxuICAgIGlmICghbWF0Y2hWYWx1ZShtYXRjaEhlYWRlclZhbHVlLCBoZWFkZXJWYWx1ZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG5mdW5jdGlvbiBzYWZlVXJsIChwYXRoKSB7XG4gIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gcGF0aFxuICB9XG5cbiAgY29uc3QgcGF0aFNlZ21lbnRzID0gcGF0aC5zcGxpdCgnPycpXG5cbiAgaWYgKHBhdGhTZWdtZW50cy5sZW5ndGggIT09IDIpIHtcbiAgICByZXR1cm4gcGF0aFxuICB9XG5cbiAgY29uc3QgcXAgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHBhdGhTZWdtZW50cy5wb3AoKSlcbiAgcXAuc29ydCgpXG4gIHJldHVybiBbLi4ucGF0aFNlZ21lbnRzLCBxcC50b1N0cmluZygpXS5qb2luKCc/Jylcbn1cblxuZnVuY3Rpb24gbWF0Y2hLZXkgKG1vY2tEaXNwYXRjaCwgeyBwYXRoLCBtZXRob2QsIGJvZHksIGhlYWRlcnMgfSkge1xuICBjb25zdCBwYXRoTWF0Y2ggPSBtYXRjaFZhbHVlKG1vY2tEaXNwYXRjaC5wYXRoLCBwYXRoKVxuICBjb25zdCBtZXRob2RNYXRjaCA9IG1hdGNoVmFsdWUobW9ja0Rpc3BhdGNoLm1ldGhvZCwgbWV0aG9kKVxuICBjb25zdCBib2R5TWF0Y2ggPSB0eXBlb2YgbW9ja0Rpc3BhdGNoLmJvZHkgIT09ICd1bmRlZmluZWQnID8gbWF0Y2hWYWx1ZShtb2NrRGlzcGF0Y2guYm9keSwgYm9keSkgOiB0cnVlXG4gIGNvbnN0IGhlYWRlcnNNYXRjaCA9IG1hdGNoSGVhZGVycyhtb2NrRGlzcGF0Y2gsIGhlYWRlcnMpXG4gIHJldHVybiBwYXRoTWF0Y2ggJiYgbWV0aG9kTWF0Y2ggJiYgYm9keU1hdGNoICYmIGhlYWRlcnNNYXRjaFxufVxuXG5mdW5jdGlvbiBnZXRSZXNwb25zZURhdGEgKGRhdGEpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihkYXRhKSkge1xuICAgIHJldHVybiBkYXRhXG4gIH0gZWxzZSBpZiAodHlwZW9mIGRhdGEgPT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGRhdGEpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGRhdGEudG9TdHJpbmcoKVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldE1vY2tEaXNwYXRjaCAobW9ja0Rpc3BhdGNoZXMsIGtleSkge1xuICBjb25zdCBiYXNlUGF0aCA9IGtleS5xdWVyeSA/IGJ1aWxkVVJMKGtleS5wYXRoLCBrZXkucXVlcnkpIDoga2V5LnBhdGhcbiAgY29uc3QgcmVzb2x2ZWRQYXRoID0gdHlwZW9mIGJhc2VQYXRoID09PSAnc3RyaW5nJyA/IHNhZmVVcmwoYmFzZVBhdGgpIDogYmFzZVBhdGhcblxuICAvLyBNYXRjaCBwYXRoXG4gIGxldCBtYXRjaGVkTW9ja0Rpc3BhdGNoZXMgPSBtb2NrRGlzcGF0Y2hlcy5maWx0ZXIoKHsgY29uc3VtZWQgfSkgPT4gIWNvbnN1bWVkKS5maWx0ZXIoKHsgcGF0aCB9KSA9PiBtYXRjaFZhbHVlKHNhZmVVcmwocGF0aCksIHJlc29sdmVkUGF0aCkpXG4gIGlmIChtYXRjaGVkTW9ja0Rpc3BhdGNoZXMubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IE1vY2tOb3RNYXRjaGVkRXJyb3IoYE1vY2sgZGlzcGF0Y2ggbm90IG1hdGNoZWQgZm9yIHBhdGggJyR7cmVzb2x2ZWRQYXRofSdgKVxuICB9XG5cbiAgLy8gTWF0Y2ggbWV0aG9kXG4gIG1hdGNoZWRNb2NrRGlzcGF0Y2hlcyA9IG1hdGNoZWRNb2NrRGlzcGF0Y2hlcy5maWx0ZXIoKHsgbWV0aG9kIH0pID0+IG1hdGNoVmFsdWUobWV0aG9kLCBrZXkubWV0aG9kKSlcbiAgaWYgKG1hdGNoZWRNb2NrRGlzcGF0Y2hlcy5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgTW9ja05vdE1hdGNoZWRFcnJvcihgTW9jayBkaXNwYXRjaCBub3QgbWF0Y2hlZCBmb3IgbWV0aG9kICcke2tleS5tZXRob2R9JyBvbiBwYXRoICcke3Jlc29sdmVkUGF0aH0nYClcbiAgfVxuXG4gIC8vIE1hdGNoIGJvZHlcbiAgbWF0Y2hlZE1vY2tEaXNwYXRjaGVzID0gbWF0Y2hlZE1vY2tEaXNwYXRjaGVzLmZpbHRlcigoeyBib2R5IH0pID0+IHR5cGVvZiBib2R5ICE9PSAndW5kZWZpbmVkJyA/IG1hdGNoVmFsdWUoYm9keSwga2V5LmJvZHkpIDogdHJ1ZSlcbiAgaWYgKG1hdGNoZWRNb2NrRGlzcGF0Y2hlcy5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgTW9ja05vdE1hdGNoZWRFcnJvcihgTW9jayBkaXNwYXRjaCBub3QgbWF0Y2hlZCBmb3IgYm9keSAnJHtrZXkuYm9keX0nIG9uIHBhdGggJyR7cmVzb2x2ZWRQYXRofSdgKVxuICB9XG5cbiAgLy8gTWF0Y2ggaGVhZGVyc1xuICBtYXRjaGVkTW9ja0Rpc3BhdGNoZXMgPSBtYXRjaGVkTW9ja0Rpc3BhdGNoZXMuZmlsdGVyKChtb2NrRGlzcGF0Y2gpID0+IG1hdGNoSGVhZGVycyhtb2NrRGlzcGF0Y2gsIGtleS5oZWFkZXJzKSlcbiAgaWYgKG1hdGNoZWRNb2NrRGlzcGF0Y2hlcy5sZW5ndGggPT09IDApIHtcbiAgICBjb25zdCBoZWFkZXJzID0gdHlwZW9mIGtleS5oZWFkZXJzID09PSAnb2JqZWN0JyA/IEpTT04uc3RyaW5naWZ5KGtleS5oZWFkZXJzKSA6IGtleS5oZWFkZXJzXG4gICAgdGhyb3cgbmV3IE1vY2tOb3RNYXRjaGVkRXJyb3IoYE1vY2sgZGlzcGF0Y2ggbm90IG1hdGNoZWQgZm9yIGhlYWRlcnMgJyR7aGVhZGVyc30nIG9uIHBhdGggJyR7cmVzb2x2ZWRQYXRofSdgKVxuICB9XG5cbiAgcmV0dXJuIG1hdGNoZWRNb2NrRGlzcGF0Y2hlc1swXVxufVxuXG5mdW5jdGlvbiBhZGRNb2NrRGlzcGF0Y2ggKG1vY2tEaXNwYXRjaGVzLCBrZXksIGRhdGEpIHtcbiAgY29uc3QgYmFzZURhdGEgPSB7IHRpbWVzSW52b2tlZDogMCwgdGltZXM6IDEsIHBlcnNpc3Q6IGZhbHNlLCBjb25zdW1lZDogZmFsc2UgfVxuICBjb25zdCByZXBseURhdGEgPSB0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJyA/IHsgY2FsbGJhY2s6IGRhdGEgfSA6IHsgLi4uZGF0YSB9XG4gIGNvbnN0IG5ld01vY2tEaXNwYXRjaCA9IHsgLi4uYmFzZURhdGEsIC4uLmtleSwgcGVuZGluZzogdHJ1ZSwgZGF0YTogeyBlcnJvcjogbnVsbCwgLi4ucmVwbHlEYXRhIH0gfVxuICBtb2NrRGlzcGF0Y2hlcy5wdXNoKG5ld01vY2tEaXNwYXRjaClcbiAgcmV0dXJuIG5ld01vY2tEaXNwYXRjaFxufVxuXG5mdW5jdGlvbiBkZWxldGVNb2NrRGlzcGF0Y2ggKG1vY2tEaXNwYXRjaGVzLCBrZXkpIHtcbiAgY29uc3QgaW5kZXggPSBtb2NrRGlzcGF0Y2hlcy5maW5kSW5kZXgoZGlzcGF0Y2ggPT4ge1xuICAgIGlmICghZGlzcGF0Y2guY29uc3VtZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICByZXR1cm4gbWF0Y2hLZXkoZGlzcGF0Y2gsIGtleSlcbiAgfSlcbiAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgIG1vY2tEaXNwYXRjaGVzLnNwbGljZShpbmRleCwgMSlcbiAgfVxufVxuXG5mdW5jdGlvbiBidWlsZEtleSAob3B0cykge1xuICBjb25zdCB7IHBhdGgsIG1ldGhvZCwgYm9keSwgaGVhZGVycywgcXVlcnkgfSA9IG9wdHNcbiAgcmV0dXJuIHtcbiAgICBwYXRoLFxuICAgIG1ldGhvZCxcbiAgICBib2R5LFxuICAgIGhlYWRlcnMsXG4gICAgcXVlcnlcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZUtleVZhbHVlcyAoZGF0YSkge1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoZGF0YSlcbiAgY29uc3QgcmVzdWx0ID0gW11cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgY29uc3Qga2V5ID0ga2V5c1tpXVxuICAgIGNvbnN0IHZhbHVlID0gZGF0YVtrZXldXG4gICAgY29uc3QgbmFtZSA9IEJ1ZmZlci5mcm9tKGAke2tleX1gKVxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB2YWx1ZS5sZW5ndGg7ICsraikge1xuICAgICAgICByZXN1bHQucHVzaChuYW1lLCBCdWZmZXIuZnJvbShgJHt2YWx1ZVtqXX1gKSlcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LnB1c2gobmFtZSwgQnVmZmVyLmZyb20oYCR7dmFsdWV9YCkpXG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHRcbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvU3RhdHVzXG4gKiBAcGFyYW0ge251bWJlcn0gc3RhdHVzQ29kZVxuICovXG5mdW5jdGlvbiBnZXRTdGF0dXNUZXh0IChzdGF0dXNDb2RlKSB7XG4gIHJldHVybiBTVEFUVVNfQ09ERVNbc3RhdHVzQ29kZV0gfHwgJ3Vua25vd24nXG59XG5cbmFzeW5jIGZ1bmN0aW9uIGdldFJlc3BvbnNlIChib2R5KSB7XG4gIGNvbnN0IGJ1ZmZlcnMgPSBbXVxuICBmb3IgYXdhaXQgKGNvbnN0IGRhdGEgb2YgYm9keSkge1xuICAgIGJ1ZmZlcnMucHVzaChkYXRhKVxuICB9XG4gIHJldHVybiBCdWZmZXIuY29uY2F0KGJ1ZmZlcnMpLnRvU3RyaW5nKCd1dGY4Jylcbn1cblxuLyoqXG4gKiBNb2NrIGRpc3BhdGNoIGZ1bmN0aW9uIHVzZWQgdG8gc2ltdWxhdGUgdW5kaWNpIGRpc3BhdGNoZXNcbiAqL1xuZnVuY3Rpb24gbW9ja0Rpc3BhdGNoIChvcHRzLCBoYW5kbGVyKSB7XG4gIC8vIEdldCBtb2NrIGRpc3BhdGNoIGZyb20gYnVpbHQga2V5XG4gIGNvbnN0IGtleSA9IGJ1aWxkS2V5KG9wdHMpXG4gIGNvbnN0IG1vY2tEaXNwYXRjaCA9IGdldE1vY2tEaXNwYXRjaCh0aGlzW2tEaXNwYXRjaGVzXSwga2V5KVxuXG4gIG1vY2tEaXNwYXRjaC50aW1lc0ludm9rZWQrK1xuXG4gIC8vIEhlcmUncyB3aGVyZSB3ZSByZXNvbHZlIGEgY2FsbGJhY2sgaWYgYSBjYWxsYmFjayBpcyBwcmVzZW50IGZvciB0aGUgZGlzcGF0Y2ggZGF0YS5cbiAgaWYgKG1vY2tEaXNwYXRjaC5kYXRhLmNhbGxiYWNrKSB7XG4gICAgbW9ja0Rpc3BhdGNoLmRhdGEgPSB7IC4uLm1vY2tEaXNwYXRjaC5kYXRhLCAuLi5tb2NrRGlzcGF0Y2guZGF0YS5jYWxsYmFjayhvcHRzKSB9XG4gIH1cblxuICAvLyBQYXJzZSBtb2NrRGlzcGF0Y2ggZGF0YVxuICBjb25zdCB7IGRhdGE6IHsgc3RhdHVzQ29kZSwgZGF0YSwgaGVhZGVycywgdHJhaWxlcnMsIGVycm9yIH0sIGRlbGF5LCBwZXJzaXN0IH0gPSBtb2NrRGlzcGF0Y2hcbiAgY29uc3QgeyB0aW1lc0ludm9rZWQsIHRpbWVzIH0gPSBtb2NrRGlzcGF0Y2hcblxuICAvLyBJZiBpdCdzIHVzZWQgdXAgYW5kIG5vdCBwZXJzaXN0ZW50LCBtYXJrIGFzIGNvbnN1bWVkXG4gIG1vY2tEaXNwYXRjaC5jb25zdW1lZCA9ICFwZXJzaXN0ICYmIHRpbWVzSW52b2tlZCA+PSB0aW1lc1xuICBtb2NrRGlzcGF0Y2gucGVuZGluZyA9IHRpbWVzSW52b2tlZCA8IHRpbWVzXG5cbiAgLy8gSWYgc3BlY2lmaWVkLCB0cmlnZ2VyIGRpc3BhdGNoIGVycm9yXG4gIGlmIChlcnJvciAhPT0gbnVsbCkge1xuICAgIGRlbGV0ZU1vY2tEaXNwYXRjaCh0aGlzW2tEaXNwYXRjaGVzXSwga2V5KVxuICAgIGhhbmRsZXIub25FcnJvcihlcnJvcilcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLy8gSGFuZGxlIHRoZSByZXF1ZXN0IHdpdGggYSBkZWxheSBpZiBuZWNlc3NhcnlcbiAgaWYgKHR5cGVvZiBkZWxheSA9PT0gJ251bWJlcicgJiYgZGVsYXkgPiAwKSB7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBoYW5kbGVSZXBseSh0aGlzW2tEaXNwYXRjaGVzXSlcbiAgICB9LCBkZWxheSlcbiAgfSBlbHNlIHtcbiAgICBoYW5kbGVSZXBseSh0aGlzW2tEaXNwYXRjaGVzXSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZVJlcGx5IChtb2NrRGlzcGF0Y2hlcywgX2RhdGEgPSBkYXRhKSB7XG4gICAgLy8gZmV0Y2gncyBIZWFkZXJzTGlzdCBpcyBhIDFEIHN0cmluZyBhcnJheVxuICAgIGNvbnN0IG9wdHNIZWFkZXJzID0gQXJyYXkuaXNBcnJheShvcHRzLmhlYWRlcnMpXG4gICAgICA/IGJ1aWxkSGVhZGVyc0Zyb21BcnJheShvcHRzLmhlYWRlcnMpXG4gICAgICA6IG9wdHMuaGVhZGVyc1xuICAgIGNvbnN0IGJvZHkgPSB0eXBlb2YgX2RhdGEgPT09ICdmdW5jdGlvbidcbiAgICAgID8gX2RhdGEoeyAuLi5vcHRzLCBoZWFkZXJzOiBvcHRzSGVhZGVycyB9KVxuICAgICAgOiBfZGF0YVxuXG4gICAgLy8gdXRpbC50eXBlcy5pc1Byb21pc2UgaXMgbGlrZWx5IG5lZWRlZCBmb3IgamVzdC5cbiAgICBpZiAoaXNQcm9taXNlKGJvZHkpKSB7XG4gICAgICAvLyBJZiBoYW5kbGVSZXBseSBpcyBhc3luY2hyb25vdXMsIHRocm93aW5nIGFuIGVycm9yXG4gICAgICAvLyBpbiB0aGUgY2FsbGJhY2sgd2lsbCByZWplY3QgdGhlIHByb21pc2UsIHJhdGhlciB0aGFuXG4gICAgICAvLyBzeW5jaHJvbm91c2x5IHRocm93IHRoZSBlcnJvciwgd2hpY2ggYnJlYWtzIHNvbWUgdGVzdHMuXG4gICAgICAvLyBSYXRoZXIsIHdlIHdhaXQgZm9yIHRoZSBjYWxsYmFjayB0byByZXNvbHZlIGlmIGl0IGlzIGFcbiAgICAgIC8vIHByb21pc2UsIGFuZCB0aGVuIHJlLXJ1biBoYW5kbGVSZXBseSB3aXRoIHRoZSBuZXcgYm9keS5cbiAgICAgIGJvZHkudGhlbigobmV3RGF0YSkgPT4gaGFuZGxlUmVwbHkobW9ja0Rpc3BhdGNoZXMsIG5ld0RhdGEpKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgcmVzcG9uc2VEYXRhID0gZ2V0UmVzcG9uc2VEYXRhKGJvZHkpXG4gICAgY29uc3QgcmVzcG9uc2VIZWFkZXJzID0gZ2VuZXJhdGVLZXlWYWx1ZXMoaGVhZGVycylcbiAgICBjb25zdCByZXNwb25zZVRyYWlsZXJzID0gZ2VuZXJhdGVLZXlWYWx1ZXModHJhaWxlcnMpXG5cbiAgICBoYW5kbGVyLm9uQ29ubmVjdD8uKGVyciA9PiBoYW5kbGVyLm9uRXJyb3IoZXJyKSwgbnVsbClcbiAgICBoYW5kbGVyLm9uSGVhZGVycz8uKHN0YXR1c0NvZGUsIHJlc3BvbnNlSGVhZGVycywgcmVzdW1lLCBnZXRTdGF0dXNUZXh0KHN0YXR1c0NvZGUpKVxuICAgIGhhbmRsZXIub25EYXRhPy4oQnVmZmVyLmZyb20ocmVzcG9uc2VEYXRhKSlcbiAgICBoYW5kbGVyLm9uQ29tcGxldGU/LihyZXNwb25zZVRyYWlsZXJzKVxuICAgIGRlbGV0ZU1vY2tEaXNwYXRjaChtb2NrRGlzcGF0Y2hlcywga2V5KVxuICB9XG5cbiAgZnVuY3Rpb24gcmVzdW1lICgpIHt9XG5cbiAgcmV0dXJuIHRydWVcbn1cblxuZnVuY3Rpb24gYnVpbGRNb2NrRGlzcGF0Y2ggKCkge1xuICBjb25zdCBhZ2VudCA9IHRoaXNba01vY2tBZ2VudF1cbiAgY29uc3Qgb3JpZ2luID0gdGhpc1trT3JpZ2luXVxuICBjb25zdCBvcmlnaW5hbERpc3BhdGNoID0gdGhpc1trT3JpZ2luYWxEaXNwYXRjaF1cblxuICByZXR1cm4gZnVuY3Rpb24gZGlzcGF0Y2ggKG9wdHMsIGhhbmRsZXIpIHtcbiAgICBpZiAoYWdlbnQuaXNNb2NrQWN0aXZlKSB7XG4gICAgICB0cnkge1xuICAgICAgICBtb2NrRGlzcGF0Y2guY2FsbCh0aGlzLCBvcHRzLCBoYW5kbGVyKVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgTW9ja05vdE1hdGNoZWRFcnJvcikge1xuICAgICAgICAgIGNvbnN0IG5ldENvbm5lY3QgPSBhZ2VudFtrR2V0TmV0Q29ubmVjdF0oKVxuICAgICAgICAgIGlmIChuZXRDb25uZWN0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE1vY2tOb3RNYXRjaGVkRXJyb3IoYCR7ZXJyb3IubWVzc2FnZX06IHN1YnNlcXVlbnQgcmVxdWVzdCB0byBvcmlnaW4gJHtvcmlnaW59IHdhcyBub3QgYWxsb3dlZCAobmV0LmNvbm5lY3QgZGlzYWJsZWQpYClcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNoZWNrTmV0Q29ubmVjdChuZXRDb25uZWN0LCBvcmlnaW4pKSB7XG4gICAgICAgICAgICBvcmlnaW5hbERpc3BhdGNoLmNhbGwodGhpcywgb3B0cywgaGFuZGxlcilcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE1vY2tOb3RNYXRjaGVkRXJyb3IoYCR7ZXJyb3IubWVzc2FnZX06IHN1YnNlcXVlbnQgcmVxdWVzdCB0byBvcmlnaW4gJHtvcmlnaW59IHdhcyBub3QgYWxsb3dlZCAobmV0LmNvbm5lY3QgaXMgbm90IGVuYWJsZWQgZm9yIHRoaXMgb3JpZ2luKWApXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IGVycm9yXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgb3JpZ2luYWxEaXNwYXRjaC5jYWxsKHRoaXMsIG9wdHMsIGhhbmRsZXIpXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrTmV0Q29ubmVjdCAobmV0Q29ubmVjdCwgb3JpZ2luKSB7XG4gIGNvbnN0IHVybCA9IG5ldyBVUkwob3JpZ2luKVxuICBpZiAobmV0Q29ubmVjdCA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiB0cnVlXG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShuZXRDb25uZWN0KSAmJiBuZXRDb25uZWN0LnNvbWUoKG1hdGNoZXIpID0+IG1hdGNoVmFsdWUobWF0Y2hlciwgdXJsLmhvc3QpKSkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIGJ1aWxkTW9ja09wdGlvbnMgKG9wdHMpIHtcbiAgaWYgKG9wdHMpIHtcbiAgICBjb25zdCB7IGFnZW50LCAuLi5tb2NrT3B0aW9ucyB9ID0gb3B0c1xuICAgIHJldHVybiBtb2NrT3B0aW9uc1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBnZXRSZXNwb25zZURhdGEsXG4gIGdldE1vY2tEaXNwYXRjaCxcbiAgYWRkTW9ja0Rpc3BhdGNoLFxuICBkZWxldGVNb2NrRGlzcGF0Y2gsXG4gIGJ1aWxkS2V5LFxuICBnZW5lcmF0ZUtleVZhbHVlcyxcbiAgbWF0Y2hWYWx1ZSxcbiAgZ2V0UmVzcG9uc2UsXG4gIGdldFN0YXR1c1RleHQsXG4gIG1vY2tEaXNwYXRjaCxcbiAgYnVpbGRNb2NrRGlzcGF0Y2gsXG4gIGNoZWNrTmV0Q29ubmVjdCxcbiAgYnVpbGRNb2NrT3B0aW9ucyxcbiAgZ2V0SGVhZGVyQnlOYW1lLFxuICBidWlsZEhlYWRlcnNGcm9tQXJyYXlcbn1cbiJdLCJuYW1lcyI6WyJNb2NrTm90TWF0Y2hlZEVycm9yIiwicmVxdWlyZSIsImtEaXNwYXRjaGVzIiwia01vY2tBZ2VudCIsImtPcmlnaW5hbERpc3BhdGNoIiwia09yaWdpbiIsImtHZXROZXRDb25uZWN0IiwiYnVpbGRVUkwiLCJTVEFUVVNfQ09ERVMiLCJ0eXBlcyIsImlzUHJvbWlzZSIsIm1hdGNoVmFsdWUiLCJtYXRjaCIsInZhbHVlIiwiUmVnRXhwIiwidGVzdCIsImxvd2VyQ2FzZUVudHJpZXMiLCJoZWFkZXJzIiwiT2JqZWN0IiwiZnJvbUVudHJpZXMiLCJlbnRyaWVzIiwibWFwIiwiaGVhZGVyTmFtZSIsImhlYWRlclZhbHVlIiwidG9Mb2NhbGVMb3dlckNhc2UiLCJnZXRIZWFkZXJCeU5hbWUiLCJrZXkiLCJBcnJheSIsImlzQXJyYXkiLCJpIiwibGVuZ3RoIiwidW5kZWZpbmVkIiwiZ2V0IiwiYnVpbGRIZWFkZXJzRnJvbUFycmF5IiwiY2xvbmUiLCJzbGljZSIsImluZGV4IiwicHVzaCIsIm1hdGNoSGVhZGVycyIsIm1vY2tEaXNwYXRjaCIsIm1hdGNoSGVhZGVyTmFtZSIsIm1hdGNoSGVhZGVyVmFsdWUiLCJzYWZlVXJsIiwicGF0aCIsInBhdGhTZWdtZW50cyIsInNwbGl0IiwicXAiLCJVUkxTZWFyY2hQYXJhbXMiLCJwb3AiLCJzb3J0IiwidG9TdHJpbmciLCJqb2luIiwibWF0Y2hLZXkiLCJtZXRob2QiLCJib2R5IiwicGF0aE1hdGNoIiwibWV0aG9kTWF0Y2giLCJib2R5TWF0Y2giLCJoZWFkZXJzTWF0Y2giLCJnZXRSZXNwb25zZURhdGEiLCJkYXRhIiwiQnVmZmVyIiwiaXNCdWZmZXIiLCJKU09OIiwic3RyaW5naWZ5IiwiZ2V0TW9ja0Rpc3BhdGNoIiwibW9ja0Rpc3BhdGNoZXMiLCJiYXNlUGF0aCIsInF1ZXJ5IiwicmVzb2x2ZWRQYXRoIiwibWF0Y2hlZE1vY2tEaXNwYXRjaGVzIiwiZmlsdGVyIiwiY29uc3VtZWQiLCJhZGRNb2NrRGlzcGF0Y2giLCJiYXNlRGF0YSIsInRpbWVzSW52b2tlZCIsInRpbWVzIiwicGVyc2lzdCIsInJlcGx5RGF0YSIsImNhbGxiYWNrIiwibmV3TW9ja0Rpc3BhdGNoIiwicGVuZGluZyIsImVycm9yIiwiZGVsZXRlTW9ja0Rpc3BhdGNoIiwiZmluZEluZGV4IiwiZGlzcGF0Y2giLCJzcGxpY2UiLCJidWlsZEtleSIsIm9wdHMiLCJnZW5lcmF0ZUtleVZhbHVlcyIsImtleXMiLCJyZXN1bHQiLCJuYW1lIiwiZnJvbSIsImoiLCJnZXRTdGF0dXNUZXh0Iiwic3RhdHVzQ29kZSIsImdldFJlc3BvbnNlIiwiYnVmZmVycyIsImNvbmNhdCIsImhhbmRsZXIiLCJ0cmFpbGVycyIsImRlbGF5Iiwib25FcnJvciIsInNldFRpbWVvdXQiLCJoYW5kbGVSZXBseSIsIl9kYXRhIiwib3B0c0hlYWRlcnMiLCJ0aGVuIiwibmV3RGF0YSIsInJlc3BvbnNlRGF0YSIsInJlc3BvbnNlSGVhZGVycyIsInJlc3BvbnNlVHJhaWxlcnMiLCJvbkNvbm5lY3QiLCJlcnIiLCJvbkhlYWRlcnMiLCJyZXN1bWUiLCJvbkRhdGEiLCJvbkNvbXBsZXRlIiwiYnVpbGRNb2NrRGlzcGF0Y2giLCJhZ2VudCIsIm9yaWdpbiIsIm9yaWdpbmFsRGlzcGF0Y2giLCJpc01vY2tBY3RpdmUiLCJjYWxsIiwibmV0Q29ubmVjdCIsIm1lc3NhZ2UiLCJjaGVja05ldENvbm5lY3QiLCJ1cmwiLCJVUkwiLCJzb21lIiwibWF0Y2hlciIsImhvc3QiLCJidWlsZE1vY2tPcHRpb25zIiwibW9ja09wdGlvbnMiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/mock/mock-utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/mock/pending-interceptors-formatter.js":
/*!************************************************************************!*\
  !*** ./node_modules/undici/lib/mock/pending-interceptors-formatter.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { Transform } = __webpack_require__(/*! node:stream */ \"node:stream\");\nconst { Console } = __webpack_require__(/*! node:console */ \"node:console\");\nconst PERSISTENT = process.versions.icu ? \"\" : \"Y \";\nconst NOT_PERSISTENT = process.versions.icu ? \"\" : \"N \";\n/**\n * Gets the output of `console.table()` as a string.\n */ module.exports = class PendingInterceptorsFormatter {\n    constructor({ disableColors } = {}){\n        this.transform = new Transform({\n            transform (chunk, _enc, cb) {\n                cb(null, chunk);\n            }\n        });\n        this.logger = new Console({\n            stdout: this.transform,\n            inspectOptions: {\n                colors: !disableColors && !process.env.CI\n            }\n        });\n    }\n    format(pendingInterceptors) {\n        const withPrettyHeaders = pendingInterceptors.map(({ method, path, data: { statusCode }, persist, times, timesInvoked, origin })=>({\n                Method: method,\n                Origin: origin,\n                Path: path,\n                \"Status code\": statusCode,\n                Persistent: persist ? PERSISTENT : NOT_PERSISTENT,\n                Invocations: timesInvoked,\n                Remaining: persist ? Infinity : times - timesInvoked\n            }));\n        this.logger.table(withPrettyHeaders);\n        return this.transform.read().toString();\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9tb2NrL3BlbmRpbmctaW50ZXJjZXB0b3JzLWZvcm1hdHRlci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU0sRUFBRUEsU0FBQUEsRUFBVyxHQUFHQyxtQkFBT0EsQ0FBQztBQUM5QixNQUFNLEVBQUVDLE9BQUFBLEVBQVMsR0FBR0QsbUJBQU9BLENBQUM7QUFFNUIsTUFBTUUsYUFBYUMsUUFBUUMsUUFBUSxDQUFDQyxHQUFHLEdBQUcsTUFBTTtBQUNoRCxNQUFNQyxpQkFBaUJILFFBQVFDLFFBQVEsQ0FBQ0MsR0FBRyxHQUFHLE1BQU07QUFFcEQ7O0NBRUEsR0FDQUUsT0FBT0MsT0FBTyxHQUFHLE1BQU1DO0lBQ3JCQyxZQUFhLEVBQUVDLGFBQUFBLEVBQWUsR0FBRyxDQUFDLENBQUMsQ0FBRTtRQUNuQyxJQUFJLENBQUNDLFNBQVMsR0FBRyxJQUFJYixVQUFVO1lBQzdCYSxXQUFXQyxLQUFLLEVBQUVDLElBQUksRUFBRUMsRUFBRTtnQkFDeEJBLEdBQUcsTUFBTUY7WUFDWDtRQUNGO1FBRUEsSUFBSSxDQUFDRyxNQUFNLEdBQUcsSUFBSWYsUUFBUTtZQUN4QmdCLFFBQVEsSUFBSSxDQUFDTCxTQUFTO1lBQ3RCTSxnQkFBZ0I7Z0JBQ2RDLFFBQVEsQ0FBQ1IsaUJBQWlCLENBQUNSLFFBQVFpQixHQUFHLENBQUNDLEVBQUFBO1lBQ3pDO1FBQ0Y7SUFDRjtJQUVBQyxPQUFRQyxtQkFBbUIsRUFBRTtRQUMzQixNQUFNQyxvQkFBb0JELG9CQUFvQkUsR0FBRyxDQUMvQyxDQUFDLEVBQUVDLE1BQU0sRUFBRUMsSUFBSSxFQUFFQyxNQUFNLEVBQUVDLFVBQUFBLEVBQVksRUFBRUMsT0FBTyxFQUFFQyxLQUFLLEVBQUVDLFlBQVksRUFBRUMsTUFBQUEsRUFBUSxHQUFNO2dCQUNqRkMsUUFBUVI7Z0JBQ1JTLFFBQVFGO2dCQUNSRyxNQUFNVDtnQkFDTixlQUFlRTtnQkFDZlEsWUFBWVAsVUFBVTVCLGFBQWFJO2dCQUNuQ2dDLGFBQWFOO2dCQUNiTyxXQUFXVCxVQUFVVSxXQUFXVCxRQUFRQztZQUMxQztRQUVGLElBQUksQ0FBQ2hCLE1BQU0sQ0FBQ3lCLEtBQUssQ0FBQ2pCO1FBQ2xCLE9BQU8sSUFBSSxDQUFDWixTQUFTLENBQUM4QixJQUFJLEdBQUdDLFFBQVE7SUFDdkM7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL21vY2t1cGZsb3cvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9tb2NrL3BlbmRpbmctaW50ZXJjZXB0b3JzLWZvcm1hdHRlci5qcz81MGIxIiwid2VicGFjazovL21vY2t1cGZsb3cvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9tb2NrL3BlbmRpbmctaW50ZXJjZXB0b3JzLWZvcm1hdHRlci5qcz81MGIxKiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyBUcmFuc2Zvcm0gfSA9IHJlcXVpcmUoJ25vZGU6c3RyZWFtJylcbmNvbnN0IHsgQ29uc29sZSB9ID0gcmVxdWlyZSgnbm9kZTpjb25zb2xlJylcblxuY29uc3QgUEVSU0lTVEVOVCA9IHByb2Nlc3MudmVyc2lvbnMuaWN1ID8gJ+KchScgOiAnWSAnXG5jb25zdCBOT1RfUEVSU0lTVEVOVCA9IHByb2Nlc3MudmVyc2lvbnMuaWN1ID8gJ+KdjCcgOiAnTiAnXG5cbi8qKlxuICogR2V0cyB0aGUgb3V0cHV0IG9mIGBjb25zb2xlLnRhYmxlKOKApilgIGFzIGEgc3RyaW5nLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIFBlbmRpbmdJbnRlcmNlcHRvcnNGb3JtYXR0ZXIge1xuICBjb25zdHJ1Y3RvciAoeyBkaXNhYmxlQ29sb3JzIH0gPSB7fSkge1xuICAgIHRoaXMudHJhbnNmb3JtID0gbmV3IFRyYW5zZm9ybSh7XG4gICAgICB0cmFuc2Zvcm0gKGNodW5rLCBfZW5jLCBjYikge1xuICAgICAgICBjYihudWxsLCBjaHVuaylcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgdGhpcy5sb2dnZXIgPSBuZXcgQ29uc29sZSh7XG4gICAgICBzdGRvdXQ6IHRoaXMudHJhbnNmb3JtLFxuICAgICAgaW5zcGVjdE9wdGlvbnM6IHtcbiAgICAgICAgY29sb3JzOiAhZGlzYWJsZUNvbG9ycyAmJiAhcHJvY2Vzcy5lbnYuQ0lcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgZm9ybWF0IChwZW5kaW5nSW50ZXJjZXB0b3JzKSB7XG4gICAgY29uc3Qgd2l0aFByZXR0eUhlYWRlcnMgPSBwZW5kaW5nSW50ZXJjZXB0b3JzLm1hcChcbiAgICAgICh7IG1ldGhvZCwgcGF0aCwgZGF0YTogeyBzdGF0dXNDb2RlIH0sIHBlcnNpc3QsIHRpbWVzLCB0aW1lc0ludm9rZWQsIG9yaWdpbiB9KSA9PiAoe1xuICAgICAgICBNZXRob2Q6IG1ldGhvZCxcbiAgICAgICAgT3JpZ2luOiBvcmlnaW4sXG4gICAgICAgIFBhdGg6IHBhdGgsXG4gICAgICAgICdTdGF0dXMgY29kZSc6IHN0YXR1c0NvZGUsXG4gICAgICAgIFBlcnNpc3RlbnQ6IHBlcnNpc3QgPyBQRVJTSVNURU5UIDogTk9UX1BFUlNJU1RFTlQsXG4gICAgICAgIEludm9jYXRpb25zOiB0aW1lc0ludm9rZWQsXG4gICAgICAgIFJlbWFpbmluZzogcGVyc2lzdCA/IEluZmluaXR5IDogdGltZXMgLSB0aW1lc0ludm9rZWRcbiAgICAgIH0pKVxuXG4gICAgdGhpcy5sb2dnZXIudGFibGUod2l0aFByZXR0eUhlYWRlcnMpXG4gICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtLnJlYWQoKS50b1N0cmluZygpXG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJUcmFuc2Zvcm0iLCJyZXF1aXJlIiwiQ29uc29sZSIsIlBFUlNJU1RFTlQiLCJwcm9jZXNzIiwidmVyc2lvbnMiLCJpY3UiLCJOT1RfUEVSU0lTVEVOVCIsIm1vZHVsZSIsImV4cG9ydHMiLCJQZW5kaW5nSW50ZXJjZXB0b3JzRm9ybWF0dGVyIiwiY29uc3RydWN0b3IiLCJkaXNhYmxlQ29sb3JzIiwidHJhbnNmb3JtIiwiY2h1bmsiLCJfZW5jIiwiY2IiLCJsb2dnZXIiLCJzdGRvdXQiLCJpbnNwZWN0T3B0aW9ucyIsImNvbG9ycyIsImVudiIsIkNJIiwiZm9ybWF0IiwicGVuZGluZ0ludGVyY2VwdG9ycyIsIndpdGhQcmV0dHlIZWFkZXJzIiwibWFwIiwibWV0aG9kIiwicGF0aCIsImRhdGEiLCJzdGF0dXNDb2RlIiwicGVyc2lzdCIsInRpbWVzIiwidGltZXNJbnZva2VkIiwib3JpZ2luIiwiTWV0aG9kIiwiT3JpZ2luIiwiUGF0aCIsIlBlcnNpc3RlbnQiLCJJbnZvY2F0aW9ucyIsIlJlbWFpbmluZyIsIkluZmluaXR5IiwidGFibGUiLCJyZWFkIiwidG9TdHJpbmciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/mock/pending-interceptors-formatter.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/mock/pluralizer.js":
/*!****************************************************!*\
  !*** ./node_modules/undici/lib/mock/pluralizer.js ***!
  \****************************************************/
/***/ ((module) => {

eval("\nconst singulars = {\n    pronoun: \"it\",\n    is: \"is\",\n    was: \"was\",\n    this: \"this\"\n};\nconst plurals = {\n    pronoun: \"they\",\n    is: \"are\",\n    was: \"were\",\n    this: \"these\"\n};\nmodule.exports = class Pluralizer {\n    constructor(singular, plural){\n        this.singular = singular;\n        this.plural = plural;\n    }\n    pluralize(count) {\n        const one = count === 1;\n        const keys = one ? singulars : plurals;\n        const noun = one ? this.singular : this.plural;\n        return {\n            ...keys,\n            count,\n            noun\n        };\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9tb2NrL3BsdXJhbGl6ZXIuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNQSxZQUFZO0lBQ2hCQyxTQUFTO0lBQ1RDLElBQUk7SUFDSkMsS0FBSztJQUNMQyxNQUFNO0FBQ1I7QUFFQSxNQUFNQyxVQUFVO0lBQ2RKLFNBQVM7SUFDVEMsSUFBSTtJQUNKQyxLQUFLO0lBQ0xDLE1BQU07QUFDUjtBQUVBRSxPQUFPQyxPQUFPLEdBQUcsTUFBTUM7SUFDckJDLFlBQWFDLFFBQVEsRUFBRUMsTUFBTSxDQUFFO1FBQzdCLElBQUksQ0FBQ0QsUUFBUSxHQUFHQTtRQUNoQixJQUFJLENBQUNDLE1BQU0sR0FBR0E7SUFDaEI7SUFFQUMsVUFBV0MsS0FBSyxFQUFFO1FBQ2hCLE1BQU1DLE1BQU1ELFVBQVU7UUFDdEIsTUFBTUUsT0FBT0QsTUFBTWQsWUFBWUs7UUFDL0IsTUFBTVcsT0FBT0YsTUFBTSxJQUFJLENBQUNKLFFBQVEsR0FBRyxJQUFJLENBQUNDLE1BQU07UUFDOUMsT0FBTztZQUFFLEdBQUdJLElBQUk7WUFBRUY7WUFBT0c7UUFBSztJQUNoQztBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbW9ja3VwZmxvdy8uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL21vY2svcGx1cmFsaXplci5qcz9jN2E3Iiwid2VicGFjazovL21vY2t1cGZsb3cvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9tb2NrL3BsdXJhbGl6ZXIuanM/YzdhNyoiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHNpbmd1bGFycyA9IHtcbiAgcHJvbm91bjogJ2l0JyxcbiAgaXM6ICdpcycsXG4gIHdhczogJ3dhcycsXG4gIHRoaXM6ICd0aGlzJ1xufVxuXG5jb25zdCBwbHVyYWxzID0ge1xuICBwcm9ub3VuOiAndGhleScsXG4gIGlzOiAnYXJlJyxcbiAgd2FzOiAnd2VyZScsXG4gIHRoaXM6ICd0aGVzZSdcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBQbHVyYWxpemVyIHtcbiAgY29uc3RydWN0b3IgKHNpbmd1bGFyLCBwbHVyYWwpIHtcbiAgICB0aGlzLnNpbmd1bGFyID0gc2luZ3VsYXJcbiAgICB0aGlzLnBsdXJhbCA9IHBsdXJhbFxuICB9XG5cbiAgcGx1cmFsaXplIChjb3VudCkge1xuICAgIGNvbnN0IG9uZSA9IGNvdW50ID09PSAxXG4gICAgY29uc3Qga2V5cyA9IG9uZSA/IHNpbmd1bGFycyA6IHBsdXJhbHNcbiAgICBjb25zdCBub3VuID0gb25lID8gdGhpcy5zaW5ndWxhciA6IHRoaXMucGx1cmFsXG4gICAgcmV0dXJuIHsgLi4ua2V5cywgY291bnQsIG5vdW4gfVxuICB9XG59XG4iXSwibmFtZXMiOlsic2luZ3VsYXJzIiwicHJvbm91biIsImlzIiwid2FzIiwidGhpcyIsInBsdXJhbHMiLCJtb2R1bGUiLCJleHBvcnRzIiwiUGx1cmFsaXplciIsImNvbnN0cnVjdG9yIiwic2luZ3VsYXIiLCJwbHVyYWwiLCJwbHVyYWxpemUiLCJjb3VudCIsIm9uZSIsImtleXMiLCJub3VuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/mock/pluralizer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/util/timers.js":
/*!************************************************!*\
  !*** ./node_modules/undici/lib/util/timers.js ***!
  \************************************************/
/***/ ((module) => {

eval("\nconst TICK_MS = 499;\nlet fastNow = Date.now();\nlet fastNowTimeout;\nconst fastTimers = [];\nfunction onTimeout() {\n    fastNow = Date.now();\n    let len = fastTimers.length;\n    let idx = 0;\n    while(idx < len){\n        const timer = fastTimers[idx];\n        if (timer.state === 0) {\n            timer.state = fastNow + timer.delay - TICK_MS;\n        } else if (timer.state > 0 && fastNow >= timer.state) {\n            timer.state = -1;\n            timer.callback(timer.opaque);\n        }\n        if (timer.state === -1) {\n            timer.state = -2;\n            if (idx !== len - 1) {\n                fastTimers[idx] = fastTimers.pop();\n            } else {\n                fastTimers.pop();\n            }\n            len -= 1;\n        } else {\n            idx += 1;\n        }\n    }\n    if (fastTimers.length > 0) {\n        refreshTimeout();\n    }\n}\nfunction refreshTimeout() {\n    if (fastNowTimeout?.refresh) {\n        fastNowTimeout.refresh();\n    } else {\n        clearTimeout(fastNowTimeout);\n        fastNowTimeout = setTimeout(onTimeout, TICK_MS);\n        if (fastNowTimeout.unref) {\n            fastNowTimeout.unref();\n        }\n    }\n}\nclass Timeout {\n    constructor(callback, delay, opaque){\n        this.callback = callback;\n        this.delay = delay;\n        this.opaque = opaque;\n        //  -2 not in timer list\n        //  -1 in timer list but inactive\n        //   0 in timer list waiting for time\n        // > 0 in timer list waiting for time to expire\n        this.state = -2;\n        this.refresh();\n    }\n    refresh() {\n        if (this.state === -2) {\n            fastTimers.push(this);\n            if (!fastNowTimeout || fastTimers.length === 1) {\n                refreshTimeout();\n            }\n        }\n        this.state = 0;\n    }\n    clear() {\n        this.state = -1;\n    }\n}\nmodule.exports = {\n    setTimeout (callback, delay, opaque) {\n        return delay <= 1e3 ? setTimeout(callback, delay, opaque) : new Timeout(callback, delay, opaque);\n    },\n    clearTimeout (timeout) {\n        if (timeout instanceof Timeout) {\n            timeout.clear();\n        } else {\n            clearTimeout(timeout);\n        }\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi91dGlsL3RpbWVycy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU1BLFVBQVU7QUFFaEIsSUFBSUMsVUFBVUMsS0FBS0MsR0FBRztBQUN0QixJQUFJQztBQUVKLE1BQU1DLGFBQWEsRUFBRTtBQUVyQixTQUFTQztJQUNQTCxVQUFVQyxLQUFLQyxHQUFHO0lBRWxCLElBQUlJLE1BQU1GLFdBQVdHLE1BQU07SUFDM0IsSUFBSUMsTUFBTTtJQUNWLE1BQU9BLE1BQU1GLElBQUs7UUFDaEIsTUFBTUcsUUFBUUwsVUFBVSxDQUFDSSxJQUFJO1FBRTdCLElBQUlDLE1BQU1DLEtBQUssS0FBSyxHQUFHO1lBQ3JCRCxNQUFNQyxLQUFLLEdBQUdWLFVBQVVTLE1BQU1FLEtBQUssR0FBR1o7UUFDeEMsT0FBTyxJQUFJVSxNQUFNQyxLQUFLLEdBQUcsS0FBS1YsV0FBV1MsTUFBTUMsS0FBSyxFQUFFO1lBQ3BERCxNQUFNQyxLQUFLLEdBQUcsQ0FBQztZQUNmRCxNQUFNRyxRQUFRLENBQUNILE1BQU1JLE1BQU07UUFDN0I7UUFFQSxJQUFJSixNQUFNQyxLQUFLLEtBQUssQ0FBQyxHQUFHO1lBQ3RCRCxNQUFNQyxLQUFLLEdBQUcsQ0FBQztZQUNmLElBQUlGLFFBQVFGLE1BQU0sR0FBRztnQkFDbkJGLFVBQVUsQ0FBQ0ksSUFBSSxHQUFHSixXQUFXVSxHQUFHO1lBQ2xDLE9BQU87Z0JBQ0xWLFdBQVdVLEdBQUc7WUFDaEI7WUFDQVIsT0FBTztRQUNULE9BQU87WUFDTEUsT0FBTztRQUNUO0lBQ0Y7SUFFQSxJQUFJSixXQUFXRyxNQUFNLEdBQUcsR0FBRztRQUN6QlE7SUFDRjtBQUNGO0FBRUEsU0FBU0E7SUFDUCxJQUFJWixnQkFBZ0JhLFNBQVM7UUFDM0JiLGVBQWVhLE9BQU87SUFDeEIsT0FBTztRQUNMQyxhQUFhZDtRQUNiQSxpQkFBaUJlLFdBQVdiLFdBQVdOO1FBQ3ZDLElBQUlJLGVBQWVnQixLQUFLLEVBQUU7WUFDeEJoQixlQUFlZ0IsS0FBSztRQUN0QjtJQUNGO0FBQ0Y7QUFFQSxNQUFNQztJQUNKQyxZQUFhVCxRQUFRLEVBQUVELEtBQUssRUFBRUUsTUFBTSxDQUFFO1FBQ3BDLElBQUksQ0FBQ0QsUUFBUSxHQUFHQTtRQUNoQixJQUFJLENBQUNELEtBQUssR0FBR0E7UUFDYixJQUFJLENBQUNFLE1BQU0sR0FBR0E7UUFFZDtRQUNBO1FBQ0E7UUFDQTtRQUNBLElBQUksQ0FBQ0gsS0FBSyxHQUFHLENBQUM7UUFFZCxJQUFJLENBQUNNLE9BQU87SUFDZDtJQUVBQSxVQUFXO1FBQ1QsSUFBSSxJQUFJLENBQUNOLEtBQUssS0FBSyxDQUFDLEdBQUc7WUFDckJOLFdBQVdrQixJQUFJLENBQUMsSUFBSTtZQUNwQixJQUFJLENBQUNuQixrQkFBa0JDLFdBQVdHLE1BQU0sS0FBSyxHQUFHO2dCQUM5Q1E7WUFDRjtRQUNGO1FBRUEsSUFBSSxDQUFDTCxLQUFLLEdBQUc7SUFDZjtJQUVBYSxRQUFTO1FBQ1AsSUFBSSxDQUFDYixLQUFLLEdBQUcsQ0FBQztJQUNoQjtBQUNGO0FBRUFjLE9BQU9DLE9BQU8sR0FBRztJQUNmUCxZQUFZTixRQUFRLEVBQUVELEtBQUssRUFBRUUsTUFBTTtRQUNqQyxPQUFPRixTQUFTLE1BQ1pPLFdBQVdOLFVBQVVELE9BQU9FLFVBQzVCLElBQUlPLFFBQVFSLFVBQVVELE9BQU9FO0lBQ25DO0lBQ0FJLGNBQWNTLE9BQU87UUFDbkIsSUFBSUEsbUJBQW1CTixTQUFTO1lBQzlCTSxRQUFRSCxLQUFLO1FBQ2YsT0FBTztZQUNMTixhQUFhUztRQUNmO0lBQ0Y7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL21vY2t1cGZsb3cvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi91dGlsL3RpbWVycy5qcz82MWQ0Iiwid2VicGFjazovL21vY2t1cGZsb3cvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi91dGlsL3RpbWVycy5qcz82MWQ0KiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgVElDS19NUyA9IDQ5OVxuXG5sZXQgZmFzdE5vdyA9IERhdGUubm93KClcbmxldCBmYXN0Tm93VGltZW91dFxuXG5jb25zdCBmYXN0VGltZXJzID0gW11cblxuZnVuY3Rpb24gb25UaW1lb3V0ICgpIHtcbiAgZmFzdE5vdyA9IERhdGUubm93KClcblxuICBsZXQgbGVuID0gZmFzdFRpbWVycy5sZW5ndGhcbiAgbGV0IGlkeCA9IDBcbiAgd2hpbGUgKGlkeCA8IGxlbikge1xuICAgIGNvbnN0IHRpbWVyID0gZmFzdFRpbWVyc1tpZHhdXG5cbiAgICBpZiAodGltZXIuc3RhdGUgPT09IDApIHtcbiAgICAgIHRpbWVyLnN0YXRlID0gZmFzdE5vdyArIHRpbWVyLmRlbGF5IC0gVElDS19NU1xuICAgIH0gZWxzZSBpZiAodGltZXIuc3RhdGUgPiAwICYmIGZhc3ROb3cgPj0gdGltZXIuc3RhdGUpIHtcbiAgICAgIHRpbWVyLnN0YXRlID0gLTFcbiAgICAgIHRpbWVyLmNhbGxiYWNrKHRpbWVyLm9wYXF1ZSlcbiAgICB9XG5cbiAgICBpZiAodGltZXIuc3RhdGUgPT09IC0xKSB7XG4gICAgICB0aW1lci5zdGF0ZSA9IC0yXG4gICAgICBpZiAoaWR4ICE9PSBsZW4gLSAxKSB7XG4gICAgICAgIGZhc3RUaW1lcnNbaWR4XSA9IGZhc3RUaW1lcnMucG9wKClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZhc3RUaW1lcnMucG9wKClcbiAgICAgIH1cbiAgICAgIGxlbiAtPSAxXG4gICAgfSBlbHNlIHtcbiAgICAgIGlkeCArPSAxXG4gICAgfVxuICB9XG5cbiAgaWYgKGZhc3RUaW1lcnMubGVuZ3RoID4gMCkge1xuICAgIHJlZnJlc2hUaW1lb3V0KClcbiAgfVxufVxuXG5mdW5jdGlvbiByZWZyZXNoVGltZW91dCAoKSB7XG4gIGlmIChmYXN0Tm93VGltZW91dD8ucmVmcmVzaCkge1xuICAgIGZhc3ROb3dUaW1lb3V0LnJlZnJlc2goKVxuICB9IGVsc2Uge1xuICAgIGNsZWFyVGltZW91dChmYXN0Tm93VGltZW91dClcbiAgICBmYXN0Tm93VGltZW91dCA9IHNldFRpbWVvdXQob25UaW1lb3V0LCBUSUNLX01TKVxuICAgIGlmIChmYXN0Tm93VGltZW91dC51bnJlZikge1xuICAgICAgZmFzdE5vd1RpbWVvdXQudW5yZWYoKVxuICAgIH1cbiAgfVxufVxuXG5jbGFzcyBUaW1lb3V0IHtcbiAgY29uc3RydWN0b3IgKGNhbGxiYWNrLCBkZWxheSwgb3BhcXVlKSB7XG4gICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrXG4gICAgdGhpcy5kZWxheSA9IGRlbGF5XG4gICAgdGhpcy5vcGFxdWUgPSBvcGFxdWVcblxuICAgIC8vICAtMiBub3QgaW4gdGltZXIgbGlzdFxuICAgIC8vICAtMSBpbiB0aW1lciBsaXN0IGJ1dCBpbmFjdGl2ZVxuICAgIC8vICAgMCBpbiB0aW1lciBsaXN0IHdhaXRpbmcgZm9yIHRpbWVcbiAgICAvLyA+IDAgaW4gdGltZXIgbGlzdCB3YWl0aW5nIGZvciB0aW1lIHRvIGV4cGlyZVxuICAgIHRoaXMuc3RhdGUgPSAtMlxuXG4gICAgdGhpcy5yZWZyZXNoKClcbiAgfVxuXG4gIHJlZnJlc2ggKCkge1xuICAgIGlmICh0aGlzLnN0YXRlID09PSAtMikge1xuICAgICAgZmFzdFRpbWVycy5wdXNoKHRoaXMpXG4gICAgICBpZiAoIWZhc3ROb3dUaW1lb3V0IHx8IGZhc3RUaW1lcnMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJlZnJlc2hUaW1lb3V0KClcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnN0YXRlID0gMFxuICB9XG5cbiAgY2xlYXIgKCkge1xuICAgIHRoaXMuc3RhdGUgPSAtMVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBzZXRUaW1lb3V0IChjYWxsYmFjaywgZGVsYXksIG9wYXF1ZSkge1xuICAgIHJldHVybiBkZWxheSA8PSAxZTNcbiAgICAgID8gc2V0VGltZW91dChjYWxsYmFjaywgZGVsYXksIG9wYXF1ZSlcbiAgICAgIDogbmV3IFRpbWVvdXQoY2FsbGJhY2ssIGRlbGF5LCBvcGFxdWUpXG4gIH0sXG4gIGNsZWFyVGltZW91dCAodGltZW91dCkge1xuICAgIGlmICh0aW1lb3V0IGluc3RhbmNlb2YgVGltZW91dCkge1xuICAgICAgdGltZW91dC5jbGVhcigpXG4gICAgfSBlbHNlIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KVxuICAgIH1cbiAgfVxufVxuIl0sIm5hbWVzIjpbIlRJQ0tfTVMiLCJmYXN0Tm93IiwiRGF0ZSIsIm5vdyIsImZhc3ROb3dUaW1lb3V0IiwiZmFzdFRpbWVycyIsIm9uVGltZW91dCIsImxlbiIsImxlbmd0aCIsImlkeCIsInRpbWVyIiwic3RhdGUiLCJkZWxheSIsImNhbGxiYWNrIiwib3BhcXVlIiwicG9wIiwicmVmcmVzaFRpbWVvdXQiLCJyZWZyZXNoIiwiY2xlYXJUaW1lb3V0Iiwic2V0VGltZW91dCIsInVucmVmIiwiVGltZW91dCIsImNvbnN0cnVjdG9yIiwicHVzaCIsImNsZWFyIiwibW9kdWxlIiwiZXhwb3J0cyIsInRpbWVvdXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/util/timers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/cache/cache.js":
/*!****************************************************!*\
  !*** ./node_modules/undici/lib/web/cache/cache.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { kConstruct } = __webpack_require__(/*! ./symbols */ \"(ssr)/./node_modules/undici/lib/web/cache/symbols.js\");\nconst { urlEquals, getFieldValues } = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/undici/lib/web/cache/util.js\");\nconst { kEnumerableProperty, isDisturbed } = __webpack_require__(/*! ../../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\");\nconst { webidl } = __webpack_require__(/*! ../fetch/webidl */ \"(ssr)/./node_modules/undici/lib/web/fetch/webidl.js\");\nconst { Response, cloneResponse, fromInnerResponse } = __webpack_require__(/*! ../fetch/response */ \"(ssr)/./node_modules/undici/lib/web/fetch/response.js\");\nconst { Request, fromInnerRequest } = __webpack_require__(/*! ../fetch/request */ \"(ssr)/./node_modules/undici/lib/web/fetch/request.js\");\nconst { kState } = __webpack_require__(/*! ../fetch/symbols */ \"(ssr)/./node_modules/undici/lib/web/fetch/symbols.js\");\nconst { fetching } = __webpack_require__(/*! ../fetch/index */ \"(ssr)/./node_modules/undici/lib/web/fetch/index.js\");\nconst { urlIsHttpHttpsScheme, createDeferredPromise, readAllBytes } = __webpack_require__(/*! ../fetch/util */ \"(ssr)/./node_modules/undici/lib/web/fetch/util.js\");\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\");\n/**\n * @see https://w3c.github.io/ServiceWorker/#dfn-cache-batch-operation\n * @typedef {Object} CacheBatchOperation\n * @property {'delete' | 'put'} type\n * @property {any} request\n * @property {any} response\n * @property {import('../../types/cache').CacheQueryOptions} options\n */ /**\n * @see https://w3c.github.io/ServiceWorker/#dfn-request-response-list\n * @typedef {[any, any][]} requestResponseList\n */ class Cache {\n    /**\n   * @see https://w3c.github.io/ServiceWorker/#dfn-relevant-request-response-list\n   * @type {requestResponseList}\n   */ #relevantRequestResponseList;\n    constructor(){\n        if (arguments[0] !== kConstruct) {\n            webidl.illegalConstructor();\n        }\n        this.#relevantRequestResponseList = arguments[1];\n    }\n    async match(request, options = {}) {\n        webidl.brandCheck(this, Cache);\n        const prefix = \"Cache.match\";\n        webidl.argumentLengthCheck(arguments, 1, prefix);\n        request = webidl.converters.RequestInfo(request, prefix, \"request\");\n        options = webidl.converters.CacheQueryOptions(options, prefix, \"options\");\n        const p = this.#internalMatchAll(request, options, 1);\n        if (p.length === 0) {\n            return;\n        }\n        return p[0];\n    }\n    async matchAll(request = undefined, options = {}) {\n        webidl.brandCheck(this, Cache);\n        const prefix = \"Cache.matchAll\";\n        if (request !== undefined) request = webidl.converters.RequestInfo(request, prefix, \"request\");\n        options = webidl.converters.CacheQueryOptions(options, prefix, \"options\");\n        return this.#internalMatchAll(request, options);\n    }\n    async add(request) {\n        webidl.brandCheck(this, Cache);\n        const prefix = \"Cache.add\";\n        webidl.argumentLengthCheck(arguments, 1, prefix);\n        request = webidl.converters.RequestInfo(request, prefix, \"request\");\n        // 1.\n        const requests = [\n            request\n        ];\n        // 2.\n        const responseArrayPromise = this.addAll(requests);\n        // 3.\n        return await responseArrayPromise;\n    }\n    async addAll(requests) {\n        webidl.brandCheck(this, Cache);\n        const prefix = \"Cache.addAll\";\n        webidl.argumentLengthCheck(arguments, 1, prefix);\n        // 1.\n        const responsePromises = [];\n        // 2.\n        const requestList = [];\n        // 3.\n        for (let request of requests){\n            if (request === undefined) {\n                throw webidl.errors.conversionFailed({\n                    prefix,\n                    argument: \"Argument 1\",\n                    types: [\n                        \"undefined is not allowed\"\n                    ]\n                });\n            }\n            request = webidl.converters.RequestInfo(request);\n            if (typeof request === \"string\") {\n                continue;\n            }\n            // 3.1\n            const r = request[kState];\n            // 3.2\n            if (!urlIsHttpHttpsScheme(r.url) || r.method !== \"GET\") {\n                throw webidl.errors.exception({\n                    header: prefix,\n                    message: \"Expected http/s scheme when method is not GET.\"\n                });\n            }\n        }\n        // 4.\n        /** @type {ReturnType<typeof fetching>[]} */ const fetchControllers = [];\n        // 5.\n        for (const request of requests){\n            // 5.1\n            const r = new Request(request)[kState];\n            // 5.2\n            if (!urlIsHttpHttpsScheme(r.url)) {\n                throw webidl.errors.exception({\n                    header: prefix,\n                    message: \"Expected http/s scheme.\"\n                });\n            }\n            // 5.4\n            r.initiator = \"fetch\";\n            r.destination = \"subresource\";\n            // 5.5\n            requestList.push(r);\n            // 5.6\n            const responsePromise = createDeferredPromise();\n            // 5.7\n            fetchControllers.push(fetching({\n                request: r,\n                processResponse (response) {\n                    // 1.\n                    if (response.type === \"error\" || response.status === 206 || response.status < 200 || response.status > 299) {\n                        responsePromise.reject(webidl.errors.exception({\n                            header: \"Cache.addAll\",\n                            message: \"Received an invalid status code or the request failed.\"\n                        }));\n                    } else if (response.headersList.contains(\"vary\")) {\n                        // 2.\n                        // 2.1\n                        const fieldValues = getFieldValues(response.headersList.get(\"vary\"));\n                        // 2.2\n                        for (const fieldValue of fieldValues){\n                            // 2.2.1\n                            if (fieldValue === \"*\") {\n                                responsePromise.reject(webidl.errors.exception({\n                                    header: \"Cache.addAll\",\n                                    message: \"invalid vary field value\"\n                                }));\n                                for (const controller of fetchControllers){\n                                    controller.abort();\n                                }\n                                return;\n                            }\n                        }\n                    }\n                },\n                processResponseEndOfBody (response) {\n                    // 1.\n                    if (response.aborted) {\n                        responsePromise.reject(new DOMException(\"aborted\", \"AbortError\"));\n                        return;\n                    }\n                    // 2.\n                    responsePromise.resolve(response);\n                }\n            }));\n            // 5.8\n            responsePromises.push(responsePromise.promise);\n        }\n        // 6.\n        const p = Promise.all(responsePromises);\n        // 7.\n        const responses = await p;\n        // 7.1\n        const operations = [];\n        // 7.2\n        let index = 0;\n        // 7.3\n        for (const response of responses){\n            // 7.3.1\n            /** @type {CacheBatchOperation} */ const operation = {\n                type: \"put\",\n                // 7.3.2\n                request: requestList[index],\n                // 7.3.3\n                response\n            };\n            operations.push(operation); // 7.3.5\n            index++; // 7.3.6\n        }\n        // 7.5\n        const cacheJobPromise = createDeferredPromise();\n        // 7.6.1\n        let errorData = null;\n        // 7.6.2\n        try {\n            this.#batchCacheOperations(operations);\n        } catch (e) {\n            errorData = e;\n        }\n        // 7.6.3\n        queueMicrotask(()=>{\n            // 7.6.3.1\n            if (errorData === null) {\n                cacheJobPromise.resolve(undefined);\n            } else {\n                // 7.6.3.2\n                cacheJobPromise.reject(errorData);\n            }\n        });\n        // 7.7\n        return cacheJobPromise.promise;\n    }\n    async put(request, response) {\n        webidl.brandCheck(this, Cache);\n        const prefix = \"Cache.put\";\n        webidl.argumentLengthCheck(arguments, 2, prefix);\n        request = webidl.converters.RequestInfo(request, prefix, \"request\");\n        response = webidl.converters.Response(response, prefix, \"response\");\n        // 1.\n        let innerRequest = null;\n        // 2.\n        if (request instanceof Request) {\n            innerRequest = request[kState];\n        } else {\n            // 3.\n            innerRequest = new Request(request)[kState];\n        }\n        // 4.\n        if (!urlIsHttpHttpsScheme(innerRequest.url) || innerRequest.method !== \"GET\") {\n            throw webidl.errors.exception({\n                header: prefix,\n                message: \"Expected an http/s scheme when method is not GET\"\n            });\n        }\n        // 5.\n        const innerResponse = response[kState];\n        // 6.\n        if (innerResponse.status === 206) {\n            throw webidl.errors.exception({\n                header: prefix,\n                message: \"Got 206 status\"\n            });\n        }\n        // 7.\n        if (innerResponse.headersList.contains(\"vary\")) {\n            // 7.1.\n            const fieldValues = getFieldValues(innerResponse.headersList.get(\"vary\"));\n            // 7.2.\n            for (const fieldValue of fieldValues){\n                // 7.2.1\n                if (fieldValue === \"*\") {\n                    throw webidl.errors.exception({\n                        header: prefix,\n                        message: \"Got * vary field value\"\n                    });\n                }\n            }\n        }\n        // 8.\n        if (innerResponse.body && (isDisturbed(innerResponse.body.stream) || innerResponse.body.stream.locked)) {\n            throw webidl.errors.exception({\n                header: prefix,\n                message: \"Response body is locked or disturbed\"\n            });\n        }\n        // 9.\n        const clonedResponse = cloneResponse(innerResponse);\n        // 10.\n        const bodyReadPromise = createDeferredPromise();\n        // 11.\n        if (innerResponse.body != null) {\n            // 11.1\n            const stream = innerResponse.body.stream;\n            // 11.2\n            const reader = stream.getReader();\n            // 11.3\n            readAllBytes(reader).then(bodyReadPromise.resolve, bodyReadPromise.reject);\n        } else {\n            bodyReadPromise.resolve(undefined);\n        }\n        // 12.\n        /** @type {CacheBatchOperation[]} */ const operations = [];\n        // 13.\n        /** @type {CacheBatchOperation} */ const operation = {\n            type: \"put\",\n            // 14.\n            request: innerRequest,\n            // 15.\n            response: clonedResponse // 16.\n        };\n        // 17.\n        operations.push(operation);\n        // 19.\n        const bytes = await bodyReadPromise.promise;\n        if (clonedResponse.body != null) {\n            clonedResponse.body.source = bytes;\n        }\n        // 19.1\n        const cacheJobPromise = createDeferredPromise();\n        // 19.2.1\n        let errorData = null;\n        // 19.2.2\n        try {\n            this.#batchCacheOperations(operations);\n        } catch (e) {\n            errorData = e;\n        }\n        // 19.2.3\n        queueMicrotask(()=>{\n            // 19.2.3.1\n            if (errorData === null) {\n                cacheJobPromise.resolve();\n            } else {\n                // 19.2.3.2\n                cacheJobPromise.reject(errorData);\n            }\n        });\n        return cacheJobPromise.promise;\n    }\n    async delete(request, options = {}) {\n        webidl.brandCheck(this, Cache);\n        const prefix = \"Cache.delete\";\n        webidl.argumentLengthCheck(arguments, 1, prefix);\n        request = webidl.converters.RequestInfo(request, prefix, \"request\");\n        options = webidl.converters.CacheQueryOptions(options, prefix, \"options\");\n        /**\n     * @type {Request}\n     */ let r = null;\n        if (request instanceof Request) {\n            r = request[kState];\n            if (r.method !== \"GET\" && !options.ignoreMethod) {\n                return false;\n            }\n        } else {\n            assert(typeof request === \"string\");\n            r = new Request(request)[kState];\n        }\n        /** @type {CacheBatchOperation[]} */ const operations = [];\n        /** @type {CacheBatchOperation} */ const operation = {\n            type: \"delete\",\n            request: r,\n            options\n        };\n        operations.push(operation);\n        const cacheJobPromise = createDeferredPromise();\n        let errorData = null;\n        let requestResponses;\n        try {\n            requestResponses = this.#batchCacheOperations(operations);\n        } catch (e) {\n            errorData = e;\n        }\n        queueMicrotask(()=>{\n            if (errorData === null) {\n                cacheJobPromise.resolve(!!requestResponses?.length);\n            } else {\n                cacheJobPromise.reject(errorData);\n            }\n        });\n        return cacheJobPromise.promise;\n    }\n    /**\n   * @see https://w3c.github.io/ServiceWorker/#dom-cache-keys\n   * @param {any} request\n   * @param {import('../../types/cache').CacheQueryOptions} options\n   * @returns {Promise<readonly Request[]>}\n   */ async keys(request = undefined, options = {}) {\n        webidl.brandCheck(this, Cache);\n        const prefix = \"Cache.keys\";\n        if (request !== undefined) request = webidl.converters.RequestInfo(request, prefix, \"request\");\n        options = webidl.converters.CacheQueryOptions(options, prefix, \"options\");\n        // 1.\n        let r = null;\n        // 2.\n        if (request !== undefined) {\n            // 2.1\n            if (request instanceof Request) {\n                // 2.1.1\n                r = request[kState];\n                // 2.1.2\n                if (r.method !== \"GET\" && !options.ignoreMethod) {\n                    return [];\n                }\n            } else if (typeof request === \"string\") {\n                // 2.2\n                r = new Request(request)[kState];\n            }\n        }\n        // 4.\n        const promise = createDeferredPromise();\n        // 5.\n        // 5.1\n        const requests = [];\n        // 5.2\n        if (request === undefined) {\n            // 5.2.1\n            for (const requestResponse of this.#relevantRequestResponseList){\n                // 5.2.1.1\n                requests.push(requestResponse[0]);\n            }\n        } else {\n            // 5.3\n            // 5.3.1\n            const requestResponses = this.#queryCache(r, options);\n            // 5.3.2\n            for (const requestResponse of requestResponses){\n                // 5.3.2.1\n                requests.push(requestResponse[0]);\n            }\n        }\n        // 5.4\n        queueMicrotask(()=>{\n            // 5.4.1\n            const requestList = [];\n            // 5.4.2\n            for (const request of requests){\n                const requestObject = fromInnerRequest(request, new AbortController().signal, \"immutable\");\n                // 5.4.2.1\n                requestList.push(requestObject);\n            }\n            // 5.4.3\n            promise.resolve(Object.freeze(requestList));\n        });\n        return promise.promise;\n    }\n    /**\n   * @see https://w3c.github.io/ServiceWorker/#batch-cache-operations-algorithm\n   * @param {CacheBatchOperation[]} operations\n   * @returns {requestResponseList}\n   */ #batchCacheOperations(operations) {\n        // 1.\n        const cache = this.#relevantRequestResponseList;\n        // 2.\n        const backupCache = [\n            ...cache\n        ];\n        // 3.\n        const addedItems = [];\n        // 4.1\n        const resultList = [];\n        try {\n            // 4.2\n            for (const operation of operations){\n                // 4.2.1\n                if (operation.type !== \"delete\" && operation.type !== \"put\") {\n                    throw webidl.errors.exception({\n                        header: \"Cache.#batchCacheOperations\",\n                        message: 'operation type does not match \"delete\" or \"put\"'\n                    });\n                }\n                // 4.2.2\n                if (operation.type === \"delete\" && operation.response != null) {\n                    throw webidl.errors.exception({\n                        header: \"Cache.#batchCacheOperations\",\n                        message: \"delete operation should not have an associated response\"\n                    });\n                }\n                // 4.2.3\n                if (this.#queryCache(operation.request, operation.options, addedItems).length) {\n                    throw new DOMException(\"???\", \"InvalidStateError\");\n                }\n                // 4.2.4\n                let requestResponses;\n                // 4.2.5\n                if (operation.type === \"delete\") {\n                    // 4.2.5.1\n                    requestResponses = this.#queryCache(operation.request, operation.options);\n                    // TODO: the spec is wrong, this is needed to pass WPTs\n                    if (requestResponses.length === 0) {\n                        return [];\n                    }\n                    // 4.2.5.2\n                    for (const requestResponse of requestResponses){\n                        const idx = cache.indexOf(requestResponse);\n                        assert(idx !== -1);\n                        // 4.2.5.2.1\n                        cache.splice(idx, 1);\n                    }\n                } else if (operation.type === \"put\") {\n                    // 4.2.6\n                    // 4.2.6.1\n                    if (operation.response == null) {\n                        throw webidl.errors.exception({\n                            header: \"Cache.#batchCacheOperations\",\n                            message: \"put operation should have an associated response\"\n                        });\n                    }\n                    // 4.2.6.2\n                    const r = operation.request;\n                    // 4.2.6.3\n                    if (!urlIsHttpHttpsScheme(r.url)) {\n                        throw webidl.errors.exception({\n                            header: \"Cache.#batchCacheOperations\",\n                            message: \"expected http or https scheme\"\n                        });\n                    }\n                    // 4.2.6.4\n                    if (r.method !== \"GET\") {\n                        throw webidl.errors.exception({\n                            header: \"Cache.#batchCacheOperations\",\n                            message: \"not get method\"\n                        });\n                    }\n                    // 4.2.6.5\n                    if (operation.options != null) {\n                        throw webidl.errors.exception({\n                            header: \"Cache.#batchCacheOperations\",\n                            message: \"options must not be defined\"\n                        });\n                    }\n                    // 4.2.6.6\n                    requestResponses = this.#queryCache(operation.request);\n                    // 4.2.6.7\n                    for (const requestResponse of requestResponses){\n                        const idx = cache.indexOf(requestResponse);\n                        assert(idx !== -1);\n                        // 4.2.6.7.1\n                        cache.splice(idx, 1);\n                    }\n                    // 4.2.6.8\n                    cache.push([\n                        operation.request,\n                        operation.response\n                    ]);\n                    // 4.2.6.10\n                    addedItems.push([\n                        operation.request,\n                        operation.response\n                    ]);\n                }\n                // 4.2.7\n                resultList.push([\n                    operation.request,\n                    operation.response\n                ]);\n            }\n            // 4.3\n            return resultList;\n        } catch (e) {\n            // 5.\n            // 5.1\n            this.#relevantRequestResponseList.length = 0;\n            // 5.2\n            this.#relevantRequestResponseList = backupCache;\n            // 5.3\n            throw e;\n        }\n    }\n    /**\n   * @see https://w3c.github.io/ServiceWorker/#query-cache\n   * @param {any} requestQuery\n   * @param {import('../../types/cache').CacheQueryOptions} options\n   * @param {requestResponseList} targetStorage\n   * @returns {requestResponseList}\n   */ #queryCache(requestQuery, options, targetStorage) {\n        /** @type {requestResponseList} */ const resultList = [];\n        const storage = targetStorage ?? this.#relevantRequestResponseList;\n        for (const requestResponse of storage){\n            const [cachedRequest, cachedResponse] = requestResponse;\n            if (this.#requestMatchesCachedItem(requestQuery, cachedRequest, cachedResponse, options)) {\n                resultList.push(requestResponse);\n            }\n        }\n        return resultList;\n    }\n    /**\n   * @see https://w3c.github.io/ServiceWorker/#request-matches-cached-item-algorithm\n   * @param {any} requestQuery\n   * @param {any} request\n   * @param {any | null} response\n   * @param {import('../../types/cache').CacheQueryOptions | undefined} options\n   * @returns {boolean}\n   */ #requestMatchesCachedItem(requestQuery, request, response = null, options) {\n        // if (options?.ignoreMethod === false && request.method === 'GET') {\n        //   return false\n        // }\n        const queryURL = new URL(requestQuery.url);\n        const cachedURL = new URL(request.url);\n        if (options?.ignoreSearch) {\n            cachedURL.search = \"\";\n            queryURL.search = \"\";\n        }\n        if (!urlEquals(queryURL, cachedURL, true)) {\n            return false;\n        }\n        if (response == null || options?.ignoreVary || !response.headersList.contains(\"vary\")) {\n            return true;\n        }\n        const fieldValues = getFieldValues(response.headersList.get(\"vary\"));\n        for (const fieldValue of fieldValues){\n            if (fieldValue === \"*\") {\n                return false;\n            }\n            const requestValue = request.headersList.get(fieldValue);\n            const queryValue = requestQuery.headersList.get(fieldValue);\n            // If one has the header and the other doesn't, or one has\n            // a different value than the other, return false\n            if (requestValue !== queryValue) {\n                return false;\n            }\n        }\n        return true;\n    }\n    #internalMatchAll(request, options, maxResponses = Infinity) {\n        // 1.\n        let r = null;\n        // 2.\n        if (request !== undefined) {\n            if (request instanceof Request) {\n                // 2.1.1\n                r = request[kState];\n                // 2.1.2\n                if (r.method !== \"GET\" && !options.ignoreMethod) {\n                    return [];\n                }\n            } else if (typeof request === \"string\") {\n                // 2.2.1\n                r = new Request(request)[kState];\n            }\n        }\n        // 5.\n        // 5.1\n        const responses = [];\n        // 5.2\n        if (request === undefined) {\n            // 5.2.1\n            for (const requestResponse of this.#relevantRequestResponseList){\n                responses.push(requestResponse[1]);\n            }\n        } else {\n            // 5.3\n            // 5.3.1\n            const requestResponses = this.#queryCache(r, options);\n            // 5.3.2\n            for (const requestResponse of requestResponses){\n                responses.push(requestResponse[1]);\n            }\n        }\n        // 5.4\n        // We don't implement CORs so we don't need to loop over the responses, yay!\n        // 5.5.1\n        const responseList = [];\n        // 5.5.2\n        for (const response of responses){\n            // 5.5.2.1\n            const responseObject = fromInnerResponse(response, \"immutable\");\n            responseList.push(responseObject.clone());\n            if (responseList.length >= maxResponses) {\n                break;\n            }\n        }\n        // 6.\n        return Object.freeze(responseList);\n    }\n}\nObject.defineProperties(Cache.prototype, {\n    [Symbol.toStringTag]: {\n        value: \"Cache\",\n        configurable: true\n    },\n    match: kEnumerableProperty,\n    matchAll: kEnumerableProperty,\n    add: kEnumerableProperty,\n    addAll: kEnumerableProperty,\n    put: kEnumerableProperty,\n    delete: kEnumerableProperty,\n    keys: kEnumerableProperty\n});\nconst cacheQueryOptionConverters = [\n    {\n        key: \"ignoreSearch\",\n        converter: webidl.converters.boolean,\n        defaultValue: ()=>false\n    },\n    {\n        key: \"ignoreMethod\",\n        converter: webidl.converters.boolean,\n        defaultValue: ()=>false\n    },\n    {\n        key: \"ignoreVary\",\n        converter: webidl.converters.boolean,\n        defaultValue: ()=>false\n    }\n];\nwebidl.converters.CacheQueryOptions = webidl.dictionaryConverter(cacheQueryOptionConverters);\nwebidl.converters.MultiCacheQueryOptions = webidl.dictionaryConverter([\n    ...cacheQueryOptionConverters,\n    {\n        key: \"cacheName\",\n        converter: webidl.converters.DOMString\n    }\n]);\nwebidl.converters.Response = webidl.interfaceConverter(Response);\nwebidl.converters[\"sequence<RequestInfo>\"] = webidl.sequenceConverter(webidl.converters.RequestInfo);\nmodule.exports = {\n    Cache\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvY2FjaGUvY2FjaGUuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNLEVBQUVBLFVBQUFBLEVBQVksR0FBR0MsbUJBQU9BLENBQUM7QUFDL0IsTUFBTSxFQUFFQyxTQUFTLEVBQUVDLGNBQUFBLEVBQWdCLEdBQUdGLG1CQUFPQSxDQUFDO0FBQzlDLE1BQU0sRUFBRUcsbUJBQW1CLEVBQUVDLFdBQUFBLEVBQWEsR0FBR0osbUJBQU9BLENBQUM7QUFDckQsTUFBTSxFQUFFSyxNQUFBQSxFQUFRLEdBQUdMLG1CQUFPQSxDQUFDO0FBQzNCLE1BQU0sRUFBRU0sUUFBUSxFQUFFQyxhQUFhLEVBQUVDLGlCQUFBQSxFQUFtQixHQUFHUixtQkFBT0EsQ0FBQztBQUMvRCxNQUFNLEVBQUVTLE9BQU8sRUFBRUMsZ0JBQUFBLEVBQWtCLEdBQUdWLG1CQUFPQSxDQUFDO0FBQzlDLE1BQU0sRUFBRVcsTUFBQUEsRUFBUSxHQUFHWCxtQkFBT0EsQ0FBQztBQUMzQixNQUFNLEVBQUVZLFFBQUFBLEVBQVUsR0FBR1osbUJBQU9BLENBQUM7QUFDN0IsTUFBTSxFQUFFYSxvQkFBb0IsRUFBRUMscUJBQXFCLEVBQUVDLFlBQUFBLEVBQWMsR0FBR2YsbUJBQU9BLENBQUM7QUFDOUUsTUFBTWdCLFNBQVNoQixtQkFBT0EsQ0FBQztBQUV2Qjs7Ozs7OztDQU9BLEdBRUE7OztDQUdBLEdBRUEsTUFBTWlCO0lBQ0o7OztHQUdGLEdBQ0UsQ0FBQ0MsMkJBQTJCO0lBRTVCQyxhQUFlO1FBQ2IsSUFBSUMsU0FBUyxDQUFDLEVBQUUsS0FBS3JCLFlBQVk7WUFDL0JNLE9BQU9nQixrQkFBa0I7UUFDM0I7UUFFQSxJQUFJLENBQUMsQ0FBQ0gsMkJBQTJCLEdBQUdFLFNBQVMsQ0FBQyxFQUFFO0lBQ2xEO0lBRUEsTUFBTUUsTUFBT0MsT0FBTyxFQUFFQyxVQUFVLENBQUMsQ0FBQyxFQUFFO1FBQ2xDbkIsT0FBT29CLFVBQVUsQ0FBQyxJ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QUFRL0Y7SUFDUmtHLE1BQU1sRztBQUNSO0FBRUEsTUFBTThJLDZCQUE2QjtJQUNqQztRQUNFQyxLQUFLO1FBQ0xDLFdBQVc5SSxPQUFPdUIsVUFBVSxDQUFDd0gsT0FBTztRQUNwQ0MsY0FBY0EsSUFBTTtJQUN0QjtJQUNBO1FBQ0VILEtBQUs7UUFDTEMsV0FBVzlJLE9BQU91QixVQUFVLENBQUN3SCxPQUFPO1FBQ3BDQyxjQUFjQSxJQUFNO0lBQ3RCO0lBQ0E7UUFDRUgsS0FBSztRQUNMQyxXQUFXOUksT0FBT3VCLFVBQVUsQ0FBQ3dILE9BQU87UUFDcENDLGNBQWNBLElBQU07SUFDdEI7Q0FDRDtBQUVEaEosT0FBT3VCLFVBQVUsQ0FBQ0UsaUJBQWlCLEdBQUd6QixPQUFPaUosbUJBQW1CLENBQUNMO0FBRWpFNUksT0FBT3VCLFVBQVUsQ0FBQzJILHNCQUFzQixHQUFHbEosT0FBT2lKLG1CQUFtQixDQUFDO09BQ2pFTDtJQUNIO1FBQ0VDLEtBQUs7UUFDTEMsV0FBVzlJLE9BQU91QixVQUFVLENBQUM0SCxTQUFBQTtJQUMvQjtDQUNEO0FBRURuSixPQUFPdUIsVUFBVSxDQUFDdEIsUUFBUSxHQUFHRCxPQUFPb0osa0JBQWtCLENBQUNuSjtBQUV2REQsT0FBT3VCLFVBQVUsQ0FBQyx3QkFBd0IsR0FBR3ZCLE9BQU9xSixpQkFBaUIsQ0FDbkVySixPQUFPdUIsVUFBVSxDQUFDQyxXQUNwQjtBQUVBOEgsT0FBT0MsT0FBTyxHQUFHO0lBQ2YzSTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbW9ja3VwZmxvdy8uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL3dlYi9jYWNoZS9jYWNoZS5qcz84ZmUwIiwid2VicGFjazovL21vY2t1cGZsb3cvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvY2FjaGUvY2FjaGUuanM/OGZlMCoiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsga0NvbnN0cnVjdCB9ID0gcmVxdWlyZSgnLi9zeW1ib2xzJylcbmNvbnN0IHsgdXJsRXF1YWxzLCBnZXRGaWVsZFZhbHVlcyB9ID0gcmVxdWlyZSgnLi91dGlsJylcbmNvbnN0IHsga0VudW1lcmFibGVQcm9wZXJ0eSwgaXNEaXN0dXJiZWQgfSA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvdXRpbCcpXG5jb25zdCB7IHdlYmlkbCB9ID0gcmVxdWlyZSgnLi4vZmV0Y2gvd2ViaWRsJylcbmNvbnN0IHsgUmVzcG9uc2UsIGNsb25lUmVzcG9uc2UsIGZyb21Jbm5lclJlc3BvbnNlIH0gPSByZXF1aXJlKCcuLi9mZXRjaC9yZXNwb25zZScpXG5jb25zdCB7IFJlcXVlc3QsIGZyb21Jbm5lclJlcXVlc3QgfSA9IHJlcXVpcmUoJy4uL2ZldGNoL3JlcXVlc3QnKVxuY29uc3QgeyBrU3RhdGUgfSA9IHJlcXVpcmUoJy4uL2ZldGNoL3N5bWJvbHMnKVxuY29uc3QgeyBmZXRjaGluZyB9ID0gcmVxdWlyZSgnLi4vZmV0Y2gvaW5kZXgnKVxuY29uc3QgeyB1cmxJc0h0dHBIdHRwc1NjaGVtZSwgY3JlYXRlRGVmZXJyZWRQcm9taXNlLCByZWFkQWxsQnl0ZXMgfSA9IHJlcXVpcmUoJy4uL2ZldGNoL3V0aWwnKVxuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZSgnbm9kZTphc3NlcnQnKVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL1NlcnZpY2VXb3JrZXIvI2Rmbi1jYWNoZS1iYXRjaC1vcGVyYXRpb25cbiAqIEB0eXBlZGVmIHtPYmplY3R9IENhY2hlQmF0Y2hPcGVyYXRpb25cbiAqIEBwcm9wZXJ0eSB7J2RlbGV0ZScgfCAncHV0J30gdHlwZVxuICogQHByb3BlcnR5IHthbnl9IHJlcXVlc3RcbiAqIEBwcm9wZXJ0eSB7YW55fSByZXNwb25zZVxuICogQHByb3BlcnR5IHtpbXBvcnQoJy4uLy4uL3R5cGVzL2NhY2hlJykuQ2FjaGVRdWVyeU9wdGlvbnN9IG9wdGlvbnNcbiAqL1xuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL1NlcnZpY2VXb3JrZXIvI2Rmbi1yZXF1ZXN0LXJlc3BvbnNlLWxpc3RcbiAqIEB0eXBlZGVmIHtbYW55LCBhbnldW119IHJlcXVlc3RSZXNwb25zZUxpc3RcbiAqL1xuXG5jbGFzcyBDYWNoZSB7XG4gIC8qKlxuICAgKiBAc2VlIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby9TZXJ2aWNlV29ya2VyLyNkZm4tcmVsZXZhbnQtcmVxdWVzdC1yZXNwb25zZS1saXN0XG4gICAqIEB0eXBlIHtyZXF1ZXN0UmVzcG9uc2VMaXN0fVxuICAgKi9cbiAgI3JlbGV2YW50UmVxdWVzdFJlc3BvbnNlTGlzdFxuXG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICBpZiAoYXJndW1lbnRzWzBdICE9PSBrQ29uc3RydWN0KSB7XG4gICAgICB3ZWJpZGwuaWxsZWdhbENvbnN0cnVjdG9yKClcbiAgICB9XG5cbiAgICB0aGlzLiNyZWxldmFudFJlcXVlc3RSZXNwb25zZUxpc3QgPSBhcmd1bWVudHNbMV1cbiAgfVxuXG4gIGFzeW5jIG1hdGNoIChyZXF1ZXN0LCBvcHRpb25zID0ge30pIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBDYWNoZSlcblxuICAgIGNvbnN0IHByZWZpeCA9ICdDYWNoZS5tYXRjaCdcbiAgICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDEsIHByZWZpeClcblxuICAgIHJlcXVlc3QgPSB3ZWJpZGwuY29udmVydGVycy5SZXF1ZXN0SW5mbyhyZXF1ZXN0LCBwcmVmaXgsICdyZXF1ZXN0JylcbiAgICBvcHRpb25zID0gd2ViaWRsLmNvbnZlcnRlcnMuQ2FjaGVRdWVyeU9wdGlvbnMob3B0aW9ucywgcHJlZml4LCAnb3B0aW9ucycpXG5cbiAgICBjb25zdCBwID0gdGhpcy4jaW50ZXJuYWxNYXRjaEFsbChyZXF1ZXN0LCBvcHRpb25zLCAxKVxuXG4gICAgaWYgKHAubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICByZXR1cm4gcFswXVxuICB9XG5cbiAgYXN5bmMgbWF0Y2hBbGwgKHJlcXVlc3QgPSB1bmRlZmluZWQsIG9wdGlvbnMgPSB7fSkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIENhY2hlKVxuXG4gICAgY29uc3QgcHJlZml4ID0gJ0NhY2hlLm1hdGNoQWxsJ1xuICAgIGlmIChyZXF1ZXN0ICE9PSB1bmRlZmluZWQpIHJlcXVlc3QgPSB3ZWJpZGwuY29udmVydGVycy5SZXF1ZXN0SW5mbyhyZXF1ZXN0LCBwcmVmaXgsICdyZXF1ZXN0JylcbiAgICBvcHRpb25zID0gd2ViaWRsLmNvbnZlcnRlcnMuQ2FjaGVRdWVyeU9wdGlvbnMob3B0aW9ucywgcHJlZml4LCAnb3B0aW9ucycpXG5cbiAgICByZXR1cm4gdGhpcy4jaW50ZXJuYWxNYXRjaEFsbChyZXF1ZXN0LCBvcHRpb25zKVxuICB9XG5cbiAgYXN5bmMgYWRkIChyZXF1ZXN0KSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgQ2FjaGUpXG5cbiAgICBjb25zdCBwcmVmaXggPSAnQ2FjaGUuYWRkJ1xuICAgIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMSwgcHJlZml4KVxuXG4gICAgcmVxdWVzdCA9IHdlYmlkbC5jb252ZXJ0ZXJzLlJlcXVlc3RJbmZvKHJlcXVlc3QsIHByZWZpeCwgJ3JlcXVlc3QnKVxuXG4gICAgLy8gMS5cbiAgICBjb25zdCByZXF1ZXN0cyA9IFtyZXF1ZXN0XVxuXG4gICAgLy8gMi5cbiAgICBjb25zdCByZXNwb25zZUFycmF5UHJvbWlzZSA9IHRoaXMuYWRkQWxsKHJlcXVlc3RzKVxuXG4gICAgLy8gMy5cbiAgICByZXR1cm4gYXdhaXQgcmVzcG9uc2VBcnJheVByb21pc2VcbiAgfVxuXG4gIGFzeW5jIGFkZEFsbCAocmVxdWVzdHMpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBDYWNoZSlcblxuICAgIGNvbnN0IHByZWZpeCA9ICdDYWNoZS5hZGRBbGwnXG4gICAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAxLCBwcmVmaXgpXG5cbiAgICAvLyAxLlxuICAgIGNvbnN0IHJlc3BvbnNlUHJvbWlzZXMgPSBbXVxuXG4gICAgLy8gMi5cbiAgICBjb25zdCByZXF1ZXN0TGlzdCA9IFtdXG5cbiAgICAvLyAzLlxuICAgIGZvciAobGV0IHJlcXVlc3Qgb2YgcmVxdWVzdHMpIHtcbiAgICAgIGlmIChyZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgd2ViaWRsLmVycm9ycy5jb252ZXJzaW9uRmFpbGVkKHtcbiAgICAgICAgICBwcmVmaXgsXG4gICAgICAgICAgYXJndW1lbnQ6ICdBcmd1bWVudCAxJyxcbiAgICAgICAgICB0eXBlczogWyd1bmRlZmluZWQgaXMgbm90IGFsbG93ZWQnXVxuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICByZXF1ZXN0ID0gd2ViaWRsLmNvbnZlcnRlcnMuUmVxdWVzdEluZm8ocmVxdWVzdClcblxuICAgICAgaWYgKHR5cGVvZiByZXF1ZXN0ID09PSAnc3RyaW5nJykge1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyAzLjFcbiAgICAgIGNvbnN0IHIgPSByZXF1ZXN0W2tTdGF0ZV1cblxuICAgICAgLy8gMy4yXG4gICAgICBpZiAoIXVybElzSHR0cEh0dHBzU2NoZW1lKHIudXJsKSB8fCByLm1ldGhvZCAhPT0gJ0dFVCcpIHtcbiAgICAgICAgdGhyb3cgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgICAgIGhlYWRlcjogcHJlZml4LFxuICAgICAgICAgIG1lc3NhZ2U6ICdFeHBlY3RlZCBodHRwL3Mgc2NoZW1lIHdoZW4gbWV0aG9kIGlzIG5vdCBHRVQuJ1xuICAgICAgICB9KVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIDQuXG4gICAgLyoqIEB0eXBlIHtSZXR1cm5UeXBlPHR5cGVvZiBmZXRjaGluZz5bXX0gKi9cbiAgICBjb25zdCBmZXRjaENvbnRyb2xsZXJzID0gW11cblxuICAgIC8vIDUuXG4gICAgZm9yIChjb25zdCByZXF1ZXN0IG9mIHJlcXVlc3RzKSB7XG4gICAgICAvLyA1LjFcbiAgICAgIGNvbnN0IHIgPSBuZXcgUmVxdWVzdChyZXF1ZXN0KVtrU3RhdGVdXG5cbiAgICAgIC8vIDUuMlxuICAgICAgaWYgKCF1cmxJc0h0dHBIdHRwc1NjaGVtZShyLnVybCkpIHtcbiAgICAgICAgdGhyb3cgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgICAgIGhlYWRlcjogcHJlZml4LFxuICAgICAgICAgIG1lc3NhZ2U6ICdFeHBlY3RlZCBodHRwL3Mgc2NoZW1lLidcbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAgLy8gNS40XG4gICAgICByLmluaXRpYXRvciA9ICdmZXRjaCdcbiAgICAgIHIuZGVzdGluYXRpb24gPSAnc3VicmVzb3VyY2UnXG5cbiAgICAgIC8vIDUuNVxuICAgICAgcmVxdWVzdExpc3QucHVzaChyKVxuXG4gICAgICAvLyA1LjZcbiAgICAgIGNvbnN0IHJlc3BvbnNlUHJvbWlzZSA9IGNyZWF0ZURlZmVycmVkUHJvbWlzZSgpXG5cbiAgICAgIC8vIDUuN1xuICAgICAgZmV0Y2hDb250cm9sbGVycy5wdXNoKGZldGNoaW5nKHtcbiAgICAgICAgcmVxdWVzdDogcixcbiAgICAgICAgcHJvY2Vzc1Jlc3BvbnNlIChyZXNwb25zZSkge1xuICAgICAgICAgIC8vIDEuXG4gICAgICAgICAgaWYgKHJlc3BvbnNlLnR5cGUgPT09ICdlcnJvcicgfHwgcmVzcG9uc2Uuc3RhdHVzID09PSAyMDYgfHwgcmVzcG9uc2Uuc3RhdHVzIDwgMjAwIHx8IHJlc3BvbnNlLnN0YXR1cyA+IDI5OSkge1xuICAgICAgICAgICAgcmVzcG9uc2VQcm9taXNlLnJlamVjdCh3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICAgICAgICAgIGhlYWRlcjogJ0NhY2hlLmFkZEFsbCcsXG4gICAgICAgICAgICAgIG1lc3NhZ2U6ICdSZWNlaXZlZCBhbiBpbnZhbGlkIHN0YXR1cyBjb2RlIG9yIHRoZSByZXF1ZXN0IGZhaWxlZC4nXG4gICAgICAgICAgICB9KSlcbiAgICAgICAgICB9IGVsc2UgaWYgKHJlc3BvbnNlLmhlYWRlcnNMaXN0LmNvbnRhaW5zKCd2YXJ5JykpIHsgLy8gMi5cbiAgICAgICAgICAgIC8vIDIuMVxuICAgICAgICAgICAgY29uc3QgZmllbGRWYWx1ZXMgPSBnZXRGaWVsZFZhbHVlcyhyZXNwb25zZS5oZWFkZXJzTGlzdC5nZXQoJ3ZhcnknKSlcblxuICAgICAgICAgICAgLy8gMi4yXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGZpZWxkVmFsdWUgb2YgZmllbGRWYWx1ZXMpIHtcbiAgICAgICAgICAgICAgLy8gMi4yLjFcbiAgICAgICAgICAgICAgaWYgKGZpZWxkVmFsdWUgPT09ICcqJykge1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlUHJvbWlzZS5yZWplY3Qod2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgICAgICAgICAgICAgaGVhZGVyOiAnQ2FjaGUuYWRkQWxsJyxcbiAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdpbnZhbGlkIHZhcnkgZmllbGQgdmFsdWUnXG4gICAgICAgICAgICAgICAgfSkpXG5cbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGNvbnRyb2xsZXIgb2YgZmV0Y2hDb250cm9sbGVycykge1xuICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5hYm9ydCgpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHByb2Nlc3NSZXNwb25zZUVuZE9mQm9keSAocmVzcG9uc2UpIHtcbiAgICAgICAgICAvLyAxLlxuICAgICAgICAgIGlmIChyZXNwb25zZS5hYm9ydGVkKSB7XG4gICAgICAgICAgICByZXNwb25zZVByb21pc2UucmVqZWN0KG5ldyBET01FeGNlcHRpb24oJ2Fib3J0ZWQnLCAnQWJvcnRFcnJvcicpKVxuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gMi5cbiAgICAgICAgICByZXNwb25zZVByb21pc2UucmVzb2x2ZShyZXNwb25zZSlcbiAgICAgICAgfVxuICAgICAgfSkpXG5cbiAgICAgIC8vIDUuOFxuICAgICAgcmVzcG9uc2VQcm9taXNlcy5wdXNoKHJlc3BvbnNlUHJvbWlzZS5wcm9taXNlKVxuICAgIH1cblxuICAgIC8vIDYuXG4gICAgY29uc3QgcCA9IFByb21pc2UuYWxsKHJlc3BvbnNlUHJvbWlzZXMpXG5cbiAgICAvLyA3LlxuICAgIGNvbnN0IHJlc3BvbnNlcyA9IGF3YWl0IHBcblxuICAgIC8vIDcuMVxuICAgIGNvbnN0IG9wZXJhdGlvbnMgPSBbXVxuXG4gICAgLy8gNy4yXG4gICAgbGV0IGluZGV4ID0gMFxuXG4gICAgLy8gNy4zXG4gICAgZm9yIChjb25zdCByZXNwb25zZSBvZiByZXNwb25zZXMpIHtcbiAgICAgIC8vIDcuMy4xXG4gICAgICAvKiogQHR5cGUge0NhY2hlQmF0Y2hPcGVyYXRpb259ICovXG4gICAgICBjb25zdCBvcGVyYXRpb24gPSB7XG4gICAgICAgIHR5cGU6ICdwdXQnLCAvLyA3LjMuMlxuICAgICAgICByZXF1ZXN0OiByZXF1ZXN0TGlzdFtpbmRleF0sIC8vIDcuMy4zXG4gICAgICAgIHJlc3BvbnNlIC8vIDcuMy40XG4gICAgICB9XG5cbiAgICAgIG9wZXJhdGlvbnMucHVzaChvcGVyYXRpb24pIC8vIDcuMy41XG5cbiAgICAgIGluZGV4KysgLy8gNy4zLjZcbiAgICB9XG5cbiAgICAvLyA3LjVcbiAgICBjb25zdCBjYWNoZUpvYlByb21pc2UgPSBjcmVhdGVEZWZlcnJlZFByb21pc2UoKVxuXG4gICAgLy8gNy42LjFcbiAgICBsZXQgZXJyb3JEYXRhID0gbnVsbFxuXG4gICAgLy8gNy42LjJcbiAgICB0cnkge1xuICAgICAgdGhpcy4jYmF0Y2hDYWNoZU9wZXJhdGlvbnMob3BlcmF0aW9ucylcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBlcnJvckRhdGEgPSBlXG4gICAgfVxuXG4gICAgLy8gNy42LjNcbiAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICAvLyA3LjYuMy4xXG4gICAgICBpZiAoZXJyb3JEYXRhID09PSBudWxsKSB7XG4gICAgICAgIGNhY2hlSm9iUHJvbWlzZS5yZXNvbHZlKHVuZGVmaW5lZClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIDcuNi4zLjJcbiAgICAgICAgY2FjaGVKb2JQcm9taXNlLnJlamVjdChlcnJvckRhdGEpXG4gICAgICB9XG4gICAgfSlcblxuICAgIC8vIDcuN1xuICAgIHJldHVybiBjYWNoZUpvYlByb21pc2UucHJvbWlzZVxuICB9XG5cbiAgYXN5bmMgcHV0IChyZXF1ZXN0LCByZXNwb25zZSkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIENhY2hlKVxuXG4gICAgY29uc3QgcHJlZml4ID0gJ0NhY2hlLnB1dCdcbiAgICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDIsIHByZWZpeClcblxuICAgIHJlcXVlc3QgPSB3ZWJpZGwuY29udmVydGVycy5SZXF1ZXN0SW5mbyhyZXF1ZXN0LCBwcmVmaXgsICdyZXF1ZXN0JylcbiAgICByZXNwb25zZSA9IHdlYmlkbC5jb252ZXJ0ZXJzLlJlc3BvbnNlKHJlc3BvbnNlLCBwcmVmaXgsICdyZXNwb25zZScpXG5cbiAgICAvLyAxLlxuICAgIGxldCBpbm5lclJlcXVlc3QgPSBudWxsXG5cbiAgICAvLyAyLlxuICAgIGlmIChyZXF1ZXN0IGluc3RhbmNlb2YgUmVxdWVzdCkge1xuICAgICAgaW5uZXJSZXF1ZXN0ID0gcmVxdWVzdFtrU3RhdGVdXG4gICAgfSBlbHNlIHsgLy8gMy5cbiAgICAgIGlubmVyUmVxdWVzdCA9IG5ldyBSZXF1ZXN0KHJlcXVlc3QpW2tTdGF0ZV1cbiAgICB9XG5cbiAgICAvLyA0LlxuICAgIGlmICghdXJsSXNIdHRwSHR0cHNTY2hlbWUoaW5uZXJSZXF1ZXN0LnVybCkgfHwgaW5uZXJSZXF1ZXN0Lm1ldGhvZCAhPT0gJ0dFVCcpIHtcbiAgICAgIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgICAgaGVhZGVyOiBwcmVmaXgsXG4gICAgICAgIG1lc3NhZ2U6ICdFeHBlY3RlZCBhbiBodHRwL3Mgc2NoZW1lIHdoZW4gbWV0aG9kIGlzIG5vdCBHRVQnXG4gICAgICB9KVxuICAgIH1cblxuICAgIC8vIDUuXG4gICAgY29uc3QgaW5uZXJSZXNwb25zZSA9IHJlc3BvbnNlW2tTdGF0ZV1cblxuICAgIC8vIDYuXG4gICAgaWYgKGlubmVyUmVzcG9uc2Uuc3RhdHVzID09PSAyMDYpIHtcbiAgICAgIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgICAgaGVhZGVyOiBwcmVmaXgsXG4gICAgICAgIG1lc3NhZ2U6ICdHb3QgMjA2IHN0YXR1cydcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgLy8gNy5cbiAgICBpZiAoaW5uZXJSZXNwb25zZS5oZWFkZXJzTGlzdC5jb250YWlucygndmFyeScpKSB7XG4gICAgICAvLyA3LjEuXG4gICAgICBjb25zdCBmaWVsZFZhbHVlcyA9IGdldEZpZWxkVmFsdWVzKGlubmVyUmVzcG9uc2UuaGVhZGVyc0xpc3QuZ2V0KCd2YXJ5JykpXG5cbiAgICAgIC8vIDcuMi5cbiAgICAgIGZvciAoY29uc3QgZmllbGRWYWx1ZSBvZiBmaWVsZFZhbHVlcykge1xuICAgICAgICAvLyA3LjIuMVxuICAgICAgICBpZiAoZmllbGRWYWx1ZSA9PT0gJyonKSB7XG4gICAgICAgICAgdGhyb3cgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgICAgICAgaGVhZGVyOiBwcmVmaXgsXG4gICAgICAgICAgICBtZXNzYWdlOiAnR290ICogdmFyeSBmaWVsZCB2YWx1ZSdcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gOC5cbiAgICBpZiAoaW5uZXJSZXNwb25zZS5ib2R5ICYmIChpc0Rpc3R1cmJlZChpbm5lclJlc3BvbnNlLmJvZHkuc3RyZWFtKSB8fCBpbm5lclJlc3BvbnNlLmJvZHkuc3RyZWFtLmxvY2tlZCkpIHtcbiAgICAgIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgICAgaGVhZGVyOiBwcmVmaXgsXG4gICAgICAgIG1lc3NhZ2U6ICdSZXNwb25zZSBib2R5IGlzIGxvY2tlZCBvciBkaXN0dXJiZWQnXG4gICAgICB9KVxuICAgIH1cblxuICAgIC8vIDkuXG4gICAgY29uc3QgY2xvbmVkUmVzcG9uc2UgPSBjbG9uZVJlc3BvbnNlKGlubmVyUmVzcG9uc2UpXG5cbiAgICAvLyAxMC5cbiAgICBjb25zdCBib2R5UmVhZFByb21pc2UgPSBjcmVhdGVEZWZlcnJlZFByb21pc2UoKVxuXG4gICAgLy8gMTEuXG4gICAgaWYgKGlubmVyUmVzcG9uc2UuYm9keSAhPSBudWxsKSB7XG4gICAgICAvLyAxMS4xXG4gICAgICBjb25zdCBzdHJlYW0gPSBpbm5lclJlc3BvbnNlLmJvZHkuc3RyZWFtXG5cbiAgICAgIC8vIDExLjJcbiAgICAgIGNvbnN0IHJlYWRlciA9IHN0cmVhbS5nZXRSZWFkZXIoKVxuXG4gICAgICAvLyAxMS4zXG4gICAgICByZWFkQWxsQnl0ZXMocmVhZGVyKS50aGVuKGJvZHlSZWFkUHJvbWlzZS5yZXNvbHZlLCBib2R5UmVhZFByb21pc2UucmVqZWN0KVxuICAgIH0gZWxzZSB7XG4gICAgICBib2R5UmVhZFByb21pc2UucmVzb2x2ZSh1bmRlZmluZWQpXG4gICAgfVxuXG4gICAgLy8gMTIuXG4gICAgLyoqIEB0eXBlIHtDYWNoZUJhdGNoT3BlcmF0aW9uW119ICovXG4gICAgY29uc3Qgb3BlcmF0aW9ucyA9IFtdXG5cbiAgICAvLyAxMy5cbiAgICAvKiogQHR5cGUge0NhY2hlQmF0Y2hPcGVyYXRpb259ICovXG4gICAgY29uc3Qgb3BlcmF0aW9uID0ge1xuICAgICAgdHlwZTogJ3B1dCcsIC8vIDE0LlxuICAgICAgcmVxdWVzdDogaW5uZXJSZXF1ZXN0LCAvLyAxNS5cbiAgICAgIHJlc3BvbnNlOiBjbG9uZWRSZXNwb25zZSAvLyAxNi5cbiAgICB9XG5cbiAgICAvLyAxNy5cbiAgICBvcGVyYXRpb25zLnB1c2gob3BlcmF0aW9uKVxuXG4gICAgLy8gMTkuXG4gICAgY29uc3QgYnl0ZXMgPSBhd2FpdCBib2R5UmVhZFByb21pc2UucHJvbWlzZVxuXG4gICAgaWYgKGNsb25lZFJlc3BvbnNlLmJvZHkgIT0gbnVsbCkge1xuICAgICAgY2xvbmVkUmVzcG9uc2UuYm9keS5zb3VyY2UgPSBieXRlc1xuICAgIH1cblxuICAgIC8vIDE5LjFcbiAgICBjb25zdCBjYWNoZUpvYlByb21pc2UgPSBjcmVhdGVEZWZlcnJlZFByb21pc2UoKVxuXG4gICAgLy8gMTkuMi4xXG4gICAgbGV0IGVycm9yRGF0YSA9IG51bGxcblxuICAgIC8vIDE5LjIuMlxuICAgIHRyeSB7XG4gICAgICB0aGlzLiNiYXRjaENhY2hlT3BlcmF0aW9ucyhvcGVyYXRpb25zKVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGVycm9yRGF0YSA9IGVcbiAgICB9XG5cbiAgICAvLyAxOS4yLjNcbiAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICAvLyAxOS4yLjMuMVxuICAgICAgaWYgKGVycm9yRGF0YSA9PT0gbnVsbCkge1xuICAgICAgICBjYWNoZUpvYlByb21pc2UucmVzb2x2ZSgpXG4gICAgICB9IGVsc2UgeyAvLyAxOS4yLjMuMlxuICAgICAgICBjYWNoZUpvYlByb21pc2UucmVqZWN0KGVycm9yRGF0YSlcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgcmV0dXJuIGNhY2hlSm9iUHJvbWlzZS5wcm9taXNlXG4gIH1cblxuICBhc3luYyBkZWxldGUgKHJlcXVlc3QsIG9wdGlvbnMgPSB7fSkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIENhY2hlKVxuXG4gICAgY29uc3QgcHJlZml4ID0gJ0NhY2hlLmRlbGV0ZSdcbiAgICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDEsIHByZWZpeClcblxuICAgIHJlcXVlc3QgPSB3ZWJpZGwuY29udmVydGVycy5SZXF1ZXN0SW5mbyhyZXF1ZXN0LCBwcmVmaXgsICdyZXF1ZXN0JylcbiAgICBvcHRpb25zID0gd2ViaWRsLmNvbnZlcnRlcnMuQ2FjaGVRdWVyeU9wdGlvbnMob3B0aW9ucywgcHJlZml4LCAnb3B0aW9ucycpXG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7UmVxdWVzdH1cbiAgICAgKi9cbiAgICBsZXQgciA9IG51bGxcblxuICAgIGlmIChyZXF1ZXN0IGluc3RhbmNlb2YgUmVxdWVzdCkge1xuICAgICAgciA9IHJlcXVlc3Rba1N0YXRlXVxuXG4gICAgICBpZiAoci5tZXRob2QgIT09ICdHRVQnICYmICFvcHRpb25zLmlnbm9yZU1ldGhvZCkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgYXNzZXJ0KHR5cGVvZiByZXF1ZXN0ID09PSAnc3RyaW5nJylcblxuICAgICAgciA9IG5ldyBSZXF1ZXN0KHJlcXVlc3QpW2tTdGF0ZV1cbiAgICB9XG5cbiAgICAvKiogQHR5cGUge0NhY2hlQmF0Y2hPcGVyYXRpb25bXX0gKi9cbiAgICBjb25zdCBvcGVyYXRpb25zID0gW11cblxuICAgIC8qKiBAdHlwZSB7Q2FjaGVCYXRjaE9wZXJhdGlvbn0gKi9cbiAgICBjb25zdCBvcGVyYXRpb24gPSB7XG4gICAgICB0eXBlOiAnZGVsZXRlJyxcbiAgICAgIHJlcXVlc3Q6IHIsXG4gICAgICBvcHRpb25zXG4gICAgfVxuXG4gICAgb3BlcmF0aW9ucy5wdXNoKG9wZXJhdGlvbilcblxuICAgIGNvbnN0IGNhY2hlSm9iUHJvbWlzZSA9IGNyZWF0ZURlZmVycmVkUHJvbWlzZSgpXG5cbiAgICBsZXQgZXJyb3JEYXRhID0gbnVsbFxuICAgIGxldCByZXF1ZXN0UmVzcG9uc2VzXG5cbiAgICB0cnkge1xuICAgICAgcmVxdWVzdFJlc3BvbnNlcyA9IHRoaXMuI2JhdGNoQ2FjaGVPcGVyYXRpb25zKG9wZXJhdGlvbnMpXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZXJyb3JEYXRhID0gZVxuICAgIH1cblxuICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgIGlmIChlcnJvckRhdGEgPT09IG51bGwpIHtcbiAgICAgICAgY2FjaGVKb2JQcm9taXNlLnJlc29sdmUoISFyZXF1ZXN0UmVzcG9uc2VzPy5sZW5ndGgpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYWNoZUpvYlByb21pc2UucmVqZWN0KGVycm9yRGF0YSlcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgcmV0dXJuIGNhY2hlSm9iUHJvbWlzZS5wcm9taXNlXG4gIH1cblxuICAvKipcbiAgICogQHNlZSBodHRwczovL3czYy5naXRodWIuaW8vU2VydmljZVdvcmtlci8jZG9tLWNhY2hlLWtleXNcbiAgICogQHBhcmFtIHthbnl9IHJlcXVlc3RcbiAgICogQHBhcmFtIHtpbXBvcnQoJy4uLy4uL3R5cGVzL2NhY2hlJykuQ2FjaGVRdWVyeU9wdGlvbnN9IG9wdGlvbnNcbiAgICogQHJldHVybnMge1Byb21pc2U8cmVhZG9ubHkgUmVxdWVzdFtdPn1cbiAgICovXG4gIGFzeW5jIGtleXMgKHJlcXVlc3QgPSB1bmRlZmluZWQsIG9wdGlvbnMgPSB7fSkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIENhY2hlKVxuXG4gICAgY29uc3QgcHJlZml4ID0gJ0NhY2hlLmtleXMnXG5cbiAgICBpZiAocmVxdWVzdCAhPT0gdW5kZWZpbmVkKSByZXF1ZXN0ID0gd2ViaWRsLmNvbnZlcnRlcnMuUmVxdWVzdEluZm8ocmVxdWVzdCwgcHJlZml4LCAncmVxdWVzdCcpXG4gICAgb3B0aW9ucyA9IHdlYmlkbC5jb252ZXJ0ZXJzLkNhY2hlUXVlcnlPcHRpb25zKG9wdGlvbnMsIHByZWZpeCwgJ29wdGlvbnMnKVxuXG4gICAgLy8gMS5cbiAgICBsZXQgciA9IG51bGxcblxuICAgIC8vIDIuXG4gICAgaWYgKHJlcXVlc3QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gMi4xXG4gICAgICBpZiAocmVxdWVzdCBpbnN0YW5jZW9mIFJlcXVlc3QpIHtcbiAgICAgICAgLy8gMi4xLjFcbiAgICAgICAgciA9IHJlcXVlc3Rba1N0YXRlXVxuXG4gICAgICAgIC8vIDIuMS4yXG4gICAgICAgIGlmIChyLm1ldGhvZCAhPT0gJ0dFVCcgJiYgIW9wdGlvbnMuaWdub3JlTWV0aG9kKSB7XG4gICAgICAgICAgcmV0dXJuIFtdXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHJlcXVlc3QgPT09ICdzdHJpbmcnKSB7IC8vIDIuMlxuICAgICAgICByID0gbmV3IFJlcXVlc3QocmVxdWVzdClba1N0YXRlXVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIDQuXG4gICAgY29uc3QgcHJvbWlzZSA9IGNyZWF0ZURlZmVycmVkUHJvbWlzZSgpXG5cbiAgICAvLyA1LlxuICAgIC8vIDUuMVxuICAgIGNvbnN0IHJlcXVlc3RzID0gW11cblxuICAgIC8vIDUuMlxuICAgIGlmIChyZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIDUuMi4xXG4gICAgICBmb3IgKGNvbnN0IHJlcXVlc3RSZXNwb25zZSBvZiB0aGlzLiNyZWxldmFudFJlcXVlc3RSZXNwb25zZUxpc3QpIHtcbiAgICAgICAgLy8gNS4yLjEuMVxuICAgICAgICByZXF1ZXN0cy5wdXNoKHJlcXVlc3RSZXNwb25zZVswXSlcbiAgICAgIH1cbiAgICB9IGVsc2UgeyAvLyA1LjNcbiAgICAgIC8vIDUuMy4xXG4gICAgICBjb25zdCByZXF1ZXN0UmVzcG9uc2VzID0gdGhpcy4jcXVlcnlDYWNoZShyLCBvcHRpb25zKVxuXG4gICAgICAvLyA1LjMuMlxuICAgICAgZm9yIChjb25zdCByZXF1ZXN0UmVzcG9uc2Ugb2YgcmVxdWVzdFJlc3BvbnNlcykge1xuICAgICAgICAvLyA1LjMuMi4xXG4gICAgICAgIHJlcXVlc3RzLnB1c2gocmVxdWVzdFJlc3BvbnNlWzBdKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIDUuNFxuICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgIC8vIDUuNC4xXG4gICAgICBjb25zdCByZXF1ZXN0TGlzdCA9IFtdXG5cbiAgICAgIC8vIDUuNC4yXG4gICAgICBmb3IgKGNvbnN0IHJlcXVlc3Qgb2YgcmVxdWVzdHMpIHtcbiAgICAgICAgY29uc3QgcmVxdWVzdE9iamVjdCA9IGZyb21Jbm5lclJlcXVlc3QoXG4gICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICBuZXcgQWJvcnRDb250cm9sbGVyKCkuc2lnbmFsLFxuICAgICAgICAgICdpbW11dGFibGUnXG4gICAgICAgIClcbiAgICAgICAgLy8gNS40LjIuMVxuICAgICAgICByZXF1ZXN0TGlzdC5wdXNoKHJlcXVlc3RPYmplY3QpXG4gICAgICB9XG5cbiAgICAgIC8vIDUuNC4zXG4gICAgICBwcm9taXNlLnJlc29sdmUoT2JqZWN0LmZyZWV6ZShyZXF1ZXN0TGlzdCkpXG4gICAgfSlcblxuICAgIHJldHVybiBwcm9taXNlLnByb21pc2VcbiAgfVxuXG4gIC8qKlxuICAgKiBAc2VlIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby9TZXJ2aWNlV29ya2VyLyNiYXRjaC1jYWNoZS1vcGVyYXRpb25zLWFsZ29yaXRobVxuICAgKiBAcGFyYW0ge0NhY2hlQmF0Y2hPcGVyYXRpb25bXX0gb3BlcmF0aW9uc1xuICAgKiBAcmV0dXJucyB7cmVxdWVzdFJlc3BvbnNlTGlzdH1cbiAgICovXG4gICNiYXRjaENhY2hlT3BlcmF0aW9ucyAob3BlcmF0aW9ucykge1xuICAgIC8vIDEuXG4gICAgY29uc3QgY2FjaGUgPSB0aGlzLiNyZWxldmFudFJlcXVlc3RSZXNwb25zZUxpc3RcblxuICAgIC8vIDIuXG4gICAgY29uc3QgYmFja3VwQ2FjaGUgPSBbLi4uY2FjaGVdXG5cbiAgICAvLyAzLlxuICAgIGNvbnN0IGFkZGVkSXRlbXMgPSBbXVxuXG4gICAgLy8gNC4xXG4gICAgY29uc3QgcmVzdWx0TGlzdCA9IFtdXG5cbiAgICB0cnkge1xuICAgICAgLy8gNC4yXG4gICAgICBmb3IgKGNvbnN0IG9wZXJhdGlvbiBvZiBvcGVyYXRpb25zKSB7XG4gICAgICAgIC8vIDQuMi4xXG4gICAgICAgIGlmIChvcGVyYXRpb24udHlwZSAhPT0gJ2RlbGV0ZScgJiYgb3BlcmF0aW9uLnR5cGUgIT09ICdwdXQnKSB7XG4gICAgICAgICAgdGhyb3cgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgICAgICAgaGVhZGVyOiAnQ2FjaGUuI2JhdGNoQ2FjaGVPcGVyYXRpb25zJyxcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdvcGVyYXRpb24gdHlwZSBkb2VzIG5vdCBtYXRjaCBcImRlbGV0ZVwiIG9yIFwicHV0XCInXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDQuMi4yXG4gICAgICAgIGlmIChvcGVyYXRpb24udHlwZSA9PT0gJ2RlbGV0ZScgJiYgb3BlcmF0aW9uLnJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICAgICAgICBoZWFkZXI6ICdDYWNoZS4jYmF0Y2hDYWNoZU9wZXJhdGlvbnMnLFxuICAgICAgICAgICAgbWVzc2FnZTogJ2RlbGV0ZSBvcGVyYXRpb24gc2hvdWxkIG5vdCBoYXZlIGFuIGFzc29jaWF0ZWQgcmVzcG9uc2UnXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDQuMi4zXG4gICAgICAgIGlmICh0aGlzLiNxdWVyeUNhY2hlKG9wZXJhdGlvbi5yZXF1ZXN0LCBvcGVyYXRpb24ub3B0aW9ucywgYWRkZWRJdGVtcykubGVuZ3RoKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbignPz8/JywgJ0ludmFsaWRTdGF0ZUVycm9yJylcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDQuMi40XG4gICAgICAgIGxldCByZXF1ZXN0UmVzcG9uc2VzXG5cbiAgICAgICAgLy8gNC4yLjVcbiAgICAgICAgaWYgKG9wZXJhdGlvbi50eXBlID09PSAnZGVsZXRlJykge1xuICAgICAgICAgIC8vIDQuMi41LjFcbiAgICAgICAgICByZXF1ZXN0UmVzcG9uc2VzID0gdGhpcy4jcXVlcnlDYWNoZShvcGVyYXRpb24ucmVxdWVzdCwgb3BlcmF0aW9uLm9wdGlvbnMpXG5cbiAgICAgICAgICAvLyBUT0RPOiB0aGUgc3BlYyBpcyB3cm9uZywgdGhpcyBpcyBuZWVkZWQgdG8gcGFzcyBXUFRzXG4gICAgICAgICAgaWYgKHJlcXVlc3RSZXNwb25zZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gW11cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyA0LjIuNS4yXG4gICAgICAgICAgZm9yIChjb25zdCByZXF1ZXN0UmVzcG9uc2Ugb2YgcmVxdWVzdFJlc3BvbnNlcykge1xuICAgICAgICAgICAgY29uc3QgaWR4ID0gY2FjaGUuaW5kZXhPZihyZXF1ZXN0UmVzcG9uc2UpXG4gICAgICAgICAgICBhc3NlcnQoaWR4ICE9PSAtMSlcblxuICAgICAgICAgICAgLy8gNC4yLjUuMi4xXG4gICAgICAgICAgICBjYWNoZS5zcGxpY2UoaWR4LCAxKVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChvcGVyYXRpb24udHlwZSA9PT0gJ3B1dCcpIHsgLy8gNC4yLjZcbiAgICAgICAgICAvLyA0LjIuNi4xXG4gICAgICAgICAgaWYgKG9wZXJhdGlvbi5yZXNwb25zZSA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICAgICAgICAgIGhlYWRlcjogJ0NhY2hlLiNiYXRjaENhY2hlT3BlcmF0aW9ucycsXG4gICAgICAgICAgICAgIG1lc3NhZ2U6ICdwdXQgb3BlcmF0aW9uIHNob3VsZCBoYXZlIGFuIGFzc29jaWF0ZWQgcmVzcG9uc2UnXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIDQuMi42LjJcbiAgICAgICAgICBjb25zdCByID0gb3BlcmF0aW9uLnJlcXVlc3RcblxuICAgICAgICAgIC8vIDQuMi42LjNcbiAgICAgICAgICBpZiAoIXVybElzSHR0cEh0dHBzU2NoZW1lKHIudXJsKSkge1xuICAgICAgICAgICAgdGhyb3cgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgICAgICAgICBoZWFkZXI6ICdDYWNoZS4jYmF0Y2hDYWNoZU9wZXJhdGlvbnMnLFxuICAgICAgICAgICAgICBtZXNzYWdlOiAnZXhwZWN0ZWQgaHR0cCBvciBodHRwcyBzY2hlbWUnXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIDQuMi42LjRcbiAgICAgICAgICBpZiAoci5tZXRob2QgIT09ICdHRVQnKSB7XG4gICAgICAgICAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICAgICAgICAgIGhlYWRlcjogJ0NhY2hlLiNiYXRjaENhY2hlT3BlcmF0aW9ucycsXG4gICAgICAgICAgICAgIG1lc3NhZ2U6ICdub3QgZ2V0IG1ldGhvZCdcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gNC4yLjYuNVxuICAgICAgICAgIGlmIChvcGVyYXRpb24ub3B0aW9ucyAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICAgICAgICAgIGhlYWRlcjogJ0NhY2hlLiNiYXRjaENhY2hlT3BlcmF0aW9ucycsXG4gICAgICAgICAgICAgIG1lc3NhZ2U6ICdvcHRpb25zIG11c3Qgbm90IGJlIGRlZmluZWQnXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIDQuMi42LjZcbiAgICAgICAgICByZXF1ZXN0UmVzcG9uc2VzID0gdGhpcy4jcXVlcnlDYWNoZShvcGVyYXRpb24ucmVxdWVzdClcblxuICAgICAgICAgIC8vIDQuMi42LjdcbiAgICAgICAgICBmb3IgKGNvbnN0IHJlcXVlc3RSZXNwb25zZSBvZiByZXF1ZXN0UmVzcG9uc2VzKSB7XG4gICAgICAgICAgICBjb25zdCBpZHggPSBjYWNoZS5pbmRleE9mKHJlcXVlc3RSZXNwb25zZSlcbiAgICAgICAgICAgIGFzc2VydChpZHggIT09IC0xKVxuXG4gICAgICAgICAgICAvLyA0LjIuNi43LjFcbiAgICAgICAgICAgIGNhY2hlLnNwbGljZShpZHgsIDEpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gNC4yLjYuOFxuICAgICAgICAgIGNhY2hlLnB1c2goW29wZXJhdGlvbi5yZXF1ZXN0LCBvcGVyYXRpb24ucmVzcG9uc2VdKVxuXG4gICAgICAgICAgLy8gNC4yLjYuMTBcbiAgICAgICAgICBhZGRlZEl0ZW1zLnB1c2goW29wZXJhdGlvbi5yZXF1ZXN0LCBvcGVyYXRpb24ucmVzcG9uc2VdKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gNC4yLjdcbiAgICAgICAgcmVzdWx0TGlzdC5wdXNoKFtvcGVyYXRpb24ucmVxdWVzdCwgb3BlcmF0aW9uLnJlc3BvbnNlXSlcbiAgICAgIH1cblxuICAgICAgLy8gNC4zXG4gICAgICByZXR1cm4gcmVzdWx0TGlzdFxuICAgIH0gY2F0Y2ggKGUpIHsgLy8gNS5cbiAgICAgIC8vIDUuMVxuICAgICAgdGhpcy4jcmVsZXZhbnRSZXF1ZXN0UmVzcG9uc2VMaXN0Lmxlbmd0aCA9IDBcblxuICAgICAgLy8gNS4yXG4gICAgICB0aGlzLiNyZWxldmFudFJlcXVlc3RSZXNwb25zZUxpc3QgPSBiYWNrdXBDYWNoZVxuXG4gICAgICAvLyA1LjNcbiAgICAgIHRocm93IGVcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHNlZSBodHRwczovL3czYy5naXRodWIuaW8vU2VydmljZVdvcmtlci8jcXVlcnktY2FjaGVcbiAgICogQHBhcmFtIHthbnl9IHJlcXVlc3RRdWVyeVxuICAgKiBAcGFyYW0ge2ltcG9ydCgnLi4vLi4vdHlwZXMvY2FjaGUnKS5DYWNoZVF1ZXJ5T3B0aW9uc30gb3B0aW9uc1xuICAgKiBAcGFyYW0ge3JlcXVlc3RSZXNwb25zZUxpc3R9IHRhcmdldFN0b3JhZ2VcbiAgICogQHJldHVybnMge3JlcXVlc3RSZXNwb25zZUxpc3R9XG4gICAqL1xuICAjcXVlcnlDYWNoZSAocmVxdWVzdFF1ZXJ5LCBvcHRpb25zLCB0YXJnZXRTdG9yYWdlKSB7XG4gICAgLyoqIEB0eXBlIHtyZXF1ZXN0UmVzcG9uc2VMaXN0fSAqL1xuICAgIGNvbnN0IHJlc3VsdExpc3QgPSBbXVxuXG4gICAgY29uc3Qgc3RvcmFnZSA9IHRhcmdldFN0b3JhZ2UgPz8gdGhpcy4jcmVsZXZhbnRSZXF1ZXN0UmVzcG9uc2VMaXN0XG5cbiAgICBmb3IgKGNvbnN0IHJlcXVlc3RSZXNwb25zZSBvZiBzdG9yYWdlKSB7XG4gICAgICBjb25zdCBbY2FjaGVkUmVxdWVzdCwgY2FjaGVkUmVzcG9uc2VdID0gcmVxdWVzdFJlc3BvbnNlXG4gICAgICBpZiAodGhpcy4jcmVxdWVzdE1hdGNoZXNDYWNoZWRJdGVtKHJlcXVlc3RRdWVyeSwgY2FjaGVkUmVxdWVzdCwgY2FjaGVkUmVzcG9uc2UsIG9wdGlvbnMpKSB7XG4gICAgICAgIHJlc3VsdExpc3QucHVzaChyZXF1ZXN0UmVzcG9uc2UpXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdExpc3RcbiAgfVxuXG4gIC8qKlxuICAgKiBAc2VlIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby9TZXJ2aWNlV29ya2VyLyNyZXF1ZXN0LW1hdGNoZXMtY2FjaGVkLWl0ZW0tYWxnb3JpdGhtXG4gICAqIEBwYXJhbSB7YW55fSByZXF1ZXN0UXVlcnlcbiAgICogQHBhcmFtIHthbnl9IHJlcXVlc3RcbiAgICogQHBhcmFtIHthbnkgfCBudWxsfSByZXNwb25zZVxuICAgKiBAcGFyYW0ge2ltcG9ydCgnLi4vLi4vdHlwZXMvY2FjaGUnKS5DYWNoZVF1ZXJ5T3B0aW9ucyB8IHVuZGVmaW5lZH0gb3B0aW9uc1xuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gICNyZXF1ZXN0TWF0Y2hlc0NhY2hlZEl0ZW0gKHJlcXVlc3RRdWVyeSwgcmVxdWVzdCwgcmVzcG9uc2UgPSBudWxsLCBvcHRpb25zKSB7XG4gICAgLy8gaWYgKG9wdGlvbnM/Lmlnbm9yZU1ldGhvZCA9PT0gZmFsc2UgJiYgcmVxdWVzdC5tZXRob2QgPT09ICdHRVQnKSB7XG4gICAgLy8gICByZXR1cm4gZmFsc2VcbiAgICAvLyB9XG5cbiAgICBjb25zdCBxdWVyeVVSTCA9IG5ldyBVUkwocmVxdWVzdFF1ZXJ5LnVybClcblxuICAgIGNvbnN0IGNhY2hlZFVSTCA9IG5ldyBVUkwocmVxdWVzdC51cmwpXG5cbiAgICBpZiAob3B0aW9ucz8uaWdub3JlU2VhcmNoKSB7XG4gICAgICBjYWNoZWRVUkwuc2VhcmNoID0gJydcblxuICAgICAgcXVlcnlVUkwuc2VhcmNoID0gJydcbiAgICB9XG5cbiAgICBpZiAoIXVybEVxdWFscyhxdWVyeVVSTCwgY2FjaGVkVVJMLCB0cnVlKSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgcmVzcG9uc2UgPT0gbnVsbCB8fFxuICAgICAgb3B0aW9ucz8uaWdub3JlVmFyeSB8fFxuICAgICAgIXJlc3BvbnNlLmhlYWRlcnNMaXN0LmNvbnRhaW5zKCd2YXJ5JylcbiAgICApIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgY29uc3QgZmllbGRWYWx1ZXMgPSBnZXRGaWVsZFZhbHVlcyhyZXNwb25zZS5oZWFkZXJzTGlzdC5nZXQoJ3ZhcnknKSlcblxuICAgIGZvciAoY29uc3QgZmllbGRWYWx1ZSBvZiBmaWVsZFZhbHVlcykge1xuICAgICAgaWYgKGZpZWxkVmFsdWUgPT09ICcqJykge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVxdWVzdFZhbHVlID0gcmVxdWVzdC5oZWFkZXJzTGlzdC5nZXQoZmllbGRWYWx1ZSlcbiAgICAgIGNvbnN0IHF1ZXJ5VmFsdWUgPSByZXF1ZXN0UXVlcnkuaGVhZGVyc0xpc3QuZ2V0KGZpZWxkVmFsdWUpXG5cbiAgICAgIC8vIElmIG9uZSBoYXMgdGhlIGhlYWRlciBhbmQgdGhlIG90aGVyIGRvZXNuJ3QsIG9yIG9uZSBoYXNcbiAgICAgIC8vIGEgZGlmZmVyZW50IHZhbHVlIHRoYW4gdGhlIG90aGVyLCByZXR1cm4gZmFsc2VcbiAgICAgIGlmIChyZXF1ZXN0VmFsdWUgIT09IHF1ZXJ5VmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gICNpbnRlcm5hbE1hdGNoQWxsIChyZXF1ZXN0LCBvcHRpb25zLCBtYXhSZXNwb25zZXMgPSBJbmZpbml0eSkge1xuICAgIC8vIDEuXG4gICAgbGV0IHIgPSBudWxsXG5cbiAgICAvLyAyLlxuICAgIGlmIChyZXF1ZXN0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChyZXF1ZXN0IGluc3RhbmNlb2YgUmVxdWVzdCkge1xuICAgICAgICAvLyAyLjEuMVxuICAgICAgICByID0gcmVxdWVzdFtrU3RhdGVdXG5cbiAgICAgICAgLy8gMi4xLjJcbiAgICAgICAgaWYgKHIubWV0aG9kICE9PSAnR0VUJyAmJiAhb3B0aW9ucy5pZ25vcmVNZXRob2QpIHtcbiAgICAgICAgICByZXR1cm4gW11cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcmVxdWVzdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy8gMi4yLjFcbiAgICAgICAgciA9IG5ldyBSZXF1ZXN0KHJlcXVlc3QpW2tTdGF0ZV1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyA1LlxuICAgIC8vIDUuMVxuICAgIGNvbnN0IHJlc3BvbnNlcyA9IFtdXG5cbiAgICAvLyA1LjJcbiAgICBpZiAocmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyA1LjIuMVxuICAgICAgZm9yIChjb25zdCByZXF1ZXN0UmVzcG9uc2Ugb2YgdGhpcy4jcmVsZXZhbnRSZXF1ZXN0UmVzcG9uc2VMaXN0KSB7XG4gICAgICAgIHJlc3BvbnNlcy5wdXNoKHJlcXVlc3RSZXNwb25zZVsxXSlcbiAgICAgIH1cbiAgICB9IGVsc2UgeyAvLyA1LjNcbiAgICAgIC8vIDUuMy4xXG4gICAgICBjb25zdCByZXF1ZXN0UmVzcG9uc2VzID0gdGhpcy4jcXVlcnlDYWNoZShyLCBvcHRpb25zKVxuXG4gICAgICAvLyA1LjMuMlxuICAgICAgZm9yIChjb25zdCByZXF1ZXN0UmVzcG9uc2Ugb2YgcmVxdWVzdFJlc3BvbnNlcykge1xuICAgICAgICByZXNwb25zZXMucHVzaChyZXF1ZXN0UmVzcG9uc2VbMV0pXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gNS40XG4gICAgLy8gV2UgZG9uJ3QgaW1wbGVtZW50IENPUnMgc28gd2UgZG9uJ3QgbmVlZCB0byBsb29wIG92ZXIgdGhlIHJlc3BvbnNlcywgeWF5IVxuXG4gICAgLy8gNS41LjFcbiAgICBjb25zdCByZXNwb25zZUxpc3QgPSBbXVxuXG4gICAgLy8gNS41LjJcbiAgICBmb3IgKGNvbnN0IHJlc3BvbnNlIG9mIHJlc3BvbnNlcykge1xuICAgICAgLy8gNS41LjIuMVxuICAgICAgY29uc3QgcmVzcG9uc2VPYmplY3QgPSBmcm9tSW5uZXJSZXNwb25zZShyZXNwb25zZSwgJ2ltbXV0YWJsZScpXG5cbiAgICAgIHJlc3BvbnNlTGlzdC5wdXNoKHJlc3BvbnNlT2JqZWN0LmNsb25lKCkpXG5cbiAgICAgIGlmIChyZXNwb25zZUxpc3QubGVuZ3RoID49IG1heFJlc3BvbnNlcykge1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIDYuXG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUocmVzcG9uc2VMaXN0KVxuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKENhY2hlLnByb3RvdHlwZSwge1xuICBbU3ltYm9sLnRvU3RyaW5nVGFnXToge1xuICAgIHZhbHVlOiAnQ2FjaGUnLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9LFxuICBtYXRjaDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgbWF0Y2hBbGw6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGFkZDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgYWRkQWxsOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBwdXQ6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGRlbGV0ZToga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAga2V5czoga0VudW1lcmFibGVQcm9wZXJ0eVxufSlcblxuY29uc3QgY2FjaGVRdWVyeU9wdGlvbkNvbnZlcnRlcnMgPSBbXG4gIHtcbiAgICBrZXk6ICdpZ25vcmVTZWFyY2gnLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuYm9vbGVhbixcbiAgICBkZWZhdWx0VmFsdWU6ICgpID0+IGZhbHNlXG4gIH0sXG4gIHtcbiAgICBrZXk6ICdpZ25vcmVNZXRob2QnLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuYm9vbGVhbixcbiAgICBkZWZhdWx0VmFsdWU6ICgpID0+IGZhbHNlXG4gIH0sXG4gIHtcbiAgICBrZXk6ICdpZ25vcmVWYXJ5JyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLmJvb2xlYW4sXG4gICAgZGVmYXVsdFZhbHVlOiAoKSA9PiBmYWxzZVxuICB9XG5dXG5cbndlYmlkbC5jb252ZXJ0ZXJzLkNhY2hlUXVlcnlPcHRpb25zID0gd2ViaWRsLmRpY3Rpb25hcnlDb252ZXJ0ZXIoY2FjaGVRdWVyeU9wdGlvbkNvbnZlcnRlcnMpXG5cbndlYmlkbC5jb252ZXJ0ZXJzLk11bHRpQ2FjaGVRdWVyeU9wdGlvbnMgPSB3ZWJpZGwuZGljdGlvbmFyeUNvbnZlcnRlcihbXG4gIC4uLmNhY2hlUXVlcnlPcHRpb25Db252ZXJ0ZXJzLFxuICB7XG4gICAga2V5OiAnY2FjaGVOYW1lJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLkRPTVN0cmluZ1xuICB9XG5dKVxuXG53ZWJpZGwuY29udmVydGVycy5SZXNwb25zZSA9IHdlYmlkbC5pbnRlcmZhY2VDb252ZXJ0ZXIoUmVzcG9uc2UpXG5cbndlYmlkbC5jb252ZXJ0ZXJzWydzZXF1ZW5jZTxSZXF1ZXN0SW5mbz4nXSA9IHdlYmlkbC5zZXF1ZW5jZUNvbnZlcnRlcihcbiAgd2ViaWRsLmNvbnZlcnRlcnMuUmVxdWVzdEluZm9cbilcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIENhY2hlXG59XG4iXSwibmFtZXMiOlsia0NvbnN0cnVjdCIsInJlcXVpcmUiLCJ1cmxFcXVhbHMiLCJnZXRGaWVsZFZhbHVlcyIsImtFbnVtZXJhYmxlUHJvcGVydHkiLCJpc0Rpc3R1cmJlZCIsIndlYmlkbCIsIlJlc3BvbnNlIiwiY2xvbmVSZXNwb25zZSIsImZyb21Jbm5lclJlc3BvbnNlIiwiUmVxdWVzdCIsImZyb21Jbm5lclJlcXVlc3QiLCJrU3RhdGUiLCJmZXRjaGluZyIsInVybElzSHR0cEh0dHBzU2NoZW1lIiwiY3JlYXRlRGVmZXJyZWRQcm9taXNlIiwicmVhZEFsbEJ5dGVzIiwiYXNzZXJ0IiwiQ2FjaGUiLCJyZWxldmFudFJlcXVlc3RSZXNwb25zZUxpc3QiLCJjb25zdHJ1Y3RvciIsImFyZ3VtZW50cyIsImlsbGVnYWxDb25zdHJ1Y3RvciIsIm1hdGNoIiwicmVxdWVzdCIsIm9wdGlvbnMiLCJicmFuZENoZWNrIiwicHJlZml4IiwiYXJndW1lbnRMZW5ndGhDaGVjayIsImNvbnZlcnRlcnMiLCJSZXF1ZXN0SW5mbyIsIkNhY2hlUXVlcnlPcHRpb25zIiwicCIsImludGVybmFsTWF0Y2hBbGwiLCJsZW5ndGgiLCJtYXRjaEFsbCIsInVuZGVmaW5lZCIsImFkZCIsInJlcXVlc3RzIiwicmVzcG9uc2VBcnJheVByb21pc2UiLCJhZGRBbGwiLCJyZXNwb25zZVByb21pc2VzIiwicmVxdWVzdExpc3QiLCJlcnJvcnMiLCJjb252ZXJzaW9uRmFpbGVkIiwiYXJndW1lbnQiLCJ0eXBlcyIsInIiLCJ1cmwiLCJtZXRob2QiLCJleGNlcHRpb24iLCJoZWFkZXIiLCJtZXNzYWdlIiwiZmV0Y2hDb250cm9sbGVycyIsImluaXRpYXRvciIsImRlc3RpbmF0aW9uIiwicHVzaCIsInJlc3BvbnNlUHJvbWlzZSIsInByb2Nlc3NSZXNwb25zZSIsInJlc3BvbnNlIiwidHlwZSIsInN0YXR1cyIsInJlamVjdCIsImhlYWRlcnNMaXN0IiwiY29udGFpbnMiLCJmaWVsZFZhbHVlcyIsImdldCIsImZpZWxkVmFsdWUiLCJjb250cm9sbGVyIiwiYWJvcnQiLCJwcm9jZXNzUmVzcG9uc2VFbmRPZkJvZHkiLCJhYm9ydGVkIiwiRE9NRXhjZXB0aW9uIiwicmVzb2x2ZSIsInByb21pc2UiLCJQcm9taXNlIiwiYWxsIiwicmVzcG9uc2VzIiwib3BlcmF0aW9ucyIsImluZGV4Iiwib3BlcmF0aW9uIiwiY2FjaGVKb2JQcm9taXNlIiwiZXJyb3JEYXRhIiwiYmF0Y2hDYWNoZU9wZXJhdGlvbnMiLCJlIiwicXVldWVNaWNyb3Rhc2siLCJwdXQiLCJpbm5lclJlcXVlc3QiLCJpbm5lclJlc3BvbnNlIiwiYm9keSIsInN0cmVhbSIsImxvY2tlZCIsImNsb25lZFJlc3BvbnNlIiwiYm9keVJlYWRQcm9taXNlIiwicmVhZGVyIiwiZ2V0UmVhZGVyIiwidGhlbiIsImJ5dGVzIiwic291cmNlIiwiZGVsZXRlIiwiaWdub3JlTWV0aG9kIiwicmVxdWVzdFJlc3BvbnNlcyIsImtleXMiLCJyZXF1ZXN0UmVzcG9uc2UiLCJxdWVyeUNhY2hlIiwicmVxdWVzdE9iamVjdCIsIkFib3J0Q29udHJvbGxlciIsInNpZ25hbCIsIk9iamVjdCIsImZyZWV6ZSIsIiNiYXRjaENhY2hlT3BlcmF0aW9ucyIsImNhY2hlIiwiYmFja3VwQ2FjaGUiLCJhZGRlZEl0ZW1zIiwicmVzdWx0TGlzdCIsImlkeCIsImluZGV4T2YiLCJzcGxpY2UiLCIjcXVlcnlDYWNoZSIsInJlcXVlc3RRdWVyeSIsInRhcmdldFN0b3JhZ2UiLCJzdG9yYWdlIiwiY2FjaGVkUmVxdWVzdCIsImNhY2hlZFJlc3BvbnNlIiwicmVxdWVzdE1hdGNoZXNDYWNoZWRJdGVtIiwiI3JlcXVlc3RNYXRjaGVzQ2FjaGVkSXRlbSIsInF1ZXJ5VVJMIiwiVVJMIiwiY2FjaGVkVVJMIiwiaWdub3JlU2VhcmNoIiwic2VhcmNoIiwiaWdub3JlVmFyeSIsInJlcXVlc3RWYWx1ZSIsInF1ZXJ5VmFsdWUiLCIjaW50ZXJuYWxNYXRjaEFsbCIsIm1heFJlc3BvbnNlcyIsIkluZmluaXR5IiwicmVzcG9uc2VMaXN0IiwicmVzcG9uc2VPYmplY3QiLCJjbG9uZSIsImRlZmluZVByb3BlcnRpZXMiLCJwcm90b3R5cGUiLCJTeW1ib2wiLCJ0b1N0cmluZ1RhZyIsInZhbHVlIiwiY29uZmlndXJhYmxlIiwiY2FjaGVRdWVyeU9wdGlvbkNvbnZlcnRlcnMiLCJrZXkiLCJjb252ZXJ0ZXIiLCJib29sZWFuIiwiZGVmYXVsdFZhbHVlIiwiZGljdGlvbmFyeUNvbnZlcnRlciIsIk11bHRpQ2FjaGVRdWVyeU9wdGlvbnMiLCJET01TdHJpbmciLCJpbnRlcmZhY2VDb252ZXJ0ZXIiLCJzZXF1ZW5jZUNvbnZlcnRlciIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/cache/cache.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/cache/cachestorage.js":
/*!***********************************************************!*\
  !*** ./node_modules/undici/lib/web/cache/cachestorage.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { kConstruct } = __webpack_require__(/*! ./symbols */ \"(ssr)/./node_modules/undici/lib/web/cache/symbols.js\");\nconst { Cache } = __webpack_require__(/*! ./cache */ \"(ssr)/./node_modules/undici/lib/web/cache/cache.js\");\nconst { webidl } = __webpack_require__(/*! ../fetch/webidl */ \"(ssr)/./node_modules/undici/lib/web/fetch/webidl.js\");\nconst { kEnumerableProperty } = __webpack_require__(/*! ../../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\");\nclass CacheStorage {\n    /**\n   * @see https://w3c.github.io/ServiceWorker/#dfn-relevant-name-to-cache-map\n   * @type {Map<string, import('./cache').requestResponseList}\n   */ #caches;\n    constructor(){\n        this.#caches = new Map();\n        if (arguments[0] !== kConstruct) {\n            webidl.illegalConstructor();\n        }\n    }\n    async match(request, options = {}) {\n        webidl.brandCheck(this, CacheStorage);\n        webidl.argumentLengthCheck(arguments, 1, \"CacheStorage.match\");\n        request = webidl.converters.RequestInfo(request);\n        options = webidl.converters.MultiCacheQueryOptions(options);\n        // 1.\n        if (options.cacheName != null) {\n            // 1.1.1.1\n            if (this.#caches.has(options.cacheName)) {\n                // 1.1.1.1.1\n                const cacheList = this.#caches.get(options.cacheName);\n                const cache = new Cache(kConstruct, cacheList);\n                return await cache.match(request, options);\n            }\n        } else {\n            // 2.\n            // 2.2\n            for (const cacheList of this.#caches.values()){\n                const cache = new Cache(kConstruct, cacheList);\n                // 2.2.1.2\n                const response = await cache.match(request, options);\n                if (response !== undefined) {\n                    return response;\n                }\n            }\n        }\n    }\n    /**\n   * @see https://w3c.github.io/ServiceWorker/#cache-storage-has\n   * @param {string} cacheName\n   * @returns {Promise<boolean>}\n   */ async has(cacheName) {\n        webidl.brandCheck(this, CacheStorage);\n        const prefix = \"CacheStorage.has\";\n        webidl.argumentLengthCheck(arguments, 1, prefix);\n        cacheName = webidl.converters.DOMString(cacheName, prefix, \"cacheName\");\n        // 2.1.1\n        // 2.2\n        return this.#caches.has(cacheName);\n    }\n    /**\n   * @see https://w3c.github.io/ServiceWorker/#dom-cachestorage-open\n   * @param {string} cacheName\n   * @returns {Promise<Cache>}\n   */ async open(cacheName) {\n        webidl.brandCheck(this, CacheStorage);\n        const prefix = \"CacheStorage.open\";\n        webidl.argumentLengthCheck(arguments, 1, prefix);\n        cacheName = webidl.converters.DOMString(cacheName, prefix, \"cacheName\");\n        // 2.1\n        if (this.#caches.has(cacheName)) {\n            // await caches.open('v1') !== await caches.open('v1')\n            // 2.1.1\n            const cache = this.#caches.get(cacheName);\n            // 2.1.1.1\n            return new Cache(kConstruct, cache);\n        }\n        // 2.2\n        const cache = [];\n        // 2.3\n        this.#caches.set(cacheName, cache);\n        // 2.4\n        return new Cache(kConstruct, cache);\n    }\n    /**\n   * @see https://w3c.github.io/ServiceWorker/#cache-storage-delete\n   * @param {string} cacheName\n   * @returns {Promise<boolean>}\n   */ async delete(cacheName) {\n        webidl.brandCheck(this, CacheStorage);\n        const prefix = \"CacheStorage.delete\";\n        webidl.argumentLengthCheck(arguments, 1, prefix);\n        cacheName = webidl.converters.DOMString(cacheName, prefix, \"cacheName\");\n        return this.#caches.delete(cacheName);\n    }\n    /**\n   * @see https://w3c.github.io/ServiceWorker/#cache-storage-keys\n   * @returns {Promise<string[]>}\n   */ async keys() {\n        webidl.brandCheck(this, CacheStorage);\n        // 2.1\n        const keys = this.#caches.keys();\n        // 2.2\n        return [\n            ...keys\n        ];\n    }\n}\nObject.defineProperties(CacheStorage.prototype, {\n    [Symbol.toStringTag]: {\n        value: \"CacheStorage\",\n        configurable: true\n    },\n    match: kEnumerableProperty,\n    has: kEnumerableProperty,\n    open: kEnumerableProperty,\n    delete: kEnumerableProperty,\n    keys: kEnumerableProperty\n});\nmodule.exports = {\n    CacheStorage\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvY2FjaGUvY2FjaGVzdG9yYWdlLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTSxFQUFFQSxVQUFBQSxFQUFZLEdBQUdDLG1CQUFPQSxDQUFDO0FBQy9CLE1BQU0sRUFBRUMsS0FBQUEsRUFBTyxHQUFHRCxtQkFBT0EsQ0FBQztBQUMxQixNQUFNLEVBQUVFLE1BQUFBLEVBQVEsR0FBR0YsbUJBQU9BLENBQUM7QUFDM0IsTUFBTSxFQUFFRyxtQkFBQUEsRUFBcUIsR0FBR0gsbUJBQU9BLENBQUM7QUFFeEMsTUFBTUk7SUFDSjs7O0dBR0YsR0FDRSxDQUFDQyxNQUFNLENBQVk7SUFFbkJDLGFBQWU7YUFGZixDQUFDRCxNQUFNLEdBQUcsSUFBSUU7UUFHWixJQUFJQyxTQUFTLENBQUMsRUFBRSxLQUFLVCxZQUFZO1lBQy9CRyxPQUFPTyxrQkFBa0I7UUFDM0I7SUFDRjtJQUVBLE1BQU1DLE1BQU9DLE9BQU8sRUFBRUMsVUFBVSxDQUFDLENBQUMsRUFBRTtRQUNsQ1YsT0FBT1csVUFBVSxDQUFDLElBQUksRUFBRVQ7UUFDeEJGLE9BQU9ZLG1CQUFtQixDQUFDTixXQUFXLEdBQUc7UUFFekNHLFVBQVVULE9BQU9hLFVBQVUsQ0FBQ0MsV0FBVyxDQUFDTDtRQUN4Q0MsVUFBVVYsT0FBT2EsVUFBVSxDQUFDRSxzQkFBc0IsQ0FBQ0w7UUFFbkQ7UUFDQSxJQUFJQSxRQUFRTSxTQUFTLElBQUksTUFBTTtZQUM3QjtZQUNBLElBQUksSUFBSSxDQUFDLENBQUNiLE1BQU0sQ0FBQ2MsR0FBRyxDQUFDUCxRQUFRTSxTQUFTLEdBQUc7Z0JBQ3ZDO2dCQUNBLE1BQU1FLFlBQVksSUFBSSxDQUFDLENBQUNmLE1BQU0sQ0FBQ2dCLEdBQUcsQ0FBQ1QsUUFBUU0sU0FBUztnQkFDcEQsTUFBTUksUUFBUSxJQUFJckIsTUFBTUYsWUFBWXFCO2dCQUVwQyxPQUFPLE1BQU1FLE1BQU1aLEtBQUssQ0FBQ0MsU0FBU0M7WUFDcEM7UUFDRixPQUFPO1lBQUU7WUFDUDtZQUNBLEtBQUssTUFBTVEsYUFBYSxJQUFJLENBQUMsQ0FBQ2YsTUFBTSxDQUFDa0IsTUFBTSxHQUFJO2dCQUM3QyxNQUFNRCxRQUFRLElBQUlyQixNQUFNRixZQUFZcUI7Z0JBRXBDO2dCQUNBLE1BQU1JLFdBQVcsTUFBTUYsTUFBTVosS0FBSyxDQUFDQyxTQUFTQztnQkFFNUMsSUFBSVksYUFBYUMsV0FBVztvQkFDMUIsT0FBT0Q7Z0JBQ1Q7WUFDRjtRQUNGO0lBQ0Y7SUFFQTs7OztHQUlGLEdBQ0UsTUFBTUwsSUFBS0QsU0FBUyxFQUFFO1FBQ3BCaEIsT0FBT1csVUFBVSxDQUFDLElBQUksRUFBRVQ7UUFFeEIsTUFBTXNCLFNBQVM7UUFDZnhCLE9BQU9ZLG1CQUFtQixDQUFDTixXQUFXLEdBQUdrQjtRQUV6Q1IsWUFBWWhCLE9BQU9hLFVBQVUsQ0FBQ1ksU0FBUyxDQUFDVCxXQUFXUSxRQUFRO1FBRTNEO1FBQ0E7UUFDQSxPQUFPLElBQUksQ0FBQyxDQUFDckIsTUFBTSxDQUFDYyxHQUFHLENBQUNEO0lBQzFCO0lBRUE7Ozs7R0FJRixHQUNFLE1BQU1VLEtBQU1WLFNBQVMsRUFBRTtRQUNyQmhCLE9BQU9XLFVBQVUsQ0FBQyxJQUFJLEVBQUVUO1FBRXhCLE1BQU1zQixTQUFTO1FBQ2Z4QixPQUFPWSxtQkFBbUIsQ0FBQ04sV0FBVyxHQUFHa0I7UUFFekNSLFlBQVloQixPQUFPYSxVQUFVLENBQUNZLFNBQVMsQ0FBQ1QsV0FBV1EsUUFBUTtRQUUzRDtRQUNBLElBQUksSUFBSSxDQUFDLENBQUNyQixNQUFNLENBQUNjLEdBQUcsQ0FBQ0QsWUFBWTtZQUMvQjtZQUVBO1lBQ0EsTUFBTUksUUFBUSxJQUFJLENBQUMsQ0FBQ2pCLE1BQU0sQ0FBQ2dCLEdBQUcsQ0FBQ0g7WUFFL0I7WUFDQSxPQUFPLElBQUlqQixNQUFNRixZQUFZdUI7UUFDL0I7UUFFQTtRQUNBLE1BQU1BLFFBQVEsRUFBRTtRQUVoQjtRQUNBLElBQUksQ0FBQyxDQUFDakIsTUFBTSxDQUFDd0IsR0FBRyxDQUFDWCxXQUFXSTtRQUU1QjtRQUNBLE9BQU8sSUFBSXJCLE1BQU1GLFlBQVl1QjtJQUMvQjtJQUVBOzs7O0dBSUYsR0FDRSxNQUFNUSxPQUFRWixTQUFTLEVBQUU7UUFDdkJoQixPQUFPVyxVQUFVLENBQUMsSUFBSSxFQUFFVDtRQUV4QixNQUFNc0IsU0FBUztRQUNmeEIsT0FBT1ksbUJBQW1CLENBQUNOLFdBQVcsR0FBR2tCO1FBRXpDUixZQUFZaEIsT0FBT2EsVUFBVSxDQUFDWSxTQUFTLENBQUNULFdBQVdRLFFBQVE7UUFFM0QsT0FBTyxJQUFJLENBQUMsQ0FBQ3JCLE1BQU0sQ0FBQ3lCLE1BQU0sQ0FBQ1o7SUFDN0I7SUFFQTs7O0dBR0YsR0FDRSxNQUFNYSxPQUFRO1FBQ1o3QixPQUFPVyxVQUFVLENBQUMsSUFBSSxFQUFFVDtRQUV4QjtRQUNBLE1BQU0yQixPQUFPLElBQUksQ0FBQyxDQUFDMUIsTUFBTSxDQUFDMEIsSUFBSTtRQUU5QjtRQUNBLE9BQU87ZUFBSUE7U0FBSztJQUNsQjtBQUNGO0FBRUFDLE9BQU9DLGdCQUFnQixDQUFDN0IsYUFBYThCLFNBQVMsRUFBRTtJQUM5QyxDQUFDQyxPQUFPQyxXQUFXLEdBQUc7UUFDcEJDLE9BQU87UUFDUEMsY0FBYztJQUNoQjtJQUNBNUIsT0FBT1A7SUFDUGdCLEtBQUtoQjtJQUNMeUIsTUFBTXpCO0lBQ04yQixRQUFRM0I7SUFDUjRCLE1BQU01QjtBQUNSO0FBRUFvQyxPQUFPQyxPQUFPLEdBQUc7SUFDZnBDO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tb2NrdXBmbG93Ly4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvd2ViL2NhY2hlL2NhY2hlc3RvcmFnZS5qcz83M2ViIiwid2VicGFjazovL21vY2t1cGZsb3cvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvY2FjaGUvY2FjaGVzdG9yYWdlLmpzPzczZWIqIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IGtDb25zdHJ1Y3QgfSA9IHJlcXVpcmUoJy4vc3ltYm9scycpXG5jb25zdCB7IENhY2hlIH0gPSByZXF1aXJlKCcuL2NhY2hlJylcbmNvbnN0IHsgd2ViaWRsIH0gPSByZXF1aXJlKCcuLi9mZXRjaC93ZWJpZGwnKVxuY29uc3QgeyBrRW51bWVyYWJsZVByb3BlcnR5IH0gPSByZXF1aXJlKCcuLi8uLi9jb3JlL3V0aWwnKVxuXG5jbGFzcyBDYWNoZVN0b3JhZ2Uge1xuICAvKipcbiAgICogQHNlZSBodHRwczovL3czYy5naXRodWIuaW8vU2VydmljZVdvcmtlci8jZGZuLXJlbGV2YW50LW5hbWUtdG8tY2FjaGUtbWFwXG4gICAqIEB0eXBlIHtNYXA8c3RyaW5nLCBpbXBvcnQoJy4vY2FjaGUnKS5yZXF1ZXN0UmVzcG9uc2VMaXN0fVxuICAgKi9cbiAgI2NhY2hlcyA9IG5ldyBNYXAoKVxuXG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICBpZiAoYXJndW1lbnRzWzBdICE9PSBrQ29uc3RydWN0KSB7XG4gICAgICB3ZWJpZGwuaWxsZWdhbENvbnN0cnVjdG9yKClcbiAgICB9XG4gIH1cblxuICBhc3luYyBtYXRjaCAocmVxdWVzdCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgQ2FjaGVTdG9yYWdlKVxuICAgIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMSwgJ0NhY2hlU3RvcmFnZS5tYXRjaCcpXG5cbiAgICByZXF1ZXN0ID0gd2ViaWRsLmNvbnZlcnRlcnMuUmVxdWVzdEluZm8ocmVxdWVzdClcbiAgICBvcHRpb25zID0gd2ViaWRsLmNvbnZlcnRlcnMuTXVsdGlDYWNoZVF1ZXJ5T3B0aW9ucyhvcHRpb25zKVxuXG4gICAgLy8gMS5cbiAgICBpZiAob3B0aW9ucy5jYWNoZU5hbWUgIT0gbnVsbCkge1xuICAgICAgLy8gMS4xLjEuMVxuICAgICAgaWYgKHRoaXMuI2NhY2hlcy5oYXMob3B0aW9ucy5jYWNoZU5hbWUpKSB7XG4gICAgICAgIC8vIDEuMS4xLjEuMVxuICAgICAgICBjb25zdCBjYWNoZUxpc3QgPSB0aGlzLiNjYWNoZXMuZ2V0KG9wdGlvbnMuY2FjaGVOYW1lKVxuICAgICAgICBjb25zdCBjYWNoZSA9IG5ldyBDYWNoZShrQ29uc3RydWN0LCBjYWNoZUxpc3QpXG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IGNhY2hlLm1hdGNoKHJlcXVlc3QsIG9wdGlvbnMpXG4gICAgICB9XG4gICAgfSBlbHNlIHsgLy8gMi5cbiAgICAgIC8vIDIuMlxuICAgICAgZm9yIChjb25zdCBjYWNoZUxpc3Qgb2YgdGhpcy4jY2FjaGVzLnZhbHVlcygpKSB7XG4gICAgICAgIGNvbnN0IGNhY2hlID0gbmV3IENhY2hlKGtDb25zdHJ1Y3QsIGNhY2hlTGlzdClcblxuICAgICAgICAvLyAyLjIuMS4yXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY2FjaGUubWF0Y2gocmVxdWVzdCwgb3B0aW9ucylcblxuICAgICAgICBpZiAocmVzcG9uc2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiByZXNwb25zZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBzZWUgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL1NlcnZpY2VXb3JrZXIvI2NhY2hlLXN0b3JhZ2UtaGFzXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjYWNoZU5hbWVcbiAgICogQHJldHVybnMge1Byb21pc2U8Ym9vbGVhbj59XG4gICAqL1xuICBhc3luYyBoYXMgKGNhY2hlTmFtZSkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIENhY2hlU3RvcmFnZSlcblxuICAgIGNvbnN0IHByZWZpeCA9ICdDYWNoZVN0b3JhZ2UuaGFzJ1xuICAgIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMSwgcHJlZml4KVxuXG4gICAgY2FjaGVOYW1lID0gd2ViaWRsLmNvbnZlcnRlcnMuRE9NU3RyaW5nKGNhY2hlTmFtZSwgcHJlZml4LCAnY2FjaGVOYW1lJylcblxuICAgIC8vIDIuMS4xXG4gICAgLy8gMi4yXG4gICAgcmV0dXJuIHRoaXMuI2NhY2hlcy5oYXMoY2FjaGVOYW1lKVxuICB9XG5cbiAgLyoqXG4gICAqIEBzZWUgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL1NlcnZpY2VXb3JrZXIvI2RvbS1jYWNoZXN0b3JhZ2Utb3BlblxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2FjaGVOYW1lXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPENhY2hlPn1cbiAgICovXG4gIGFzeW5jIG9wZW4gKGNhY2hlTmFtZSkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIENhY2hlU3RvcmFnZSlcblxuICAgIGNvbnN0IHByZWZpeCA9ICdDYWNoZVN0b3JhZ2Uub3BlbidcbiAgICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDEsIHByZWZpeClcblxuICAgIGNhY2hlTmFtZSA9IHdlYmlkbC5jb252ZXJ0ZXJzLkRPTVN0cmluZyhjYWNoZU5hbWUsIHByZWZpeCwgJ2NhY2hlTmFtZScpXG5cbiAgICAvLyAyLjFcbiAgICBpZiAodGhpcy4jY2FjaGVzLmhhcyhjYWNoZU5hbWUpKSB7XG4gICAgICAvLyBhd2FpdCBjYWNoZXMub3BlbigndjEnKSAhPT0gYXdhaXQgY2FjaGVzLm9wZW4oJ3YxJylcblxuICAgICAgLy8gMi4xLjFcbiAgICAgIGNvbnN0IGNhY2hlID0gdGhpcy4jY2FjaGVzLmdldChjYWNoZU5hbWUpXG5cbiAgICAgIC8vIDIuMS4xLjFcbiAgICAgIHJldHVybiBuZXcgQ2FjaGUoa0NvbnN0cnVjdCwgY2FjaGUpXG4gICAgfVxuXG4gICAgLy8gMi4yXG4gICAgY29uc3QgY2FjaGUgPSBbXVxuXG4gICAgLy8gMi4zXG4gICAgdGhpcy4jY2FjaGVzLnNldChjYWNoZU5hbWUsIGNhY2hlKVxuXG4gICAgLy8gMi40XG4gICAgcmV0dXJuIG5ldyBDYWNoZShrQ29uc3RydWN0LCBjYWNoZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAc2VlIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby9TZXJ2aWNlV29ya2VyLyNjYWNoZS1zdG9yYWdlLWRlbGV0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2FjaGVOYW1lXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPGJvb2xlYW4+fVxuICAgKi9cbiAgYXN5bmMgZGVsZXRlIChjYWNoZU5hbWUpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBDYWNoZVN0b3JhZ2UpXG5cbiAgICBjb25zdCBwcmVmaXggPSAnQ2FjaGVTdG9yYWdlLmRlbGV0ZSdcbiAgICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDEsIHByZWZpeClcblxuICAgIGNhY2hlTmFtZSA9IHdlYmlkbC5jb252ZXJ0ZXJzLkRPTVN0cmluZyhjYWNoZU5hbWUsIHByZWZpeCwgJ2NhY2hlTmFtZScpXG5cbiAgICByZXR1cm4gdGhpcy4jY2FjaGVzLmRlbGV0ZShjYWNoZU5hbWUpXG4gIH1cblxuICAvKipcbiAgICogQHNlZSBodHRwczovL3czYy5naXRodWIuaW8vU2VydmljZVdvcmtlci8jY2FjaGUtc3RvcmFnZS1rZXlzXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZ1tdPn1cbiAgICovXG4gIGFzeW5jIGtleXMgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIENhY2hlU3RvcmFnZSlcblxuICAgIC8vIDIuMVxuICAgIGNvbnN0IGtleXMgPSB0aGlzLiNjYWNoZXMua2V5cygpXG5cbiAgICAvLyAyLjJcbiAgICByZXR1cm4gWy4uLmtleXNdXG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoQ2FjaGVTdG9yYWdlLnByb3RvdHlwZSwge1xuICBbU3ltYm9sLnRvU3RyaW5nVGFnXToge1xuICAgIHZhbHVlOiAnQ2FjaGVTdG9yYWdlJyxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSxcbiAgbWF0Y2g6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGhhczoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgb3Blbjoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgZGVsZXRlOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBrZXlzOiBrRW51bWVyYWJsZVByb3BlcnR5XG59KVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgQ2FjaGVTdG9yYWdlXG59XG4iXSwibmFtZXMiOlsia0NvbnN0cnVjdCIsInJlcXVpcmUiLCJDYWNoZSIsIndlYmlkbCIsImtFbnVtZXJhYmxlUHJvcGVydHkiLCJDYWNoZVN0b3JhZ2UiLCJjYWNoZXMiLCJjb25zdHJ1Y3RvciIsIk1hcCIsImFyZ3VtZW50cyIsImlsbGVnYWxDb25zdHJ1Y3RvciIsIm1hdGNoIiwicmVxdWVzdCIsIm9wdGlvbnMiLCJicmFuZENoZWNrIiwiYXJndW1lbnRMZW5ndGhDaGVjayIsImNvbnZlcnRlcnMiLCJSZXF1ZXN0SW5mbyIsIk11bHRpQ2FjaGVRdWVyeU9wdGlvbnMiLCJjYWNoZU5hbWUiLCJoYXMiLCJjYWNoZUxpc3QiLCJnZXQiLCJjYWNoZSIsInZhbHVlcyIsInJlc3BvbnNlIiwidW5kZWZpbmVkIiwicHJlZml4IiwiRE9NU3RyaW5nIiwib3BlbiIsInNldCIsImRlbGV0ZSIsImtleXMiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0aWVzIiwicHJvdG90eXBlIiwiU3ltYm9sIiwidG9TdHJpbmdUYWciLCJ2YWx1ZSIsImNvbmZpZ3VyYWJsZSIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/cache/cachestorage.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/cache/symbols.js":
/*!******************************************************!*\
  !*** ./node_modules/undici/lib/web/cache/symbols.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nmodule.exports = {\n    kConstruct: (__webpack_require__(/*! ../../core/symbols */ \"(ssr)/./node_modules/undici/lib/core/symbols.js\").kConstruct)\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvY2FjaGUvc3ltYm9scy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBQSxPQUFPQyxPQUFPLEdBQUc7SUFDZkMsWUFBWUMsNkdBQThCRDtBQUM1QyIsInNvdXJjZXMiOlsid2VicGFjazovL21vY2t1cGZsb3cvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvY2FjaGUvc3ltYm9scy5qcz85ZGM5Iiwid2VicGFjazovL21vY2t1cGZsb3cvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvY2FjaGUvc3ltYm9scy5qcz85ZGM5KiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGtDb25zdHJ1Y3Q6IHJlcXVpcmUoJy4uLy4uL2NvcmUvc3ltYm9scycpLmtDb25zdHJ1Y3Rcbn1cbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwia0NvbnN0cnVjdCIsInJlcXVpcmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/cache/symbols.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/cache/util.js":
/*!***************************************************!*\
  !*** ./node_modules/undici/lib/web/cache/util.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\");\nconst { URLSerializer } = __webpack_require__(/*! ../fetch/data-url */ \"(ssr)/./node_modules/undici/lib/web/fetch/data-url.js\");\nconst { isValidHeaderName } = __webpack_require__(/*! ../fetch/util */ \"(ssr)/./node_modules/undici/lib/web/fetch/util.js\");\n/**\n * @see https://url.spec.whatwg.org/#concept-url-equals\n * @param {URL} A\n * @param {URL} B\n * @param {boolean | undefined} excludeFragment\n * @returns {boolean}\n */ function urlEquals(A, B, excludeFragment = false) {\n    const serializedA = URLSerializer(A, excludeFragment);\n    const serializedB = URLSerializer(B, excludeFragment);\n    return serializedA === serializedB;\n}\n/**\n * @see https://github.com/chromium/chromium/blob/694d20d134cb553d8d89e5500b9148012b1ba299/content/browser/cache_storage/cache_storage_cache.cc#L260-L262\n * @param {string} header\n */ function getFieldValues(header) {\n    assert(header !== null);\n    const values = [];\n    for (let value of header.split(\",\")){\n        value = value.trim();\n        if (isValidHeaderName(value)) {\n            values.push(value);\n        }\n    }\n    return values;\n}\nmodule.exports = {\n    urlEquals,\n    getFieldValues\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvY2FjaGUvdXRpbC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU1BLFNBQVNDLG1CQUFPQSxDQUFDO0FBQ3ZCLE1BQU0sRUFBRUMsYUFBQUEsRUFBZSxHQUFHRCxtQkFBT0EsQ0FBQztBQUNsQyxNQUFNLEVBQUVFLGlCQUFBQSxFQUFtQixHQUFHRixtQkFBT0EsQ0FBQztBQUV0Qzs7Ozs7O0NBTUEsR0FDQSxTQUFTRyxVQUFXQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsa0JBQWtCLEtBQUs7SUFDL0MsTUFBTUMsY0FBY04sY0FBY0csR0FBR0U7SUFFckMsTUFBTUUsY0FBY1AsY0FBY0ksR0FBR0M7SUFFckMsT0FBT0MsZ0JBQWdCQztBQUN6QjtBQUVBOzs7Q0FHQSxHQUNBLFNBQVNDLGVBQWdCQyxNQUFNO0lBQzdCWCxPQUFPVyxXQUFXO0lBRWxCLE1BQU1DLFNBQVMsRUFBRTtJQUVqQixLQUFLLElBQUlDLFNBQVNGLE9BQU9HLEtBQUssQ0FBQyxLQUFNO1FBQ25DRCxRQUFRQSxNQUFNRSxJQUFJO1FBRWxCLElBQUlaLGtCQUFrQlUsUUFBUTtZQUM1QkQsT0FBT0ksSUFBSSxDQUFDSDtRQUNkO0lBQ0Y7SUFFQSxPQUFPRDtBQUNUO0FBRUFLLE9BQU9DLE9BQU8sR0FBRztJQUNmZDtJQUNBTTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbW9ja3VwZmxvdy8uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL3dlYi9jYWNoZS91dGlsLmpzP2ExMzgiLCJ3ZWJwYWNrOi8vbW9ja3VwZmxvdy8uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL3dlYi9jYWNoZS91dGlsLmpzP2ExMzgqIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdub2RlOmFzc2VydCcpXG5jb25zdCB7IFVSTFNlcmlhbGl6ZXIgfSA9IHJlcXVpcmUoJy4uL2ZldGNoL2RhdGEtdXJsJylcbmNvbnN0IHsgaXNWYWxpZEhlYWRlck5hbWUgfSA9IHJlcXVpcmUoJy4uL2ZldGNoL3V0aWwnKVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LXVybC1lcXVhbHNcbiAqIEBwYXJhbSB7VVJMfSBBXG4gKiBAcGFyYW0ge1VSTH0gQlxuICogQHBhcmFtIHtib29sZWFuIHwgdW5kZWZpbmVkfSBleGNsdWRlRnJhZ21lbnRcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiB1cmxFcXVhbHMgKEEsIEIsIGV4Y2x1ZGVGcmFnbWVudCA9IGZhbHNlKSB7XG4gIGNvbnN0IHNlcmlhbGl6ZWRBID0gVVJMU2VyaWFsaXplcihBLCBleGNsdWRlRnJhZ21lbnQpXG5cbiAgY29uc3Qgc2VyaWFsaXplZEIgPSBVUkxTZXJpYWxpemVyKEIsIGV4Y2x1ZGVGcmFnbWVudClcblxuICByZXR1cm4gc2VyaWFsaXplZEEgPT09IHNlcmlhbGl6ZWRCXG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vY2hyb21pdW0vY2hyb21pdW0vYmxvYi82OTRkMjBkMTM0Y2I1NTNkOGQ4OWU1NTAwYjkxNDgwMTJiMWJhMjk5L2NvbnRlbnQvYnJvd3Nlci9jYWNoZV9zdG9yYWdlL2NhY2hlX3N0b3JhZ2VfY2FjaGUuY2MjTDI2MC1MMjYyXG4gKiBAcGFyYW0ge3N0cmluZ30gaGVhZGVyXG4gKi9cbmZ1bmN0aW9uIGdldEZpZWxkVmFsdWVzIChoZWFkZXIpIHtcbiAgYXNzZXJ0KGhlYWRlciAhPT0gbnVsbClcblxuICBjb25zdCB2YWx1ZXMgPSBbXVxuXG4gIGZvciAobGV0IHZhbHVlIG9mIGhlYWRlci5zcGxpdCgnLCcpKSB7XG4gICAgdmFsdWUgPSB2YWx1ZS50cmltKClcblxuICAgIGlmIChpc1ZhbGlkSGVhZGVyTmFtZSh2YWx1ZSkpIHtcbiAgICAgIHZhbHVlcy5wdXNoKHZhbHVlKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB2YWx1ZXNcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHVybEVxdWFscyxcbiAgZ2V0RmllbGRWYWx1ZXNcbn1cbiJdLCJuYW1lcyI6WyJhc3NlcnQiLCJyZXF1aXJlIiwiVVJMU2VyaWFsaXplciIsImlzVmFsaWRIZWFkZXJOYW1lIiwidXJsRXF1YWxzIiwiQSIsIkIiLCJleGNsdWRlRnJhZ21lbnQiLCJzZXJpYWxpemVkQSIsInNlcmlhbGl6ZWRCIiwiZ2V0RmllbGRWYWx1ZXMiLCJoZWFkZXIiLCJ2YWx1ZXMiLCJ2YWx1ZSIsInNwbGl0IiwidHJpbSIsInB1c2giLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/cache/util.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/cookies/constants.js":
/*!**********************************************************!*\
  !*** ./node_modules/undici/lib/web/cookies/constants.js ***!
  \**********************************************************/
/***/ ((module) => {

eval("\n// https://wicg.github.io/cookie-store/#cookie-maximum-attribute-value-size\nconst maxAttributeValueSize = 1024;\n// https://wicg.github.io/cookie-store/#cookie-maximum-name-value-pair-size\nconst maxNameValuePairSize = 4096;\nmodule.exports = {\n    maxAttributeValueSize,\n    maxNameValuePairSize\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvY29va2llcy9jb25zdGFudHMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQTtBQUNBLE1BQU1BLHdCQUF3QjtBQUU5QjtBQUNBLE1BQU1DLHVCQUF1QjtBQUU3QkMsT0FBT0MsT0FBTyxHQUFHO0lBQ2ZIO0lBQ0FDO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tb2NrdXBmbG93Ly4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvd2ViL2Nvb2tpZXMvY29uc3RhbnRzLmpzPzUzN2UiLCJ3ZWJwYWNrOi8vbW9ja3VwZmxvdy8uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL3dlYi9jb29raWVzL2NvbnN0YW50cy5qcz81MzdlKiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuLy8gaHR0cHM6Ly93aWNnLmdpdGh1Yi5pby9jb29raWUtc3RvcmUvI2Nvb2tpZS1tYXhpbXVtLWF0dHJpYnV0ZS12YWx1ZS1zaXplXG5jb25zdCBtYXhBdHRyaWJ1dGVWYWx1ZVNpemUgPSAxMDI0XG5cbi8vIGh0dHBzOi8vd2ljZy5naXRodWIuaW8vY29va2llLXN0b3JlLyNjb29raWUtbWF4aW11bS1uYW1lLXZhbHVlLXBhaXItc2l6ZVxuY29uc3QgbWF4TmFtZVZhbHVlUGFpclNpemUgPSA0MDk2XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBtYXhBdHRyaWJ1dGVWYWx1ZVNpemUsXG4gIG1heE5hbWVWYWx1ZVBhaXJTaXplXG59XG4iXSwibmFtZXMiOlsibWF4QXR0cmlidXRlVmFsdWVTaXplIiwibWF4TmFtZVZhbHVlUGFpclNpemUiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/cookies/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/cookies/index.js":
/*!******************************************************!*\
  !*** ./node_modules/undici/lib/web/cookies/index.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { parseSetCookie } = __webpack_require__(/*! ./parse */ \"(ssr)/./node_modules/undici/lib/web/cookies/parse.js\");\nconst { stringify } = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/undici/lib/web/cookies/util.js\");\nconst { webidl } = __webpack_require__(/*! ../fetch/webidl */ \"(ssr)/./node_modules/undici/lib/web/fetch/webidl.js\");\nconst { Headers } = __webpack_require__(/*! ../fetch/headers */ \"(ssr)/./node_modules/undici/lib/web/fetch/headers.js\");\n/**\n * @typedef {Object} Cookie\n * @property {string} name\n * @property {string} value\n * @property {Date|number|undefined} expires\n * @property {number|undefined} maxAge\n * @property {string|undefined} domain\n * @property {string|undefined} path\n * @property {boolean|undefined} secure\n * @property {boolean|undefined} httpOnly\n * @property {'Strict'|'Lax'|'None'} sameSite\n * @property {string[]} unparsed\n */ /**\n * @param {Headers} headers\n * @returns {Record<string, string>}\n */ function getCookies(headers) {\n    webidl.argumentLengthCheck(arguments, 1, \"getCookies\");\n    webidl.brandCheck(headers, Headers, {\n        strict: false\n    });\n    const cookie = headers.get(\"cookie\");\n    const out = {};\n    if (!cookie) {\n        return out;\n    }\n    for (const piece of cookie.split(\";\")){\n        const [name, ...value] = piece.split(\"=\");\n        out[name.trim()] = value.join(\"=\");\n    }\n    return out;\n}\n/**\n * @param {Headers} headers\n * @param {string} name\n * @param {{ path?: string, domain?: string }|undefined} attributes\n * @returns {void}\n */ function deleteCookie(headers, name, attributes) {\n    webidl.brandCheck(headers, Headers, {\n        strict: false\n    });\n    const prefix = \"deleteCookie\";\n    webidl.argumentLengthCheck(arguments, 2, prefix);\n    name = webidl.converters.DOMString(name, prefix, \"name\");\n    attributes = webidl.converters.DeleteCookieAttributes(attributes);\n    // Matches behavior of\n    // https://github.com/denoland/deno_std/blob/63827b16330b82489a04614027c33b7904e08be5/http/cookie.ts#L278\n    setCookie(headers, {\n        name,\n        value: \"\",\n        expires: new Date(0),\n        ...attributes\n    });\n}\n/**\n * @param {Headers} headers\n * @returns {Cookie[]}\n */ function getSetCookies(headers) {\n    webidl.argumentLengthCheck(arguments, 1, \"getSetCookies\");\n    webidl.brandCheck(headers, Headers, {\n        strict: false\n    });\n    const cookies = headers.getSetCookie();\n    if (!cookies) {\n        return [];\n    }\n    return cookies.map((pair)=>parseSetCookie(pair));\n}\n/**\n * @param {Headers} headers\n * @param {Cookie} cookie\n * @returns {void}\n */ function setCookie(headers, cookie) {\n    webidl.argumentLengthCheck(arguments, 2, \"setCookie\");\n    webidl.brandCheck(headers, Headers, {\n        strict: false\n    });\n    cookie = webidl.converters.Cookie(cookie);\n    const str = stringify(cookie);\n    if (str) {\n        headers.append(\"Set-Cookie\", str);\n    }\n}\nwebidl.converters.DeleteCookieAttributes = webidl.dictionaryConverter([\n    {\n        converter: webidl.nullableConverter(webidl.converters.DOMString),\n        key: \"path\",\n        defaultValue: ()=>null\n    },\n    {\n        converter: webidl.nullableConverter(webidl.converters.DOMString),\n        key: \"domain\",\n        defaultValue: ()=>null\n    }\n]);\nwebidl.converters.Cookie = webidl.dictionaryConverter([\n    {\n        converter: webidl.converters.DOMString,\n        key: \"name\"\n    },\n    {\n        converter: webidl.converters.DOMString,\n        key: \"value\"\n    },\n    {\n        converter: webidl.nullableConverter((value)=>{\n            if (typeof value === \"number\") {\n                return webidl.converters[\"unsigned long long\"](value);\n            }\n            return new Date(value);\n        }),\n        key: \"expires\",\n        defaultValue: ()=>null\n    },\n    {\n        converter: webidl.nullableConverter(webidl.converters[\"long long\"]),\n        key: \"maxAge\",\n        defaultValue: ()=>null\n    },\n    {\n        converter: webidl.nullableConverter(webidl.converters.DOMString),\n        key: \"domain\",\n        defaultValue: ()=>null\n    },\n    {\n        converter: webidl.nullableConverter(webidl.converters.DOMString),\n        key: \"path\",\n        defaultValue: ()=>null\n    },\n    {\n        converter: webidl.nullableConverter(webidl.converters.boolean),\n        key: \"secure\",\n        defaultValue: ()=>null\n    },\n    {\n        converter: webidl.nullableConverter(webidl.converters.boolean),\n        key: \"httpOnly\",\n        defaultValue: ()=>null\n    },\n    {\n        converter: webidl.converters.USVString,\n        key: \"sameSite\",\n        allowedValues: [\n            \"Strict\",\n            \"Lax\",\n            \"None\"\n        ]\n    },\n    {\n        converter: webidl.sequenceConverter(webidl.converters.DOMString),\n        key: \"unparsed\",\n        defaultValue: ()=>new Array(0)\n    }\n]);\nmodule.exports = {\n    getCookies,\n    deleteCookie,\n    getSetCookies,\n    setCookie\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvY29va2llcy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU0sRUFBRUEsY0FBQUEsRUFBZ0IsR0FBR0MsbUJBQU9BLENBQUM7QUFDbkMsTUFBTSxFQUFFQyxTQUFBQSxFQUFXLEdBQUdELG1CQUFPQSxDQUFDO0FBQzlCLE1BQU0sRUFBRUUsTUFBQUEsRUFBUSxHQUFHRixtQkFBT0EsQ0FBQztBQUMzQixNQUFNLEVBQUVHLE9BQUFBLEVBQVMsR0FBR0gsbUJBQU9BLENBQUM7QUFFNUI7Ozs7Ozs7Ozs7OztDQVlBLEdBRUE7OztDQUdBLEdBQ0EsU0FBU0ksV0FBWUMsT0FBTztJQUMxQkgsT0FBT0ksbUJBQW1CLENBQUNDLFdBQVcsR0FBRztJQUV6Q0wsT0FBT00sVUFBVSxDQUFDSCxTQUFTRixTQUFTO1FBQUVNLFFBQVE7SUFBTTtJQUVwRCxNQUFNQyxTQUFTTCxRQUFRTSxHQUFHLENBQUM7SUFDM0IsTUFBTUMsTUFBTSxDQUFDO0lBRWIsSUFBSSxDQUFDRixRQUFRO1FBQ1gsT0FBT0U7SUFDVDtJQUVBLEtBQUssTUFBTUMsU0FBU0gsT0FBT0ksS0FBSyxDQUFDLEtBQU07UUFDckMsTUFBTSxDQUFDQyxNQUFNLEdBQUdDLE1BQU0sR0FBR0gsTUFBTUMsS0FBSyxDQUFDO1FBRXJDRixHQUFHLENBQUNHLEtBQUtFLElBQUksR0FBRyxHQUFHRCxNQUFNRSxJQUFJLENBQUM7SUFDaEM7SUFFQSxPQUFPTjtBQUNUO0FBRUE7Ozs7O0NBS0EsR0FDQSxTQUFTTyxhQUFjZCxPQUFPLEVBQUVVLElBQUksRUFBRUssVUFBVTtJQUM5Q2xCLE9BQU9NLFVBQVUsQ0FBQ0gsU0FBU0YsU0FBUztRQUFFTSxRQUFRO0lBQU07SUFFcEQsTUFBTVksU0FBUztJQUNmbkIsT0FBT0ksbUJBQW1CLENBQUNDLFdBQVcsR0FBR2M7SUFFekNOLE9BQU9iLE9BQU9vQixVQUFVLENBQUNDLFNBQVMsQ0FBQ1IsTUFBTU0s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Q29CLFNBQVM7UUFDdENILEtBQUs7UUFDTEksZUFBZTtZQUFDO1lBQVU7WUFBTztTQUFNO0lBQ3pDO0lBQ0E7UUFDRU4sV0FBV25DLE9BQU8wQyxpQkFBaUIsQ0FBQzFDLE9BQU9vQixVQUFVLENBQUNDLFNBQVM7UUFDL0RnQixLQUFLO1FBQ0xDLGNBQWNBLElBQU0sSUFBSUssTUFBTTtJQUNoQztDQUNEO0FBRURDLE9BQU9DLE9BQU8sR0FBRztJQUNmM0M7SUFDQWU7SUFDQVM7SUFDQUg7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL21vY2t1cGZsb3cvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvY29va2llcy9pbmRleC5qcz8yZDg4Iiwid2VicGFjazovL21vY2t1cGZsb3cvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvY29va2llcy9pbmRleC5qcz8yZDg4KiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyBwYXJzZVNldENvb2tpZSB9ID0gcmVxdWlyZSgnLi9wYXJzZScpXG5jb25zdCB7IHN0cmluZ2lmeSB9ID0gcmVxdWlyZSgnLi91dGlsJylcbmNvbnN0IHsgd2ViaWRsIH0gPSByZXF1aXJlKCcuLi9mZXRjaC93ZWJpZGwnKVxuY29uc3QgeyBIZWFkZXJzIH0gPSByZXF1aXJlKCcuLi9mZXRjaC9oZWFkZXJzJylcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBDb29raWVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBuYW1lXG4gKiBAcHJvcGVydHkge3N0cmluZ30gdmFsdWVcbiAqIEBwcm9wZXJ0eSB7RGF0ZXxudW1iZXJ8dW5kZWZpbmVkfSBleHBpcmVzXG4gKiBAcHJvcGVydHkge251bWJlcnx1bmRlZmluZWR9IG1heEFnZVxuICogQHByb3BlcnR5IHtzdHJpbmd8dW5kZWZpbmVkfSBkb21haW5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfHVuZGVmaW5lZH0gcGF0aFxuICogQHByb3BlcnR5IHtib29sZWFufHVuZGVmaW5lZH0gc2VjdXJlXG4gKiBAcHJvcGVydHkge2Jvb2xlYW58dW5kZWZpbmVkfSBodHRwT25seVxuICogQHByb3BlcnR5IHsnU3RyaWN0J3wnTGF4J3wnTm9uZSd9IHNhbWVTaXRlXG4gKiBAcHJvcGVydHkge3N0cmluZ1tdfSB1bnBhcnNlZFxuICovXG5cbi8qKlxuICogQHBhcmFtIHtIZWFkZXJzfSBoZWFkZXJzXG4gKiBAcmV0dXJucyB7UmVjb3JkPHN0cmluZywgc3RyaW5nPn1cbiAqL1xuZnVuY3Rpb24gZ2V0Q29va2llcyAoaGVhZGVycykge1xuICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDEsICdnZXRDb29raWVzJylcblxuICB3ZWJpZGwuYnJhbmRDaGVjayhoZWFkZXJzLCBIZWFkZXJzLCB7IHN0cmljdDogZmFsc2UgfSlcblxuICBjb25zdCBjb29raWUgPSBoZWFkZXJzLmdldCgnY29va2llJylcbiAgY29uc3Qgb3V0ID0ge31cblxuICBpZiAoIWNvb2tpZSkge1xuICAgIHJldHVybiBvdXRcbiAgfVxuXG4gIGZvciAoY29uc3QgcGllY2Ugb2YgY29va2llLnNwbGl0KCc7JykpIHtcbiAgICBjb25zdCBbbmFtZSwgLi4udmFsdWVdID0gcGllY2Uuc3BsaXQoJz0nKVxuXG4gICAgb3V0W25hbWUudHJpbSgpXSA9IHZhbHVlLmpvaW4oJz0nKVxuICB9XG5cbiAgcmV0dXJuIG91dFxufVxuXG4vKipcbiAqIEBwYXJhbSB7SGVhZGVyc30gaGVhZGVyc1xuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7eyBwYXRoPzogc3RyaW5nLCBkb21haW4/OiBzdHJpbmcgfXx1bmRlZmluZWR9IGF0dHJpYnV0ZXNcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiBkZWxldGVDb29raWUgKGhlYWRlcnMsIG5hbWUsIGF0dHJpYnV0ZXMpIHtcbiAgd2ViaWRsLmJyYW5kQ2hlY2soaGVhZGVycywgSGVhZGVycywgeyBzdHJpY3Q6IGZhbHNlIH0pXG5cbiAgY29uc3QgcHJlZml4ID0gJ2RlbGV0ZUNvb2tpZSdcbiAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAyLCBwcmVmaXgpXG5cbiAgbmFtZSA9IHdlYmlkbC5jb252ZXJ0ZXJzLkRPTVN0cmluZyhuYW1lLCBwcmVmaXgsICduYW1lJylcbiAgYXR0cmlidXRlcyA9IHdlYmlkbC5jb252ZXJ0ZXJzLkRlbGV0ZUNvb2tpZUF0dHJpYnV0ZXMoYXR0cmlidXRlcylcblxuICAvLyBNYXRjaGVzIGJlaGF2aW9yIG9mXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9kZW5vbGFuZC9kZW5vX3N0ZC9ibG9iLzYzODI3YjE2MzMwYjgyNDg5YTA0NjE0MDI3YzMzYjc5MDRlMDhiZTUvaHR0cC9jb29raWUudHMjTDI3OFxuICBzZXRDb29raWUoaGVhZGVycywge1xuICAgIG5hbWUsXG4gICAgdmFsdWU6ICcnLFxuICAgIGV4cGlyZXM6IG5ldyBEYXRlKDApLFxuICAgIC4uLmF0dHJpYnV0ZXNcbiAgfSlcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0hlYWRlcnN9IGhlYWRlcnNcbiAqIEByZXR1cm5zIHtDb29raWVbXX1cbiAqL1xuZnVuY3Rpb24gZ2V0U2V0Q29va2llcyAoaGVhZGVycykge1xuICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDEsICdnZXRTZXRDb29raWVzJylcblxuICB3ZWJpZGwuYnJhbmRDaGVjayhoZWFkZXJzLCBIZWFkZXJzLCB7IHN0cmljdDogZmFsc2UgfSlcblxuICBjb25zdCBjb29raWVzID0gaGVhZGVycy5nZXRTZXRDb29raWUoKVxuXG4gIGlmICghY29va2llcykge1xuICAgIHJldHVybiBbXVxuICB9XG5cbiAgcmV0dXJuIGNvb2tpZXMubWFwKChwYWlyKSA9PiBwYXJzZVNldENvb2tpZShwYWlyKSlcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0hlYWRlcnN9IGhlYWRlcnNcbiAqIEBwYXJhbSB7Q29va2llfSBjb29raWVcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiBzZXRDb29raWUgKGhlYWRlcnMsIGNvb2tpZSkge1xuICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDIsICdzZXRDb29raWUnKVxuXG4gIHdlYmlkbC5icmFuZENoZWNrKGhlYWRlcnMsIEhlYWRlcnMsIHsgc3RyaWN0OiBmYWxzZSB9KVxuXG4gIGNvb2tpZSA9IHdlYmlkbC5jb252ZXJ0ZXJzLkNvb2tpZShjb29raWUpXG5cbiAgY29uc3Qgc3RyID0gc3RyaW5naWZ5KGNvb2tpZSlcblxuICBpZiAoc3RyKSB7XG4gICAgaGVhZGVycy5hcHBlbmQoJ1NldC1Db29raWUnLCBzdHIpXG4gIH1cbn1cblxud2ViaWRsLmNvbnZlcnRlcnMuRGVsZXRlQ29va2llQXR0cmlidXRlcyA9IHdlYmlkbC5kaWN0aW9uYXJ5Q29udmVydGVyKFtcbiAge1xuICAgIGNvbnZlcnRlcjogd2ViaWRsLm51bGxhYmxlQ29udmVydGVyKHdlYmlkbC5jb252ZXJ0ZXJzLkRPTVN0cmluZyksXG4gICAga2V5OiAncGF0aCcsXG4gICAgZGVmYXVsdFZhbHVlOiAoKSA9PiBudWxsXG4gIH0sXG4gIHtcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5udWxsYWJsZUNvbnZlcnRlcih3ZWJpZGwuY29udmVydGVycy5ET01TdHJpbmcpLFxuICAgIGtleTogJ2RvbWFpbicsXG4gICAgZGVmYXVsdFZhbHVlOiAoKSA9PiBudWxsXG4gIH1cbl0pXG5cbndlYmlkbC5jb252ZXJ0ZXJzLkNvb2tpZSA9IHdlYmlkbC5kaWN0aW9uYXJ5Q29udmVydGVyKFtcbiAge1xuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuRE9NU3RyaW5nLFxuICAgIGtleTogJ25hbWUnXG4gIH0sXG4gIHtcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLkRPTVN0cmluZyxcbiAgICBrZXk6ICd2YWx1ZSdcbiAgfSxcbiAge1xuICAgIGNvbnZlcnRlcjogd2ViaWRsLm51bGxhYmxlQ29udmVydGVyKCh2YWx1ZSkgPT4ge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIHdlYmlkbC5jb252ZXJ0ZXJzWyd1bnNpZ25lZCBsb25nIGxvbmcnXSh2YWx1ZSlcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBEYXRlKHZhbHVlKVxuICAgIH0pLFxuICAgIGtleTogJ2V4cGlyZXMnLFxuICAgIGRlZmF1bHRWYWx1ZTogKCkgPT4gbnVsbFxuICB9LFxuICB7XG4gICAgY29udmVydGVyOiB3ZWJpZGwubnVsbGFibGVDb252ZXJ0ZXIod2ViaWRsLmNvbnZlcnRlcnNbJ2xvbmcgbG9uZyddKSxcbiAgICBrZXk6ICdtYXhBZ2UnLFxuICAgIGRlZmF1bHRWYWx1ZTogKCkgPT4gbnVsbFxuICB9LFxuICB7XG4gICAgY29udmVydGVyOiB3ZWJpZGwubnVsbGFibGVDb252ZXJ0ZXIod2ViaWRsLmNvbnZlcnRlcnMuRE9NU3RyaW5nKSxcbiAgICBrZXk6ICdkb21haW4nLFxuICAgIGRlZmF1bHRWYWx1ZTogKCkgPT4gbnVsbFxuICB9LFxuICB7XG4gICAgY29udmVydGVyOiB3ZWJpZGwubnVsbGFibGVDb252ZXJ0ZXIod2ViaWRsLmNvbnZlcnRlcnMuRE9NU3RyaW5nKSxcbiAgICBrZXk6ICdwYXRoJyxcbiAgICBkZWZhdWx0VmFsdWU6ICgpID0+IG51bGxcbiAgfSxcbiAge1xuICAgIGNvbnZlcnRlcjogd2ViaWRsLm51bGxhYmxlQ29udmVydGVyKHdlYmlkbC5jb252ZXJ0ZXJzLmJvb2xlYW4pLFxuICAgIGtleTogJ3NlY3VyZScsXG4gICAgZGVmYXVsdFZhbHVlOiAoKSA9PiBudWxsXG4gIH0sXG4gIHtcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5udWxsYWJsZUNvbnZlcnRlcih3ZWJpZGwuY29udmVydGVycy5ib29sZWFuKSxcbiAgICBrZXk6ICdodHRwT25seScsXG4gICAgZGVmYXVsdFZhbHVlOiAoKSA9PiBudWxsXG4gIH0sXG4gIHtcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLlVTVlN0cmluZyxcbiAgICBrZXk6ICdzYW1lU2l0ZScsXG4gICAgYWxsb3dlZFZhbHVlczogWydTdHJpY3QnLCAnTGF4JywgJ05vbmUnXVxuICB9LFxuICB7XG4gICAgY29udmVydGVyOiB3ZWJpZGwuc2VxdWVuY2VDb252ZXJ0ZXIod2ViaWRsLmNvbnZlcnRlcnMuRE9NU3RyaW5nKSxcbiAgICBrZXk6ICd1bnBhcnNlZCcsXG4gICAgZGVmYXVsdFZhbHVlOiAoKSA9PiBuZXcgQXJyYXkoMClcbiAgfVxuXSlcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGdldENvb2tpZXMsXG4gIGRlbGV0ZUNvb2tpZSxcbiAgZ2V0U2V0Q29va2llcyxcbiAgc2V0Q29va2llXG59XG4iXSwibmFtZXMiOlsicGFyc2VTZXRDb29raWUiLCJyZXF1aXJlIiwic3RyaW5naWZ5Iiwid2ViaWRsIiwiSGVhZGVycyIsImdldENvb2tpZXMiLCJoZWFkZXJzIiwiYXJndW1lbnRMZW5ndGhDaGVjayIsImFyZ3VtZW50cyIsImJyYW5kQ2hlY2siLCJzdHJpY3QiLCJjb29raWUiLCJnZXQiLCJvdXQiLCJwaWVjZSIsInNwbGl0IiwibmFtZSIsInZhbHVlIiwidHJpbSIsImpvaW4iLCJkZWxldGVDb29raWUiLCJhdHRyaWJ1dGVzIiwicHJlZml4IiwiY29udmVydGVycyIsIkRPTVN0cmluZyIsIkRlbGV0ZUNvb2tpZUF0dHJpYnV0ZXMiLCJzZXRDb29raWUiLCJleHBpcmVzIiwiRGF0ZSIsImdldFNldENvb2tpZXMiLCJjb29raWVzIiwiZ2V0U2V0Q29va2llIiwibWFwIiwicGFpciIsIkNvb2tpZSIsInN0ciIsImFwcGVuZCIsImRpY3Rpb25hcnlDb252ZXJ0ZXIiLCJjb252ZXJ0ZXIiLCJudWxsYWJsZUNvbnZlcnRlciIsImtleSIsImRlZmF1bHRWYWx1ZSIsImJvb2xlYW4iLCJVU1ZTdHJpbmciLCJhbGxvd2VkVmFsdWVzIiwic2VxdWVuY2VDb252ZXJ0ZXIiLCJBcnJheSIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/cookies/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/cookies/parse.js":
/*!******************************************************!*\
  !*** ./node_modules/undici/lib/web/cookies/parse.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { maxNameValuePairSize, maxAttributeValueSize } = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/undici/lib/web/cookies/constants.js\");\nconst { isCTLExcludingHtab } = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/undici/lib/web/cookies/util.js\");\nconst { collectASequenceOfCodePointsFast } = __webpack_require__(/*! ../fetch/data-url */ \"(ssr)/./node_modules/undici/lib/web/fetch/data-url.js\");\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\");\n/**\n * @description Parses the field-value attributes of a set-cookie header string.\n * @see https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4\n * @param {string} header\n * @returns if the header is invalid, null will be returned\n */ function parseSetCookie(header) {\n    // 1. If the set-cookie-string contains a %x00-08 / %x0A-1F / %x7F\n    //    character (CTL characters excluding HTAB): Abort these steps and\n    //    ignore the set-cookie-string entirely.\n    if (isCTLExcludingHtab(header)) {\n        return null;\n    }\n    let nameValuePair = \"\";\n    let unparsedAttributes = \"\";\n    let name = \"\";\n    let value = \"\";\n    // 2. If the set-cookie-string contains a %x3B (\";\") character:\n    if (header.includes(\";\")) {\n        // 1. The name-value-pair string consists of the characters up to,\n        //    but not including, the first %x3B (\";\"), and the unparsed-\n        //    attributes consist of the remainder of the set-cookie-string\n        //    (including the %x3B (\";\") in question).\n        const position = {\n            position: 0\n        };\n        nameValuePair = collectASequenceOfCodePointsFast(\";\", header, position);\n        unparsedAttributes = header.slice(position.position);\n    } else {\n        // Otherwise:\n        // 1. The name-value-pair string consists of all the characters\n        //    contained in the set-cookie-string, and the unparsed-\n        //    attributes is the empty string.\n        nameValuePair = header;\n    }\n    // 3. If the name-value-pair string lacks a %x3D (\"=\") character, then\n    //    the name string is empty, and the value string is the value of\n    //    name-value-pair.\n    if (!nameValuePair.includes(\"=\")) {\n        value = nameValuePair;\n    } else {\n        //    Otherwise, the name string consists of the characters up to, but\n        //    not including, the first %x3D (\"=\") character, and the (possibly\n        //    empty) value string consists of the characters after the first\n        //    %x3D (\"=\") character.\n        const position = {\n            position: 0\n        };\n        name = collectASequenceOfCodePointsFast(\"=\", nameValuePair, position);\n        value = nameValuePair.slice(position.position + 1);\n    }\n    // 4. Remove any leading or trailing WSP characters from the name\n    //    string and the value string.\n    name = name.trim();\n    value = value.trim();\n    // 5. If the sum of the lengths of the name string and the value string\n    //    is more than 4096 octets, abort these steps and ignore the set-\n    //    cookie-string entirely.\n    if (name.length + value.length > maxNameValuePairSize) {\n        return null;\n    }\n    // 6. The cookie-name is the name string, and the cookie-value is the\n    //    value string.\n    return {\n        name,\n        value,\n        ...parseUnparsedAttributes(unparsedAttributes)\n    };\n}\n/**\n * Parses the remaining attributes of a set-cookie header\n * @see https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4\n * @param {string} unparsedAttributes\n * @param {[Object.<string, unknown>]={}} cookieAttributeList\n */ function parseUnparsedAttributes(unparsedAttributes, cookieAttributeList = {}) {\n    // 1. If the unparsed-attributes string is empty, skip the rest of\n    //    these steps.\n    if (unparsedAttributes.length === 0) {\n        return cookieAttributeList;\n    }\n    // 2. Discard the first character of the unparsed-attributes (which\n    //    will be a %x3B (\";\") character).\n    assert(unparsedAttributes[0] === \";\");\n    unparsedAttributes = unparsedAttributes.slice(1);\n    let cookieAv = \"\";\n    // 3. If the remaining unparsed-attributes contains a %x3B (\";\")\n    //    character:\n    if (unparsedAttributes.includes(\";\")) {\n        // 1. Consume the characters of the unparsed-attributes up to, but\n        //    not including, the first %x3B (\";\") character.\n        cookieAv = collectASequenceOfCodePointsFast(\";\", unparsedAttributes, {\n            position: 0\n        });\n        unparsedAttributes = unparsedAttributes.slice(cookieAv.length);\n    } else {\n        // Otherwise:\n        // 1. Consume the remainder of the unparsed-attributes.\n        cookieAv = unparsedAttributes;\n        unparsedAttributes = \"\";\n    }\n    // Let the cookie-av string be the characters consumed in this step.\n    let attributeName = \"\";\n    let attributeValue = \"\";\n    // 4. If the cookie-av string contains a %x3D (\"=\") character:\n    if (cookieAv.includes(\"=\")) {\n        // 1. The (possibly empty) attribute-name string consists of the\n        //    characters up to, but not including, the first %x3D (\"=\")\n        //    character, and the (possibly empty) attribute-value string\n        //    consists of the characters after the first %x3D (\"=\")\n        //    character.\n        const position = {\n            position: 0\n        };\n        attributeName = collectASequenceOfCodePointsFast(\"=\", cookieAv, position);\n        attributeValue = cookieAv.slice(position.position + 1);\n    } else {\n        // Otherwise:\n        // 1. The attribute-name string consists of the entire cookie-av\n        //    string, and the attribute-value string is empty.\n        attributeName = cookieAv;\n    }\n    // 5. Remove any leading or trailing WSP characters from the attribute-\n    //    name string and the attribute-value string.\n    attributeName = attributeName.trim();\n    attributeValue = attributeValue.trim();\n    // 6. If the attribute-value is longer than 1024 octets, ignore the\n    //    cookie-av string and return to Step 1 of this algorithm.\n    if (attributeValue.length > maxAttributeValueSize) {\n        return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);\n    }\n    // 7. Process the attribute-name and attribute-value according to the\n    //    requirements in the following subsections.  (Notice that\n    //    attributes with unrecognized attribute-names are ignored.)\n    const attributeNameLowercase = attributeName.toLowerCase();\n    // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.1\n    // If the attribute-name case-insensitively matches the string\n    // \"Expires\", the user agent MUST process the cookie-av as follows.\n    if (attributeNameLowercase === \"expires\") {\n        // 1. Let the expiry-time be the result of parsing the attribute-value\n        //    as cookie-date (see Section 5.1.1).\n        const expiryTime = new Date(attributeValue);\n        // 2. If the attribute-value failed to parse as a cookie date, ignore\n        //    the cookie-av.\n        cookieAttributeList.expires = expiryTime;\n    } else if (attributeNameLowercase === \"max-age\") {\n        // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.2\n        // If the attribute-name case-insensitively matches the string \"Max-\n        // Age\", the user agent MUST process the cookie-av as follows.\n        // 1. If the first character of the attribute-value is not a DIGIT or a\n        //    \"-\" character, ignore the cookie-av.\n        const charCode = attributeValue.charCodeAt(0);\n        if ((charCode < 48 || charCode > 57) && attributeValue[0] !== \"-\") {\n            return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);\n        }\n        // 2. If the remainder of attribute-value contains a non-DIGIT\n        //    character, ignore the cookie-av.\n        if (!/^\\d+$/.test(attributeValue)) {\n            return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);\n        }\n        // 3. Let delta-seconds be the attribute-value converted to an integer.\n        const deltaSeconds = Number(attributeValue);\n        // 4. Let cookie-age-limit be the maximum age of the cookie (which\n        //    SHOULD be 400 days or less, see Section 4.1.2.2).\n        // 5. Set delta-seconds to the smaller of its present value and cookie-\n        //    age-limit.\n        // deltaSeconds = Math.min(deltaSeconds * 1000, maxExpiresMs)\n        // 6. If delta-seconds is less than or equal to zero (0), let expiry-\n        //    time be the earliest representable date and time.  Otherwise, let\n        //    the expiry-time be the current date and time plus delta-seconds\n        //    seconds.\n        // const expiryTime = deltaSeconds <= 0 ? Date.now() : Date.now() + deltaSeconds\n        // 7. Append an attribute to the cookie-attribute-list with an\n        //    attribute-name of Max-Age and an attribute-value of expiry-time.\n        cookieAttributeList.maxAge = deltaSeconds;\n    } else if (attributeNameLowercase === \"domain\") {\n        // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.3\n        // If the attribute-name case-insensitively matches the string \"Domain\",\n        // the user agent MUST process the cookie-av as follows.\n        // 1. Let cookie-domain be the attribute-value.\n        let cookieDomain = attributeValue;\n        // 2. If cookie-domain starts with %x2E (\".\"), let cookie-domain be\n        //    cookie-domain without its leading %x2E (\".\").\n        if (cookieDomain[0] === \".\") {\n            cookieDomain = cookieDomain.slice(1);\n        }\n        // 3. Convert the cookie-domain to lower case.\n        cookieDomain = cookieDomain.toLowerCase();\n        // 4. Append an attribute to the cookie-attribute-list with an\n        //    attribute-name of Domain and an attribute-value of cookie-domain.\n        cookieAttributeList.domain = cookieDomain;\n    } else if (attributeNameLowercase === \"path\") {\n        // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.4\n        // If the attribute-name case-insensitively matches the string \"Path\",\n        // the user agent MUST process the cookie-av as follows.\n        // 1. If the attribute-value is empty or if the first character of the\n        //    attribute-value is not %x2F (\"/\"):\n        let cookiePath = \"\";\n        if (attributeValue.length === 0 || attributeValue[0] !== \"/\") {\n            // 1. Let cookie-path be the default-path.\n            cookiePath = \"/\";\n        } else {\n            // Otherwise:\n            // 1. Let cookie-path be the attribute-value.\n            cookiePath = attributeValue;\n        }\n        // 2. Append an attribute to the cookie-attribute-list with an\n        //    attribute-name of Path and an attribute-value of cookie-path.\n        cookieAttributeList.path = cookiePath;\n    } else if (attributeNameLowercase === \"secure\") {\n        // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.5\n        // If the attribute-name case-insensitively matches the string \"Secure\",\n        // the user agent MUST append an attribute to the cookie-attribute-list\n        // with an attribute-name of Secure and an empty attribute-value.\n        cookieAttributeList.secure = true;\n    } else if (attributeNameLowercase === \"httponly\") {\n        // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.6\n        // If the attribute-name case-insensitively matches the string\n        // \"HttpOnly\", the user agent MUST append an attribute to the cookie-\n        // attribute-list with an attribute-name of HttpOnly and an empty\n        // attribute-value.\n        cookieAttributeList.httpOnly = true;\n    } else if (attributeNameLowercase === \"samesite\") {\n        // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.7\n        // If the attribute-name case-insensitively matches the string\n        // \"SameSite\", the user agent MUST process the cookie-av as follows:\n        // 1. Let enforcement be \"Default\".\n        let enforcement = \"Default\";\n        const attributeValueLowercase = attributeValue.toLowerCase();\n        // 2. If cookie-av's attribute-value is a case-insensitive match for\n        //    \"None\", set enforcement to \"None\".\n        if (attributeValueLowercase.includes(\"none\")) {\n            enforcement = \"None\";\n        }\n        // 3. If cookie-av's attribute-value is a case-insensitive match for\n        //    \"Strict\", set enforcement to \"Strict\".\n        if (attributeValueLowercase.includes(\"strict\")) {\n            enforcement = \"Strict\";\n        }\n        // 4. If cookie-av's attribute-value is a case-insensitive match for\n        //    \"Lax\", set enforcement to \"Lax\".\n        if (attributeValueLowercase.includes(\"lax\")) {\n            enforcement = \"Lax\";\n        }\n        // 5. Append an attribute to the cookie-attribute-list with an\n        //    attribute-name of \"SameSite\" and an attribute-value of\n        //    enforcement.\n        cookieAttributeList.sameSite = enforcement;\n    } else {\n        cookieAttributeList.unparsed ??= [];\n        cookieAttributeList.unparsed.push(`${attributeName}=${attributeValue}`);\n    }\n    // 8. Return to Step 1 of this algorithm.\n    return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);\n}\nmodule.exports = {\n    parseSetCookie,\n    parseUnparsedAttributes\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvY29va2llcy9wYXJzZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU0sRUFBRUEsb0JBQW9CLEVBQUVDLHFCQUFBQSxFQUF1QixHQUFHQyxtQkFBT0EsQ0FBQztBQUNoRSxNQUFNLEVBQUVDLGtCQUFBQSxFQUFvQixHQUFHRCxtQkFBT0EsQ0FBQztBQUN2QyxNQUFNLEVBQUVFLGdDQUFBQSxFQUFrQyxHQUFHRixtQkFBT0EsQ0FBQztBQUNyRCxNQUFNRyxTQUFTSCxtQkFBT0EsQ0FBQztBQUV2Qjs7Ozs7Q0FLQSxHQUNBLFNBQVNJLGVBQWdCQyxNQUFNO0lBQzdCO0lBQ0E7SUFDQTtJQUNBLElBQUlKLG1CQUFtQkksU0FBUztRQUM5QixPQUFPO0lBQ1Q7SUFFQSxJQUFJQyxnQkFBZ0I7SUFDcEIsSUFBSUMscUJBQXFCO0lBQ3pCLElBQUlDLE9BQU87SUFDWCxJQUFJQyxRQUFRO0lBRVo7SUFDQSxJQUFJSixPQUFPSyxRQUFRLENBQUMsTUFBTTtRQUN4QjtRQUNBO1FBQ0E7UUFDQTtRQUNBLE1BQU1DLFdBQVc7WUFBRUEsVUFBVTtRQUFFO1FBRS9CTCxnQkFBZ0JKLGlDQUFpQyxLQUFLRyxRQUFRTTtRQUM5REoscUJBQXFCRixPQUFPTyxLQUFLLENBQUNELFNBQVNBLFFBQVE7SUFDckQsT0FBTztRQUNMO1FBRUE7UUFDQTtRQUNBO1FBQ0FMLGdCQUFnQkQ7SUFDbEI7SUFFQTtJQUNBO0lBQ0E7SUFDQSxJQUFJLENBQUNDLGNBQWNJLFFBQVEsQ0FBQyxNQUFNO1FBQ2hDRCxRQUFRSDtJQUNWLE9BQU87UUFDTDtRQUNBO1FBQ0E7UUFDQTtRQUNBLE1BQU1LLFdBQVc7WUFBRUEsVUFBVTtRQUFFO1FBQy9CSCxPQUFPTixpQ0FDTCxLQUNBSSxlQUNBSztRQUVGRixRQUFRSCxjQUFjTSxLQUFLLENBQUNELFNBQVNBLFFBQVEsR0FBRztJQUNsRDtJQUVBO0lBQ0E7SUFDQUgsT0FBT0EsS0FBS0ssSUFB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Li9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvY29va2llcy9wYXJzZS5qcz8yZmMyIiwid2VicGFjazovL21vY2t1cGZsb3cvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvY29va2llcy9wYXJzZS5qcz8yZmMyKiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyBtYXhOYW1lVmFsdWVQYWlyU2l6ZSwgbWF4QXR0cmlidXRlVmFsdWVTaXplIH0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpXG5jb25zdCB7IGlzQ1RMRXhjbHVkaW5nSHRhYiB9ID0gcmVxdWlyZSgnLi91dGlsJylcbmNvbnN0IHsgY29sbGVjdEFTZXF1ZW5jZU9mQ29kZVBvaW50c0Zhc3QgfSA9IHJlcXVpcmUoJy4uL2ZldGNoL2RhdGEtdXJsJylcbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ25vZGU6YXNzZXJ0JylcblxuLyoqXG4gKiBAZGVzY3JpcHRpb24gUGFyc2VzIHRoZSBmaWVsZC12YWx1ZSBhdHRyaWJ1dGVzIG9mIGEgc2V0LWNvb2tpZSBoZWFkZXIgc3RyaW5nLlxuICogQHNlZSBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL2RyYWZ0LWlldGYtaHR0cGJpcy1yZmM2MjY1YmlzI3NlY3Rpb24tNS40XG4gKiBAcGFyYW0ge3N0cmluZ30gaGVhZGVyXG4gKiBAcmV0dXJucyBpZiB0aGUgaGVhZGVyIGlzIGludmFsaWQsIG51bGwgd2lsbCBiZSByZXR1cm5lZFxuICovXG5mdW5jdGlvbiBwYXJzZVNldENvb2tpZSAoaGVhZGVyKSB7XG4gIC8vIDEuIElmIHRoZSBzZXQtY29va2llLXN0cmluZyBjb250YWlucyBhICV4MDAtMDggLyAleDBBLTFGIC8gJXg3RlxuICAvLyAgICBjaGFyYWN0ZXIgKENUTCBjaGFyYWN0ZXJzIGV4Y2x1ZGluZyBIVEFCKTogQWJvcnQgdGhlc2Ugc3RlcHMgYW5kXG4gIC8vICAgIGlnbm9yZSB0aGUgc2V0LWNvb2tpZS1zdHJpbmcgZW50aXJlbHkuXG4gIGlmIChpc0NUTEV4Y2x1ZGluZ0h0YWIoaGVhZGVyKSkge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICBsZXQgbmFtZVZhbHVlUGFpciA9ICcnXG4gIGxldCB1bnBhcnNlZEF0dHJpYnV0ZXMgPSAnJ1xuICBsZXQgbmFtZSA9ICcnXG4gIGxldCB2YWx1ZSA9ICcnXG5cbiAgLy8gMi4gSWYgdGhlIHNldC1jb29raWUtc3RyaW5nIGNvbnRhaW5zIGEgJXgzQiAoXCI7XCIpIGNoYXJhY3RlcjpcbiAgaWYgKGhlYWRlci5pbmNsdWRlcygnOycpKSB7XG4gICAgLy8gMS4gVGhlIG5hbWUtdmFsdWUtcGFpciBzdHJpbmcgY29uc2lzdHMgb2YgdGhlIGNoYXJhY3RlcnMgdXAgdG8sXG4gICAgLy8gICAgYnV0IG5vdCBpbmNsdWRpbmcsIHRoZSBmaXJzdCAleDNCIChcIjtcIiksIGFuZCB0aGUgdW5wYXJzZWQtXG4gICAgLy8gICAgYXR0cmlidXRlcyBjb25zaXN0IG9mIHRoZSByZW1haW5kZXIgb2YgdGhlIHNldC1jb29raWUtc3RyaW5nXG4gICAgLy8gICAgKGluY2x1ZGluZyB0aGUgJXgzQiAoXCI7XCIpIGluIHF1ZXN0aW9uKS5cbiAgICBjb25zdCBwb3NpdGlvbiA9IHsgcG9zaXRpb246IDAgfVxuXG4gICAgbmFtZVZhbHVlUGFpciA9IGNvbGxlY3RBU2VxdWVuY2VPZkNvZGVQb2ludHNGYXN0KCc7JywgaGVhZGVyLCBwb3NpdGlvbilcbiAgICB1bnBhcnNlZEF0dHJpYnV0ZXMgPSBoZWFkZXIuc2xpY2UocG9zaXRpb24ucG9zaXRpb24pXG4gIH0gZWxzZSB7XG4gICAgLy8gT3RoZXJ3aXNlOlxuXG4gICAgLy8gMS4gVGhlIG5hbWUtdmFsdWUtcGFpciBzdHJpbmcgY29uc2lzdHMgb2YgYWxsIHRoZSBjaGFyYWN0ZXJzXG4gICAgLy8gICAgY29udGFpbmVkIGluIHRoZSBzZXQtY29va2llLXN0cmluZywgYW5kIHRoZSB1bnBhcnNlZC1cbiAgICAvLyAgICBhdHRyaWJ1dGVzIGlzIHRoZSBlbXB0eSBzdHJpbmcuXG4gICAgbmFtZVZhbHVlUGFpciA9IGhlYWRlclxuICB9XG5cbiAgLy8gMy4gSWYgdGhlIG5hbWUtdmFsdWUtcGFpciBzdHJpbmcgbGFja3MgYSAleDNEIChcIj1cIikgY2hhcmFjdGVyLCB0aGVuXG4gIC8vICAgIHRoZSBuYW1lIHN0cmluZyBpcyBlbXB0eSwgYW5kIHRoZSB2YWx1ZSBzdHJpbmcgaXMgdGhlIHZhbHVlIG9mXG4gIC8vICAgIG5hbWUtdmFsdWUtcGFpci5cbiAgaWYgKCFuYW1lVmFsdWVQYWlyLmluY2x1ZGVzKCc9JykpIHtcbiAgICB2YWx1ZSA9IG5hbWVWYWx1ZVBhaXJcbiAgfSBlbHNlIHtcbiAgICAvLyAgICBPdGhlcndpc2UsIHRoZSBuYW1lIHN0cmluZyBjb25zaXN0cyBvZiB0aGUgY2hhcmFjdGVycyB1cCB0bywgYnV0XG4gICAgLy8gICAgbm90IGluY2x1ZGluZywgdGhlIGZpcnN0ICV4M0QgKFwiPVwiKSBjaGFyYWN0ZXIsIGFuZCB0aGUgKHBvc3NpYmx5XG4gICAgLy8gICAgZW1wdHkpIHZhbHVlIHN0cmluZyBjb25zaXN0cyBvZiB0aGUgY2hhcmFjdGVycyBhZnRlciB0aGUgZmlyc3RcbiAgICAvLyAgICAleDNEIChcIj1cIikgY2hhcmFjdGVyLlxuICAgIGNvbnN0IHBvc2l0aW9uID0geyBwb3NpdGlvbjogMCB9XG4gICAgbmFtZSA9IGNvbGxlY3RBU2VxdWVuY2VPZkNvZGVQb2ludHNGYXN0KFxuICAgICAgJz0nLFxuICAgICAgbmFtZVZhbHVlUGFpcixcbiAgICAgIHBvc2l0aW9uXG4gICAgKVxuICAgIHZhbHVlID0gbmFtZVZhbHVlUGFpci5zbGljZShwb3NpdGlvbi5wb3NpdGlvbiArIDEpXG4gIH1cblxuICAvLyA0LiBSZW1vdmUgYW55IGxlYWRpbmcgb3IgdHJhaWxpbmcgV1NQIGNoYXJhY3RlcnMgZnJvbSB0aGUgbmFtZVxuICAvLyAgICBzdHJpbmcgYW5kIHRoZSB2YWx1ZSBzdHJpbmcuXG4gIG5hbWUgPSBuYW1lLnRyaW0oKVxuICB2YWx1ZSA9IHZhbHVlLnRyaW0oKVxuXG4gIC8vIDUuIElmIHRoZSBzdW0gb2YgdGhlIGxlbmd0aHMgb2YgdGhlIG5hbWUgc3RyaW5nIGFuZCB0aGUgdmFsdWUgc3RyaW5nXG4gIC8vICAgIGlzIG1vcmUgdGhhbiA0MDk2IG9jdGV0cywgYWJvcnQgdGhlc2Ugc3RlcHMgYW5kIGlnbm9yZSB0aGUgc2V0LVxuICAvLyAgICBjb29raWUtc3RyaW5nIGVudGlyZWx5LlxuICBpZiAobmFtZS5sZW5ndGggKyB2YWx1ZS5sZW5ndGggPiBtYXhOYW1lVmFsdWVQYWlyU2l6ZSkge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICAvLyA2LiBUaGUgY29va2llLW5hbWUgaXMgdGhlIG5hbWUgc3RyaW5nLCBhbmQgdGhlIGNvb2tpZS12YWx1ZSBpcyB0aGVcbiAgLy8gICAgdmFsdWUgc3RyaW5nLlxuICByZXR1cm4ge1xuICAgIG5hbWUsIHZhbHVlLCAuLi5wYXJzZVVucGFyc2VkQXR0cmlidXRlcyh1bnBhcnNlZEF0dHJpYnV0ZXMpXG4gIH1cbn1cblxuLyoqXG4gKiBQYXJzZXMgdGhlIHJlbWFpbmluZyBhdHRyaWJ1dGVzIG9mIGEgc2V0LWNvb2tpZSBoZWFkZXJcbiAqIEBzZWUgaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9kcmFmdC1pZXRmLWh0dHBiaXMtcmZjNjI2NWJpcyNzZWN0aW9uLTUuNFxuICogQHBhcmFtIHtzdHJpbmd9IHVucGFyc2VkQXR0cmlidXRlc1xuICogQHBhcmFtIHtbT2JqZWN0LjxzdHJpbmcsIHVua25vd24+XT17fX0gY29va2llQXR0cmlidXRlTGlzdFxuICovXG5mdW5jdGlvbiBwYXJzZVVucGFyc2VkQXR0cmlidXRlcyAodW5wYXJzZWRBdHRyaWJ1dGVzLCBjb29raWVBdHRyaWJ1dGVMaXN0ID0ge30pIHtcbiAgLy8gMS4gSWYgdGhlIHVucGFyc2VkLWF0dHJpYnV0ZXMgc3RyaW5nIGlzIGVtcHR5LCBza2lwIHRoZSByZXN0IG9mXG4gIC8vICAgIHRoZXNlIHN0ZXBzLlxuICBpZiAodW5wYXJzZWRBdHRyaWJ1dGVzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBjb29raWVBdHRyaWJ1dGVMaXN0XG4gIH1cblxuICAvLyAyLiBEaXNjYXJkIHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgdGhlIHVucGFyc2VkLWF0dHJpYnV0ZXMgKHdoaWNoXG4gIC8vICAgIHdpbGwgYmUgYSAleDNCIChcIjtcIikgY2hhcmFjdGVyKS5cbiAgYXNzZXJ0KHVucGFyc2VkQXR0cmlidXRlc1swXSA9PT0gJzsnKVxuICB1bnBhcnNlZEF0dHJpYnV0ZXMgPSB1bnBhcnNlZEF0dHJpYnV0ZXMuc2xpY2UoMSlcblxuICBsZXQgY29va2llQXYgPSAnJ1xuXG4gIC8vIDMuIElmIHRoZSByZW1haW5pbmcgdW5wYXJzZWQtYXR0cmlidXRlcyBjb250YWlucyBhICV4M0IgKFwiO1wiKVxuICAvLyAgICBjaGFyYWN0ZXI6XG4gIGlmICh1bnBhcnNlZEF0dHJpYnV0ZXMuaW5jbHVkZXMoJzsnKSkge1xuICAgIC8vIDEuIENvbnN1bWUgdGhlIGNoYXJhY3RlcnMgb2YgdGhlIHVucGFyc2VkLWF0dHJpYnV0ZXMgdXAgdG8sIGJ1dFxuICAgIC8vICAgIG5vdCBpbmNsdWRpbmcsIHRoZSBmaXJzdCAleDNCIChcIjtcIikgY2hhcmFjdGVyLlxuICAgIGNvb2tpZUF2ID0gY29sbGVjdEFTZXF1ZW5jZU9mQ29kZVBvaW50c0Zhc3QoXG4gICAgICAnOycsXG4gICAgICB1bnBhcnNlZEF0dHJpYnV0ZXMsXG4gICAgICB7IHBvc2l0aW9uOiAwIH1cbiAgICApXG4gICAgdW5wYXJzZWRBdHRyaWJ1dGVzID0gdW5wYXJzZWRBdHRyaWJ1dGVzLnNsaWNlKGNvb2tpZUF2Lmxlbmd0aClcbiAgfSBlbHNlIHtcbiAgICAvLyBPdGhlcndpc2U6XG5cbiAgICAvLyAxLiBDb25zdW1lIHRoZSByZW1haW5kZXIgb2YgdGhlIHVucGFyc2VkLWF0dHJpYnV0ZXMuXG4gICAgY29va2llQXYgPSB1bnBhcnNlZEF0dHJpYnV0ZXNcbiAgICB1bnBhcnNlZEF0dHJpYnV0ZXMgPSAnJ1xuICB9XG5cbiAgLy8gTGV0IHRoZSBjb29raWUtYXYgc3RyaW5nIGJlIHRoZSBjaGFyYWN0ZXJzIGNvbnN1bWVkIGluIHRoaXMgc3RlcC5cblxuICBsZXQgYXR0cmlidXRlTmFtZSA9ICcnXG4gIGxldCBhdHRyaWJ1dGVWYWx1ZSA9ICcnXG5cbiAgLy8gNC4gSWYgdGhlIGNvb2tpZS1hdiBzdHJpbmcgY29udGFpbnMgYSAleDNEIChcIj1cIikgY2hhcmFjdGVyOlxuICBpZiAoY29va2llQXYuaW5jbHVkZXMoJz0nKSkge1xuICAgIC8vIDEuIFRoZSAocG9zc2libHkgZW1wdHkpIGF0dHJpYnV0ZS1uYW1lIHN0cmluZyBjb25zaXN0cyBvZiB0aGVcbiAgICAvLyAgICBjaGFyYWN0ZXJzIHVwIHRvLCBidXQgbm90IGluY2x1ZGluZywgdGhlIGZpcnN0ICV4M0QgKFwiPVwiKVxuICAgIC8vICAgIGNoYXJhY3RlciwgYW5kIHRoZSAocG9zc2libHkgZW1wdHkpIGF0dHJpYnV0ZS12YWx1ZSBzdHJpbmdcbiAgICAvLyAgICBjb25zaXN0cyBvZiB0aGUgY2hhcmFjdGVycyBhZnRlciB0aGUgZmlyc3QgJXgzRCAoXCI9XCIpXG4gICAgLy8gICAgY2hhcmFjdGVyLlxuICAgIGNvbnN0IHBvc2l0aW9uID0geyBwb3NpdGlvbjogMCB9XG5cbiAgICBhdHRyaWJ1dGVOYW1lID0gY29sbGVjdEFTZXF1ZW5jZU9mQ29kZVBvaW50c0Zhc3QoXG4gICAgICAnPScsXG4gICAgICBjb29raWVBdixcbiAgICAgIHBvc2l0aW9uXG4gICAgKVxuICAgIGF0dHJpYnV0ZVZhbHVlID0gY29va2llQXYuc2xpY2UocG9zaXRpb24ucG9zaXRpb24gKyAxKVxuICB9IGVsc2Uge1xuICAgIC8vIE90aGVyd2lzZTpcblxuICAgIC8vIDEuIFRoZSBhdHRyaWJ1dGUtbmFtZSBzdHJpbmcgY29uc2lzdHMgb2YgdGhlIGVudGlyZSBjb29raWUtYXZcbiAgICAvLyAgICBzdHJpbmcsIGFuZCB0aGUgYXR0cmlidXRlLXZhbHVlIHN0cmluZyBpcyBlbXB0eS5cbiAgICBhdHRyaWJ1dGVOYW1lID0gY29va2llQXZcbiAgfVxuXG4gIC8vIDUuIFJlbW92ZSBhbnkgbGVhZGluZyBvciB0cmFpbGluZyBXU1AgY2hhcmFjdGVycyBmcm9tIHRoZSBhdHRyaWJ1dGUtXG4gIC8vICAgIG5hbWUgc3RyaW5nIGFuZCB0aGUgYXR0cmlidXRlLXZhbHVlIHN0cmluZy5cbiAgYXR0cmlidXRlTmFtZSA9IGF0dHJpYnV0ZU5hbWUudHJpbSgpXG4gIGF0dHJpYnV0ZVZhbHVlID0gYXR0cmlidXRlVmFsdWUudHJpbSgpXG5cbiAgLy8gNi4gSWYgdGhlIGF0dHJpYnV0ZS12YWx1ZSBpcyBsb25nZXIgdGhhbiAxMDI0IG9jdGV0cywgaWdub3JlIHRoZVxuICAvLyAgICBjb29raWUtYXYgc3RyaW5nIGFuZCByZXR1cm4gdG8gU3RlcCAxIG9mIHRoaXMgYWxnb3JpdGhtLlxuICBpZiAoYXR0cmlidXRlVmFsdWUubGVuZ3RoID4gbWF4QXR0cmlidXRlVmFsdWVTaXplKSB7XG4gICAgcmV0dXJuIHBhcnNlVW5wYXJzZWRBdHRyaWJ1dGVzKHVucGFyc2VkQXR0cmlidXRlcywgY29va2llQXR0cmlidXRlTGlzdClcbiAgfVxuXG4gIC8vIDcuIFByb2Nlc3MgdGhlIGF0dHJpYnV0ZS1uYW1lIGFuZCBhdHRyaWJ1dGUtdmFsdWUgYWNjb3JkaW5nIHRvIHRoZVxuICAvLyAgICByZXF1aXJlbWVudHMgaW4gdGhlIGZvbGxvd2luZyBzdWJzZWN0aW9ucy4gIChOb3RpY2UgdGhhdFxuICAvLyAgICBhdHRyaWJ1dGVzIHdpdGggdW5yZWNvZ25pemVkIGF0dHJpYnV0ZS1uYW1lcyBhcmUgaWdub3JlZC4pXG4gIGNvbnN0IGF0dHJpYnV0ZU5hbWVMb3dlcmNhc2UgPSBhdHRyaWJ1dGVOYW1lLnRvTG93ZXJDYXNlKClcblxuICAvLyBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL2RyYWZ0LWlldGYtaHR0cGJpcy1yZmM2MjY1YmlzI3NlY3Rpb24tNS40LjFcbiAgLy8gSWYgdGhlIGF0dHJpYnV0ZS1uYW1lIGNhc2UtaW5zZW5zaXRpdmVseSBtYXRjaGVzIHRoZSBzdHJpbmdcbiAgLy8gXCJFeHBpcmVzXCIsIHRoZSB1c2VyIGFnZW50IE1VU1QgcHJvY2VzcyB0aGUgY29va2llLWF2IGFzIGZvbGxvd3MuXG4gIGlmIChhdHRyaWJ1dGVOYW1lTG93ZXJjYXNlID09PSAnZXhwaXJlcycpIHtcbiAgICAvLyAxLiBMZXQgdGhlIGV4cGlyeS10aW1lIGJlIHRoZSByZXN1bHQgb2YgcGFyc2luZyB0aGUgYXR0cmlidXRlLXZhbHVlXG4gICAgLy8gICAgYXMgY29va2llLWRhdGUgKHNlZSBTZWN0aW9uIDUuMS4xKS5cbiAgICBjb25zdCBleHBpcnlUaW1lID0gbmV3IERhdGUoYXR0cmlidXRlVmFsdWUpXG5cbiAgICAvLyAyLiBJZiB0aGUgYXR0cmlidXRlLXZhbHVlIGZhaWxlZCB0byBwYXJzZSBhcyBhIGNvb2tpZSBkYXRlLCBpZ25vcmVcbiAgICAvLyAgICB0aGUgY29va2llLWF2LlxuXG4gICAgY29va2llQXR0cmlidXRlTGlzdC5leHBpcmVzID0gZXhwaXJ5VGltZVxuICB9IGVsc2UgaWYgKGF0dHJpYnV0ZU5hbWVMb3dlcmNhc2UgPT09ICdtYXgtYWdlJykge1xuICAgIC8vIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvZHJhZnQtaWV0Zi1odHRwYmlzLXJmYzYyNjViaXMjc2VjdGlvbi01LjQuMlxuICAgIC8vIElmIHRoZSBhdHRyaWJ1dGUtbmFtZSBjYXNlLWluc2Vuc2l0aXZlbHkgbWF0Y2hlcyB0aGUgc3RyaW5nIFwiTWF4LVxuICAgIC8vIEFnZVwiLCB0aGUgdXNlciBhZ2VudCBNVVNUIHByb2Nlc3MgdGhlIGNvb2tpZS1hdiBhcyBmb2xsb3dzLlxuXG4gICAgLy8gMS4gSWYgdGhlIGZpcnN0IGNoYXJhY3RlciBvZiB0aGUgYXR0cmlidXRlLXZhbHVlIGlzIG5vdCBhIERJR0lUIG9yIGFcbiAgICAvLyAgICBcIi1cIiBjaGFyYWN0ZXIsIGlnbm9yZSB0aGUgY29va2llLWF2LlxuICAgIGNvbnN0IGNoYXJDb2RlID0gYXR0cmlidXRlVmFsdWUuY2hhckNvZGVBdCgwKVxuXG4gICAgaWYgKChjaGFyQ29kZSA8IDQ4IHx8IGNoYXJDb2RlID4gNTcpICYmIGF0dHJpYnV0ZVZhbHVlWzBdICE9PSAnLScpIHtcbiAgICAgIHJldHVybiBwYXJzZVVucGFyc2VkQXR0cmlidXRlcyh1bnBhcnNlZEF0dHJpYnV0ZXMsIGNvb2tpZUF0dHJpYnV0ZUxpc3QpXG4gICAgfVxuXG4gICAgLy8gMi4gSWYgdGhlIHJlbWFpbmRlciBvZiBhdHRyaWJ1dGUtdmFsdWUgY29udGFpbnMgYSBub24tRElHSVRcbiAgICAvLyAgICBjaGFyYWN0ZXIsIGlnbm9yZSB0aGUgY29va2llLWF2LlxuICAgIGlmICghL15cXGQrJC8udGVzdChhdHRyaWJ1dGVWYWx1ZSkpIHtcbiAgICAgIHJldHVybiBwYXJzZVVucGFyc2VkQXR0cmlidXRlcyh1bnBhcnNlZEF0dHJpYnV0ZXMsIGNvb2tpZUF0dHJpYnV0ZUxpc3QpXG4gICAgfVxuXG4gICAgLy8gMy4gTGV0IGRlbHRhLXNlY29uZHMgYmUgdGhlIGF0dHJpYnV0ZS12YWx1ZSBjb252ZXJ0ZWQgdG8gYW4gaW50ZWdlci5cbiAgICBjb25zdCBkZWx0YVNlY29uZHMgPSBOdW1iZXIoYXR0cmlidXRlVmFsdWUpXG5cbiAgICAvLyA0LiBMZXQgY29va2llLWFnZS1saW1pdCBiZSB0aGUgbWF4aW11bSBhZ2Ugb2YgdGhlIGNvb2tpZSAod2hpY2hcbiAgICAvLyAgICBTSE9VTEQgYmUgNDAwIGRheXMgb3IgbGVzcywgc2VlIFNlY3Rpb24gNC4xLjIuMikuXG5cbiAgICAvLyA1LiBTZXQgZGVsdGEtc2Vjb25kcyB0byB0aGUgc21hbGxlciBvZiBpdHMgcHJlc2VudCB2YWx1ZSBhbmQgY29va2llLVxuICAgIC8vICAgIGFnZS1saW1pdC5cbiAgICAvLyBkZWx0YVNlY29uZHMgPSBNYXRoLm1pbihkZWx0YVNlY29uZHMgKiAxMDAwLCBtYXhFeHBpcmVzTXMpXG5cbiAgICAvLyA2LiBJZiBkZWx0YS1zZWNvbmRzIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byB6ZXJvICgwKSwgbGV0IGV4cGlyeS1cbiAgICAvLyAgICB0aW1lIGJlIHRoZSBlYXJsaWVzdCByZXByZXNlbnRhYmxlIGRhdGUgYW5kIHRpbWUuICBPdGhlcndpc2UsIGxldFxuICAgIC8vICAgIHRoZSBleHBpcnktdGltZSBiZSB0aGUgY3VycmVudCBkYXRlIGFuZCB0aW1lIHBsdXMgZGVsdGEtc2Vjb25kc1xuICAgIC8vICAgIHNlY29uZHMuXG4gICAgLy8gY29uc3QgZXhwaXJ5VGltZSA9IGRlbHRhU2Vjb25kcyA8PSAwID8gRGF0ZS5ub3coKSA6IERhdGUubm93KCkgKyBkZWx0YVNlY29uZHNcblxuICAgIC8vIDcuIEFwcGVuZCBhbiBhdHRyaWJ1dGUgdG8gdGhlIGNvb2tpZS1hdHRyaWJ1dGUtbGlzdCB3aXRoIGFuXG4gICAgLy8gICAgYXR0cmlidXRlLW5hbWUgb2YgTWF4LUFnZSBhbmQgYW4gYXR0cmlidXRlLXZhbHVlIG9mIGV4cGlyeS10aW1lLlxuICAgIGNvb2tpZUF0dHJpYnV0ZUxpc3QubWF4QWdlID0gZGVsdGFTZWNvbmRzXG4gIH0gZWxzZSBpZiAoYXR0cmlidXRlTmFtZUxvd2VyY2FzZSA9PT0gJ2RvbWFpbicpIHtcbiAgICAvLyBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL2RyYWZ0LWlldGYtaHR0cGJpcy1yZmM2MjY1YmlzI3NlY3Rpb24tNS40LjNcbiAgICAvLyBJZiB0aGUgYXR0cmlidXRlLW5hbWUgY2FzZS1pbnNlbnNpdGl2ZWx5IG1hdGNoZXMgdGhlIHN0cmluZyBcIkRvbWFpblwiLFxuICAgIC8vIHRoZSB1c2VyIGFnZW50IE1VU1QgcHJvY2VzcyB0aGUgY29va2llLWF2IGFzIGZvbGxvd3MuXG5cbiAgICAvLyAxLiBMZXQgY29va2llLWRvbWFpbiBiZSB0aGUgYXR0cmlidXRlLXZhbHVlLlxuICAgIGxldCBjb29raWVEb21haW4gPSBhdHRyaWJ1dGVWYWx1ZVxuXG4gICAgLy8gMi4gSWYgY29va2llLWRvbWFpbiBzdGFydHMgd2l0aCAleDJFIChcIi5cIiksIGxldCBjb29raWUtZG9tYWluIGJlXG4gICAgLy8gICAgY29va2llLWRvbWFpbiB3aXRob3V0IGl0cyBsZWFkaW5nICV4MkUgKFwiLlwiKS5cbiAgICBpZiAoY29va2llRG9tYWluWzBdID09PSAnLicpIHtcbiAgICAgIGNvb2tpZURvbWFpbiA9IGNvb2tpZURvbWFpbi5zbGljZSgxKVxuICAgIH1cblxuICAgIC8vIDMuIENvbnZlcnQgdGhlIGNvb2tpZS1kb21haW4gdG8gbG93ZXIgY2FzZS5cbiAgICBjb29raWVEb21haW4gPSBjb29raWVEb21haW4udG9Mb3dlckNhc2UoKVxuXG4gICAgLy8gNC4gQXBwZW5kIGFuIGF0dHJpYnV0ZSB0byB0aGUgY29va2llLWF0dHJpYnV0ZS1saXN0IHdpdGggYW5cbiAgICAvLyAgICBhdHRyaWJ1dGUtbmFtZSBvZiBEb21haW4gYW5kIGFuIGF0dHJpYnV0ZS12YWx1ZSBvZiBjb29raWUtZG9tYWluLlxuICAgIGNvb2tpZUF0dHJpYnV0ZUxpc3QuZG9tYWluID0gY29va2llRG9tYWluXG4gIH0gZWxzZSBpZiAoYXR0cmlidXRlTmFtZUxvd2VyY2FzZSA9PT0gJ3BhdGgnKSB7XG4gICAgLy8gaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9kcmFmdC1pZXRmLWh0dHBiaXMtcmZjNjI2NWJpcyNzZWN0aW9uLTUuNC40XG4gICAgLy8gSWYgdGhlIGF0dHJpYnV0ZS1uYW1lIGNhc2UtaW5zZW5zaXRpdmVseSBtYXRjaGVzIHRoZSBzdHJpbmcgXCJQYXRoXCIsXG4gICAgLy8gdGhlIHVzZXIgYWdlbnQgTVVTVCBwcm9jZXNzIHRoZSBjb29raWUtYXYgYXMgZm9sbG93cy5cblxuICAgIC8vIDEuIElmIHRoZSBhdHRyaWJ1dGUtdmFsdWUgaXMgZW1wdHkgb3IgaWYgdGhlIGZpcnN0IGNoYXJhY3RlciBvZiB0aGVcbiAgICAvLyAgICBhdHRyaWJ1dGUtdmFsdWUgaXMgbm90ICV4MkYgKFwiL1wiKTpcbiAgICBsZXQgY29va2llUGF0aCA9ICcnXG4gICAgaWYgKGF0dHJpYnV0ZVZhbHVlLmxlbmd0aCA9PT0gMCB8fCBhdHRyaWJ1dGVWYWx1ZVswXSAhPT0gJy8nKSB7XG4gICAgICAvLyAxLiBMZXQgY29va2llLXBhdGggYmUgdGhlIGRlZmF1bHQtcGF0aC5cbiAgICAgIGNvb2tpZVBhdGggPSAnLydcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gT3RoZXJ3aXNlOlxuXG4gICAgICAvLyAxLiBMZXQgY29va2llLXBhdGggYmUgdGhlIGF0dHJpYnV0ZS12YWx1ZS5cbiAgICAgIGNvb2tpZVBhdGggPSBhdHRyaWJ1dGVWYWx1ZVxuICAgIH1cblxuICAgIC8vIDIuIEFwcGVuZCBhbiBhdHRyaWJ1dGUgdG8gdGhlIGNvb2tpZS1hdHRyaWJ1dGUtbGlzdCB3aXRoIGFuXG4gICAgLy8gICAgYXR0cmlidXRlLW5hbWUgb2YgUGF0aCBhbmQgYW4gYXR0cmlidXRlLXZhbHVlIG9mIGNvb2tpZS1wYXRoLlxuICAgIGNvb2tpZUF0dHJpYnV0ZUxpc3QucGF0aCA9IGNvb2tpZVBhdGhcbiAgfSBlbHNlIGlmIChhdHRyaWJ1dGVOYW1lTG93ZXJjYXNlID09PSAnc2VjdXJlJykge1xuICAgIC8vIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvZHJhZnQtaWV0Zi1odHRwYmlzLXJmYzYyNjViaXMjc2VjdGlvbi01LjQuNVxuICAgIC8vIElmIHRoZSBhdHRyaWJ1dGUtbmFtZSBjYXNlLWluc2Vuc2l0aXZlbHkgbWF0Y2hlcyB0aGUgc3RyaW5nIFwiU2VjdXJlXCIsXG4gICAgLy8gdGhlIHVzZXIgYWdlbnQgTVVTVCBhcHBlbmQgYW4gYXR0cmlidXRlIHRvIHRoZSBjb29raWUtYXR0cmlidXRlLWxpc3RcbiAgICAvLyB3aXRoIGFuIGF0dHJpYnV0ZS1uYW1lIG9mIFNlY3VyZSBhbmQgYW4gZW1wdHkgYXR0cmlidXRlLXZhbHVlLlxuXG4gICAgY29va2llQXR0cmlidXRlTGlzdC5zZWN1cmUgPSB0cnVlXG4gIH0gZWxzZSBpZiAoYXR0cmlidXRlTmFtZUxvd2VyY2FzZSA9PT0gJ2h0dHBvbmx5Jykge1xuICAgIC8vIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvZHJhZnQtaWV0Zi1odHRwYmlzLXJmYzYyNjViaXMjc2VjdGlvbi01LjQuNlxuICAgIC8vIElmIHRoZSBhdHRyaWJ1dGUtbmFtZSBjYXNlLWluc2Vuc2l0aXZlbHkgbWF0Y2hlcyB0aGUgc3RyaW5nXG4gICAgLy8gXCJIdHRwT25seVwiLCB0aGUgdXNlciBhZ2VudCBNVVNUIGFwcGVuZCBhbiBhdHRyaWJ1dGUgdG8gdGhlIGNvb2tpZS1cbiAgICAvLyBhdHRyaWJ1dGUtbGlzdCB3aXRoIGFuIGF0dHJpYnV0ZS1uYW1lIG9mIEh0dHBPbmx5IGFuZCBhbiBlbXB0eVxuICAgIC8vIGF0dHJpYnV0ZS12YWx1ZS5cblxuICAgIGNvb2tpZUF0dHJpYnV0ZUxpc3QuaHR0cE9ubHkgPSB0cnVlXG4gIH0gZWxzZSBpZiAoYXR0cmlidXRlTmFtZUxvd2VyY2FzZSA9PT0gJ3NhbWVzaXRlJykge1xuICAgIC8vIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvZHJhZnQtaWV0Zi1odHRwYmlzLXJmYzYyNjViaXMjc2VjdGlvbi01LjQuN1xuICAgIC8vIElmIHRoZSBhdHRyaWJ1dGUtbmFtZSBjYXNlLWluc2Vuc2l0aXZlbHkgbWF0Y2hlcyB0aGUgc3RyaW5nXG4gICAgLy8gXCJTYW1lU2l0ZVwiLCB0aGUgdXNlciBhZ2VudCBNVVNUIHByb2Nlc3MgdGhlIGNvb2tpZS1hdiBhcyBmb2xsb3dzOlxuXG4gICAgLy8gMS4gTGV0IGVuZm9yY2VtZW50IGJlIFwiRGVmYXVsdFwiLlxuICAgIGxldCBlbmZvcmNlbWVudCA9ICdEZWZhdWx0J1xuXG4gICAgY29uc3QgYXR0cmlidXRlVmFsdWVMb3dlcmNhc2UgPSBhdHRyaWJ1dGVWYWx1ZS50b0xvd2VyQ2FzZSgpXG4gICAgLy8gMi4gSWYgY29va2llLWF2J3MgYXR0cmlidXRlLXZhbHVlIGlzIGEgY2FzZS1pbnNlbnNpdGl2ZSBtYXRjaCBmb3JcbiAgICAvLyAgICBcIk5vbmVcIiwgc2V0IGVuZm9yY2VtZW50IHRvIFwiTm9uZVwiLlxuICAgIGlmIChhdHRyaWJ1dGVWYWx1ZUxvd2VyY2FzZS5pbmNsdWRlcygnbm9uZScpKSB7XG4gICAgICBlbmZvcmNlbWVudCA9ICdOb25lJ1xuICAgIH1cblxuICAgIC8vIDMuIElmIGNvb2tpZS1hdidzIGF0dHJpYnV0ZS12YWx1ZSBpcyBhIGNhc2UtaW5zZW5zaXRpdmUgbWF0Y2ggZm9yXG4gICAgLy8gICAgXCJTdHJpY3RcIiwgc2V0IGVuZm9yY2VtZW50IHRvIFwiU3RyaWN0XCIuXG4gICAgaWYgKGF0dHJpYnV0ZVZhbHVlTG93ZXJjYXNlLmluY2x1ZGVzKCdzdHJpY3QnKSkge1xuICAgICAgZW5mb3JjZW1lbnQgPSAnU3RyaWN0J1xuICAgIH1cblxuICAgIC8vIDQuIElmIGNvb2tpZS1hdidzIGF0dHJpYnV0ZS12YWx1ZSBpcyBhIGNhc2UtaW5zZW5zaXRpdmUgbWF0Y2ggZm9yXG4gICAgLy8gICAgXCJMYXhcIiwgc2V0IGVuZm9yY2VtZW50IHRvIFwiTGF4XCIuXG4gICAgaWYgKGF0dHJpYnV0ZVZhbHVlTG93ZXJjYXNlLmluY2x1ZGVzKCdsYXgnKSkge1xuICAgICAgZW5mb3JjZW1lbnQgPSAnTGF4J1xuICAgIH1cblxuICAgIC8vIDUuIEFwcGVuZCBhbiBhdHRyaWJ1dGUgdG8gdGhlIGNvb2tpZS1hdHRyaWJ1dGUtbGlzdCB3aXRoIGFuXG4gICAgLy8gICAgYXR0cmlidXRlLW5hbWUgb2YgXCJTYW1lU2l0ZVwiIGFuZCBhbiBhdHRyaWJ1dGUtdmFsdWUgb2ZcbiAgICAvLyAgICBlbmZvcmNlbWVudC5cbiAgICBjb29raWVBdHRyaWJ1dGVMaXN0LnNhbWVTaXRlID0gZW5mb3JjZW1lbnRcbiAgfSBlbHNlIHtcbiAgICBjb29raWVBdHRyaWJ1dGVMaXN0LnVucGFyc2VkID8/PSBbXVxuXG4gICAgY29va2llQXR0cmlidXRlTGlzdC51bnBhcnNlZC5wdXNoKGAke2F0dHJpYnV0ZU5hbWV9PSR7YXR0cmlidXRlVmFsdWV9YClcbiAgfVxuXG4gIC8vIDguIFJldHVybiB0byBTdGVwIDEgb2YgdGhpcyBhbGdvcml0aG0uXG4gIHJldHVybiBwYXJzZVVucGFyc2VkQXR0cmlidXRlcyh1bnBhcnNlZEF0dHJpYnV0ZXMsIGNvb2tpZUF0dHJpYnV0ZUxpc3QpXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBwYXJzZVNldENvb2tpZSxcbiAgcGFyc2VVbnBhcnNlZEF0dHJpYnV0ZXNcbn1cbiJdLCJuYW1lcyI6WyJtYXhOYW1lVmFsdWVQYWlyU2l6ZSIsIm1heEF0dHJpYnV0ZVZhbHVlU2l6ZSIsInJlcXVpcmUiLCJpc0NUTEV4Y2x1ZGluZ0h0YWIiLCJjb2xsZWN0QVNlcXVlbmNlT2ZDb2RlUG9pbnRzRmFzdCIsImFzc2VydCIsInBhcnNlU2V0Q29va2llIiwiaGVhZGVyIiwibmFtZVZhbHVlUGFpciIsInVucGFyc2VkQXR0cmlidXRlcyIsIm5hbWUiLCJ2YWx1ZSIsImluY2x1ZGVzIiwicG9zaXRpb24iLCJzbGljZSIsInRyaW0iLCJsZW5ndGgiLCJwYXJzZVVucGFyc2VkQXR0cmlidXRlcyIsImNvb2tpZUF0dHJpYnV0ZUxpc3QiLCJjb29raWVBdiIsImF0dHJpYnV0ZU5hbWUiLCJhdHRyaWJ1dGVWYWx1ZSIsImF0dHJpYnV0ZU5hbWVMb3dlcmNhc2UiLCJ0b0xvd2VyQ2FzZSIsImV4cGlyeVRpbWUiLCJEYXRlIiwiZXhwaXJlcyIsImNoYXJDb2RlIiwiY2hhckNvZGVBdCIsInRlc3QiLCJkZWx0YVNlY29uZHMiLCJOdW1iZXIiLCJtYXhBZ2UiLCJjb29raWVEb21haW4iLCJkb21haW4iLCJjb29raWVQYXRoIiwicGF0aCIsInNlY3VyZSIsImh0dHBPbmx5IiwiZW5mb3JjZW1lbnQiLCJhdHRyaWJ1dGVWYWx1ZUxvd2VyY2FzZSIsInNhbWVTaXRlIiwidW5wYXJzZWQiLCJwdXNoIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/cookies/parse.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/cookies/util.js":
/*!*****************************************************!*\
  !*** ./node_modules/undici/lib/web/cookies/util.js ***!
  \*****************************************************/
/***/ ((module) => {

eval("\n/**\n * @param {string} value\n * @returns {boolean}\n */ function isCTLExcludingHtab(value) {\n    for(let i = 0; i < value.length; ++i){\n        const code = value.charCodeAt(i);\n        if (code >= 0x00 && code <= 0x08 || code >= 0x0A && code <= 0x1F || code === 0x7F) {\n            return true;\n        }\n    }\n    return false;\n}\n/**\n CHAR           = <any US-ASCII character (octets 0 - 127)>\n token          = 1*<any CHAR except CTLs or separators>\n separators     = \"(\" | \")\" | \"<\" | \">\" | \"@\"\n                | \",\" | \";\" | \":\" | \"\\\" | <\">\n                | \"/\" | \"[\" | \"]\" | \"?\" | \"=\"\n                | \"{\" | \"}\" | SP | HT\n * @param {string} name\n */ function validateCookieName(name) {\n    for(let i = 0; i < name.length; ++i){\n        const code = name.charCodeAt(i);\n        if (code < 0x21 || // exclude CTLs (0-31), SP and HT\n        code > 0x7E || // exclude non-ascii and DEL\n        code === 0x22 || // \"\n        code === 0x28 || // (\n        code === 0x29 || // )\n        code === 0x3C || // <\n        code === 0x3E || // >\n        code === 0x40 || // @\n        code === 0x2C || // ,\n        code === 0x3B || // ;\n        code === 0x3A || // :\n        code === 0x5C || // \\\n        code === 0x2F || // /\n        code === 0x5B || // [\n        code === 0x5D || // ]\n        code === 0x3F || // ?\n        code === 0x3D || // =\n        code === 0x7B || // {\n        code === 0x7D // }\n        ) {\n            throw new Error(\"Invalid cookie name\");\n        }\n    }\n}\n/**\n cookie-value      = *cookie-octet / ( DQUOTE *cookie-octet DQUOTE )\n cookie-octet      = %x21 / %x23-2B / %x2D-3A / %x3C-5B / %x5D-7E\n                       ; US-ASCII characters excluding CTLs,\n                       ; whitespace DQUOTE, comma, semicolon,\n                       ; and backslash\n * @param {string} value\n */ function validateCookieValue(value) {\n    let len = value.length;\n    let i = 0;\n    // if the value is wrapped in DQUOTE\n    if (value[0] === '\"') {\n        if (len === 1 || value[len - 1] !== '\"') {\n            throw new Error(\"Invalid cookie value\");\n        }\n        --len;\n        ++i;\n    }\n    while(i < len){\n        const code = value.charCodeAt(i++);\n        if (code < 0x21 || // exclude CTLs (0-31)\n        code > 0x7E || // non-ascii and DEL (127)\n        code === 0x22 || // \"\n        code === 0x2C || // ,\n        code === 0x3B || // ;\n        code === 0x5C // \\\n        ) {\n            throw new Error(\"Invalid cookie value\");\n        }\n    }\n}\n/**\n * path-value        = <any CHAR except CTLs or \";\">\n * @param {string} path\n */ function validateCookiePath(path) {\n    for(let i = 0; i < path.length; ++i){\n        const code = path.charCodeAt(i);\n        if (code < 0x20 || // exclude CTLs (0-31)\n        code === 0x7F || // DEL\n        code === 0x3B // ;\n        ) {\n            throw new Error(\"Invalid cookie path\");\n        }\n    }\n}\n/**\n * I have no idea why these values aren't allowed to be honest,\n * but Deno tests these. - Khafra\n * @param {string} domain\n */ function validateCookieDomain(domain) {\n    if (domain.startsWith(\"-\") || domain.endsWith(\".\") || domain.endsWith(\"-\")) {\n        throw new Error(\"Invalid cookie domain\");\n    }\n}\nconst IMFDays = [\n    \"Sun\",\n    \"Mon\",\n    \"Tue\",\n    \"Wed\",\n    \"Thu\",\n    \"Fri\",\n    \"Sat\"\n];\nconst IMFMonths = [\n    \"Jan\",\n    \"Feb\",\n    \"Mar\",\n    \"Apr\",\n    \"May\",\n    \"Jun\",\n    \"Jul\",\n    \"Aug\",\n    \"Sep\",\n    \"Oct\",\n    \"Nov\",\n    \"Dec\"\n];\nconst IMFPaddedNumbers = Array(61).fill(0).map((_, i)=>i.toString().padStart(2, \"0\"));\n/**\n * @see https://www.rfc-editor.org/rfc/rfc7231#section-7.1.1.1\n * @param {number|Date} date\n  IMF-fixdate  = day-name \",\" SP date1 SP time-of-day SP GMT\n  ; fixed length/zone/capitalization subset of the format\n  ; see Section 3.3 of [RFC5322]\n\n  day-name     = %x4D.6F.6E ; \"Mon\", case-sensitive\n              / %x54.75.65 ; \"Tue\", case-sensitive\n              / %x57.65.64 ; \"Wed\", case-sensitive\n              / %x54.68.75 ; \"Thu\", case-sensitive\n              / %x46.72.69 ; \"Fri\", case-sensitive\n              / %x53.61.74 ; \"Sat\", case-sensitive\n              / %x53.75.6E ; \"Sun\", case-sensitive\n  date1        = day SP month SP year\n                  ; e.g., 02 Jun 1982\n\n  day          = 2DIGIT\n  month        = %x4A.61.6E ; \"Jan\", case-sensitive\n              / %x46.65.62 ; \"Feb\", case-sensitive\n              / %x4D.61.72 ; \"Mar\", case-sensitive\n              / %x41.70.72 ; \"Apr\", case-sensitive\n              / %x4D.61.79 ; \"May\", case-sensitive\n              / %x4A.75.6E ; \"Jun\", case-sensitive\n              / %x4A.75.6C ; \"Jul\", case-sensitive\n              / %x41.75.67 ; \"Aug\", case-sensitive\n              / %x53.65.70 ; \"Sep\", case-sensitive\n              / %x4F.63.74 ; \"Oct\", case-sensitive\n              / %x4E.6F.76 ; \"Nov\", case-sensitive\n              / %x44.65.63 ; \"Dec\", case-sensitive\n  year         = 4DIGIT\n\n  GMT          = %x47.4D.54 ; \"GMT\", case-sensitive\n\n  time-of-day  = hour \":\" minute \":\" second\n              ; 00:00:00 - 23:59:60 (leap second)\n\n  hour         = 2DIGIT\n  minute       = 2DIGIT\n  second       = 2DIGIT\n */ function toIMFDate(date) {\n    if (typeof date === \"number\") {\n        date = new Date(date);\n    }\n    return `${IMFDays[date.getUTCDay()]}, ${IMFPaddedNumbers[date.getUTCDate()]} ${IMFMonths[date.getUTCMonth()]} ${date.getUTCFullYear()} ${IMFPaddedNumbers[date.getUTCHours()]}:${IMFPaddedNumbers[date.getUTCMinutes()]}:${IMFPaddedNumbers[date.getUTCSeconds()]} GMT`;\n}\n/**\n max-age-av        = \"Max-Age=\" non-zero-digit *DIGIT\n                       ; In practice, both expires-av and max-age-av\n                       ; are limited to dates representable by the\n                       ; user agent.\n * @param {number} maxAge\n */ function validateCookieMaxAge(maxAge) {\n    if (maxAge < 0) {\n        throw new Error(\"Invalid cookie max-age\");\n    }\n}\n/**\n * @see https://www.rfc-editor.org/rfc/rfc6265#section-4.1.1\n * @param {import('./index').Cookie} cookie\n */ function stringify(cookie) {\n    if (cookie.name.length === 0) {\n        return null;\n    }\n    validateCookieName(cookie.name);\n    validateCookieValue(cookie.value);\n    const out = [\n        `${cookie.name}=${cookie.value}`\n    ];\n    // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-cookie-prefixes-00#section-3.1\n    // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-cookie-prefixes-00#section-3.2\n    if (cookie.name.startsWith(\"__Secure-\")) {\n        cookie.secure = true;\n    }\n    if (cookie.name.startsWith(\"__Host-\")) {\n        cookie.secure = true;\n        cookie.domain = null;\n        cookie.path = \"/\";\n    }\n    if (cookie.secure) {\n        out.push(\"Secure\");\n    }\n    if (cookie.httpOnly) {\n        out.push(\"HttpOnly\");\n    }\n    if (typeof cookie.maxAge === \"number\") {\n        validateCookieMaxAge(cookie.maxAge);\n        out.push(`Max-Age=${cookie.maxAge}`);\n    }\n    if (cookie.domain) {\n        validateCookieDomain(cookie.domain);\n        out.push(`Domain=${cookie.domain}`);\n    }\n    if (cookie.path) {\n        validateCookiePath(cookie.path);\n        out.push(`Path=${cookie.path}`);\n    }\n    if (cookie.expires && cookie.expires.toString() !== \"Invalid Date\") {\n        out.push(`Expires=${toIMFDate(cookie.expires)}`);\n    }\n    if (cookie.sameSite) {\n        out.push(`SameSite=${cookie.sameSite}`);\n    }\n    for (const part of cookie.unparsed){\n        if (!part.includes(\"=\")) {\n            throw new Error(\"Invalid unparsed\");\n        }\n        const [key, ...value] = part.split(\"=\");\n        out.push(`${key.trim()}=${value.join(\"=\")}`);\n    }\n    return out.join(\"; \");\n}\nmodule.exports = {\n    isCTLExcludingHtab,\n    validateCookieName,\n    validateCookiePath,\n    validateCookieValue,\n    toIMFDate,\n    stringify\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvY29va2llcy91dGlsLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUE7OztDQUdBLEdBQ0EsU0FBU0EsbUJBQW9CQyxLQUFLO0lBQ2hDLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJRCxNQUFNRSxNQUFNLEVBQUUsRUFBRUQsRUFBRztRQUNyQyxNQUFNRSxPQUFPSCxNQUFNSSxVQUFVLENBQUNIO1FBRTlCLElBQ0dFLFFBQVEsUUFBUUEsUUFBUSxRQUN4QkEsUUFBUSxRQUFRQSxRQUFRLFFBQ3pCQSxTQUFTLE1BQ1Q7WUFDQSxPQUFPO1FBQ1Q7SUFDRjtJQUNBLE9BQU87QUFDVDtBQUVBOzs7Ozs7OztDQVFBLEdBQ0EsU0FBU0UsbUJBQW9CQyxJQUFJO0lBQy9CLElBQUssSUFBSUwsSUFBSSxHQUFHQSxJQUFJSyxLQUFLSixNQUFNLEVBQUUsRUFBRUQsRUFBRztRQUNwQyxNQUFNRSxPQUFPRyxLQUFLRixVQUFVLENBQUNIO1FBRTdCLElBQ0VFLE9BQU8sUUFBUTtRQUNmQSxPQUFPLFFBQVE7UUFDZkEsU0FBUyxRQUFRO1FBQ2pCQSxTQUFTLFFBQVE7UUFDakJBLFNBQVMsUUFBUTtRQUNqQkEsU0FBUyxRQUFRO1FBQ2pCQSxTQUFTLFFBQVE7UUFDakJBLFNBQVMsUUFBUTtRQUNqQkEsU0FBUyxRQUFRO1FBQ2pCQSxTQUFTLFFBQVE7UUFDakJBLFNBQVMsUUFBUTtRQUNqQkEsU0FBUyxRQUFRO1FBQ2pCQSxTQUFTLFFBQVE7UUFDakJBLFNBQVMsUUFBUTtRQUNqQkEsU0FBUyxRQUFRO1FBQ2pCQSxTQUFTLFFBQVE7UUFDakJBLFNBQVMsUUFBUTtRQUNqQkEsU0FBUyxRQUFRO1FBQ2pCQSxTQUFTLEtBQUs7VUFDZDtZQUNBLE1BQU0sSUFBSUksTUFBTTtRQUNsQjtJQUNGO0FBQ0Y7QUFFQTs7Ozs7OztDQU9BLEdBQ0EsU0FBU0Msb0JBQXFCUixLQUFLO0lBQ2pDLElBQUlTLE1BQU1ULE1BQU1FLE1BQU07SUFDdEIsSUFBSUQsSUFBSTtJQUVSO0lBQ0EsSUFBSUQsS0FBSyxDQUFDLEVBQUUsS0FBSyxLQUFLO1FBQ3BCLElBQUlTLFFBQVEsS0FBS1QsS0FBSyxDQUFDUyxNQUFNLEVBQUUsS0FBSyxLQUFLO1lBQ3ZDLE1BQU0sSUFBSUYsTUFBTTtRQUNsQjtRQUNBLEVBQUVFO1FBQ0YsRUFBRVI7SUFDSjtJQUVBLE1BQU9BLElBQUlRLElBQUs7UUFDZCxNQUFNTixPQUFPSCxNQUFNSSxVQUFVLENBQUNIO1FBRTlCLElBQ0VFLE9BQU8sUUFBUTtRQUNmQSxPQUFPLFFBQVE7UUFDZkEsU0FBUyxRQUFRO1FBQ2pCQSxTQUFTLFFBQVE7UUFDakJBLFNBQVMsUUFBUTtRQUNqQkEsU0FBUyxLQUFLO1VBQ2Q7WUFDQSxNQUFNLElBQUlJLE1BQU07UUFDbEI7SUFDRjtBQUNGO0FBRUE7OztDQUdBLEdBQ0EsU0FBU0csbUJBQW9CQyxJQUFJO0lBQy9CLElBQUssSUFBSVYsSUFBSSxHQUFHQSxJQUFJVSxLQUFLVCxNQUFNLEVBQUUsRUFBRUQsRUFBRztRQUNwQyxNQUFNRSxPQUFPUSxLQUFLUCxVQUFVLENBQUNIO1FBRTdCLElBQ0VFLE9BQU8sUUFBUTtRQUNmQSxTQUFTLFFBQVE7UUFDakJBLFNBQVMsS0FBSztVQUNkO1lBQ0EsTUFBTSxJQUFJSSxNQUFNO1FBQ2xCO0lBQ0Y7QUFDRjtBQUVBOzs7O0NBSUEsR0FDQSxTQUFTSyxxQkFBc0JDLE1BQU07SUFDbkMsSUFDRUEsT0FBT0MsVUFBVSxDQUFDLFFBQ2xCRCxPQUFPRSxRQUFRLENBQUMsUUFDaEJGLE9BQU9FLFFBQVEsQ0FBQyxNQUNoQjtRQUNBLE1BQU0sSUFBSVIsTUFBTTtJQUNsQjtBQUNGO0FBRUEsTUFBTVMsVUFBVTtJQUNkO0lBQU87SUFBTztJQUFPO0lBQ3JCO0lBQU87SUFBTztDQUNmO0FBRUQsTUFBTUMsWUFBWTtJQUNoQjtJQUFPO0lBQU87SUFBTztJQUFPO0lBQU87SUFDbkM7SUFBTztJQUFPO0lBQU87SUFBTztJQUFPO0NBQ3BDO0FBRUQsTUFBTUMsbUJBQW1CQyxNQUFNLElBQUlDLElBQUksQ0FBQyxHQUFHQyxHQUFHLENBQUMsQ0FBQ0MsR0FBR3JCLElBQU1BLEVBQUVzQixRQUFRLEdBQUdDLFFBQVEsQ0FBQyxHQUFHO0FBRWxGOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBd0NBLEdBQ0EsU0FBU0MsVUFBV0MsSUFBSTtJQUN0QixJQUFJLE9BQU9BLFNBQVMsVUFBVTtRQUM1QkEsT0FBTyxJQUFJQyxLQUFLRDtJQUNsQjtJQUVBLE9BQU8sR0FBR1YsT0FBTyxDQUFDVSxLQUFLRSxTQUFTLEdBQUcsS0FBS1YsZ0JBQWdCLENBQUNRLEtBQUtHLFVBQVUsR0FBRyxJQUFJWixTQUFTLENBQUNTLEtBQUtJLFdBQVcsR0FBRyxJQUFJSixLQUFLSyxjQUFjLEdBQUUsR0FBSWIsZ0JBQWdCLENBQUNRLEtBQUtNLFdBQVcsR0FBRyxJQUFJZCxnQkFBZ0IsQ0FBQ1EsS0FBS08sYUFBYSxHQUFHLElBQUlmLGdCQUFnQixDQUFDUSxLQUFLUSxhQUFhLEdBQUcsTUFBTTtBQUN6UTtBQUVBOzs7Ozs7Q0FNQSxHQUNBLFNBQVNDLHFCQUFzQkMsTUFBTTtJQUNuQyxJQUFJQSxTQUFTLEdBQUc7UUFDZCxNQUFNLElBQUk3QixNQUFNO0lBQ2xCO0FBQ0Y7QUFFQTs7O0NBR0EsR0FDQSxTQUFTOEIsVUFBV0MsTUFBTTtJQUN4QixJQUFJQSxPQUFPaEMsSUFBSSxDQUFDSixNQUFNLEtBQUssR0FBRztRQUM1QixPQUFPO0lBQ1Q7SUFFQUcsbUJBQW1CaUMsT0FBT2hDLElBQUk7SUFDOUJFLG9CQUFvQjhCLE9BQU90QyxLQUFLO0lBRWhDLE1BQU11QyxNQUFNO1FBQUMsR0FBR0QsT0FBT2hDLElBQUksSUFBSWdDLE9BQU90QyxLQUFLLEVBQUU7S0FBQztJQUU5QztJQUNBO0lBQ0EsSUFBSXNDLE9BQU9oQyxJQUFJLENBQUNRLFVBQVUsQ0FBQyxjQUFjO1FBQ3ZDd0IsT0FBT0UsTUFBTSxHQUFHO0lBQ2xCO0lBRUEsSUFBSUYsT0FBT2hDLElBQUksQ0FBQ1EsVUFBVSxDQUFDLFlBQVk7UUFDckN3QixPQUFPRSxNQUFNLEdBQUc7UUFDaEJGLE9BQU96QixNQUFNLEdBQUc7UUFDaEJ5QixPQUFPM0IsSUFBSSxHQUFHO0lBQ2hCO0lBRUEsSUFBSTJCLE9BQU9FLE1BQU0sRUFBRTtRQUNqQkQsSUFBSUUsSUFBSSxDQUFDO0lBQ1g7SUFFQSxJQUFJSCxPQUFPSSxRQUFRLEVBQUU7UUFDbkJILElBQUlFLElBQUksQ0FBQztJQUNYO0lBRUEsSUFBSSxPQUFPSCxPQUFPRixNQUFNLEtBQUssVUFBVTtRQUNyQ0QscUJBQXFCRyxPQUFPRixNQUFNO1FBQ2xDRyxJQUFJRSxJQUFJLENBQUMsV0FBV0gsT0FBT0YsTUFBTSxFQUFFO0lBQ3JDO0lBRUEsSUFBSUUsT0FBT3pCLE1BQU0sRUFBRTtRQUNqQkQscUJBQXFCMEIsT0FBT3pCLE1BQU07UUFDbEMwQixJQUFJRSxJQUFJLENBQUMsVUFBVUgsT0FBT3pCLE1BQU0sRUFBRTtJQUNwQztJQUVBLElBQUl5QixPQUFPM0IsSUFBSSxFQUFFO1FBQ2ZELG1CQUFtQjRCLE9BQU8zQixJQUFJO1FBQzlCNEIsSUFBSUUsSUFBSSxDQUFDLFFBQVFILE9BQU8zQixJQUFJLEVBQUU7SUFDaEM7SUFFQSxJQUFJMkIsT0FBT0ssT0FBTyxJQUFJTCxPQUFPSyxPQUFPLENBQUNwQixRQUFRLE9BQU8sZ0JBQWdCO1FBQ2xFZ0IsSUFBSUUsSUFBSSxDQUFDLFdBQVdoQixVQUFVYSxPQUFPSyxPQUFPLEVBQUMsQ0FBRTtJQUNqRDtJQUVBLElBQUlMLE9BQU9NLFFBQVEsRUFBRTtRQUNuQkwsSUFBSUUsSUFBSSxDQUFDLFlBQVlILE9BQU9NLFFBQVEsRUFBRTtJQUN4QztJQUVBLEtBQUssTUFBTUMsUUFBUVAsT0FBT1EsUUFBUSxDQUFFO1FBQ2xDLElBQUksQ0FBQ0QsS0FBS0UsUUFBUSxDQUFDLE1BQU07WUFDdkIsTUFBTSxJQUFJeEMsTUFBTTtRQUNsQjtRQUVBLE1BQU0sQ0FBQ3lDLEtBQUssR0FBR2hELE1BQU0sR0FBRzZDLEtBQUtJLEtBQUssQ0FBQztRQUVuQ1YsSUFBSUUsSUFBSSxDQUFDLEdBQUdPLElBQUlFLElBQUksR0FBRSxHQUFJbEQsTUFBTW1ELElBQUksQ0FBQyxLQUFJLENBQUU7SUFDN0M7SUFFQSxPQUFPWixJQUFJWSxJQUFJLENBQUM7QUFDbEI7QUFFQUMsT0FBT0MsT0FBTyxHQUFHO0lBQ2Z0RDtJQUNBTTtJQUNBSztJQUNBRjtJQUNBaUI7SUFDQVk7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL21vY2t1cGZsb3cvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvY29va2llcy91dGlsLmpzPzRiYmQiLCJ3ZWJwYWNrOi8vbW9ja3VwZmxvdy8uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL3dlYi9jb29raWVzL3V0aWwuanM/NGJiZCoiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNDVExFeGNsdWRpbmdIdGFiICh2YWx1ZSkge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgKytpKSB7XG4gICAgY29uc3QgY29kZSA9IHZhbHVlLmNoYXJDb2RlQXQoaSlcblxuICAgIGlmIChcbiAgICAgIChjb2RlID49IDB4MDAgJiYgY29kZSA8PSAweDA4KSB8fFxuICAgICAgKGNvZGUgPj0gMHgwQSAmJiBjb2RlIDw9IDB4MUYpIHx8XG4gICAgICBjb2RlID09PSAweDdGXG4gICAgKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuLyoqXG4gQ0hBUiAgICAgICAgICAgPSA8YW55IFVTLUFTQ0lJIGNoYXJhY3RlciAob2N0ZXRzIDAgLSAxMjcpPlxuIHRva2VuICAgICAgICAgID0gMSo8YW55IENIQVIgZXhjZXB0IENUTHMgb3Igc2VwYXJhdG9ycz5cbiBzZXBhcmF0b3JzICAgICA9IFwiKFwiIHwgXCIpXCIgfCBcIjxcIiB8IFwiPlwiIHwgXCJAXCJcbiAgICAgICAgICAgICAgICB8IFwiLFwiIHwgXCI7XCIgfCBcIjpcIiB8IFwiXFxcIiB8IDxcIj5cbiAgICAgICAgICAgICAgICB8IFwiL1wiIHwgXCJbXCIgfCBcIl1cIiB8IFwiP1wiIHwgXCI9XCJcbiAgICAgICAgICAgICAgICB8IFwie1wiIHwgXCJ9XCIgfCBTUCB8IEhUXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUNvb2tpZU5hbWUgKG5hbWUpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBuYW1lLmxlbmd0aDsgKytpKSB7XG4gICAgY29uc3QgY29kZSA9IG5hbWUuY2hhckNvZGVBdChpKVxuXG4gICAgaWYgKFxuICAgICAgY29kZSA8IDB4MjEgfHwgLy8gZXhjbHVkZSBDVExzICgwLTMxKSwgU1AgYW5kIEhUXG4gICAgICBjb2RlID4gMHg3RSB8fCAvLyBleGNsdWRlIG5vbi1hc2NpaSBhbmQgREVMXG4gICAgICBjb2RlID09PSAweDIyIHx8IC8vIFwiXG4gICAgICBjb2RlID09PSAweDI4IHx8IC8vIChcbiAgICAgIGNvZGUgPT09IDB4MjkgfHwgLy8gKVxuICAgICAgY29kZSA9PT0gMHgzQyB8fCAvLyA8XG4gICAgICBjb2RlID09PSAweDNFIHx8IC8vID5cbiAgICAgIGNvZGUgPT09IDB4NDAgfHwgLy8gQFxuICAgICAgY29kZSA9PT0gMHgyQyB8fCAvLyAsXG4gICAgICBjb2RlID09PSAweDNCIHx8IC8vIDtcbiAgICAgIGNvZGUgPT09IDB4M0EgfHwgLy8gOlxuICAgICAgY29kZSA9PT0gMHg1QyB8fCAvLyBcXFxuICAgICAgY29kZSA9PT0gMHgyRiB8fCAvLyAvXG4gICAgICBjb2RlID09PSAweDVCIHx8IC8vIFtcbiAgICAgIGNvZGUgPT09IDB4NUQgfHwgLy8gXVxuICAgICAgY29kZSA9PT0gMHgzRiB8fCAvLyA/XG4gICAgICBjb2RlID09PSAweDNEIHx8IC8vID1cbiAgICAgIGNvZGUgPT09IDB4N0IgfHwgLy8ge1xuICAgICAgY29kZSA9PT0gMHg3RCAvLyB9XG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29va2llIG5hbWUnKVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiBjb29raWUtdmFsdWUgICAgICA9ICpjb29raWUtb2N0ZXQgLyAoIERRVU9URSAqY29va2llLW9jdGV0IERRVU9URSApXG4gY29va2llLW9jdGV0ICAgICAgPSAleDIxIC8gJXgyMy0yQiAvICV4MkQtM0EgLyAleDNDLTVCIC8gJXg1RC03RVxuICAgICAgICAgICAgICAgICAgICAgICA7IFVTLUFTQ0lJIGNoYXJhY3RlcnMgZXhjbHVkaW5nIENUTHMsXG4gICAgICAgICAgICAgICAgICAgICAgIDsgd2hpdGVzcGFjZSBEUVVPVEUsIGNvbW1hLCBzZW1pY29sb24sXG4gICAgICAgICAgICAgICAgICAgICAgIDsgYW5kIGJhY2tzbGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlQ29va2llVmFsdWUgKHZhbHVlKSB7XG4gIGxldCBsZW4gPSB2YWx1ZS5sZW5ndGhcbiAgbGV0IGkgPSAwXG5cbiAgLy8gaWYgdGhlIHZhbHVlIGlzIHdyYXBwZWQgaW4gRFFVT1RFXG4gIGlmICh2YWx1ZVswXSA9PT0gJ1wiJykge1xuICAgIGlmIChsZW4gPT09IDEgfHwgdmFsdWVbbGVuIC0gMV0gIT09ICdcIicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb29raWUgdmFsdWUnKVxuICAgIH1cbiAgICAtLWxlblxuICAgICsraVxuICB9XG5cbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICBjb25zdCBjb2RlID0gdmFsdWUuY2hhckNvZGVBdChpKyspXG5cbiAgICBpZiAoXG4gICAgICBjb2RlIDwgMHgyMSB8fCAvLyBleGNsdWRlIENUTHMgKDAtMzEpXG4gICAgICBjb2RlID4gMHg3RSB8fCAvLyBub24tYXNjaWkgYW5kIERFTCAoMTI3KVxuICAgICAgY29kZSA9PT0gMHgyMiB8fCAvLyBcIlxuICAgICAgY29kZSA9PT0gMHgyQyB8fCAvLyAsXG4gICAgICBjb2RlID09PSAweDNCIHx8IC8vIDtcbiAgICAgIGNvZGUgPT09IDB4NUMgLy8gXFxcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb29raWUgdmFsdWUnKVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIHBhdGgtdmFsdWUgICAgICAgID0gPGFueSBDSEFSIGV4Y2VwdCBDVExzIG9yIFwiO1wiPlxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGhcbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVDb29raWVQYXRoIChwYXRoKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7ICsraSkge1xuICAgIGNvbnN0IGNvZGUgPSBwYXRoLmNoYXJDb2RlQXQoaSlcblxuICAgIGlmIChcbiAgICAgIGNvZGUgPCAweDIwIHx8IC8vIGV4Y2x1ZGUgQ1RMcyAoMC0zMSlcbiAgICAgIGNvZGUgPT09IDB4N0YgfHwgLy8gREVMXG4gICAgICBjb2RlID09PSAweDNCIC8vIDtcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb29raWUgcGF0aCcpXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogSSBoYXZlIG5vIGlkZWEgd2h5IHRoZXNlIHZhbHVlcyBhcmVuJ3QgYWxsb3dlZCB0byBiZSBob25lc3QsXG4gKiBidXQgRGVubyB0ZXN0cyB0aGVzZS4gLSBLaGFmcmFcbiAqIEBwYXJhbSB7c3RyaW5nfSBkb21haW5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVDb29raWVEb21haW4gKGRvbWFpbikge1xuICBpZiAoXG4gICAgZG9tYWluLnN0YXJ0c1dpdGgoJy0nKSB8fFxuICAgIGRvbWFpbi5lbmRzV2l0aCgnLicpIHx8XG4gICAgZG9tYWluLmVuZHNXaXRoKCctJylcbiAgKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvb2tpZSBkb21haW4nKVxuICB9XG59XG5cbmNvbnN0IElNRkRheXMgPSBbXG4gICdTdW4nLCAnTW9uJywgJ1R1ZScsICdXZWQnLFxuICAnVGh1JywgJ0ZyaScsICdTYXQnXG5dXG5cbmNvbnN0IElNRk1vbnRocyA9IFtcbiAgJ0phbicsICdGZWInLCAnTWFyJywgJ0FwcicsICdNYXknLCAnSnVuJyxcbiAgJ0p1bCcsICdBdWcnLCAnU2VwJywgJ09jdCcsICdOb3YnLCAnRGVjJ1xuXVxuXG5jb25zdCBJTUZQYWRkZWROdW1iZXJzID0gQXJyYXkoNjEpLmZpbGwoMCkubWFwKChfLCBpKSA9PiBpLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgJzAnKSlcblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM3MjMxI3NlY3Rpb24tNy4xLjEuMVxuICogQHBhcmFtIHtudW1iZXJ8RGF0ZX0gZGF0ZVxuICBJTUYtZml4ZGF0ZSAgPSBkYXktbmFtZSBcIixcIiBTUCBkYXRlMSBTUCB0aW1lLW9mLWRheSBTUCBHTVRcbiAgOyBmaXhlZCBsZW5ndGgvem9uZS9jYXBpdGFsaXphdGlvbiBzdWJzZXQgb2YgdGhlIGZvcm1hdFxuICA7IHNlZSBTZWN0aW9uIDMuMyBvZiBbUkZDNTMyMl1cblxuICBkYXktbmFtZSAgICAgPSAleDRELjZGLjZFIDsgXCJNb25cIiwgY2FzZS1zZW5zaXRpdmVcbiAgICAgICAgICAgICAgLyAleDU0Ljc1LjY1IDsgXCJUdWVcIiwgY2FzZS1zZW5zaXRpdmVcbiAgICAgICAgICAgICAgLyAleDU3LjY1LjY0IDsgXCJXZWRcIiwgY2FzZS1zZW5zaXRpdmVcbiAgICAgICAgICAgICAgLyAleDU0LjY4Ljc1IDsgXCJUaHVcIiwgY2FzZS1zZW5zaXRpdmVcbiAgICAgICAgICAgICAgLyAleDQ2LjcyLjY5IDsgXCJGcmlcIiwgY2FzZS1zZW5zaXRpdmVcbiAgICAgICAgICAgICAgLyAleDUzLjYxLjc0IDsgXCJTYXRcIiwgY2FzZS1zZW5zaXRpdmVcbiAgICAgICAgICAgICAgLyAleDUzLjc1LjZFIDsgXCJTdW5cIiwgY2FzZS1zZW5zaXRpdmVcbiAgZGF0ZTEgICAgICAgID0gZGF5IFNQIG1vbnRoIFNQIHllYXJcbiAgICAgICAgICAgICAgICAgIDsgZS5nLiwgMDIgSnVuIDE5ODJcblxuICBkYXkgICAgICAgICAgPSAyRElHSVRcbiAgbW9udGggICAgICAgID0gJXg0QS42MS42RSA7IFwiSmFuXCIsIGNhc2Utc2Vuc2l0aXZlXG4gICAgICAgICAgICAgIC8gJXg0Ni42NS42MiA7IFwiRmViXCIsIGNhc2Utc2Vuc2l0aXZlXG4gICAgICAgICAgICAgIC8gJXg0RC42MS43MiA7IFwiTWFyXCIsIGNhc2Utc2Vuc2l0aXZlXG4gICAgICAgICAgICAgIC8gJXg0MS43MC43MiA7IFwiQXByXCIsIGNhc2Utc2Vuc2l0aXZlXG4gICAgICAgICAgICAgIC8gJXg0RC42MS43OSA7IFwiTWF5XCIsIGNhc2Utc2Vuc2l0aXZlXG4gICAgICAgICAgICAgIC8gJXg0QS43NS42RSA7IFwiSnVuXCIsIGNhc2Utc2Vuc2l0aXZlXG4gICAgICAgICAgICAgIC8gJXg0QS43NS42QyA7IFwiSnVsXCIsIGNhc2Utc2Vuc2l0aXZlXG4gICAgICAgICAgICAgIC8gJXg0MS43NS42NyA7IFwiQXVnXCIsIGNhc2Utc2Vuc2l0aXZlXG4gICAgICAgICAgICAgIC8gJXg1My42NS43MCA7IFwiU2VwXCIsIGNhc2Utc2Vuc2l0aXZlXG4gICAgICAgICAgICAgIC8gJXg0Ri42My43NCA7IFwiT2N0XCIsIGNhc2Utc2Vuc2l0aXZlXG4gICAgICAgICAgICAgIC8gJXg0RS42Ri43NiA7IFwiTm92XCIsIGNhc2Utc2Vuc2l0aXZlXG4gICAgICAgICAgICAgIC8gJXg0NC42NS42MyA7IFwiRGVjXCIsIGNhc2Utc2Vuc2l0aXZlXG4gIHllYXIgICAgICAgICA9IDRESUdJVFxuXG4gIEdNVCAgICAgICAgICA9ICV4NDcuNEQuNTQgOyBcIkdNVFwiLCBjYXNlLXNlbnNpdGl2ZVxuXG4gIHRpbWUtb2YtZGF5ICA9IGhvdXIgXCI6XCIgbWludXRlIFwiOlwiIHNlY29uZFxuICAgICAgICAgICAgICA7IDAwOjAwOjAwIC0gMjM6NTk6NjAgKGxlYXAgc2Vjb25kKVxuXG4gIGhvdXIgICAgICAgICA9IDJESUdJVFxuICBtaW51dGUgICAgICAgPSAyRElHSVRcbiAgc2Vjb25kICAgICAgID0gMkRJR0lUXG4gKi9cbmZ1bmN0aW9uIHRvSU1GRGF0ZSAoZGF0ZSkge1xuICBpZiAodHlwZW9mIGRhdGUgPT09ICdudW1iZXInKSB7XG4gICAgZGF0ZSA9IG5ldyBEYXRlKGRhdGUpXG4gIH1cblxuICByZXR1cm4gYCR7SU1GRGF5c1tkYXRlLmdldFVUQ0RheSgpXX0sICR7SU1GUGFkZGVkTnVtYmVyc1tkYXRlLmdldFVUQ0RhdGUoKV19ICR7SU1GTW9udGhzW2RhdGUuZ2V0VVRDTW9udGgoKV19ICR7ZGF0ZS5nZXRVVENGdWxsWWVhcigpfSAke0lNRlBhZGRlZE51bWJlcnNbZGF0ZS5nZXRVVENIb3VycygpXX06JHtJTUZQYWRkZWROdW1iZXJzW2RhdGUuZ2V0VVRDTWludXRlcygpXX06JHtJTUZQYWRkZWROdW1iZXJzW2RhdGUuZ2V0VVRDU2Vjb25kcygpXX0gR01UYFxufVxuXG4vKipcbiBtYXgtYWdlLWF2ICAgICAgICA9IFwiTWF4LUFnZT1cIiBub24temVyby1kaWdpdCAqRElHSVRcbiAgICAgICAgICAgICAgICAgICAgICAgOyBJbiBwcmFjdGljZSwgYm90aCBleHBpcmVzLWF2IGFuZCBtYXgtYWdlLWF2XG4gICAgICAgICAgICAgICAgICAgICAgIDsgYXJlIGxpbWl0ZWQgdG8gZGF0ZXMgcmVwcmVzZW50YWJsZSBieSB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgOyB1c2VyIGFnZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IG1heEFnZVxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUNvb2tpZU1heEFnZSAobWF4QWdlKSB7XG4gIGlmIChtYXhBZ2UgPCAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvb2tpZSBtYXgtYWdlJylcbiAgfVxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzYyNjUjc2VjdGlvbi00LjEuMVxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW5kZXgnKS5Db29raWV9IGNvb2tpZVxuICovXG5mdW5jdGlvbiBzdHJpbmdpZnkgKGNvb2tpZSkge1xuICBpZiAoY29va2llLm5hbWUubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIHZhbGlkYXRlQ29va2llTmFtZShjb29raWUubmFtZSlcbiAgdmFsaWRhdGVDb29raWVWYWx1ZShjb29raWUudmFsdWUpXG5cbiAgY29uc3Qgb3V0ID0gW2Ake2Nvb2tpZS5uYW1lfT0ke2Nvb2tpZS52YWx1ZX1gXVxuXG4gIC8vIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvZHJhZnQtaWV0Zi1odHRwYmlzLWNvb2tpZS1wcmVmaXhlcy0wMCNzZWN0aW9uLTMuMVxuICAvLyBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL2RyYWZ0LWlldGYtaHR0cGJpcy1jb29raWUtcHJlZml4ZXMtMDAjc2VjdGlvbi0zLjJcbiAgaWYgKGNvb2tpZS5uYW1lLnN0YXJ0c1dpdGgoJ19fU2VjdXJlLScpKSB7XG4gICAgY29va2llLnNlY3VyZSA9IHRydWVcbiAgfVxuXG4gIGlmIChjb29raWUubmFtZS5zdGFydHNXaXRoKCdfX0hvc3QtJykpIHtcbiAgICBjb29raWUuc2VjdXJlID0gdHJ1ZVxuICAgIGNvb2tpZS5kb21haW4gPSBudWxsXG4gICAgY29va2llLnBhdGggPSAnLydcbiAgfVxuXG4gIGlmIChjb29raWUuc2VjdXJlKSB7XG4gICAgb3V0LnB1c2goJ1NlY3VyZScpXG4gIH1cblxuICBpZiAoY29va2llLmh0dHBPbmx5KSB7XG4gICAgb3V0LnB1c2goJ0h0dHBPbmx5JylcbiAgfVxuXG4gIGlmICh0eXBlb2YgY29va2llLm1heEFnZSA9PT0gJ251bWJlcicpIHtcbiAgICB2YWxpZGF0ZUNvb2tpZU1heEFnZShjb29raWUubWF4QWdlKVxuICAgIG91dC5wdXNoKGBNYXgtQWdlPSR7Y29va2llLm1heEFnZX1gKVxuICB9XG5cbiAgaWYgKGNvb2tpZS5kb21haW4pIHtcbiAgICB2YWxpZGF0ZUNvb2tpZURvbWFpbihjb29raWUuZG9tYWluKVxuICAgIG91dC5wdXNoKGBEb21haW49JHtjb29raWUuZG9tYWlufWApXG4gIH1cblxuICBpZiAoY29va2llLnBhdGgpIHtcbiAgICB2YWxpZGF0ZUNvb2tpZVBhdGgoY29va2llLnBhdGgpXG4gICAgb3V0LnB1c2goYFBhdGg9JHtjb29raWUucGF0aH1gKVxuICB9XG5cbiAgaWYgKGNvb2tpZS5leHBpcmVzICYmIGNvb2tpZS5leHBpcmVzLnRvU3RyaW5nKCkgIT09ICdJbnZhbGlkIERhdGUnKSB7XG4gICAgb3V0LnB1c2goYEV4cGlyZXM9JHt0b0lNRkRhdGUoY29va2llLmV4cGlyZXMpfWApXG4gIH1cblxuICBpZiAoY29va2llLnNhbWVTaXRlKSB7XG4gICAgb3V0LnB1c2goYFNhbWVTaXRlPSR7Y29va2llLnNhbWVTaXRlfWApXG4gIH1cblxuICBmb3IgKGNvbnN0IHBhcnQgb2YgY29va2llLnVucGFyc2VkKSB7XG4gICAgaWYgKCFwYXJ0LmluY2x1ZGVzKCc9JykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB1bnBhcnNlZCcpXG4gICAgfVxuXG4gICAgY29uc3QgW2tleSwgLi4udmFsdWVdID0gcGFydC5zcGxpdCgnPScpXG5cbiAgICBvdXQucHVzaChgJHtrZXkudHJpbSgpfT0ke3ZhbHVlLmpvaW4oJz0nKX1gKVxuICB9XG5cbiAgcmV0dXJuIG91dC5qb2luKCc7ICcpXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpc0NUTEV4Y2x1ZGluZ0h0YWIsXG4gIHZhbGlkYXRlQ29va2llTmFtZSxcbiAgdmFsaWRhdGVDb29raWVQYXRoLFxuICB2YWxpZGF0ZUNvb2tpZVZhbHVlLFxuICB0b0lNRkRhdGUsXG4gIHN0cmluZ2lmeVxufVxuIl0sIm5hbWVzIjpbImlzQ1RMRXhjbHVkaW5nSHRhYiIsInZhbHVlIiwiaSIsImxlbmd0aCIsImNvZGUiLCJjaGFyQ29kZUF0IiwidmFsaWRhdGVDb29raWVOYW1lIiwibmFtZSIsIkVycm9yIiwidmFsaWRhdGVDb29raWVWYWx1ZSIsImxlbiIsInZhbGlkYXRlQ29va2llUGF0aCIsInBhdGgiLCJ2YWxpZGF0ZUNvb2tpZURvbWFpbiIsImRvbWFpbiIsInN0YXJ0c1dpdGgiLCJlbmRzV2l0aCIsIklNRkRheXMiLCJJTUZNb250aHMiLCJJTUZQYWRkZWROdW1iZXJzIiwiQXJyYXkiLCJmaWxsIiwibWFwIiwiXyIsInRvU3RyaW5nIiwicGFkU3RhcnQiLCJ0b0lNRkRhdGUiLCJkYXRlIiwiRGF0ZSIsImdldFVUQ0RheSIsImdldFVUQ0RhdGUiLCJnZXRVVENNb250aCIsImdldFVUQ0Z1bGxZZWFyIiwiZ2V0VVRDSG91cnMiLCJnZXRVVENNaW51dGVzIiwiZ2V0VVRDU2Vjb25kcyIsInZhbGlkYXRlQ29va2llTWF4QWdlIiwibWF4QWdlIiwic3RyaW5naWZ5IiwiY29va2llIiwib3V0Iiwic2VjdXJlIiwicHVzaCIsImh0dHBPbmx5IiwiZXhwaXJlcyIsInNhbWVTaXRlIiwicGFydCIsInVucGFyc2VkIiwiaW5jbHVkZXMiLCJrZXkiLCJzcGxpdCIsInRyaW0iLCJqb2luIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/cookies/util.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/eventsource/eventsource-stream.js":
/*!***********************************************************************!*\
  !*** ./node_modules/undici/lib/web/eventsource/eventsource-stream.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { Transform } = __webpack_require__(/*! node:stream */ \"node:stream\");\nconst { isASCIINumber, isValidLastEventId } = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/undici/lib/web/eventsource/util.js\");\n/**\n * @type {number[]} BOM\n */ const BOM = [\n    0xEF,\n    0xBB,\n    0xBF\n];\n/**\n * @type {10} LF\n */ const LF = 0x0A;\n/**\n * @type {13} CR\n */ const CR = 0x0D;\n/**\n * @type {58} COLON\n */ const COLON = 0x3A;\n/**\n * @type {32} SPACE\n */ const SPACE = 0x20;\n/**\n * @typedef {object} EventSourceStreamEvent\n * @type {object}\n * @property {string} [event] The event type.\n * @property {string} [data] The data of the message.\n * @property {string} [id] A unique ID for the event.\n * @property {string} [retry] The reconnection time, in milliseconds.\n */ /**\n * @typedef eventSourceSettings\n * @type {object}\n * @property {string} lastEventId The last event ID received from the server.\n * @property {string} origin The origin of the event source.\n * @property {number} reconnectionTime The reconnection time, in milliseconds.\n */ class EventSourceStream extends Transform {\n    /**\n   * @param {object} options\n   * @param {eventSourceSettings} options.eventSourceSettings\n   * @param {Function} [options.push]\n   */ constructor(options = {}){\n        // Enable object mode as EventSourceStream emits objects of shape\n        // EventSourceStreamEvent\n        options.readableObjectMode = true;\n        super(options);\n        /**\n   * @type {eventSourceSettings}\n   */ this.state = null;\n        /**\n   * Leading byte-order-mark check.\n   * @type {boolean}\n   */ this.checkBOM = true;\n        /**\n   * @type {boolean}\n   */ this.crlfCheck = false;\n        /**\n   * @type {boolean}\n   */ this.eventEndCheck = false;\n        /**\n   * @type {Buffer}\n   */ this.buffer = null;\n        this.pos = 0;\n        this.event = {\n            data: undefined,\n            event: undefined,\n            id: undefined,\n            retry: undefined\n        };\n        this.state = options.eventSourceSettings || {};\n        if (options.push) {\n            this.push = options.push;\n        }\n    }\n    /**\n   * @param {Buffer} chunk\n   * @param {string} _encoding\n   * @param {Function} callback\n   * @returns {void}\n   */ _transform(chunk, _encoding, callback) {\n        if (chunk.length === 0) {\n            callback();\n            return;\n        }\n        // Cache the chunk in the buffer, as the data might not be complete while\n        // processing it\n        // TODO: Investigate if there is a more performant way to handle\n        // incoming chunks\n        // see: https://github.com/nodejs/undici/issues/2630\n        if (this.buffer) {\n            this.buffer = Buffer.concat([\n                this.buffer,\n                chunk\n            ]);\n        } else {\n            this.buffer = chunk;\n        }\n        // Strip leading byte-order-mark if we opened the stream and started\n        // the processing of the incoming data\n        if (this.checkBOM) {\n            switch(this.buffer.length){\n                case 1:\n                    // Check if the first byte is the same as the first byte of the BOM\n                    if (this.buffer[0] === BOM[0]) {\n                        // If it is, we need to wait for more data\n                        callback();\n                        return;\n                    }\n                    // Set the checkBOM flag to false as we don't need to check for the\n                    // BOM anymore\n                    this.checkBOM = false;\n                    // The buffer only contains one byte so we need to wait for more data\n                    callback();\n                    return;\n                case 2:\n                    // Check if the first two bytes are the same as the first two bytes\n                    // of the BOM\n                    if (this.buffer[0] === BOM[0] && this.buffer[1] === BOM[1]) {\n                        // If it is, we need to wait for more data, because the third byte\n                        // is needed to determine if it is the BOM or not\n                        callback();\n                        return;\n                    }\n                    // Set the checkBOM flag to false as we don't need to check for the\n                    // BOM anymore\n                    this.checkBOM = false;\n                    break;\n                case 3:\n                    // Check if the first three bytes are the same as the first three\n                    // bytes of the BOM\n                    if (this.buffer[0] === BOM[0] && this.buffer[1] === BOM[1] && this.buffer[2] === BOM[2]) {\n                        // If it is, we can drop the buffered data, as it is only the BOM\n                        this.buffer = Buffer.alloc(0);\n                        // Set the checkBOM flag to false as we don't need to check for the\n                        // BOM anymore\n                        this.checkBOM = false;\n                        // Await more data\n                        callback();\n                        return;\n                    }\n                    // If it is not the BOM, we can start processing the data\n                    this.checkBOM = false;\n                    break;\n                default:\n                    // The buffer is longer than 3 bytes, so we can drop the BOM if it is\n                    // present\n                    if (this.buffer[0] === BOM[0] && this.buffer[1] === BOM[1] && this.buffer[2] === BOM[2]) {\n                        // Remove the BOM from the buffer\n                        this.buffer = this.buffer.subarray(3);\n                    }\n                    // Set the checkBOM flag to false as we don't need to check for the\n                    this.checkBOM = false;\n                    break;\n            }\n        }\n        while(this.pos < this.buffer.length){\n            // If the previous line ended with an end-of-line, we need to check\n            // if the next character is also an end-of-line.\n            if (this.eventEndCheck) {\n                // If the the current character is an end-of-line, then the event\n                // is finished and we can process it\n                // If the previous line ended with a carriage return, we need to\n                // check if the current character is a line feed and remove it\n                // from the buffer.\n                if (this.crlfCheck) {\n                    // If the current character is a line feed, we can remove it\n                    // from the buffer and reset the crlfCheck flag\n                    if (this.buffer[this.pos] === LF) {\n                        this.buffer = this.buffer.subarray(this.pos + 1);\n                        this.pos = 0;\n                        this.crlfCheck = false;\n                        continue;\n                    }\n                    this.crlfCheck = false;\n                }\n                if (this.buffer[this.pos] === LF || this.buffer[this.pos] === CR) {\n                    // If the current character is a carriage return, we need to\n                    // set the crlfCheck flag to true, as we need to check if the\n                    // next character is a line feed so we can remove it from the\n                    // buffer\n                    if (this.buffer[this.pos] === CR) {\n                        this.crlfCheck = true;\n                    }\n                    this.buffer = this.buffer.subarray(this.pos + 1);\n                    this.pos = 0;\n                    if (this.event.data !== undefined || this.event.event || this.event.id || this.event.retry) {\n                        this.processEvent(this.event);\n                    }\n                    this.clearEvent();\n                    continue;\n                }\n                // If the current character is not an end-of-line, then the event\n                // is not finished and we have to reset the eventEndCheck flag\n                this.eventEndCheck = false;\n                continue;\n            }\n            // If the current character is an end-of-line, we can process the\n            // line\n            if (this.buffer[this.pos] === LF || this.buffer[this.pos] === CR) {\n                // If the current character is a carriage return, we need to\n                // set the crlfCheck flag to true, as we need to check if the\n                // next character is a line feed\n                if (this.buffer[this.pos] === CR) {\n                    this.crlfCheck = true;\n                }\n                // In any case, we can process the line as we reached an\n                // end-of-line character\n                this.parseLine(this.buffer.subarray(0, this.pos), this.event);\n                // Remove the processed line from the buffer\n                this.buffer = this.buffer.subarray(this.pos + 1);\n                // Reset the position as we removed the processed line from the buffer\n                this.pos = 0;\n                // A line was processed and this could be the end of the event. We need\n                // to check if the next line is empty to determine if the event is\n                // finished.\n                this.eventEndCheck = true;\n                continue;\n            }\n            this.pos++;\n        }\n        callback();\n    }\n    /**\n   * @param {Buffer} line\n   * @param {EventStreamEvent} event\n   */ parseLine(line, event) {\n        // If the line is empty (a blank line)\n        // Dispatch the event, as defined below.\n        // This will be handled in the _transform method\n        if (line.length === 0) {\n            return;\n        }\n        // If the line starts with a U+003A COLON character (:)\n        // Ignore the line.\n        const colonPosition = line.indexOf(COLON);\n        if (colonPosition === 0) {\n            return;\n        }\n        let field = \"\";\n        let value = \"\";\n        // If the line contains a U+003A COLON character (:)\n        if (colonPosition !== -1) {\n            // Collect the characters on the line before the first U+003A COLON\n            // character (:), and let field be that string.\n            // TODO: Investigate if there is a more performant way to extract the\n            // field\n            // see: https://github.com/nodejs/undici/issues/2630\n            field = line.subarray(0, colonPosition).toString(\"utf8\");\n            // Collect the characters on the line after the first U+003A COLON\n            // character (:), and let value be that string.\n            // If value starts with a U+0020 SPACE character, remove it from value.\n            let valueStart = colonPosition + 1;\n            if (line[valueStart] === SPACE) {\n                ++valueStart;\n            }\n            // TODO: Investigate if there is a more performant way to extract the\n            // value\n            // see: https://github.com/nodejs/undici/issues/2630\n            value = line.subarray(valueStart).toString(\"utf8\");\n        // Otherwise, the string is not empty but does not contain a U+003A COLON\n        // character (:)\n        } else {\n            // Process the field using the steps described below, using the whole\n            // line as the field name, and the empty string as the field value.\n            field = line.toString(\"utf8\");\n            value = \"\";\n        }\n        // Modify the event with the field name and value. The value is also\n        // decoded as UTF-8\n        switch(field){\n            case \"data\":\n                if (event[field] === undefined) {\n                    event[field] = value;\n                } else {\n                    event[field] += `\\n${value}`;\n                }\n                break;\n            case \"retry\":\n                if (isASCIINumber(value)) {\n                    event[field] = value;\n                }\n                break;\n            case \"id\":\n                if (isValidLastEventId(value)) {\n                    event[field] = value;\n                }\n                break;\n            case \"event\":\n                if (value.length > 0) {\n                    event[field] = value;\n                }\n                break;\n        }\n    }\n    /**\n   * @param {EventSourceStreamEvent} event\n   */ processEvent(event) {\n        if (event.retry && isASCIINumber(event.retry)) {\n            this.state.reconnectionTime = parseInt(event.retry, 10);\n        }\n        if (event.id && isValidLastEventId(event.id)) {\n            this.state.lastEventId = event.id;\n        }\n        // only dispatch event, when data is provided\n        if (event.data !== undefined) {\n            this.push({\n                type: event.event || \"message\",\n                options: {\n                    data: event.data,\n                    lastEventId: this.state.lastEventId,\n                    origin: this.state.origin\n                }\n            });\n        }\n    }\n    clearEvent() {\n        this.event = {\n            data: undefined,\n            event: undefined,\n            id: undefined,\n            retry: undefined\n        };\n    }\n}\nmodule.exports = {\n    EventSourceStream\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZXZlbnRzb3VyY2UvZXZlbnRzb3VyY2Utc3RyZWFtLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsTUFBTSxFQUFFQSxTQUFBQSxFQUFXLEdBQUdDLG1CQUFPQSxDQUFDO0FBQzlCLE1BQU0sRUFBRUMsYUFBYSxFQUFFQyxrQkFBQUEsRUFBb0IsR0FBR0YsbUJBQU9BLENBQUM7QUFFdEQ7O0NBRUEsR0FDQSxNQUFNRyxNQUFNO0lBQUM7SUFBTTtJQUFNO0NBQUs7QUFDOUI7O0NBRUEsR0FDQSxNQUFNQyxLQUFLO0FBQ1g7O0NBRUEsR0FDQSxNQUFNQyxLQUFLO0FBQ1g7O0NBRUEsR0FDQSxNQUFNQyxRQUFRO0FBQ2Q7O0NBRUEsR0FDQSxNQUFNQyxRQUFRO0FBRWQ7Ozs7Ozs7Q0FPQSxHQUVBOzs7Ozs7Q0FNQSxHQUVBLE1BQU1DLDBCQUEwQlQ7SUFvQzlCOzs7O0dBSUYsR0FDRVUsWUFBYUMsVUFBVSxDQUFDLENBQUMsQ0FBRTtRQUN6QjtRQUNBO1FBQ0FBLFFBQVFDLGtCQUFrQixHQUFHO1FBRTdCLEtBQUssQ0FBQ0Q7UUE3Q1I7O0dBRUYsUUFDRUUsUUFBUTtRQUVSOzs7R0FHRixRQUNFQyxXQUFXO1FBRVg7O0dBRUYsUUFDRUMsWUFBWTtRQUVaOztHQUVGLFFBQ0VDLGdCQUFnQjtRQUVoQjs7R0FFRixRQUNFQyxTQUFTO2FBRVRDLE1BQU07YUFFTkMsUUFBUTtZQUNOQyxNQUFNQztZQUNORixPQUFPRTtZQUNQQyxJQUFJRDtZQUNKRSxPQUFPRjtRQUNUO1FBY0UsSUFBSSxDQUFDUixLQUFLLEdBQUdGLFFBQVFhLG1CQUFtQixJQUFJLENBQUM7UUFDN0MsSUFBSWIsUUFBUWMsSUFBSSxFQUFFO1lBQ2hCLElBQUksQ0FBQ0EsSUFBSSxHQUFHZCxRQUFRYyxJQUFJO1FBQzFCO0lBQ0Y7SUFFQTs7Ozs7R0FLRixHQUNFQyxXQUFZQyxLQUFLLEVBQUVDLFNBQVMsRUFBRUMsUUFBUSxFQUFFO1FBQ3RD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O0lBRUFiLGFBQWM7UUFDWixJQUFJLENBQUNqQixLQUFLLEdBQUc7WUFDWEMsTUFBTUM7WUFDTkYsT0FBT0U7WUFDUEMsSUFBSUQ7WUFDSkUsT0FBT0Y7UUFDVDtJQUNGO0FBQ0Y7QUFFQTZCLE9BQU9DLE9BQU8sR0FBRztJQUNmMUM7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL21vY2t1cGZsb3cvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZXZlbnRzb3VyY2UvZXZlbnRzb3VyY2Utc3RyZWFtLmpzP2UzMWUiLCJ3ZWJwYWNrOi8vbW9ja3VwZmxvdy8uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL3dlYi9ldmVudHNvdXJjZS9ldmVudHNvdXJjZS1zdHJlYW0uanM/ZTMxZSoiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5jb25zdCB7IFRyYW5zZm9ybSB9ID0gcmVxdWlyZSgnbm9kZTpzdHJlYW0nKVxuY29uc3QgeyBpc0FTQ0lJTnVtYmVyLCBpc1ZhbGlkTGFzdEV2ZW50SWQgfSA9IHJlcXVpcmUoJy4vdXRpbCcpXG5cbi8qKlxuICogQHR5cGUge251bWJlcltdfSBCT01cbiAqL1xuY29uc3QgQk9NID0gWzB4RUYsIDB4QkIsIDB4QkZdXG4vKipcbiAqIEB0eXBlIHsxMH0gTEZcbiAqL1xuY29uc3QgTEYgPSAweDBBXG4vKipcbiAqIEB0eXBlIHsxM30gQ1JcbiAqL1xuY29uc3QgQ1IgPSAweDBEXG4vKipcbiAqIEB0eXBlIHs1OH0gQ09MT05cbiAqL1xuY29uc3QgQ09MT04gPSAweDNBXG4vKipcbiAqIEB0eXBlIHszMn0gU1BBQ0VcbiAqL1xuY29uc3QgU1BBQ0UgPSAweDIwXG5cbi8qKlxuICogQHR5cGVkZWYge29iamVjdH0gRXZlbnRTb3VyY2VTdHJlYW1FdmVudFxuICogQHR5cGUge29iamVjdH1cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbZXZlbnRdIFRoZSBldmVudCB0eXBlLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtkYXRhXSBUaGUgZGF0YSBvZiB0aGUgbWVzc2FnZS5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbaWRdIEEgdW5pcXVlIElEIGZvciB0aGUgZXZlbnQuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3JldHJ5XSBUaGUgcmVjb25uZWN0aW9uIHRpbWUsIGluIG1pbGxpc2Vjb25kcy5cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIGV2ZW50U291cmNlU2V0dGluZ3NcbiAqIEB0eXBlIHtvYmplY3R9XG4gKiBAcHJvcGVydHkge3N0cmluZ30gbGFzdEV2ZW50SWQgVGhlIGxhc3QgZXZlbnQgSUQgcmVjZWl2ZWQgZnJvbSB0aGUgc2VydmVyLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IG9yaWdpbiBUaGUgb3JpZ2luIG9mIHRoZSBldmVudCBzb3VyY2UuXG4gKiBAcHJvcGVydHkge251bWJlcn0gcmVjb25uZWN0aW9uVGltZSBUaGUgcmVjb25uZWN0aW9uIHRpbWUsIGluIG1pbGxpc2Vjb25kcy5cbiAqL1xuXG5jbGFzcyBFdmVudFNvdXJjZVN0cmVhbSBleHRlbmRzIFRyYW5zZm9ybSB7XG4gIC8qKlxuICAgKiBAdHlwZSB7ZXZlbnRTb3VyY2VTZXR0aW5nc31cbiAgICovXG4gIHN0YXRlID0gbnVsbFxuXG4gIC8qKlxuICAgKiBMZWFkaW5nIGJ5dGUtb3JkZXItbWFyayBjaGVjay5cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBjaGVja0JPTSA9IHRydWVcblxuICAvKipcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBjcmxmQ2hlY2sgPSBmYWxzZVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIGV2ZW50RW5kQ2hlY2sgPSBmYWxzZVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7QnVmZmVyfVxuICAgKi9cbiAgYnVmZmVyID0gbnVsbFxuXG4gIHBvcyA9IDBcblxuICBldmVudCA9IHtcbiAgICBkYXRhOiB1bmRlZmluZWQsXG4gICAgZXZlbnQ6IHVuZGVmaW5lZCxcbiAgICBpZDogdW5kZWZpbmVkLFxuICAgIHJldHJ5OiB1bmRlZmluZWRcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge2V2ZW50U291cmNlU2V0dGluZ3N9IG9wdGlvbnMuZXZlbnRTb3VyY2VTZXR0aW5nc1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5wdXNoXVxuICAgKi9cbiAgY29uc3RydWN0b3IgKG9wdGlvbnMgPSB7fSkge1xuICAgIC8vIEVuYWJsZSBvYmplY3QgbW9kZSBhcyBFdmVudFNvdXJjZVN0cmVhbSBlbWl0cyBvYmplY3RzIG9mIHNoYXBlXG4gICAgLy8gRXZlbnRTb3VyY2VTdHJlYW1FdmVudFxuICAgIG9wdGlvbnMucmVhZGFibGVPYmplY3RNb2RlID0gdHJ1ZVxuXG4gICAgc3VwZXIob3B0aW9ucylcblxuICAgIHRoaXMuc3RhdGUgPSBvcHRpb25zLmV2ZW50U291cmNlU2V0dGluZ3MgfHwge31cbiAgICBpZiAob3B0aW9ucy5wdXNoKSB7XG4gICAgICB0aGlzLnB1c2ggPSBvcHRpb25zLnB1c2hcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGNodW5rXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBfZW5jb2RpbmdcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBfdHJhbnNmb3JtIChjaHVuaywgX2VuY29kaW5nLCBjYWxsYmFjaykge1xuICAgIGlmIChjaHVuay5sZW5ndGggPT09IDApIHtcbiAgICAgIGNhbGxiYWNrKClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIENhY2hlIHRoZSBjaHVuayBpbiB0aGUgYnVmZmVyLCBhcyB0aGUgZGF0YSBtaWdodCBub3QgYmUgY29tcGxldGUgd2hpbGVcbiAgICAvLyBwcm9jZXNzaW5nIGl0XG4gICAgLy8gVE9ETzogSW52ZXN0aWdhdGUgaWYgdGhlcmUgaXMgYSBtb3JlIHBlcmZvcm1hbnQgd2F5IHRvIGhhbmRsZVxuICAgIC8vIGluY29taW5nIGNodW5rc1xuICAgIC8vIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy91bmRpY2kvaXNzdWVzLzI2MzBcbiAgICBpZiAodGhpcy5idWZmZXIpIHtcbiAgICAgIHRoaXMuYnVmZmVyID0gQnVmZmVyLmNvbmNhdChbdGhpcy5idWZmZXIsIGNodW5rXSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5idWZmZXIgPSBjaHVua1xuICAgIH1cblxuICAgIC8vIFN0cmlwIGxlYWRpbmcgYnl0ZS1vcmRlci1tYXJrIGlmIHdlIG9wZW5lZCB0aGUgc3RyZWFtIGFuZCBzdGFydGVkXG4gICAgLy8gdGhlIHByb2Nlc3Npbmcgb2YgdGhlIGluY29taW5nIGRhdGFcbiAgICBpZiAodGhpcy5jaGVja0JPTSkge1xuICAgICAgc3dpdGNoICh0aGlzLmJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBmaXJzdCBieXRlIGlzIHRoZSBzYW1lIGFzIHRoZSBmaXJzdCBieXRlIG9mIHRoZSBCT01cbiAgICAgICAgICBpZiAodGhpcy5idWZmZXJbMF0gPT09IEJPTVswXSkge1xuICAgICAgICAgICAgLy8gSWYgaXQgaXMsIHdlIG5lZWQgdG8gd2FpdCBmb3IgbW9yZSBkYXRhXG4gICAgICAgICAgICBjYWxsYmFjaygpXG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gU2V0IHRoZSBjaGVja0JPTSBmbGFnIHRvIGZhbHNlIGFzIHdlIGRvbid0IG5lZWQgdG8gY2hlY2sgZm9yIHRoZVxuICAgICAgICAgIC8vIEJPTSBhbnltb3JlXG4gICAgICAgICAgdGhpcy5jaGVja0JPTSA9IGZhbHNlXG5cbiAgICAgICAgICAvLyBUaGUgYnVmZmVyIG9ubHkgY29udGFpbnMgb25lIGJ5dGUgc28gd2UgbmVlZCB0byB3YWl0IGZvciBtb3JlIGRhdGFcbiAgICAgICAgICBjYWxsYmFjaygpXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgZmlyc3QgdHdvIGJ5dGVzIGFyZSB0aGUgc2FtZSBhcyB0aGUgZmlyc3QgdHdvIGJ5dGVzXG4gICAgICAgICAgLy8gb2YgdGhlIEJPTVxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyWzBdID09PSBCT01bMF0gJiZcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyWzFdID09PSBCT01bMV1cbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIC8vIElmIGl0IGlzLCB3ZSBuZWVkIHRvIHdhaXQgZm9yIG1vcmUgZGF0YSwgYmVjYXVzZSB0aGUgdGhpcmQgYnl0ZVxuICAgICAgICAgICAgLy8gaXMgbmVlZGVkIHRvIGRldGVybWluZSBpZiBpdCBpcyB0aGUgQk9NIG9yIG5vdFxuICAgICAgICAgICAgY2FsbGJhY2soKVxuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gU2V0IHRoZSBjaGVja0JPTSBmbGFnIHRvIGZhbHNlIGFzIHdlIGRvbid0IG5lZWQgdG8gY2hlY2sgZm9yIHRoZVxuICAgICAgICAgIC8vIEJPTSBhbnltb3JlXG4gICAgICAgICAgdGhpcy5jaGVja0JPTSA9IGZhbHNlXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBmaXJzdCB0aHJlZSBieXRlcyBhcmUgdGhlIHNhbWUgYXMgdGhlIGZpcnN0IHRocmVlXG4gICAgICAgICAgLy8gYnl0ZXMgb2YgdGhlIEJPTVxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyWzBdID09PSBCT01bMF0gJiZcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyWzFdID09PSBCT01bMV0gJiZcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyWzJdID09PSBCT01bMl1cbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIC8vIElmIGl0IGlzLCB3ZSBjYW4gZHJvcCB0aGUgYnVmZmVyZWQgZGF0YSwgYXMgaXQgaXMgb25seSB0aGUgQk9NXG4gICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygwKVxuICAgICAgICAgICAgLy8gU2V0IHRoZSBjaGVja0JPTSBmbGFnIHRvIGZhbHNlIGFzIHdlIGRvbid0IG5lZWQgdG8gY2hlY2sgZm9yIHRoZVxuICAgICAgICAgICAgLy8gQk9NIGFueW1vcmVcbiAgICAgICAgICAgIHRoaXMuY2hlY2tCT00gPSBmYWxzZVxuXG4gICAgICAgICAgICAvLyBBd2FpdCBtb3JlIGRhdGFcbiAgICAgICAgICAgIGNhbGxiYWNrKClcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBJZiBpdCBpcyBub3QgdGhlIEJPTSwgd2UgY2FuIHN0YXJ0IHByb2Nlc3NpbmcgdGhlIGRhdGFcbiAgICAgICAgICB0aGlzLmNoZWNrQk9NID0gZmFsc2VcbiAgICAgICAgICBicmVha1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIC8vIFRoZSBidWZmZXIgaXMgbG9uZ2VyIHRoYW4gMyBieXRlcywgc28gd2UgY2FuIGRyb3AgdGhlIEJPTSBpZiBpdCBpc1xuICAgICAgICAgIC8vIHByZXNlbnRcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICB0aGlzLmJ1ZmZlclswXSA9PT0gQk9NWzBdICYmXG4gICAgICAgICAgICB0aGlzLmJ1ZmZlclsxXSA9PT0gQk9NWzFdICYmXG4gICAgICAgICAgICB0aGlzLmJ1ZmZlclsyXSA9PT0gQk9NWzJdXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICAvLyBSZW1vdmUgdGhlIEJPTSBmcm9tIHRoZSBidWZmZXJcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gdGhpcy5idWZmZXIuc3ViYXJyYXkoMylcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBTZXQgdGhlIGNoZWNrQk9NIGZsYWcgdG8gZmFsc2UgYXMgd2UgZG9uJ3QgbmVlZCB0byBjaGVjayBmb3IgdGhlXG4gICAgICAgICAgdGhpcy5jaGVja0JPTSA9IGZhbHNlXG4gICAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB3aGlsZSAodGhpcy5wb3MgPCB0aGlzLmJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgIC8vIElmIHRoZSBwcmV2aW91cyBsaW5lIGVuZGVkIHdpdGggYW4gZW5kLW9mLWxpbmUsIHdlIG5lZWQgdG8gY2hlY2tcbiAgICAgIC8vIGlmIHRoZSBuZXh0IGNoYXJhY3RlciBpcyBhbHNvIGFuIGVuZC1vZi1saW5lLlxuICAgICAgaWYgKHRoaXMuZXZlbnRFbmRDaGVjaykge1xuICAgICAgICAvLyBJZiB0aGUgdGhlIGN1cnJlbnQgY2hhcmFjdGVyIGlzIGFuIGVuZC1vZi1saW5lLCB0aGVuIHRoZSBldmVudFxuICAgICAgICAvLyBpcyBmaW5pc2hlZCBhbmQgd2UgY2FuIHByb2Nlc3MgaXRcblxuICAgICAgICAvLyBJZiB0aGUgcHJldmlvdXMgbGluZSBlbmRlZCB3aXRoIGEgY2FycmlhZ2UgcmV0dXJuLCB3ZSBuZWVkIHRvXG4gICAgICAgIC8vIGNoZWNrIGlmIHRoZSBjdXJyZW50IGNoYXJhY3RlciBpcyBhIGxpbmUgZmVlZCBhbmQgcmVtb3ZlIGl0XG4gICAgICAgIC8vIGZyb20gdGhlIGJ1ZmZlci5cbiAgICAgICAgaWYgKHRoaXMuY3JsZkNoZWNrKSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGN1cnJlbnQgY2hhcmFjdGVyIGlzIGEgbGluZSBmZWVkLCB3ZSBjYW4gcmVtb3ZlIGl0XG4gICAgICAgICAgLy8gZnJvbSB0aGUgYnVmZmVyIGFuZCByZXNldCB0aGUgY3JsZkNoZWNrIGZsYWdcbiAgICAgICAgICBpZiAodGhpcy5idWZmZXJbdGhpcy5wb3NdID09PSBMRikge1xuICAgICAgICAgICAgdGhpcy5idWZmZXIgPSB0aGlzLmJ1ZmZlci5zdWJhcnJheSh0aGlzLnBvcyArIDEpXG4gICAgICAgICAgICB0aGlzLnBvcyA9IDBcbiAgICAgICAgICAgIHRoaXMuY3JsZkNoZWNrID0gZmFsc2VcblxuICAgICAgICAgICAgLy8gSXQgaXMgcG9zc2libGUgdGhhdCB0aGUgbGluZSBmZWVkIGlzIG5vdCB0aGUgZW5kIG9mIHRoZVxuICAgICAgICAgICAgLy8gZXZlbnQuIFdlIG5lZWQgdG8gY2hlY2sgaWYgdGhlIG5leHQgY2hhcmFjdGVyIGlzIGFuXG4gICAgICAgICAgICAvLyBlbmQtb2YtbGluZSBjaGFyYWN0ZXIgdG8gZGV0ZXJtaW5lIGlmIHRoZSBldmVudCBpc1xuICAgICAgICAgICAgLy8gZmluaXNoZWQuIFdlIHNpbXBseSBjb250aW51ZSB0aGUgbG9vcCB0byBjaGVjayB0aGUgbmV4dFxuICAgICAgICAgICAgLy8gY2hhcmFjdGVyLlxuXG4gICAgICAgICAgICAvLyBBcyB3ZSByZW1vdmVkIHRoZSBsaW5lIGZlZWQgZnJvbSB0aGUgYnVmZmVyIGFuZCBzZXQgdGhlXG4gICAgICAgICAgICAvLyBjcmxmQ2hlY2sgZmxhZyB0byBmYWxzZSwgd2UgYmFzaWNhbGx5IGRvbid0IG1ha2UgYW55XG4gICAgICAgICAgICAvLyBkaXN0aW5jdGlvbiBiZXR3ZWVuIGEgbGluZSBmZWVkIGFuZCBhIGNhcnJpYWdlIHJldHVybi5cbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuY3JsZkNoZWNrID0gZmFsc2VcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmJ1ZmZlclt0aGlzLnBvc10gPT09IExGIHx8IHRoaXMuYnVmZmVyW3RoaXMucG9zXSA9PT0gQ1IpIHtcbiAgICAgICAgICAvLyBJZiB0aGUgY3VycmVudCBjaGFyYWN0ZXIgaXMgYSBjYXJyaWFnZSByZXR1cm4sIHdlIG5lZWQgdG9cbiAgICAgICAgICAvLyBzZXQgdGhlIGNybGZDaGVjayBmbGFnIHRvIHRydWUsIGFzIHdlIG5lZWQgdG8gY2hlY2sgaWYgdGhlXG4gICAgICAgICAgLy8gbmV4dCBjaGFyYWN0ZXIgaXMgYSBsaW5lIGZlZWQgc28gd2UgY2FuIHJlbW92ZSBpdCBmcm9tIHRoZVxuICAgICAgICAgIC8vIGJ1ZmZlclxuICAgICAgICAgIGlmICh0aGlzLmJ1ZmZlclt0aGlzLnBvc10gPT09IENSKSB7XG4gICAgICAgICAgICB0aGlzLmNybGZDaGVjayA9IHRydWVcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmJ1ZmZlciA9IHRoaXMuYnVmZmVyLnN1YmFycmF5KHRoaXMucG9zICsgMSlcbiAgICAgICAgICB0aGlzLnBvcyA9IDBcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICB0aGlzLmV2ZW50LmRhdGEgIT09IHVuZGVmaW5lZCB8fCB0aGlzLmV2ZW50LmV2ZW50IHx8IHRoaXMuZXZlbnQuaWQgfHwgdGhpcy5ldmVudC5yZXRyeSkge1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzRXZlbnQodGhpcy5ldmVudClcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5jbGVhckV2ZW50KClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZSBjdXJyZW50IGNoYXJhY3RlciBpcyBub3QgYW4gZW5kLW9mLWxpbmUsIHRoZW4gdGhlIGV2ZW50XG4gICAgICAgIC8vIGlzIG5vdCBmaW5pc2hlZCBhbmQgd2UgaGF2ZSB0byByZXNldCB0aGUgZXZlbnRFbmRDaGVjayBmbGFnXG4gICAgICAgIHRoaXMuZXZlbnRFbmRDaGVjayA9IGZhbHNlXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIElmIHRoZSBjdXJyZW50IGNoYXJhY3RlciBpcyBhbiBlbmQtb2YtbGluZSwgd2UgY2FuIHByb2Nlc3MgdGhlXG4gICAgICAvLyBsaW5lXG4gICAgICBpZiAodGhpcy5idWZmZXJbdGhpcy5wb3NdID09PSBMRiB8fCB0aGlzLmJ1ZmZlclt0aGlzLnBvc10gPT09IENSKSB7XG4gICAgICAgIC8vIElmIHRoZSBjdXJyZW50IGNoYXJhY3RlciBpcyBhIGNhcnJpYWdlIHJldHVybiwgd2UgbmVlZCB0b1xuICAgICAgICAvLyBzZXQgdGhlIGNybGZDaGVjayBmbGFnIHRvIHRydWUsIGFzIHdlIG5lZWQgdG8gY2hlY2sgaWYgdGhlXG4gICAgICAgIC8vIG5leHQgY2hhcmFjdGVyIGlzIGEgbGluZSBmZWVkXG4gICAgICAgIGlmICh0aGlzLmJ1ZmZlclt0aGlzLnBvc10gPT09IENSKSB7XG4gICAgICAgICAgdGhpcy5jcmxmQ2hlY2sgPSB0cnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyBJbiBhbnkgY2FzZSwgd2UgY2FuIHByb2Nlc3MgdGhlIGxpbmUgYXMgd2UgcmVhY2hlZCBhblxuICAgICAgICAvLyBlbmQtb2YtbGluZSBjaGFyYWN0ZXJcbiAgICAgICAgdGhpcy5wYXJzZUxpbmUodGhpcy5idWZmZXIuc3ViYXJyYXkoMCwgdGhpcy5wb3MpLCB0aGlzLmV2ZW50KVxuXG4gICAgICAgIC8vIFJlbW92ZSB0aGUgcHJvY2Vzc2VkIGxpbmUgZnJvbSB0aGUgYnVmZmVyXG4gICAgICAgIHRoaXMuYnVmZmVyID0gdGhpcy5idWZmZXIuc3ViYXJyYXkodGhpcy5wb3MgKyAxKVxuICAgICAgICAvLyBSZXNldCB0aGUgcG9zaXRpb24gYXMgd2UgcmVtb3ZlZCB0aGUgcHJvY2Vzc2VkIGxpbmUgZnJvbSB0aGUgYnVmZmVyXG4gICAgICAgIHRoaXMucG9zID0gMFxuICAgICAgICAvLyBBIGxpbmUgd2FzIHByb2Nlc3NlZCBhbmQgdGhpcyBjb3VsZCBiZSB0aGUgZW5kIG9mIHRoZSBldmVudC4gV2UgbmVlZFxuICAgICAgICAvLyB0byBjaGVjayBpZiB0aGUgbmV4dCBsaW5lIGlzIGVtcHR5IHRvIGRldGVybWluZSBpZiB0aGUgZXZlbnQgaXNcbiAgICAgICAgLy8gZmluaXNoZWQuXG4gICAgICAgIHRoaXMuZXZlbnRFbmRDaGVjayA9IHRydWVcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgdGhpcy5wb3MrK1xuICAgIH1cblxuICAgIGNhbGxiYWNrKClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gbGluZVxuICAgKiBAcGFyYW0ge0V2ZW50U3RyZWFtRXZlbnR9IGV2ZW50XG4gICAqL1xuICBwYXJzZUxpbmUgKGxpbmUsIGV2ZW50KSB7XG4gICAgLy8gSWYgdGhlIGxpbmUgaXMgZW1wdHkgKGEgYmxhbmsgbGluZSlcbiAgICAvLyBEaXNwYXRjaCB0aGUgZXZlbnQsIGFzIGRlZmluZWQgYmVsb3cuXG4gICAgLy8gVGhpcyB3aWxsIGJlIGhhbmRsZWQgaW4gdGhlIF90cmFuc2Zvcm0gbWV0aG9kXG4gICAgaWYgKGxpbmUubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgbGluZSBzdGFydHMgd2l0aCBhIFUrMDAzQSBDT0xPTiBjaGFyYWN0ZXIgKDopXG4gICAgLy8gSWdub3JlIHRoZSBsaW5lLlxuICAgIGNvbnN0IGNvbG9uUG9zaXRpb24gPSBsaW5lLmluZGV4T2YoQ09MT04pXG4gICAgaWYgKGNvbG9uUG9zaXRpb24gPT09IDApIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGxldCBmaWVsZCA9ICcnXG4gICAgbGV0IHZhbHVlID0gJydcblxuICAgIC8vIElmIHRoZSBsaW5lIGNvbnRhaW5zIGEgVSswMDNBIENPTE9OIGNoYXJhY3RlciAoOilcbiAgICBpZiAoY29sb25Qb3NpdGlvbiAhPT0gLTEpIHtcbiAgICAgIC8vIENvbGxlY3QgdGhlIGNoYXJhY3RlcnMgb24gdGhlIGxpbmUgYmVmb3JlIHRoZSBmaXJzdCBVKzAwM0EgQ09MT05cbiAgICAgIC8vIGNoYXJhY3RlciAoOiksIGFuZCBsZXQgZmllbGQgYmUgdGhhdCBzdHJpbmcuXG4gICAgICAvLyBUT0RPOiBJbnZlc3RpZ2F0ZSBpZiB0aGVyZSBpcyBhIG1vcmUgcGVyZm9ybWFudCB3YXkgdG8gZXh0cmFjdCB0aGVcbiAgICAgIC8vIGZpZWxkXG4gICAgICAvLyBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvdW5kaWNpL2lzc3Vlcy8yNjMwXG4gICAgICBmaWVsZCA9IGxpbmUuc3ViYXJyYXkoMCwgY29sb25Qb3NpdGlvbikudG9TdHJpbmcoJ3V0ZjgnKVxuXG4gICAgICAvLyBDb2xsZWN0IHRoZSBjaGFyYWN0ZXJzIG9uIHRoZSBsaW5lIGFmdGVyIHRoZSBmaXJzdCBVKzAwM0EgQ09MT05cbiAgICAgIC8vIGNoYXJhY3RlciAoOiksIGFuZCBsZXQgdmFsdWUgYmUgdGhhdCBzdHJpbmcuXG4gICAgICAvLyBJZiB2YWx1ZSBzdGFydHMgd2l0aCBhIFUrMDAyMCBTUEFDRSBjaGFyYWN0ZXIsIHJlbW92ZSBpdCBmcm9tIHZhbHVlLlxuICAgICAgbGV0IHZhbHVlU3RhcnQgPSBjb2xvblBvc2l0aW9uICsgMVxuICAgICAgaWYgKGxpbmVbdmFsdWVTdGFydF0gPT09IFNQQUNFKSB7XG4gICAgICAgICsrdmFsdWVTdGFydFxuICAgICAgfVxuICAgICAgLy8gVE9ETzogSW52ZXN0aWdhdGUgaWYgdGhlcmUgaXMgYSBtb3JlIHBlcmZvcm1hbnQgd2F5IHRvIGV4dHJhY3QgdGhlXG4gICAgICAvLyB2YWx1ZVxuICAgICAgLy8gc2VlOiBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL3VuZGljaS9pc3N1ZXMvMjYzMFxuICAgICAgdmFsdWUgPSBsaW5lLnN1YmFycmF5KHZhbHVlU3RhcnQpLnRvU3RyaW5nKCd1dGY4JylcblxuICAgICAgLy8gT3RoZXJ3aXNlLCB0aGUgc3RyaW5nIGlzIG5vdCBlbXB0eSBidXQgZG9lcyBub3QgY29udGFpbiBhIFUrMDAzQSBDT0xPTlxuICAgICAgLy8gY2hhcmFjdGVyICg6KVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBQcm9jZXNzIHRoZSBmaWVsZCB1c2luZyB0aGUgc3RlcHMgZGVzY3JpYmVkIGJlbG93LCB1c2luZyB0aGUgd2hvbGVcbiAgICAgIC8vIGxpbmUgYXMgdGhlIGZpZWxkIG5hbWUsIGFuZCB0aGUgZW1wdHkgc3RyaW5nIGFzIHRoZSBmaWVsZCB2YWx1ZS5cbiAgICAgIGZpZWxkID0gbGluZS50b1N0cmluZygndXRmOCcpXG4gICAgICB2YWx1ZSA9ICcnXG4gICAgfVxuXG4gICAgLy8gTW9kaWZ5IHRoZSBldmVudCB3aXRoIHRoZSBmaWVsZCBuYW1lIGFuZCB2YWx1ZS4gVGhlIHZhbHVlIGlzIGFsc29cbiAgICAvLyBkZWNvZGVkIGFzIFVURi04XG4gICAgc3dpdGNoIChmaWVsZCkge1xuICAgICAgY2FzZSAnZGF0YSc6XG4gICAgICAgIGlmIChldmVudFtmaWVsZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGV2ZW50W2ZpZWxkXSA9IHZhbHVlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZXZlbnRbZmllbGRdICs9IGBcXG4ke3ZhbHVlfWBcbiAgICAgICAgfVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAncmV0cnknOlxuICAgICAgICBpZiAoaXNBU0NJSU51bWJlcih2YWx1ZSkpIHtcbiAgICAgICAgICBldmVudFtmaWVsZF0gPSB2YWx1ZVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdpZCc6XG4gICAgICAgIGlmIChpc1ZhbGlkTGFzdEV2ZW50SWQodmFsdWUpKSB7XG4gICAgICAgICAgZXZlbnRbZmllbGRdID0gdmFsdWVcbiAgICAgICAgfVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAnZXZlbnQnOlxuICAgICAgICBpZiAodmFsdWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGV2ZW50W2ZpZWxkXSA9IHZhbHVlXG4gICAgICAgIH1cbiAgICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtFdmVudFNvdXJjZVN0cmVhbUV2ZW50fSBldmVudFxuICAgKi9cbiAgcHJvY2Vzc0V2ZW50IChldmVudCkge1xuICAgIGlmIChldmVudC5yZXRyeSAmJiBpc0FTQ0lJTnVtYmVyKGV2ZW50LnJldHJ5KSkge1xuICAgICAgdGhpcy5zdGF0ZS5yZWNvbm5lY3Rpb25UaW1lID0gcGFyc2VJbnQoZXZlbnQucmV0cnksIDEwKVxuICAgIH1cblxuICAgIGlmIChldmVudC5pZCAmJiBpc1ZhbGlkTGFzdEV2ZW50SWQoZXZlbnQuaWQpKSB7XG4gICAgICB0aGlzLnN0YXRlLmxhc3RFdmVudElkID0gZXZlbnQuaWRcbiAgICB9XG5cbiAgICAvLyBvbmx5IGRpc3BhdGNoIGV2ZW50LCB3aGVuIGRhdGEgaXMgcHJvdmlkZWRcbiAgICBpZiAoZXZlbnQuZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLnB1c2goe1xuICAgICAgICB0eXBlOiBldmVudC5ldmVudCB8fCAnbWVzc2FnZScsXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICBkYXRhOiBldmVudC5kYXRhLFxuICAgICAgICAgIGxhc3RFdmVudElkOiB0aGlzLnN0YXRlLmxhc3RFdmVudElkLFxuICAgICAgICAgIG9yaWdpbjogdGhpcy5zdGF0ZS5vcmlnaW5cbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICBjbGVhckV2ZW50ICgpIHtcbiAgICB0aGlzLmV2ZW50ID0ge1xuICAgICAgZGF0YTogdW5kZWZpbmVkLFxuICAgICAgZXZlbnQ6IHVuZGVmaW5lZCxcbiAgICAgIGlkOiB1bmRlZmluZWQsXG4gICAgICByZXRyeTogdW5kZWZpbmVkXG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBFdmVudFNvdXJjZVN0cmVhbVxufVxuIl0sIm5hbWVzIjpbIlRyYW5zZm9ybSIsInJlcXVpcmUiLCJpc0FTQ0lJTnVtYmVyIiwiaXNWYWxpZExhc3RFdmVudElkIiwiQk9NIiwiTEYiLCJDUiIsIkNPTE9OIiwiU1BBQ0UiLCJFdmVudFNvdXJjZVN0cmVhbSIsImNvbnN0cnVjdG9yIiwib3B0aW9ucyIsInJlYWRhYmxlT2JqZWN0TW9kZSIsInN0YXRlIiwiY2hlY2tCT00iLCJjcmxmQ2hlY2siLCJldmVudEVuZENoZWNrIiwiYnVmZmVyIiwicG9zIiwiZXZlbnQiLCJkYXRhIiwidW5kZWZpbmVkIiwiaWQiLCJyZXRyeSIsImV2ZW50U291cmNlU2V0dGluZ3MiLCJwdXNoIiwiX3RyYW5zZm9ybSIsImNodW5rIiwiX2VuY29kaW5nIiwiY2FsbGJhY2siLCJsZW5ndGgiLCJCdWZmZXIiLCJjb25jYXQiLCJhbGxvYyIsInN1YmFycmF5IiwicHJvY2Vzc0V2ZW50IiwiY2xlYXJFdmVudCIsInBhcnNlTGluZSIsImxpbmUiLCJjb2xvblBvc2l0aW9uIiwiaW5kZXhPZiIsImZpZWxkIiwidmFsdWUiLCJ0b1N0cmluZyIsInZhbHVlU3RhcnQiLCJyZWNvbm5lY3Rpb25UaW1lIiwicGFyc2VJbnQiLCJsYXN0RXZlbnRJZCIsInR5cGUiLCJvcmlnaW4iLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/eventsource/eventsource-stream.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/eventsource/eventsource.js":
/*!****************************************************************!*\
  !*** ./node_modules/undici/lib/web/eventsource/eventsource.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { pipeline } = __webpack_require__(/*! node:stream */ \"node:stream\");\nconst { fetching } = __webpack_require__(/*! ../fetch */ \"(ssr)/./node_modules/undici/lib/web/fetch/index.js\");\nconst { makeRequest } = __webpack_require__(/*! ../fetch/request */ \"(ssr)/./node_modules/undici/lib/web/fetch/request.js\");\nconst { webidl } = __webpack_require__(/*! ../fetch/webidl */ \"(ssr)/./node_modules/undici/lib/web/fetch/webidl.js\");\nconst { EventSourceStream } = __webpack_require__(/*! ./eventsource-stream */ \"(ssr)/./node_modules/undici/lib/web/eventsource/eventsource-stream.js\");\nconst { parseMIMEType } = __webpack_require__(/*! ../fetch/data-url */ \"(ssr)/./node_modules/undici/lib/web/fetch/data-url.js\");\nconst { createFastMessageEvent } = __webpack_require__(/*! ../websocket/events */ \"(ssr)/./node_modules/undici/lib/web/websocket/events.js\");\nconst { isNetworkError } = __webpack_require__(/*! ../fetch/response */ \"(ssr)/./node_modules/undici/lib/web/fetch/response.js\");\nconst { delay } = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/undici/lib/web/eventsource/util.js\");\nconst { kEnumerableProperty } = __webpack_require__(/*! ../../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\");\nconst { environmentSettingsObject } = __webpack_require__(/*! ../fetch/util */ \"(ssr)/./node_modules/undici/lib/web/fetch/util.js\");\nlet experimentalWarned = false;\n/**\n * A reconnection time, in milliseconds. This must initially be an implementation-defined value,\n * probably in the region of a few seconds.\n *\n * In Comparison:\n * - Chrome uses 3000ms.\n * - Deno uses 5000ms.\n *\n * @type {3000}\n */ const defaultReconnectionTime = 3000;\n/**\n * The readyState attribute represents the state of the connection.\n * @enum\n * @readonly\n * @see https://html.spec.whatwg.org/multipage/server-sent-events.html#dom-eventsource-readystate-dev\n */ /**\n * The connection has not yet been established, or it was closed and the user\n * agent is reconnecting.\n * @type {0}\n */ const CONNECTING = 0;\n/**\n * The user agent has an open connection and is dispatching events as it\n * receives them.\n * @type {1}\n */ const OPEN = 1;\n/**\n * The connection is not open, and the user agent is not trying to reconnect.\n * @type {2}\n */ const CLOSED = 2;\n/**\n * Requests for the element will have their mode set to \"cors\" and their credentials mode set to \"same-origin\".\n * @type {'anonymous'}\n */ const ANONYMOUS = \"anonymous\";\n/**\n * Requests for the element will have their mode set to \"cors\" and their credentials mode set to \"include\".\n * @type {'use-credentials'}\n */ const USE_CREDENTIALS = \"use-credentials\";\n/**\n * The EventSource interface is used to receive server-sent events. It\n * connects to a server over HTTP and receives events in text/event-stream\n * format without closing the connection.\n * @extends {EventTarget}\n * @see https://html.spec.whatwg.org/multipage/server-sent-events.html#server-sent-events\n * @api public\n */ class EventSource extends EventTarget {\n    #events;\n    #url;\n    #withCredentials;\n    #readyState;\n    #request;\n    #controller;\n    #dispatcher;\n    /**\n   * @type {import('./eventsource-stream').eventSourceSettings}\n   */ #state;\n    /**\n   * Creates a new EventSource object.\n   * @param {string} url\n   * @param {EventSourceInit} [eventSourceInitDict]\n   * @see https://html.spec.whatwg.org/multipage/server-sent-events.html#the-eventsource-interface\n   */ constructor(url, eventSourceInitDict = {}){\n        // 1. Let ev be a new EventSource object.\n        super();\n        this.#events = {\n            open: null,\n            error: null,\n            message: null\n        };\n        this.#url = null;\n        this.#withCredentials = false;\n        this.#readyState = CONNECTING;\n        this.#request = null;\n        this.#controller = null;\n        const prefix = \"EventSource constructor\";\n        webidl.argumentLengthCheck(arguments, 1, prefix);\n        if (!experimentalWarned) {\n            experimentalWarned = true;\n            process.emitWarning(\"EventSource is experimental, expect them to change at any time.\", {\n                code: \"UNDICI-ES\"\n            });\n        }\n        url = webidl.converters.USVString(url, prefix, \"url\");\n        eventSourceInitDict = webidl.converters.EventSourceInitDict(eventSourceInitDict, prefix, \"eventSourceInitDict\");\n        this.#dispatcher = eventSourceInitDict.dispatcher;\n        this.#state = {\n            lastEventId: \"\",\n            reconnectionTime: defaultReconnectionTime\n        };\n        // 2. Let settings be ev's relevant settings object.\n        // https://html.spec.whatwg.org/multipage/webappapis.html#environment-settings-object\n        const settings = environmentSettingsObject;\n        let urlRecord;\n        try {\n            // 3. Let urlRecord be the result of encoding-parsing a URL given url, relative to settings.\n            urlRecord = new URL(url, settings.settingsObject.baseUrl);\n            this.#state.origin = urlRecord.origin;\n        } catch (e) {\n            // 4. If urlRecord is failure, then throw a \"SyntaxError\" DOMException.\n            throw new DOMException(e, \"SyntaxError\");\n        }\n        // 5. Set ev's url to urlRecord.\n        this.#url = urlRecord.href;\n        // 6. Let corsAttributeState be Anonymous.\n        let corsAttributeState = ANONYMOUS;\n        // 7. If the value of eventSourceInitDict's withCredentials member is true,\n        // then set corsAttributeState to Use Credentials and set ev's\n        // withCredentials attribute to true.\n        if (eventSourceInitDict.withCredentials) {\n            corsAttributeState = USE_CREDENTIALS;\n            this.#withCredentials = true;\n        }\n        // 8. Let request be the result of creating a potential-CORS request given\n        // urlRecord, the empty string, and corsAttributeState.\n        const initRequest = {\n            redirect: \"follow\",\n            keepalive: true,\n            // @see https://html.spec.whatwg.org/multipage/urls-and-fetching.html#cors-settings-attributes\n            mode: \"cors\",\n            credentials: corsAttributeState === \"anonymous\" ? \"same-origin\" : \"omit\",\n            referrer: \"no-referrer\"\n        };\n        // 9. Set request's client to settings.\n        initRequest.client = environmentSettingsObject.settingsObject;\n        // 10. User agents may set (`Accept`, `text/event-stream`) in request's header list.\n        initRequest.headersList = [\n            [\n                \"accept\",\n                {\n                    name: \"accept\",\n                    value: \"text/event-stream\"\n                }\n            ]\n        ];\n        // 11. Set request's cache mode to \"no-store\".\n        initRequest.cache = \"no-store\";\n        // 12. Set request's initiator type to \"other\".\n        initRequest.initiator = \"other\";\n        initRequest.urlList = [\n            new URL(this.#url)\n        ];\n        // 13. Set ev's request to request.\n        this.#request = makeRequest(initRequest);\n        this.#connect();\n    }\n    /**\n   * Returns the state of this EventSource object's connection. It can have the\n   * values described below.\n   * @returns {0|1|2}\n   * @readonly\n   */ get readyState() {\n        return this.#readyState;\n    }\n    /**\n   * Returns the URL providing the event stream.\n   * @readonly\n   * @returns {string}\n   */ get url() {\n        return this.#url;\n    }\n    /**\n   * Returns a boolean indicating whether the EventSource object was\n   * instantiated with CORS credentials set (true), or not (false, the default).\n   */ get withCredentials() {\n        return this.#withCredentials;\n    }\n    #connect() {\n        if (this.#readyState === CLOSED) return;\n        this.#readyState = CONNECTING;\n        const fetchParams = {\n            request: this.#request,\n            dispatcher: this.#dispatcher\n        };\n        // 14. Let processEventSourceEndOfBody given response res be the following step: if res is not a network error, then reestablish the connection.\n        const processEventSourceEndOfBody = (response)=>{\n            if (isNetworkError(response)) {\n                this.dispatchEvent(new Event(\"error\"));\n                this.close();\n            }\n            this.#reconnect();\n        };\n        // 15. Fetch request, with processResponseEndOfBody set to processEventSourceEndOfBody...\n        fetchParams.processResponseEndOfBody = processEventSourceEndOfBody;\n        // and processResponse set to the following steps given response res:\n        fetchParams.processResponse = (response)=>{\n            // 1. If res is an aborted network error, then fail the connection.\n            if (isNetworkError(response)) {\n                // 1. When a user agent is to fail the connection, the user agent\n                // must queue a task which, if the readyState attribute is set to a\n                // value other than CLOSED, sets the readyState attribute to CLOSED\n                // and fires an event named error at the EventSource object. Once the\n                // user agent has failed the connection, it does not attempt to\n                // reconnect.\n                if (response.aborted) {\n                    this.close();\n                    this.dispatchEvent(new Event(\"error\"));\n                    return;\n                // 2. Otherwise, if res is a network error, then reestablish the\n                // connection, unless the user agent knows that to be futile, in\n                // which case the user agent may fail the connection.\n                } else {\n                    this.#reconnect();\n                    return;\n                }\n            }\n            // 3. Otherwise, if res's status is not 200, or if res's `Content-Type`\n            // is not `text/event-stream`, then fail the connection.\n            const contentType = response.headersList.get(\"content-type\", true);\n            const mimeType = contentType !== null ? parseMIMEType(contentType) : \"failure\";\n            const contentTypeValid = mimeType !== \"failure\" && mimeType.essence === \"text/event-stream\";\n            if (response.status !== 200 || contentTypeValid === false) {\n                this.close();\n                this.dispatchEvent(new Event(\"error\"));\n                return;\n            }\n            // 4. Otherwise, announce the connection and interpret res's body\n            // line by line.\n            // When a user agent is to announce the connection, the user agent\n            // must queue a task which, if the readyState attribute is set to a\n            // value other than CLOSED, sets the readyState attribute to OPEN\n            // and fires an event named open at the EventSource object.\n            // @see https://html.spec.whatwg.org/multipage/server-sent-events.html#sse-processing-model\n            this.#readyState = OPEN;\n            this.dispatchEvent(new Event(\"open\"));\n            // If redirected to a different origin, set the origin to the new origin.\n            this.#state.origin = response.urlList[response.urlList.length - 1].origin;\n            const eventSourceStream = new EventSourceStream({\n                eventSourceSettings: this.#state,\n                push: (event)=>{\n                    this.dispatchEvent(createFastMessageEvent(event.type, event.options));\n                }\n            });\n            pipeline(response.body.stream, eventSourceStream, (error)=>{\n                if (error?.aborted === false) {\n                    this.close();\n                    this.dispatchEvent(new Event(\"error\"));\n                }\n            });\n        };\n        this.#controller = fetching(fetchParams);\n    }\n    /**\n   * @see https://html.spec.whatwg.org/multipage/server-sent-events.html#sse-processing-model\n   * @returns {Promise<void>}\n   */ async #reconnect() {\n        // When a user agent is to reestablish the connection, the user agent must\n        // run the following steps. These steps are run in parallel, not as part of\n        // a task. (The tasks that it queues, of course, are run like normal tasks\n        // and not themselves in parallel.)\n        // 1. Queue a task to run the following steps:\n        //   1. If the readyState attribute is set to CLOSED, abort the task.\n        if (this.#readyState === CLOSED) return;\n        //   2. Set the readyState attribute to CONNECTING.\n        this.#readyState = CONNECTING;\n        //   3. Fire an event named error at the EventSource object.\n        this.dispatchEvent(new Event(\"error\"));\n        // 2. Wait a delay equal to the reconnection time of the event source.\n        await delay(this.#state.reconnectionTime);\n        // 5. Queue a task to run the following steps:\n        //   1. If the EventSource object's readyState attribute is not set to\n        //      CONNECTING, then return.\n        if (this.#readyState !== CONNECTING) return;\n        //   2. Let request be the EventSource object's request.\n        //   3. If the EventSource object's last event ID string is not the empty\n        //      string, then:\n        //      1. Let lastEventIDValue be the EventSource object's last event ID\n        //         string, encoded as UTF-8.\n        //      2. Set (`Last-Event-ID`, lastEventIDValue) in request's header\n        //         list.\n        if (this.#state.lastEventId.length) {\n            this.#request.headersList.set(\"last-event-id\", this.#state.lastEventId, true);\n        }\n        //   4. Fetch request and process the response obtained in this fashion, if any, as described earlier in this section.\n        this.#connect();\n    }\n    /**\n   * Closes the connection, if any, and sets the readyState attribute to\n   * CLOSED.\n   */ close() {\n        webidl.brandCheck(this, EventSource);\n        if (this.#readyState === CLOSED) return;\n        this.#readyState = CLOSED;\n        this.#controller.abort();\n        this.#request = null;\n    }\n    get onopen() {\n        return this.#events.open;\n    }\n    set onopen(fn) {\n        if (this.#events.open) {\n            this.removeEventListener(\"open\", this.#events.open);\n        }\n        if (typeof fn === \"function\") {\n            this.#events.open = fn;\n            this.addEventListener(\"open\", fn);\n        } else {\n            this.#events.open = null;\n        }\n    }\n    get onmessage() {\n        return this.#events.message;\n    }\n    set onmessage(fn) {\n        if (this.#events.message) {\n            this.removeEventListener(\"message\", this.#events.message);\n        }\n        if (typeof fn === \"function\") {\n            this.#events.message = fn;\n            this.addEventListener(\"message\", fn);\n        } else {\n            this.#events.message = null;\n        }\n    }\n    get onerror() {\n        return this.#events.error;\n    }\n    set onerror(fn) {\n        if (this.#events.error) {\n            this.removeEventListener(\"error\", this.#events.error);\n        }\n        if (typeof fn === \"function\") {\n            this.#events.error = fn;\n            this.addEventListener(\"error\", fn);\n        } else {\n            this.#events.error = null;\n        }\n    }\n}\nconst constantsPropertyDescriptors = {\n    CONNECTING: {\n        __proto__: null,\n        configurable: false,\n        enumerable: true,\n        value: CONNECTING,\n        writable: false\n    },\n    OPEN: {\n        __proto__: null,\n        configurable: false,\n        enumerable: true,\n        value: OPEN,\n        writable: false\n    },\n    CLOSED: {\n        __proto__: null,\n        configurable: false,\n        enumerable: true,\n        value: CLOSED,\n        writable: false\n    }\n};\nObject.defineProperties(EventSource, constantsPropertyDescriptors);\nObject.defineProperties(EventSource.prototype, constantsPropertyDescriptors);\nObject.defineProperties(EventSource.prototype, {\n    close: kEnumerableProperty,\n    onerror: kEnumerableProperty,\n    onmessage: kEnumerableProperty,\n    onopen: kEnumerableProperty,\n    readyState: kEnumerableProperty,\n    url: kEnumerableProperty,\n    withCredentials: kEnumerableProperty\n});\nwebidl.converters.EventSourceInitDict = webidl.dictionaryConverter([\n    {\n        key: \"withCredentials\",\n        converter: webidl.converters.boolean,\n        defaultValue: ()=>false\n    },\n    {\n        key: \"dispatcher\",\n        // undici only\n        converter: webidl.converters.any\n    }\n]);\nmodule.exports = {\n    EventSource,\n    defaultReconnectionTime\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZXZlbnRzb3VyY2UvZXZlbnRzb3VyY2UuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNLEVBQUVBLFFBQUFBLEVBQVUsR0FBR0MsbUJBQU9BLENBQUM7QUFDN0IsTUFBTSxFQUFFQyxRQUFBQSxFQUFVLEdBQUdELG1CQUFPQSxDQUFDO0FBQzdCLE1BQU0sRUFBRUUsV0FBQUEsRUFBYSxHQUFHRixtQkFBT0EsQ0FBQztBQUNoQyxNQUFNLEVBQUVHLE1BQUFBLEVBQVEsR0FBR0gsbUJBQU9BLENBQUM7QUFDM0IsTUFBTSxFQUFFSSxpQkFBQUEsRUFBbUIsR0FBR0osbUJBQU9BLENBQUM7QUFDdEMsTUFBTSxFQUFFSyxhQUFBQSxFQUFlLEdBQUdMLG1CQUFPQSxDQUFDO0FBQ2xDLE1BQU0sRUFBRU0sc0JBQUFBLEVBQXdCLEdBQUdOLG1CQUFPQSxDQUFDO0FBQzNDLE1BQU0sRUFBRU8sY0FBQUEsRUFBZ0IsR0FBR1AsbUJBQU9BLENBQUM7QUFDbkMsTUFBTSxFQUFFUSxLQUFBQSxFQUFPLEdBQUdSLG1CQUFPQSxDQUFDO0FBQzFCLE1BQU0sRUFBRVMsbUJBQUFBLEVBQXFCLEdBQUdULG1CQUFPQSxDQUFDO0FBQ3hDLE1BQU0sRUFBRVUseUJBQUFBLEVBQTJCLEdBQUdWLG1CQUFPQSxDQUFDO0FBRTlDLElBQUlXLHFCQUFxQjtBQUV6Qjs7Ozs7Ozs7O0NBU0EsR0FDQSxNQUFNQywwQkFBMEI7QUFFaEM7Ozs7O0NBS0EsR0FFQTs7OztDQUlBLEdBQ0EsTUFBTUMsYUFBYTtBQUVuQjs7OztDQUlBLEdBQ0EsTUFBTUMsT0FBTztBQUViOzs7Q0FHQSxHQUNBLE1BQU1DLFNBQVM7QUFFZjs7O0NBR0EsR0FDQSxNQUFNQyxZQUFZO0FBRWxCOzs7Q0FHQSxHQUNBLE1BQU1DLGtCQUFrQjtBQUV4Qjs7Ozs7OztDQU9BLEdBQ0EsTUFBTUMsb0JBQW9CQztJQUN4QixDQUFDQyxNQUFNLENBSU47SUFFRCxDQUFD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WTtRQUNaNUMsT0FBT2pEO1FBQ1A4RixVQUFVO0lBQ1o7SUFDQTdGLFFBQVE7UUFDTjBGLFdBQVc7UUFDWEMsY0FBYztRQUNkQyxZQUFZO1FBQ1o1QyxPQUFPaEQ7UUFDUDZGLFVBQVU7SUFDWjtBQUNGO0FBRUFDLE9BQU9DLGdCQUFnQixDQUFDNUYsYUFBYXNGO0FBQ3JDSyxPQUFPQyxnQkFBZ0IsQ0FBQzVGLFlBQVk2RixTQUFTLEVBQUVQO0FBRS9DSyxPQUFPQyxnQkFBZ0IsQ0FBQzVGLFlBQVk2RixTQUFTLEVBQUU7SUFDN0NyQyxPQUFPakU7SUFDUDhGLFNBQVM5RjtJQUNUNkYsV0FBVzdGO0lBQ1h5RixRQUFRekY7SUFDUmMsWUFBWWQ7SUFDWlksS0FBS1o7SUFDTGEsaUJBQWlCYjtBQUNuQjtBQUVBTixPQUFPb0MsVUFBVSxDQUFDRSxtQkFBbUIsR0FBR3RDLE9BQU82RyxtQkFBbUIsQ0FBQztJQUNqRTtRQUNFQyxLQUFLO1FBQ0xDLFdBQVcvRyxPQUFPb0MsVUFBVSxDQUFDNEUsT0FBTztRQUNwQ0MsY0FBY0EsSUFBTTtJQUN0QjtJQUNBO1FBQ0VILEtBQUs7UUFBYztRQUNuQkMsV0FBVy9HLE9BQU9vQyxVQUFVLENBQUM4RSxHQUFBQTtJQUMvQjtDQUNEO0FBRURDLE9BQU9DLE9BQU8sR0FBRztJQUNmckc7SUFDQU47QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL21vY2t1cGZsb3cvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZXZlbnRzb3VyY2UvZXZlbnRzb3VyY2UuanM/M2Y2YiIsIndlYnBhY2s6Ly9tb2NrdXBmbG93Ly4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvd2ViL2V2ZW50c291cmNlL2V2ZW50c291cmNlLmpzPzNmNmIqIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IHBpcGVsaW5lIH0gPSByZXF1aXJlKCdub2RlOnN0cmVhbScpXG5jb25zdCB7IGZldGNoaW5nIH0gPSByZXF1aXJlKCcuLi9mZXRjaCcpXG5jb25zdCB7IG1ha2VSZXF1ZXN0IH0gPSByZXF1aXJlKCcuLi9mZXRjaC9yZXF1ZXN0JylcbmNvbnN0IHsgd2ViaWRsIH0gPSByZXF1aXJlKCcuLi9mZXRjaC93ZWJpZGwnKVxuY29uc3QgeyBFdmVudFNvdXJjZVN0cmVhbSB9ID0gcmVxdWlyZSgnLi9ldmVudHNvdXJjZS1zdHJlYW0nKVxuY29uc3QgeyBwYXJzZU1JTUVUeXBlIH0gPSByZXF1aXJlKCcuLi9mZXRjaC9kYXRhLXVybCcpXG5jb25zdCB7IGNyZWF0ZUZhc3RNZXNzYWdlRXZlbnQgfSA9IHJlcXVpcmUoJy4uL3dlYnNvY2tldC9ldmVudHMnKVxuY29uc3QgeyBpc05ldHdvcmtFcnJvciB9ID0gcmVxdWlyZSgnLi4vZmV0Y2gvcmVzcG9uc2UnKVxuY29uc3QgeyBkZWxheSB9ID0gcmVxdWlyZSgnLi91dGlsJylcbmNvbnN0IHsga0VudW1lcmFibGVQcm9wZXJ0eSB9ID0gcmVxdWlyZSgnLi4vLi4vY29yZS91dGlsJylcbmNvbnN0IHsgZW52aXJvbm1lbnRTZXR0aW5nc09iamVjdCB9ID0gcmVxdWlyZSgnLi4vZmV0Y2gvdXRpbCcpXG5cbmxldCBleHBlcmltZW50YWxXYXJuZWQgPSBmYWxzZVxuXG4vKipcbiAqIEEgcmVjb25uZWN0aW9uIHRpbWUsIGluIG1pbGxpc2Vjb25kcy4gVGhpcyBtdXN0IGluaXRpYWxseSBiZSBhbiBpbXBsZW1lbnRhdGlvbi1kZWZpbmVkIHZhbHVlLFxuICogcHJvYmFibHkgaW4gdGhlIHJlZ2lvbiBvZiBhIGZldyBzZWNvbmRzLlxuICpcbiAqIEluIENvbXBhcmlzb246XG4gKiAtIENocm9tZSB1c2VzIDMwMDBtcy5cbiAqIC0gRGVubyB1c2VzIDUwMDBtcy5cbiAqXG4gKiBAdHlwZSB7MzAwMH1cbiAqL1xuY29uc3QgZGVmYXVsdFJlY29ubmVjdGlvblRpbWUgPSAzMDAwXG5cbi8qKlxuICogVGhlIHJlYWR5U3RhdGUgYXR0cmlidXRlIHJlcHJlc2VudHMgdGhlIHN0YXRlIG9mIHRoZSBjb25uZWN0aW9uLlxuICogQGVudW1cbiAqIEByZWFkb25seVxuICogQHNlZSBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zZXJ2ZXItc2VudC1ldmVudHMuaHRtbCNkb20tZXZlbnRzb3VyY2UtcmVhZHlzdGF0ZS1kZXZcbiAqL1xuXG4vKipcbiAqIFRoZSBjb25uZWN0aW9uIGhhcyBub3QgeWV0IGJlZW4gZXN0YWJsaXNoZWQsIG9yIGl0IHdhcyBjbG9zZWQgYW5kIHRoZSB1c2VyXG4gKiBhZ2VudCBpcyByZWNvbm5lY3RpbmcuXG4gKiBAdHlwZSB7MH1cbiAqL1xuY29uc3QgQ09OTkVDVElORyA9IDBcblxuLyoqXG4gKiBUaGUgdXNlciBhZ2VudCBoYXMgYW4gb3BlbiBjb25uZWN0aW9uIGFuZCBpcyBkaXNwYXRjaGluZyBldmVudHMgYXMgaXRcbiAqIHJlY2VpdmVzIHRoZW0uXG4gKiBAdHlwZSB7MX1cbiAqL1xuY29uc3QgT1BFTiA9IDFcblxuLyoqXG4gKiBUaGUgY29ubmVjdGlvbiBpcyBub3Qgb3BlbiwgYW5kIHRoZSB1c2VyIGFnZW50IGlzIG5vdCB0cnlpbmcgdG8gcmVjb25uZWN0LlxuICogQHR5cGUgezJ9XG4gKi9cbmNvbnN0IENMT1NFRCA9IDJcblxuLyoqXG4gKiBSZXF1ZXN0cyBmb3IgdGhlIGVsZW1lbnQgd2lsbCBoYXZlIHRoZWlyIG1vZGUgc2V0IHRvIFwiY29yc1wiIGFuZCB0aGVpciBjcmVkZW50aWFscyBtb2RlIHNldCB0byBcInNhbWUtb3JpZ2luXCIuXG4gKiBAdHlwZSB7J2Fub255bW91cyd9XG4gKi9cbmNvbnN0IEFOT05ZTU9VUyA9ICdhbm9ueW1vdXMnXG5cbi8qKlxuICogUmVxdWVzdHMgZm9yIHRoZSBlbGVtZW50IHdpbGwgaGF2ZSB0aGVpciBtb2RlIHNldCB0byBcImNvcnNcIiBhbmQgdGhlaXIgY3JlZGVudGlhbHMgbW9kZSBzZXQgdG8gXCJpbmNsdWRlXCIuXG4gKiBAdHlwZSB7J3VzZS1jcmVkZW50aWFscyd9XG4gKi9cbmNvbnN0IFVTRV9DUkVERU5USUFMUyA9ICd1c2UtY3JlZGVudGlhbHMnXG5cbi8qKlxuICogVGhlIEV2ZW50U291cmNlIGludGVyZmFjZSBpcyB1c2VkIHRvIHJlY2VpdmUgc2VydmVyLXNlbnQgZXZlbnRzLiBJdFxuICogY29ubmVjdHMgdG8gYSBzZXJ2ZXIgb3ZlciBIVFRQIGFuZCByZWNlaXZlcyBldmVudHMgaW4gdGV4dC9ldmVudC1zdHJlYW1cbiAqIGZvcm1hdCB3aXRob3V0IGNsb3NpbmcgdGhlIGNvbm5lY3Rpb24uXG4gKiBAZXh0ZW5kcyB7RXZlbnRUYXJnZXR9XG4gKiBAc2VlIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3NlcnZlci1zZW50LWV2ZW50cy5odG1sI3NlcnZlci1zZW50LWV2ZW50c1xuICogQGFwaSBwdWJsaWNcbiAqL1xuY2xhc3MgRXZlbnRTb3VyY2UgZXh0ZW5kcyBFdmVudFRhcmdldCB7XG4gICNldmVudHMgPSB7XG4gICAgb3BlbjogbnVsbCxcbiAgICBlcnJvcjogbnVsbCxcbiAgICBtZXNzYWdlOiBudWxsXG4gIH1cblxuICAjdXJsID0gbnVsbFxuICAjd2l0aENyZWRlbnRpYWxzID0gZmFsc2VcblxuICAjcmVhZHlTdGF0ZSA9IENPTk5FQ1RJTkdcblxuICAjcmVxdWVzdCA9IG51bGxcbiAgI2NvbnRyb2xsZXIgPSBudWxsXG5cbiAgI2Rpc3BhdGNoZXJcblxuICAvKipcbiAgICogQHR5cGUge2ltcG9ydCgnLi9ldmVudHNvdXJjZS1zdHJlYW0nKS5ldmVudFNvdXJjZVNldHRpbmdzfVxuICAgKi9cbiAgI3N0YXRlXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgRXZlbnRTb3VyY2Ugb2JqZWN0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsXG4gICAqIEBwYXJhbSB7RXZlbnRTb3VyY2VJbml0fSBbZXZlbnRTb3VyY2VJbml0RGljdF1cbiAgICogQHNlZSBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zZXJ2ZXItc2VudC1ldmVudHMuaHRtbCN0aGUtZXZlbnRzb3VyY2UtaW50ZXJmYWNlXG4gICAqL1xuICBjb25zdHJ1Y3RvciAodXJsLCBldmVudFNvdXJjZUluaXREaWN0ID0ge30pIHtcbiAgICAvLyAxLiBMZXQgZXYgYmUgYSBuZXcgRXZlbnRTb3VyY2Ugb2JqZWN0LlxuICAgIHN1cGVyKClcblxuICAgIGNvbnN0IHByZWZpeCA9ICdFdmVudFNvdXJjZSBjb25zdHJ1Y3RvcidcbiAgICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDEsIHByZWZpeClcblxuICAgIGlmICghZXhwZXJpbWVudGFsV2FybmVkKSB7XG4gICAgICBleHBlcmltZW50YWxXYXJuZWQgPSB0cnVlXG4gICAgICBwcm9jZXNzLmVtaXRXYXJuaW5nKCdFdmVudFNvdXJjZSBpcyBleHBlcmltZW50YWwsIGV4cGVjdCB0aGVtIHRvIGNoYW5nZSBhdCBhbnkgdGltZS4nLCB7XG4gICAgICAgIGNvZGU6ICdVTkRJQ0ktRVMnXG4gICAgICB9KVxuICAgIH1cblxuICAgIHVybCA9IHdlYmlkbC5jb252ZXJ0ZXJzLlVTVlN0cmluZyh1cmwsIHByZWZpeCwgJ3VybCcpXG4gICAgZXZlbnRTb3VyY2VJbml0RGljdCA9IHdlYmlkbC5jb252ZXJ0ZXJzLkV2ZW50U291cmNlSW5pdERpY3QoZXZlbnRTb3VyY2VJbml0RGljdCwgcHJlZml4LCAnZXZlbnRTb3VyY2VJbml0RGljdCcpXG5cbiAgICB0aGlzLiNkaXNwYXRjaGVyID0gZXZlbnRTb3VyY2VJbml0RGljdC5kaXNwYXRjaGVyXG4gICAgdGhpcy4jc3RhdGUgPSB7XG4gICAgICBsYXN0RXZlbnRJZDogJycsXG4gICAgICByZWNvbm5lY3Rpb25UaW1lOiBkZWZhdWx0UmVjb25uZWN0aW9uVGltZVxuICAgIH1cblxuICAgIC8vIDIuIExldCBzZXR0aW5ncyBiZSBldidzIHJlbGV2YW50IHNldHRpbmdzIG9iamVjdC5cbiAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS93ZWJhcHBhcGlzLmh0bWwjZW52aXJvbm1lbnQtc2V0dGluZ3Mtb2JqZWN0XG4gICAgY29uc3Qgc2V0dGluZ3MgPSBlbnZpcm9ubWVudFNldHRpbmdzT2JqZWN0XG5cbiAgICBsZXQgdXJsUmVjb3JkXG5cbiAgICB0cnkge1xuICAgICAgLy8gMy4gTGV0IHVybFJlY29yZCBiZSB0aGUgcmVzdWx0IG9mIGVuY29kaW5nLXBhcnNpbmcgYSBVUkwgZ2l2ZW4gdXJsLCByZWxhdGl2ZSB0byBzZXR0aW5ncy5cbiAgICAgIHVybFJlY29yZCA9IG5ldyBVUkwodXJsLCBzZXR0aW5ncy5zZXR0aW5nc09iamVjdC5iYXNlVXJsKVxuICAgICAgdGhpcy4jc3RhdGUub3JpZ2luID0gdXJsUmVjb3JkLm9yaWdpblxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIDQuIElmIHVybFJlY29yZCBpcyBmYWlsdXJlLCB0aGVuIHRocm93IGEgXCJTeW50YXhFcnJvclwiIERPTUV4Y2VwdGlvbi5cbiAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oZSwgJ1N5bnRheEVycm9yJylcbiAgICB9XG5cbiAgICAvLyA1LiBTZXQgZXYncyB1cmwgdG8gdXJsUmVjb3JkLlxuICAgIHRoaXMuI3VybCA9IHVybFJlY29yZC5ocmVmXG5cbiAgICAvLyA2LiBMZXQgY29yc0F0dHJpYnV0ZVN0YXRlIGJlIEFub255bW91cy5cbiAgICBsZXQgY29yc0F0dHJpYnV0ZVN0YXRlID0gQU5PTllNT1VTXG5cbiAgICAvLyA3LiBJZiB0aGUgdmFsdWUgb2YgZXZlbnRTb3VyY2VJbml0RGljdCdzIHdpdGhDcmVkZW50aWFscyBtZW1iZXIgaXMgdHJ1ZSxcbiAgICAvLyB0aGVuIHNldCBjb3JzQXR0cmlidXRlU3RhdGUgdG8gVXNlIENyZWRlbnRpYWxzIGFuZCBzZXQgZXYnc1xuICAgIC8vIHdpdGhDcmVkZW50aWFscyBhdHRyaWJ1dGUgdG8gdHJ1ZS5cbiAgICBpZiAoZXZlbnRTb3VyY2VJbml0RGljdC53aXRoQ3JlZGVudGlhbHMpIHtcbiAgICAgIGNvcnNBdHRyaWJ1dGVTdGF0ZSA9IFVTRV9DUkVERU5USUFMU1xuICAgICAgdGhpcy4jd2l0aENyZWRlbnRpYWxzID0gdHJ1ZVxuICAgIH1cblxuICAgIC8vIDguIExldCByZXF1ZXN0IGJlIHRoZSByZXN1bHQgb2YgY3JlYXRpbmcgYSBwb3RlbnRpYWwtQ09SUyByZXF1ZXN0IGdpdmVuXG4gICAgLy8gdXJsUmVjb3JkLCB0aGUgZW1wdHkgc3RyaW5nLCBhbmQgY29yc0F0dHJpYnV0ZVN0YXRlLlxuICAgIGNvbnN0IGluaXRSZXF1ZXN0ID0ge1xuICAgICAgcmVkaXJlY3Q6ICdmb2xsb3cnLFxuICAgICAga2VlcGFsaXZlOiB0cnVlLFxuICAgICAgLy8gQHNlZSBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS91cmxzLWFuZC1mZXRjaGluZy5odG1sI2NvcnMtc2V0dGluZ3MtYXR0cmlidXRlc1xuICAgICAgbW9kZTogJ2NvcnMnLFxuICAgICAgY3JlZGVudGlhbHM6IGNvcnNBdHRyaWJ1dGVTdGF0ZSA9PT0gJ2Fub255bW91cydcbiAgICAgICAgPyAnc2FtZS1vcmlnaW4nXG4gICAgICAgIDogJ29taXQnLFxuICAgICAgcmVmZXJyZXI6ICduby1yZWZlcnJlcidcbiAgICB9XG5cbiAgICAvLyA5LiBTZXQgcmVxdWVzdCdzIGNsaWVudCB0byBzZXR0aW5ncy5cbiAgICBpbml0UmVxdWVzdC5jbGllbnQgPSBlbnZpcm9ubWVudFNldHRpbmdzT2JqZWN0LnNldHRpbmdzT2JqZWN0XG5cbiAgICAvLyAxMC4gVXNlciBhZ2VudHMgbWF5IHNldCAoYEFjY2VwdGAsIGB0ZXh0L2V2ZW50LXN0cmVhbWApIGluIHJlcXVlc3QncyBoZWFkZXIgbGlzdC5cbiAgICBpbml0UmVxdWVzdC5oZWFkZXJzTGlzdCA9IFtbJ2FjY2VwdCcsIHsgbmFtZTogJ2FjY2VwdCcsIHZhbHVlOiAndGV4dC9ldmVudC1zdHJlYW0nIH1dXVxuXG4gICAgLy8gMTEuIFNldCByZXF1ZXN0J3MgY2FjaGUgbW9kZSB0byBcIm5vLXN0b3JlXCIuXG4gICAgaW5pdFJlcXVlc3QuY2FjaGUgPSAnbm8tc3RvcmUnXG5cbiAgICAvLyAxMi4gU2V0IHJlcXVlc3QncyBpbml0aWF0b3IgdHlwZSB0byBcIm90aGVyXCIuXG4gICAgaW5pdFJlcXVlc3QuaW5pdGlhdG9yID0gJ290aGVyJ1xuXG4gICAgaW5pdFJlcXVlc3QudXJsTGlzdCA9IFtuZXcgVVJMKHRoaXMuI3VybCldXG5cbiAgICAvLyAxMy4gU2V0IGV2J3MgcmVxdWVzdCB0byByZXF1ZXN0LlxuICAgIHRoaXMuI3JlcXVlc3QgPSBtYWtlUmVxdWVzdChpbml0UmVxdWVzdClcblxuICAgIHRoaXMuI2Nvbm5lY3QoKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHN0YXRlIG9mIHRoaXMgRXZlbnRTb3VyY2Ugb2JqZWN0J3MgY29ubmVjdGlvbi4gSXQgY2FuIGhhdmUgdGhlXG4gICAqIHZhbHVlcyBkZXNjcmliZWQgYmVsb3cuXG4gICAqIEByZXR1cm5zIHswfDF8Mn1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgcmVhZHlTdGF0ZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3JlYWR5U3RhdGVcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBVUkwgcHJvdmlkaW5nIHRoZSBldmVudCBzdHJlYW0uXG4gICAqIEByZWFkb25seVxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IHVybCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3VybFxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgRXZlbnRTb3VyY2Ugb2JqZWN0IHdhc1xuICAgKiBpbnN0YW50aWF0ZWQgd2l0aCBDT1JTIGNyZWRlbnRpYWxzIHNldCAodHJ1ZSksIG9yIG5vdCAoZmFsc2UsIHRoZSBkZWZhdWx0KS5cbiAgICovXG4gIGdldCB3aXRoQ3JlZGVudGlhbHMgKCkge1xuICAgIHJldHVybiB0aGlzLiN3aXRoQ3JlZGVudGlhbHNcbiAgfVxuXG4gICNjb25uZWN0ICgpIHtcbiAgICBpZiAodGhpcy4jcmVhZHlTdGF0ZSA9PT0gQ0xPU0VEKSByZXR1cm5cblxuICAgIHRoaXMuI3JlYWR5U3RhdGUgPSBDT05ORUNUSU5HXG5cbiAgICBjb25zdCBmZXRjaFBhcmFtcyA9IHtcbiAgICAgIHJlcXVlc3Q6IHRoaXMuI3JlcXVlc3QsXG4gICAgICBkaXNwYXRjaGVyOiB0aGlzLiNkaXNwYXRjaGVyXG4gICAgfVxuXG4gICAgLy8gMTQuIExldCBwcm9jZXNzRXZlbnRTb3VyY2VFbmRPZkJvZHkgZ2l2ZW4gcmVzcG9uc2UgcmVzIGJlIHRoZSBmb2xsb3dpbmcgc3RlcDogaWYgcmVzIGlzIG5vdCBhIG5ldHdvcmsgZXJyb3IsIHRoZW4gcmVlc3RhYmxpc2ggdGhlIGNvbm5lY3Rpb24uXG4gICAgY29uc3QgcHJvY2Vzc0V2ZW50U291cmNlRW5kT2ZCb2R5ID0gKHJlc3BvbnNlKSA9PiB7XG4gICAgICBpZiAoaXNOZXR3b3JrRXJyb3IocmVzcG9uc2UpKSB7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ2Vycm9yJykpXG4gICAgICAgIHRoaXMuY2xvc2UoKVxuICAgICAgfVxuXG4gICAgICB0aGlzLiNyZWNvbm5lY3QoKVxuICAgIH1cblxuICAgIC8vIDE1LiBGZXRjaCByZXF1ZXN0LCB3aXRoIHByb2Nlc3NSZXNwb25zZUVuZE9mQm9keSBzZXQgdG8gcHJvY2Vzc0V2ZW50U291cmNlRW5kT2ZCb2R5Li4uXG4gICAgZmV0Y2hQYXJhbXMucHJvY2Vzc1Jlc3BvbnNlRW5kT2ZCb2R5ID0gcHJvY2Vzc0V2ZW50U291cmNlRW5kT2ZCb2R5XG5cbiAgICAvLyBhbmQgcHJvY2Vzc1Jlc3BvbnNlIHNldCB0byB0aGUgZm9sbG93aW5nIHN0ZXBzIGdpdmVuIHJlc3BvbnNlIHJlczpcbiAgICBmZXRjaFBhcmFtcy5wcm9jZXNzUmVzcG9uc2UgPSAocmVzcG9uc2UpID0+IHtcbiAgICAgIC8vIDEuIElmIHJlcyBpcyBhbiBhYm9ydGVkIG5ldHdvcmsgZXJyb3IsIHRoZW4gZmFpbCB0aGUgY29ubmVjdGlvbi5cblxuICAgICAgaWYgKGlzTmV0d29ya0Vycm9yKHJlc3BvbnNlKSkge1xuICAgICAgICAvLyAxLiBXaGVuIGEgdXNlciBhZ2VudCBpcyB0byBmYWlsIHRoZSBjb25uZWN0aW9uLCB0aGUgdXNlciBhZ2VudFxuICAgICAgICAvLyBtdXN0IHF1ZXVlIGEgdGFzayB3aGljaCwgaWYgdGhlIHJlYWR5U3RhdGUgYXR0cmlidXRlIGlzIHNldCB0byBhXG4gICAgICAgIC8vIHZhbHVlIG90aGVyIHRoYW4gQ0xPU0VELCBzZXRzIHRoZSByZWFkeVN0YXRlIGF0dHJpYnV0ZSB0byBDTE9TRURcbiAgICAgICAgLy8gYW5kIGZpcmVzIGFuIGV2ZW50IG5hbWVkIGVycm9yIGF0IHRoZSBFdmVudFNvdXJjZSBvYmplY3QuIE9uY2UgdGhlXG4gICAgICAgIC8vIHVzZXIgYWdlbnQgaGFzIGZhaWxlZCB0aGUgY29ubmVjdGlvbiwgaXQgZG9lcyBub3QgYXR0ZW1wdCB0b1xuICAgICAgICAvLyByZWNvbm5lY3QuXG4gICAgICAgIGlmIChyZXNwb25zZS5hYm9ydGVkKSB7XG4gICAgICAgICAgdGhpcy5jbG9zZSgpXG4gICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnZXJyb3InKSlcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAvLyAyLiBPdGhlcndpc2UsIGlmIHJlcyBpcyBhIG5ldHdvcmsgZXJyb3IsIHRoZW4gcmVlc3RhYmxpc2ggdGhlXG4gICAgICAgICAgLy8gY29ubmVjdGlvbiwgdW5sZXNzIHRoZSB1c2VyIGFnZW50IGtub3dzIHRoYXQgdG8gYmUgZnV0aWxlLCBpblxuICAgICAgICAgIC8vIHdoaWNoIGNhc2UgdGhlIHVzZXIgYWdlbnQgbWF5IGZhaWwgdGhlIGNvbm5lY3Rpb24uXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy4jcmVjb25uZWN0KClcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyAzLiBPdGhlcndpc2UsIGlmIHJlcydzIHN0YXR1cyBpcyBub3QgMjAwLCBvciBpZiByZXMncyBgQ29udGVudC1UeXBlYFxuICAgICAgLy8gaXMgbm90IGB0ZXh0L2V2ZW50LXN0cmVhbWAsIHRoZW4gZmFpbCB0aGUgY29ubmVjdGlvbi5cbiAgICAgIGNvbnN0IGNvbnRlbnRUeXBlID0gcmVzcG9uc2UuaGVhZGVyc0xpc3QuZ2V0KCdjb250ZW50LXR5cGUnLCB0cnVlKVxuICAgICAgY29uc3QgbWltZVR5cGUgPSBjb250ZW50VHlwZSAhPT0gbnVsbCA/IHBhcnNlTUlNRVR5cGUoY29udGVudFR5cGUpIDogJ2ZhaWx1cmUnXG4gICAgICBjb25zdCBjb250ZW50VHlwZVZhbGlkID0gbWltZVR5cGUgIT09ICdmYWlsdXJlJyAmJiBtaW1lVHlwZS5lc3NlbmNlID09PSAndGV4dC9ldmVudC1zdHJlYW0nXG4gICAgICBpZiAoXG4gICAgICAgIHJlc3BvbnNlLnN0YXR1cyAhPT0gMjAwIHx8XG4gICAgICAgIGNvbnRlbnRUeXBlVmFsaWQgPT09IGZhbHNlXG4gICAgICApIHtcbiAgICAgICAgdGhpcy5jbG9zZSgpXG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ2Vycm9yJykpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICAvLyA0LiBPdGhlcndpc2UsIGFubm91bmNlIHRoZSBjb25uZWN0aW9uIGFuZCBpbnRlcnByZXQgcmVzJ3MgYm9keVxuICAgICAgLy8gbGluZSBieSBsaW5lLlxuXG4gICAgICAvLyBXaGVuIGEgdXNlciBhZ2VudCBpcyB0byBhbm5vdW5jZSB0aGUgY29ubmVjdGlvbiwgdGhlIHVzZXIgYWdlbnRcbiAgICAgIC8vIG11c3QgcXVldWUgYSB0YXNrIHdoaWNoLCBpZiB0aGUgcmVhZHlTdGF0ZSBhdHRyaWJ1dGUgaXMgc2V0IHRvIGFcbiAgICAgIC8vIHZhbHVlIG90aGVyIHRoYW4gQ0xPU0VELCBzZXRzIHRoZSByZWFkeVN0YXRlIGF0dHJpYnV0ZSB0byBPUEVOXG4gICAgICAvLyBhbmQgZmlyZXMgYW4gZXZlbnQgbmFtZWQgb3BlbiBhdCB0aGUgRXZlbnRTb3VyY2Ugb2JqZWN0LlxuICAgICAgLy8gQHNlZSBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zZXJ2ZXItc2VudC1ldmVudHMuaHRtbCNzc2UtcHJvY2Vzc2luZy1tb2RlbFxuICAgICAgdGhpcy4jcmVhZHlTdGF0ZSA9IE9QRU5cbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ29wZW4nKSlcblxuICAgICAgLy8gSWYgcmVkaXJlY3RlZCB0byBhIGRpZmZlcmVudCBvcmlnaW4sIHNldCB0aGUgb3JpZ2luIHRvIHRoZSBuZXcgb3JpZ2luLlxuICAgICAgdGhpcy4jc3RhdGUub3JpZ2luID0gcmVzcG9uc2UudXJsTGlzdFtyZXNwb25zZS51cmxMaXN0Lmxlbmd0aCAtIDFdLm9yaWdpblxuXG4gICAgICBjb25zdCBldmVudFNvdXJjZVN0cmVhbSA9IG5ldyBFdmVudFNvdXJjZVN0cmVhbSh7XG4gICAgICAgIGV2ZW50U291cmNlU2V0dGluZ3M6IHRoaXMuI3N0YXRlLFxuICAgICAgICBwdXNoOiAoZXZlbnQpID0+IHtcbiAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoY3JlYXRlRmFzdE1lc3NhZ2VFdmVudChcbiAgICAgICAgICAgIGV2ZW50LnR5cGUsXG4gICAgICAgICAgICBldmVudC5vcHRpb25zXG4gICAgICAgICAgKSlcbiAgICAgICAgfVxuICAgICAgfSlcblxuICAgICAgcGlwZWxpbmUocmVzcG9uc2UuYm9keS5zdHJlYW0sXG4gICAgICAgIGV2ZW50U291cmNlU3RyZWFtLFxuICAgICAgICAoZXJyb3IpID0+IHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBlcnJvcj8uYWJvcnRlZCA9PT0gZmFsc2VcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2UoKVxuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnZXJyb3InKSlcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgdGhpcy4jY29udHJvbGxlciA9IGZldGNoaW5nKGZldGNoUGFyYW1zKVxuICB9XG5cbiAgLyoqXG4gICAqIEBzZWUgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc2VydmVyLXNlbnQtZXZlbnRzLmh0bWwjc3NlLXByb2Nlc3NpbmctbW9kZWxcbiAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAqL1xuICBhc3luYyAjcmVjb25uZWN0ICgpIHtcbiAgICAvLyBXaGVuIGEgdXNlciBhZ2VudCBpcyB0byByZWVzdGFibGlzaCB0aGUgY29ubmVjdGlvbiwgdGhlIHVzZXIgYWdlbnQgbXVzdFxuICAgIC8vIHJ1biB0aGUgZm9sbG93aW5nIHN0ZXBzLiBUaGVzZSBzdGVwcyBhcmUgcnVuIGluIHBhcmFsbGVsLCBub3QgYXMgcGFydCBvZlxuICAgIC8vIGEgdGFzay4gKFRoZSB0YXNrcyB0aGF0IGl0IHF1ZXVlcywgb2YgY291cnNlLCBhcmUgcnVuIGxpa2Ugbm9ybWFsIHRhc2tzXG4gICAgLy8gYW5kIG5vdCB0aGVtc2VsdmVzIGluIHBhcmFsbGVsLilcblxuICAgIC8vIDEuIFF1ZXVlIGEgdGFzayB0byBydW4gdGhlIGZvbGxvd2luZyBzdGVwczpcblxuICAgIC8vICAgMS4gSWYgdGhlIHJlYWR5U3RhdGUgYXR0cmlidXRlIGlzIHNldCB0byBDTE9TRUQsIGFib3J0IHRoZSB0YXNrLlxuICAgIGlmICh0aGlzLiNyZWFkeVN0YXRlID09PSBDTE9TRUQpIHJldHVyblxuXG4gICAgLy8gICAyLiBTZXQgdGhlIHJlYWR5U3RhdGUgYXR0cmlidXRlIHRvIENPTk5FQ1RJTkcuXG4gICAgdGhpcy4jcmVhZHlTdGF0ZSA9IENPTk5FQ1RJTkdcblxuICAgIC8vICAgMy4gRmlyZSBhbiBldmVudCBuYW1lZCBlcnJvciBhdCB0aGUgRXZlbnRTb3VyY2Ugb2JqZWN0LlxuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ2Vycm9yJykpXG5cbiAgICAvLyAyLiBXYWl0IGEgZGVsYXkgZXF1YWwgdG8gdGhlIHJlY29ubmVjdGlvbiB0aW1lIG9mIHRoZSBldmVudCBzb3VyY2UuXG4gICAgYXdhaXQgZGVsYXkodGhpcy4jc3RhdGUucmVjb25uZWN0aW9uVGltZSlcblxuICAgIC8vIDUuIFF1ZXVlIGEgdGFzayB0byBydW4gdGhlIGZvbGxvd2luZyBzdGVwczpcblxuICAgIC8vICAgMS4gSWYgdGhlIEV2ZW50U291cmNlIG9iamVjdCdzIHJlYWR5U3RhdGUgYXR0cmlidXRlIGlzIG5vdCBzZXQgdG9cbiAgICAvLyAgICAgIENPTk5FQ1RJTkcsIHRoZW4gcmV0dXJuLlxuICAgIGlmICh0aGlzLiNyZWFkeVN0YXRlICE9PSBDT05ORUNUSU5HKSByZXR1cm5cblxuICAgIC8vICAgMi4gTGV0IHJlcXVlc3QgYmUgdGhlIEV2ZW50U291cmNlIG9iamVjdCdzIHJlcXVlc3QuXG4gICAgLy8gICAzLiBJZiB0aGUgRXZlbnRTb3VyY2Ugb2JqZWN0J3MgbGFzdCBldmVudCBJRCBzdHJpbmcgaXMgbm90IHRoZSBlbXB0eVxuICAgIC8vICAgICAgc3RyaW5nLCB0aGVuOlxuICAgIC8vICAgICAgMS4gTGV0IGxhc3RFdmVudElEVmFsdWUgYmUgdGhlIEV2ZW50U291cmNlIG9iamVjdCdzIGxhc3QgZXZlbnQgSURcbiAgICAvLyAgICAgICAgIHN0cmluZywgZW5jb2RlZCBhcyBVVEYtOC5cbiAgICAvLyAgICAgIDIuIFNldCAoYExhc3QtRXZlbnQtSURgLCBsYXN0RXZlbnRJRFZhbHVlKSBpbiByZXF1ZXN0J3MgaGVhZGVyXG4gICAgLy8gICAgICAgICBsaXN0LlxuICAgIGlmICh0aGlzLiNzdGF0ZS5sYXN0RXZlbnRJZC5sZW5ndGgpIHtcbiAgICAgIHRoaXMuI3JlcXVlc3QuaGVhZGVyc0xpc3Quc2V0KCdsYXN0LWV2ZW50LWlkJywgdGhpcy4jc3RhdGUubGFzdEV2ZW50SWQsIHRydWUpXG4gICAgfVxuXG4gICAgLy8gICA0LiBGZXRjaCByZXF1ZXN0IGFuZCBwcm9jZXNzIHRoZSByZXNwb25zZSBvYnRhaW5lZCBpbiB0aGlzIGZhc2hpb24sIGlmIGFueSwgYXMgZGVzY3JpYmVkIGVhcmxpZXIgaW4gdGhpcyBzZWN0aW9uLlxuICAgIHRoaXMuI2Nvbm5lY3QoKVxuICB9XG5cbiAgLyoqXG4gICAqIENsb3NlcyB0aGUgY29ubmVjdGlvbiwgaWYgYW55LCBhbmQgc2V0cyB0aGUgcmVhZHlTdGF0ZSBhdHRyaWJ1dGUgdG9cbiAgICogQ0xPU0VELlxuICAgKi9cbiAgY2xvc2UgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEV2ZW50U291cmNlKVxuXG4gICAgaWYgKHRoaXMuI3JlYWR5U3RhdGUgPT09IENMT1NFRCkgcmV0dXJuXG4gICAgdGhpcy4jcmVhZHlTdGF0ZSA9IENMT1NFRFxuICAgIHRoaXMuI2NvbnRyb2xsZXIuYWJvcnQoKVxuICAgIHRoaXMuI3JlcXVlc3QgPSBudWxsXG4gIH1cblxuICBnZXQgb25vcGVuICgpIHtcbiAgICByZXR1cm4gdGhpcy4jZXZlbnRzLm9wZW5cbiAgfVxuXG4gIHNldCBvbm9wZW4gKGZuKSB7XG4gICAgaWYgKHRoaXMuI2V2ZW50cy5vcGVuKSB7XG4gICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ29wZW4nLCB0aGlzLiNldmVudHMub3BlbilcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLiNldmVudHMub3BlbiA9IGZuXG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ29wZW4nLCBmbilcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4jZXZlbnRzLm9wZW4gPSBudWxsXG4gICAgfVxuICB9XG5cbiAgZ2V0IG9ubWVzc2FnZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2V2ZW50cy5tZXNzYWdlXG4gIH1cblxuICBzZXQgb25tZXNzYWdlIChmbikge1xuICAgIGlmICh0aGlzLiNldmVudHMubWVzc2FnZSkge1xuICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgdGhpcy4jZXZlbnRzLm1lc3NhZ2UpXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy4jZXZlbnRzLm1lc3NhZ2UgPSBmblxuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgZm4pXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuI2V2ZW50cy5tZXNzYWdlID0gbnVsbFxuICAgIH1cbiAgfVxuXG4gIGdldCBvbmVycm9yICgpIHtcbiAgICByZXR1cm4gdGhpcy4jZXZlbnRzLmVycm9yXG4gIH1cblxuICBzZXQgb25lcnJvciAoZm4pIHtcbiAgICBpZiAodGhpcy4jZXZlbnRzLmVycm9yKSB7XG4gICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgdGhpcy4jZXZlbnRzLmVycm9yKVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXMuI2V2ZW50cy5lcnJvciA9IGZuXG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgZm4pXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuI2V2ZW50cy5lcnJvciA9IG51bGxcbiAgICB9XG4gIH1cbn1cblxuY29uc3QgY29uc3RhbnRzUHJvcGVydHlEZXNjcmlwdG9ycyA9IHtcbiAgQ09OTkVDVElORzoge1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgdmFsdWU6IENPTk5FQ1RJTkcsXG4gICAgd3JpdGFibGU6IGZhbHNlXG4gIH0sXG4gIE9QRU46IHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBPUEVOLFxuICAgIHdyaXRhYmxlOiBmYWxzZVxuICB9LFxuICBDTE9TRUQ6IHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBDTE9TRUQsXG4gICAgd3JpdGFibGU6IGZhbHNlXG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoRXZlbnRTb3VyY2UsIGNvbnN0YW50c1Byb3BlcnR5RGVzY3JpcHRvcnMpXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhFdmVudFNvdXJjZS5wcm90b3R5cGUsIGNvbnN0YW50c1Byb3BlcnR5RGVzY3JpcHRvcnMpXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEV2ZW50U291cmNlLnByb3RvdHlwZSwge1xuICBjbG9zZToga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgb25lcnJvcjoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgb25tZXNzYWdlOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBvbm9wZW46IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIHJlYWR5U3RhdGU6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIHVybDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgd2l0aENyZWRlbnRpYWxzOiBrRW51bWVyYWJsZVByb3BlcnR5XG59KVxuXG53ZWJpZGwuY29udmVydGVycy5FdmVudFNvdXJjZUluaXREaWN0ID0gd2ViaWRsLmRpY3Rpb25hcnlDb252ZXJ0ZXIoW1xuICB7XG4gICAga2V5OiAnd2l0aENyZWRlbnRpYWxzJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLmJvb2xlYW4sXG4gICAgZGVmYXVsdFZhbHVlOiAoKSA9PiBmYWxzZVxuICB9LFxuICB7XG4gICAga2V5OiAnZGlzcGF0Y2hlcicsIC8vIHVuZGljaSBvbmx5XG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5hbnlcbiAgfVxuXSlcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEV2ZW50U291cmNlLFxuICBkZWZhdWx0UmVjb25uZWN0aW9uVGltZVxufVxuIl0sIm5hbWVzIjpbInBpcGVsaW5lIiwicmVxdWlyZSIsImZldGNoaW5nIiwibWFrZVJlcXVlc3QiLCJ3ZWJpZGwiLCJFdmVudFNvdXJjZVN0cmVhbSIsInBhcnNlTUlNRVR5cGUiLCJjcmVhdGVGYXN0TWVzc2FnZUV2ZW50IiwiaXNOZXR3b3JrRXJyb3IiLCJkZWxheSIsImtFbnVtZXJhYmxlUHJvcGVydHkiLCJlbnZpcm9ubWVudFNldHRpbmdzT2JqZWN0IiwiZXhwZXJpbWVudGFsV2FybmVkIiwiZGVmYXVsdFJlY29ubmVjdGlvblRpbWUiLCJDT05ORUNUSU5HIiwiT1BFTiIsIkNMT1NFRCIsIkFOT05ZTU9VUyIsIlVTRV9DUkVERU5USUFMUyIsIkV2ZW50U291cmNlIiwiRXZlbnRUYXJnZXQiLCJldmVudHMiLCJ1cmwiLCJ3aXRoQ3JlZGVudGlhbHMiLCJyZWFkeVN0YXRlIiwicmVxdWVzdCIsImNvbnRyb2xsZXIiLCJkaXNwYXRjaGVyIiwic3RhdGUiLCJjb25zdHJ1Y3RvciIsImV2ZW50U291cmNlSW5pdERpY3QiLCJvcGVuIiwiZXJyb3IiLCJtZXNzYWdlIiwicHJlZml4IiwiYXJndW1lbnRMZW5ndGhDaGVjayIsImFyZ3VtZW50cyIsInByb2Nlc3MiLCJlbWl0V2FybmluZyIsImNvZGUiLCJjb252ZXJ0ZXJzIiwiVVNWU3RyaW5nIiwiRXZlbnRTb3VyY2VJbml0RGljdCIsImxhc3RFdmVudElkIiwicmVjb25uZWN0aW9uVGltZSIsInNldHRpbmdzIiwidXJsUmVjb3JkIiwiVVJMIiwic2V0dGluZ3NPYmplY3QiLCJiYXNlVXJsIiwib3JpZ2luIiwiZSIsIkRPTUV4Y2VwdGlvbiIsImhyZWYiLCJjb3JzQXR0cmlidXRlU3RhdGUiLCJpbml0UmVxdWVzdCIsInJlZGlyZWN0Iiwia2VlcGFsaXZlIiwibW9kZSIsImNyZWRlbnRpYWxzIiwicmVmZXJyZXIiLCJjbGllbnQiLCJoZWFkZXJzTGlzdCIsIm5hbWUiLCJ2YWx1ZSIsImNhY2hlIiwiaW5pdGlhdG9yIiwidXJsTGlzdCIsImNvbm5lY3QiLCIjY29ubmVjdCIsImZldGNoUGFyYW1zIiwicHJvY2Vzc0V2ZW50U291cmNlRW5kT2ZCb2R5IiwicmVzcG9uc2UiLCJkaXNwYXRjaEV2ZW50IiwiRXZlbnQiLCJjbG9zZSIsInJlY29ubmVjdCIsInByb2Nlc3NSZXNwb25zZUVuZE9mQm9keSIsInByb2Nlc3NSZXNwb25zZSIsImFib3J0ZWQiLCJjb250ZW50VHlwZSIsImdldCIsIm1pbWVUeXBlIiwiY29udGVudFR5cGVWYWxpZCIsImVzc2VuY2UiLCJzdGF0dXMiLCJsZW5ndGgiLCJldmVudFNvdXJjZVN0cmVhbSIsImV2ZW50U291cmNlU2V0dGluZ3MiLCJwdXNoIiwiZXZlbnQiLCJ0eXBlIiwib3B0aW9ucyIsImJvZHkiLCJzdHJlYW0iLCIjcmVjb25uZWN0Iiwic2V0IiwiYnJhbmRDaGVjayIsImFib3J0Iiwib25vcGVuIiwiZm4iLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiYWRkRXZlbnRMaXN0ZW5lciIsIm9ubWVzc2FnZSIsIm9uZXJyb3IiLCJjb25zdGFudHNQcm9wZXJ0eURlc2NyaXB0b3JzIiwiX19wcm90b19fIiwiY29uZmlndXJhYmxlIiwiZW51bWVyYWJsZSIsIndyaXRhYmxlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydGllcyIsInByb3RvdHlwZSIsImRpY3Rpb25hcnlDb252ZXJ0ZXIiLCJrZXkiLCJjb252ZXJ0ZXIiLCJib29sZWFuIiwiZGVmYXVsdFZhbHVlIiwiYW55IiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/eventsource/eventsource.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/eventsource/util.js":
/*!*********************************************************!*\
  !*** ./node_modules/undici/lib/web/eventsource/util.js ***!
  \*********************************************************/
/***/ ((module) => {

eval("\n/**\n * Checks if the given value is a valid LastEventId.\n * @param {string} value\n * @returns {boolean}\n */ function isValidLastEventId(value) {\n    // LastEventId should not contain U+0000 NULL\n    return value.indexOf(\"\\x00\") === -1;\n}\n/**\n * Checks if the given value is a base 10 digit.\n * @param {string} value\n * @returns {boolean}\n */ function isASCIINumber(value) {\n    if (value.length === 0) return false;\n    for(let i = 0; i < value.length; i++){\n        if (value.charCodeAt(i) < 0x30 || value.charCodeAt(i) > 0x39) return false;\n    }\n    return true;\n}\n// https://github.com/nodejs/undici/issues/2664\nfunction delay(ms) {\n    return new Promise((resolve)=>{\n        setTimeout(resolve, ms).unref();\n    });\n}\nmodule.exports = {\n    isValidLastEventId,\n    isASCIINumber,\n    delay\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZXZlbnRzb3VyY2UvdXRpbC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBOzs7O0NBSUEsR0FDQSxTQUFTQSxtQkFBb0JDLEtBQUs7SUFDaEM7SUFDQSxPQUFPQSxNQUFNQyxPQUFPLENBQUMsWUFBYyxDQUFDO0FBQ3RDO0FBRUE7Ozs7Q0FJQSxHQUNBLFNBQVNDLGNBQWVGLEtBQUs7SUFDM0IsSUFBSUEsTUFBTUcsTUFBTSxLQUFLLEdBQUcsT0FBTztJQUMvQixJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUosTUFBTUcsTUFBTSxFQUFFQyxJQUFLO1FBQ3JDLElBQUlKLE1BQU1LLFVBQVUsQ0FBQ0QsS0FBSyxRQUFRSixNQUFNSyxVQUFVLENBQUNELEtBQUssTUFBTSxPQUFPO0lBQ3ZFO0lBQ0EsT0FBTztBQUNUO0FBRUE7QUFDQSxTQUFTRSxNQUFPQyxFQUFFO0lBQ2hCLE9BQU8sSUFBSUMsUUFBU0MsQ0FBQUE7UUFDbEJDLFdBQVdELFNBQVNGLElBQUlJLEtBQUs7SUFDL0I7QUFDRjtBQUVBQyxPQUFPQyxPQUFPLEdBQUc7SUFDZmQ7SUFDQUc7SUFDQUk7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL21vY2t1cGZsb3cvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZXZlbnRzb3VyY2UvdXRpbC5qcz84ODMxIiwid2VicGFjazovL21vY2t1cGZsb3cvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZXZlbnRzb3VyY2UvdXRpbC5qcz84ODMxKiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQgTGFzdEV2ZW50SWQuXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc1ZhbGlkTGFzdEV2ZW50SWQgKHZhbHVlKSB7XG4gIC8vIExhc3RFdmVudElkIHNob3VsZCBub3QgY29udGFpbiBVKzAwMDAgTlVMTFxuICByZXR1cm4gdmFsdWUuaW5kZXhPZignXFx1MDAwMCcpID09PSAtMVxufVxuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSBiYXNlIDEwIGRpZ2l0LlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNBU0NJSU51bWJlciAodmFsdWUpIHtcbiAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gMCkgcmV0dXJuIGZhbHNlXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAodmFsdWUuY2hhckNvZGVBdChpKSA8IDB4MzAgfHwgdmFsdWUuY2hhckNvZGVBdChpKSA+IDB4MzkpIHJldHVybiBmYWxzZVxuICB9XG4gIHJldHVybiB0cnVlXG59XG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvdW5kaWNpL2lzc3Vlcy8yNjY0XG5mdW5jdGlvbiBkZWxheSAobXMpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgc2V0VGltZW91dChyZXNvbHZlLCBtcykudW5yZWYoKVxuICB9KVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaXNWYWxpZExhc3RFdmVudElkLFxuICBpc0FTQ0lJTnVtYmVyLFxuICBkZWxheVxufVxuIl0sIm5hbWVzIjpbImlzVmFsaWRMYXN0RXZlbnRJZCIsInZhbHVlIiwiaW5kZXhPZiIsImlzQVNDSUlOdW1iZXIiLCJsZW5ndGgiLCJpIiwiY2hhckNvZGVBdCIsImRlbGF5IiwibXMiLCJQcm9taXNlIiwicmVzb2x2ZSIsInNldFRpbWVvdXQiLCJ1bnJlZiIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/eventsource/util.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/fetch/body.js":
/*!***************************************************!*\
  !*** ./node_modules/undici/lib/web/fetch/body.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst util = __webpack_require__(/*! ../../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\");\nconst { ReadableStreamFrom, isBlobLike, isReadableStreamLike, readableStreamClose, createDeferredPromise, fullyReadBody, extractMimeType, utf8DecodeBytes } = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/undici/lib/web/fetch/util.js\");\nconst { FormData } = __webpack_require__(/*! ./formdata */ \"(ssr)/./node_modules/undici/lib/web/fetch/formdata.js\");\nconst { kState } = __webpack_require__(/*! ./symbols */ \"(ssr)/./node_modules/undici/lib/web/fetch/symbols.js\");\nconst { webidl } = __webpack_require__(/*! ./webidl */ \"(ssr)/./node_modules/undici/lib/web/fetch/webidl.js\");\nconst { Blob } = __webpack_require__(/*! node:buffer */ \"node:buffer\");\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\");\nconst { isErrored } = __webpack_require__(/*! ../../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\");\nconst { isArrayBuffer } = __webpack_require__(/*! node:util/types */ \"node:util/types\");\nconst { serializeAMimeType } = __webpack_require__(/*! ./data-url */ \"(ssr)/./node_modules/undici/lib/web/fetch/data-url.js\");\nconst { multipartFormDataParser } = __webpack_require__(/*! ./formdata-parser */ \"(ssr)/./node_modules/undici/lib/web/fetch/formdata-parser.js\");\nconst textEncoder = new TextEncoder();\n// https://fetch.spec.whatwg.org/#concept-bodyinit-extract\nfunction extractBody(object, keepalive = false) {\n    // 1. Let stream be null.\n    let stream = null;\n    // 2. If object is a ReadableStream object, then set stream to object.\n    if (object instanceof ReadableStream) {\n        stream = object;\n    } else if (isBlobLike(object)) {\n        // 3. Otherwise, if object is a Blob object, set stream to the\n        //    result of running objects get stream.\n        stream = object.stream();\n    } else {\n        // 4. Otherwise, set stream to a new ReadableStream object, and set\n        //    up stream with byte reading support.\n        stream = new ReadableStream({\n            async pull (controller) {\n                const buffer = typeof source === \"string\" ? textEncoder.encode(source) : source;\n                if (buffer.byteLength) {\n                    controller.enqueue(buffer);\n                }\n                queueMicrotask(()=>readableStreamClose(controller));\n            },\n            start () {},\n            type: \"bytes\"\n        });\n    }\n    // 5. Assert: stream is a ReadableStream object.\n    assert(isReadableStreamLike(stream));\n    // 6. Let action be null.\n    let action = null;\n    // 7. Let source be null.\n    let source = null;\n    // 8. Let length be null.\n    let length = null;\n    // 9. Let type be null.\n    let type = null;\n    // 10. Switch on object:\n    if (typeof object === \"string\") {\n        // Set source to the UTF-8 encoding of object.\n        // Note: setting source to a Uint8Array here breaks some mocking assumptions.\n        source = object;\n        // Set type to `text/plain;charset=UTF-8`.\n        type = \"text/plain;charset=UTF-8\";\n    } else if (object instanceof URLSearchParams) {\n        // URLSearchParams\n        // spec says to run application/x-www-form-urlencoded on body.list\n        // this is implemented in Node.js as apart of an URLSearchParams instance toString method\n        // See: https://github.com/nodejs/node/blob/e46c680bf2b211bbd52cf959ca17ee98c7f657f5/lib/internal/url.js#L490\n        // and https://github.com/nodejs/node/blob/e46c680bf2b211bbd52cf959ca17ee98c7f657f5/lib/internal/url.js#L1100\n        // Set source to the result of running the application/x-www-form-urlencoded serializer with objects list.\n        source = object.toString();\n        // Set type to `application/x-www-form-urlencoded;charset=UTF-8`.\n        type = \"application/x-www-form-urlencoded;charset=UTF-8\";\n    } else if (isArrayBuffer(object)) {\n        // BufferSource/ArrayBuffer\n        // Set source to a copy of the bytes held by object.\n        source = new Uint8Array(object.slice());\n    } else if (ArrayBuffer.isView(object)) {\n        // BufferSource/ArrayBufferView\n        // Set source to a copy of the bytes held by object.\n        source = new Uint8Array(object.buffer.slice(object.byteOffset, object.byteOffset + object.byteLength));\n    } else if (util.isFormDataLike(object)) {\n        const boundary = `----formdata-undici-0${`${Math.floor(Math.random() * 1e11)}`.padStart(11, \"0\")}`;\n        const prefix = `--${boundary}\\r\\nContent-Disposition: form-data`;\n        /*! formdata-polyfill. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> */ const escape = (str)=>str.replace(/\\n/g, \"%0A\").replace(/\\r/g, \"%0D\").replace(/\"/g, \"%22\");\n        const normalizeLinefeeds = (value)=>value.replace(/\\r?\\n|\\r/g, \"\\r\\n\");\n        // Set action to this step: run the multipart/form-data\n        // encoding algorithm, with objects entry list and UTF-8.\n        // - This ensures that the body is immutable and can't be changed afterwords\n        // - That the content-length is calculated in advance.\n        // - And that all parts are pre-encoded and ready to be sent.\n        const blobParts = [];\n        const rn = new Uint8Array([\n            13,\n            10\n        ]); // '\\r\\n'\n        length = 0;\n        let hasUnknownSizeValue = false;\n        for (const [name, value] of object){\n            if (typeof value === \"string\") {\n                const chunk = textEncoder.encode(prefix + `; name=\"${escape(normalizeLinefeeds(name))}\"` + `\\r\\n\\r\\n${normalizeLinefeeds(value)}\\r\\n`);\n                blobParts.push(chunk);\n                length += chunk.byteLength;\n            } else {\n                const chunk = textEncoder.encode(`${prefix}; name=\"${escape(normalizeLinefeeds(name))}\"` + (value.name ? `; filename=\"${escape(value.name)}\"` : \"\") + \"\\r\\n\" + `Content-Type: ${value.type || \"application/octet-stream\"}\\r\\n\\r\\n`);\n                blobParts.push(chunk, value, rn);\n                if (typeof value.size === \"number\") {\n                    length += chunk.byteLength + value.size + rn.byteLength;\n                } else {\n                    hasUnknownSizeValue = true;\n                }\n            }\n        }\n        const chunk = textEncoder.encode(`--${boundary}--`);\n        blobParts.push(chunk);\n        length += chunk.byteLength;\n        if (hasUnknownSizeValue) {\n            length = null;\n        }\n        // Set source to object.\n        source = object;\n        action = async function*() {\n            for (const part of blobParts){\n                if (part.stream) {\n                    yield* part.stream();\n                } else {\n                    yield part;\n                }\n            }\n        };\n        // Set type to `multipart/form-data; boundary=`,\n        // followed by the multipart/form-data boundary string generated\n        // by the multipart/form-data encoding algorithm.\n        type = `multipart/form-data; boundary=${boundary}`;\n    } else if (isBlobLike(object)) {\n        // Blob\n        // Set source to object.\n        source = object;\n        // Set length to objects size.\n        length = object.size;\n        // If objects type attribute is not the empty byte sequence, set\n        // type to its value.\n        if (object.type) {\n            type = object.type;\n        }\n    } else if (typeof object[Symbol.asyncIterator] === \"function\") {\n        // If keepalive is true, then throw a TypeError.\n        if (keepalive) {\n            throw new TypeError(\"keepalive\");\n        }\n        // If object is disturbed or locked, then throw a TypeError.\n        if (util.isDisturbed(object) || object.locked) {\n            throw new TypeError(\"Response body object should not be disturbed or locked\");\n        }\n        stream = object instanceof ReadableStream ? object : ReadableStreamFrom(object);\n    }\n    // 11. If source is a byte sequence, then set action to a\n    // step that returns source and length to sources length.\n    if (typeof source === \"string\" || util.isBuffer(source)) {\n        length = Buffer.byteLength(source);\n    }\n    // 12. If action is non-null, then run these steps in in parallel:\n    if (action != null) {\n        // Run action.\n        let iterator;\n        stream = new ReadableStream({\n            async start () {\n                iterator = action(object)[Symbol.asyncIterator]();\n            },\n            async pull (controller) {\n                const { value, done } = await iterator.next();\n                if (done) {\n                    // When running action is done, close stream.\n                    queueMicrotask(()=>{\n                        controller.close();\n                        controller.byobRequest?.respond(0);\n                    });\n                } else {\n                    // Whenever one or more bytes are available and stream is not errored,\n                    // enqueue a Uint8Array wrapping an ArrayBuffer containing the available\n                    // bytes into stream.\n                    if (!isErrored(stream)) {\n                        const buffer = new Uint8Array(value);\n                        if (buffer.byteLength) {\n                            controller.enqueue(buffer);\n                        }\n                    }\n                }\n                return controller.desiredSize > 0;\n            },\n            async cancel (reason) {\n                await iterator.return();\n            },\n            type: \"bytes\"\n        });\n    }\n    // 13. Let body be a body whose stream is stream, source is source,\n    // and length is length.\n    const body = {\n        stream,\n        source,\n        length\n    };\n    // 14. Return (body, type).\n    return [\n        body,\n        type\n    ];\n}\n// https://fetch.spec.whatwg.org/#bodyinit-safely-extract\nfunction safelyExtractBody(object, keepalive = false) {\n    // To safely extract a body and a `Content-Type` value from\n    // a byte sequence or BodyInit object object, run these steps:\n    // 1. If object is a ReadableStream object, then:\n    if (object instanceof ReadableStream) {\n        // Assert: object is neither disturbed nor locked.\n        // istanbul ignore next\n        assert(!util.isDisturbed(object), \"The body has already been consumed.\");\n        // istanbul ignore next\n        assert(!object.locked, \"The stream is locked.\");\n    }\n    // 2. Return the results of extracting object.\n    return extractBody(object, keepalive);\n}\nfunction cloneBody(body) {\n    // To clone a body body, run these steps:\n    // https://fetch.spec.whatwg.org/#concept-body-clone\n    // 1. Let  out1, out2  be the result of teeing bodys stream.\n    const [out1, out2] = body.stream.tee();\n    // 2. Set bodys stream to out1.\n    body.stream = out1;\n    // 3. Return a body whose stream is out2 and other members are copied from body.\n    return {\n        stream: out2,\n        length: body.length,\n        source: body.source\n    };\n}\nfunction throwIfAborted(state) {\n    if (state.aborted) {\n        throw new DOMException(\"The operation was aborted.\", \"AbortError\");\n    }\n}\nfunction bodyMixinMethods(instance) {\n    const methods = {\n        blob () {\n            // The blob() method steps are to return the result of\n            // running consume body with this and the following step\n            // given a byte sequence bytes: return a Blob whose\n            // contents are bytes and whose type attribute is thiss\n            // MIME type.\n            return consumeBody(this, (bytes)=>{\n                let mimeType = bodyMimeType(this);\n                if (mimeType === null) {\n                    mimeType = \"\";\n                } else if (mimeType) {\n                    mimeType = serializeAMimeType(mimeType);\n                }\n                // Return a Blob whose contents are bytes and type attribute\n                // is mimeType.\n                return new Blob([\n                    bytes\n                ], {\n                    type: mimeType\n                });\n            }, instance);\n        },\n        arrayBuffer () {\n            // The arrayBuffer() method steps are to return the result\n            // of running consume body with this and the following step\n            // given a byte sequence bytes: return a new ArrayBuffer\n            // whose contents are bytes.\n            return consumeBody(this, (bytes)=>{\n                return new Uint8Array(bytes).buffer;\n            }, instance);\n        },\n        text () {\n            // The text() method steps are to return the result of running\n            // consume body with this and UTF-8 decode.\n            return consumeBody(this, utf8DecodeBytes, instance);\n        },\n        json () {\n            // The json() method steps are to return the result of running\n            // consume body with this and parse JSON from bytes.\n            return consumeBody(this, parseJSONFromBytes, instance);\n        },\n        formData () {\n            // The formData() method steps are to return the result of running\n            // consume body with this and the following step given a byte sequence bytes:\n            return consumeBody(this, (value)=>{\n                // 1. Let mimeType be the result of get the MIME type with this.\n                const mimeType = bodyMimeType(this);\n                // 2. If mimeType is non-null, then switch on mimeTypes essence and run\n                //    the corresponding steps:\n                if (mimeType !== null) {\n                    switch(mimeType.essence){\n                        case \"multipart/form-data\":\n                            {\n                                // 1. ... [long step]\n                                const parsed = multipartFormDataParser(value, mimeType);\n                                // 2. If that fails for some reason, then throw a TypeError.\n                                if (parsed === \"failure\") {\n                                    throw new TypeError(\"Failed to parse body as FormData.\");\n                                }\n                                // 3. Return a new FormData object, appending each entry,\n                                //    resulting from the parsing operation, to its entry list.\n                                const fd = new FormData();\n                                fd[kState] = parsed;\n                                return fd;\n                            }\n                        case \"application/x-www-form-urlencoded\":\n                            {\n                                // 1. Let entries be the result of parsing bytes.\n                                const entries = new URLSearchParams(value.toString());\n                                // 2. If entries is failure, then throw a TypeError.\n                                // 3. Return a new FormData object whose entry list is entries.\n                                const fd = new FormData();\n                                for (const [name, value] of entries){\n                                    fd.append(name, value);\n                                }\n                                return fd;\n                            }\n                    }\n                }\n                // 3. Throw a TypeError.\n                throw new TypeError('Content-Type was not one of \"multipart/form-data\" or \"application/x-www-form-urlencoded\".');\n            }, instance);\n        },\n        bytes () {\n            // The bytes() method steps are to return the result of running consume body\n            // with this and the following step given a byte sequence bytes: return the\n            // result of creating a Uint8Array from bytes in thiss relevant realm.\n            return consumeBody(this, (bytes)=>{\n                return new Uint8Array(bytes);\n            }, instance);\n        }\n    };\n    return methods;\n}\nfunction mixinBody(prototype) {\n    Object.assign(prototype.prototype, bodyMixinMethods(prototype));\n}\n/**\n * @see https://fetch.spec.whatwg.org/#concept-body-consume-body\n * @param {Response|Request} object\n * @param {(value: unknown) => unknown} convertBytesToJSValue\n * @param {Response|Request} instance\n */ async function consumeBody(object, convertBytesToJSValue, instance) {\n    webidl.brandCheck(object, instance);\n    // 1. If object is unusable, then return a promise rejected\n    //    with a TypeError.\n    if (bodyUnusable(object[kState].body)) {\n        throw new TypeError(\"Body is unusable: Body has already been read\");\n    }\n    throwIfAborted(object[kState]);\n    // 2. Let promise be a new promise.\n    const promise = createDeferredPromise();\n    // 3. Let errorSteps given error be to reject promise with error.\n    const errorSteps = (error)=>promise.reject(error);\n    // 4. Let successSteps given a byte sequence data be to resolve\n    //    promise with the result of running convertBytesToJSValue\n    //    with data. If that threw an exception, then run errorSteps\n    //    with that exception.\n    const successSteps = (data)=>{\n        try {\n            promise.resolve(convertBytesToJSValue(data));\n        } catch (e) {\n            errorSteps(e);\n        }\n    };\n    // 5. If objects body is null, then run successSteps with an\n    //    empty byte sequence.\n    if (object[kState].body == null) {\n        successSteps(Buffer.allocUnsafe(0));\n        return promise.promise;\n    }\n    // 6. Otherwise, fully read objects body given successSteps,\n    //    errorSteps, and objects relevant global object.\n    await fullyReadBody(object[kState].body, successSteps, errorSteps);\n    // 7. Return promise.\n    return promise.promise;\n}\n// https://fetch.spec.whatwg.org/#body-unusable\nfunction bodyUnusable(body) {\n    // An object including the Body interface mixin is\n    // said to be unusable if its body is non-null and\n    // its bodys stream is disturbed or locked.\n    return body != null && (body.stream.locked || util.isDisturbed(body.stream));\n}\n/**\n * @see https://infra.spec.whatwg.org/#parse-json-bytes-to-a-javascript-value\n * @param {Uint8Array} bytes\n */ function parseJSONFromBytes(bytes) {\n    return JSON.parse(utf8DecodeBytes(bytes));\n}\n/**\n * @see https://fetch.spec.whatwg.org/#concept-body-mime-type\n * @param {import('./response').Response|import('./request').Request} requestOrResponse\n */ function bodyMimeType(requestOrResponse) {\n    // 1. Let headers be null.\n    // 2. If requestOrResponse is a Request object, then set headers to requestOrResponses requests header list.\n    // 3. Otherwise, set headers to requestOrResponses responses header list.\n    /** @type {import('./headers').HeadersList} */ const headers = requestOrResponse[kState].headersList;\n    // 4. Let mimeType be the result of extracting a MIME type from headers.\n    const mimeType = extractMimeType(headers);\n    // 5. If mimeType is failure, then return null.\n    if (mimeType === \"failure\") {\n        return null;\n    }\n    // 6. Return mimeType.\n    return mimeType;\n}\nmodule.exports = {\n    extractBody,\n    safelyExtractBody,\n    cloneBody,\n    mixinBody\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZmV0Y2gvYm9keS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU1BLE9BQU9DLG1CQUFPQSxDQUFDO0FBQ3JCLE1BQU0sRUFDSkMsa0JBQWtCLEVBQ2xCQyxVQUFVLEVBQ1ZDLG9CQUFvQixFQUNwQkMsbUJBQW1CLEVBQ25CQyxxQkFBcUIsRUFDckJDLGFBQWEsRUFDYkMsZUFBZSxFQUNmQyxlQUFBQSxFQUNELEdBQUdSLG1CQUFPQSxDQUFDO0FBQ1osTUFBTSxFQUFFUyxRQUFBQSxFQUFVLEdBQUdULG1CQUFPQSxDQUFDO0FBQzdCLE1BQU0sRUFBRVUsTUFBQUEsRUFBUSxHQUFHVixtQkFBT0EsQ0FBQztBQUMzQixNQUFNLEVBQUVXLE1BQUFBLEVBQVEsR0FBR1gsbUJBQU9BLENBQUM7QUFDM0IsTUFBTSxFQUFFWSxJQUFBQSxFQUFNLEdBQUdaLG1CQUFPQSxDQUFDO0FBQ3pCLE1BQU1hLFNBQVNiLG1CQUFPQSxDQUFDO0FBQ3ZCLE1BQU0sRUFBRWMsU0FBQUEsRUFBVyxHQUFHZCxtQkFBT0EsQ0FBQztBQUM5QixNQUFNLEVBQUVlLGFBQUFBLEVBQWUsR0FBR2YsbUJBQU9BLENBQUM7QUFDbEMsTUFBTSxFQUFFZ0Isa0JBQUFBLEVBQW9CLEdBQUdoQixtQkFBT0EsQ0FBQztBQUN2QyxNQUFNLEVBQUVpQix1QkFBQUEsRUFBeUIsR0FBR2pCLG1CQUFPQSxDQUFDO0FBRTVDLE1BQU1rQixjQUFjLElBQUlDO0FBRXhCO0FBQ0EsU0FBU0MsWUFBYUMsTUFBTSxFQUFFQyxZQUFZLEtBQUs7SUFDN0M7SUFDQSxJQUFJQyxTQUFTO0lBRWI7SUFDQSxJQUFJRixrQkFBa0JHLGdCQUFnQjtRQUNwQ0QsU0FBU0Y7SUFDWCxPQUFPLElBQUluQixXQUFXbUIsU0FBUztRQUM3QjtRQUNBO1FBQ0FFLFNBQVNGLE9BQU9FLE1BQU07SUFDeEIsT0FBTztRQUNMO1FBQ0E7UUFDQUEsU0FBUyxJQUFJQyxlQUFlO1lB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T0MsT0FBTyxHQUFHO0lBQ2YvRztJQUNBOEQ7SUFDQUM7SUFDQTBCO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tb2NrdXBmbG93Ly4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvd2ViL2ZldGNoL2JvZHkuanM/NzQ5NiIsIndlYnBhY2s6Ly9tb2NrdXBmbG93Ly4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvd2ViL2ZldGNoL2JvZHkuanM/NzQ5NioiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHV0aWwgPSByZXF1aXJlKCcuLi8uLi9jb3JlL3V0aWwnKVxuY29uc3Qge1xuICBSZWFkYWJsZVN0cmVhbUZyb20sXG4gIGlzQmxvYkxpa2UsXG4gIGlzUmVhZGFibGVTdHJlYW1MaWtlLFxuICByZWFkYWJsZVN0cmVhbUNsb3NlLFxuICBjcmVhdGVEZWZlcnJlZFByb21pc2UsXG4gIGZ1bGx5UmVhZEJvZHksXG4gIGV4dHJhY3RNaW1lVHlwZSxcbiAgdXRmOERlY29kZUJ5dGVzXG59ID0gcmVxdWlyZSgnLi91dGlsJylcbmNvbnN0IHsgRm9ybURhdGEgfSA9IHJlcXVpcmUoJy4vZm9ybWRhdGEnKVxuY29uc3QgeyBrU3RhdGUgfSA9IHJlcXVpcmUoJy4vc3ltYm9scycpXG5jb25zdCB7IHdlYmlkbCB9ID0gcmVxdWlyZSgnLi93ZWJpZGwnKVxuY29uc3QgeyBCbG9iIH0gPSByZXF1aXJlKCdub2RlOmJ1ZmZlcicpXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdub2RlOmFzc2VydCcpXG5jb25zdCB7IGlzRXJyb3JlZCB9ID0gcmVxdWlyZSgnLi4vLi4vY29yZS91dGlsJylcbmNvbnN0IHsgaXNBcnJheUJ1ZmZlciB9ID0gcmVxdWlyZSgnbm9kZTp1dGlsL3R5cGVzJylcbmNvbnN0IHsgc2VyaWFsaXplQU1pbWVUeXBlIH0gPSByZXF1aXJlKCcuL2RhdGEtdXJsJylcbmNvbnN0IHsgbXVsdGlwYXJ0Rm9ybURhdGFQYXJzZXIgfSA9IHJlcXVpcmUoJy4vZm9ybWRhdGEtcGFyc2VyJylcblxuY29uc3QgdGV4dEVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1ib2R5aW5pdC1leHRyYWN0XG5mdW5jdGlvbiBleHRyYWN0Qm9keSAob2JqZWN0LCBrZWVwYWxpdmUgPSBmYWxzZSkge1xuICAvLyAxLiBMZXQgc3RyZWFtIGJlIG51bGwuXG4gIGxldCBzdHJlYW0gPSBudWxsXG5cbiAgLy8gMi4gSWYgb2JqZWN0IGlzIGEgUmVhZGFibGVTdHJlYW0gb2JqZWN0LCB0aGVuIHNldCBzdHJlYW0gdG8gb2JqZWN0LlxuICBpZiAob2JqZWN0IGluc3RhbmNlb2YgUmVhZGFibGVTdHJlYW0pIHtcbiAgICBzdHJlYW0gPSBvYmplY3RcbiAgfSBlbHNlIGlmIChpc0Jsb2JMaWtlKG9iamVjdCkpIHtcbiAgICAvLyAzLiBPdGhlcndpc2UsIGlmIG9iamVjdCBpcyBhIEJsb2Igb2JqZWN0LCBzZXQgc3RyZWFtIHRvIHRoZVxuICAgIC8vICAgIHJlc3VsdCBvZiBydW5uaW5nIG9iamVjdOKAmXMgZ2V0IHN0cmVhbS5cbiAgICBzdHJlYW0gPSBvYmplY3Quc3RyZWFtKClcbiAgfSBlbHNlIHtcbiAgICAvLyA0LiBPdGhlcndpc2UsIHNldCBzdHJlYW0gdG8gYSBuZXcgUmVhZGFibGVTdHJlYW0gb2JqZWN0LCBhbmQgc2V0XG4gICAgLy8gICAgdXAgc3RyZWFtIHdpdGggYnl0ZSByZWFkaW5nIHN1cHBvcnQuXG4gICAgc3RyZWFtID0gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICAgIGFzeW5jIHB1bGwgKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgY29uc3QgYnVmZmVyID0gdHlwZW9mIHNvdXJjZSA9PT0gJ3N0cmluZycgPyB0ZXh0RW5jb2Rlci5lbmNvZGUoc291cmNlKSA6IHNvdXJjZVxuXG4gICAgICAgIGlmIChidWZmZXIuYnl0ZUxlbmd0aCkge1xuICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShidWZmZXIpXG4gICAgICAgIH1cblxuICAgICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiByZWFkYWJsZVN0cmVhbUNsb3NlKGNvbnRyb2xsZXIpKVxuICAgICAgfSxcbiAgICAgIHN0YXJ0ICgpIHt9LFxuICAgICAgdHlwZTogJ2J5dGVzJ1xuICAgIH0pXG4gIH1cblxuICAvLyA1LiBBc3NlcnQ6IHN0cmVhbSBpcyBhIFJlYWRhYmxlU3RyZWFtIG9iamVjdC5cbiAgYXNzZXJ0KGlzUmVhZGFibGVTdHJlYW1MaWtlKHN0cmVhbSkpXG5cbiAgLy8gNi4gTGV0IGFjdGlvbiBiZSBudWxsLlxuICBsZXQgYWN0aW9uID0gbnVsbFxuXG4gIC8vIDcuIExldCBzb3VyY2UgYmUgbnVsbC5cbiAgbGV0IHNvdXJjZSA9IG51bGxcblxuICAvLyA4LiBMZXQgbGVuZ3RoIGJlIG51bGwuXG4gIGxldCBsZW5ndGggPSBudWxsXG5cbiAgLy8gOS4gTGV0IHR5cGUgYmUgbnVsbC5cbiAgbGV0IHR5cGUgPSBudWxsXG5cbiAgLy8gMTAuIFN3aXRjaCBvbiBvYmplY3Q6XG4gIGlmICh0eXBlb2Ygb2JqZWN0ID09PSAnc3RyaW5nJykge1xuICAgIC8vIFNldCBzb3VyY2UgdG8gdGhlIFVURi04IGVuY29kaW5nIG9mIG9iamVjdC5cbiAgICAvLyBOb3RlOiBzZXR0aW5nIHNvdXJjZSB0byBhIFVpbnQ4QXJyYXkgaGVyZSBicmVha3Mgc29tZSBtb2NraW5nIGFzc3VtcHRpb25zLlxuICAgIHNvdXJjZSA9IG9iamVjdFxuXG4gICAgLy8gU2V0IHR5cGUgdG8gYHRleHQvcGxhaW47Y2hhcnNldD1VVEYtOGAuXG4gICAgdHlwZSA9ICd0ZXh0L3BsYWluO2NoYXJzZXQ9VVRGLTgnXG4gIH0gZWxzZSBpZiAob2JqZWN0IGluc3RhbmNlb2YgVVJMU2VhcmNoUGFyYW1zKSB7XG4gICAgLy8gVVJMU2VhcmNoUGFyYW1zXG5cbiAgICAvLyBzcGVjIHNheXMgdG8gcnVuIGFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCBvbiBib2R5Lmxpc3RcbiAgICAvLyB0aGlzIGlzIGltcGxlbWVudGVkIGluIE5vZGUuanMgYXMgYXBhcnQgb2YgYW4gVVJMU2VhcmNoUGFyYW1zIGluc3RhbmNlIHRvU3RyaW5nIG1ldGhvZFxuICAgIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvZTQ2YzY4MGJmMmIyMTFiYmQ1MmNmOTU5Y2ExN2VlOThjN2Y2NTdmNS9saWIvaW50ZXJuYWwvdXJsLmpzI0w0OTBcbiAgICAvLyBhbmQgaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvZTQ2YzY4MGJmMmIyMTFiYmQ1MmNmOTU5Y2ExN2VlOThjN2Y2NTdmNS9saWIvaW50ZXJuYWwvdXJsLmpzI0wxMTAwXG5cbiAgICAvLyBTZXQgc291cmNlIHRvIHRoZSByZXN1bHQgb2YgcnVubmluZyB0aGUgYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkIHNlcmlhbGl6ZXIgd2l0aCBvYmplY3TigJlzIGxpc3QuXG4gICAgc291cmNlID0gb2JqZWN0LnRvU3RyaW5nKClcblxuICAgIC8vIFNldCB0eXBlIHRvIGBhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7Y2hhcnNldD1VVEYtOGAuXG4gICAgdHlwZSA9ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7Y2hhcnNldD1VVEYtOCdcbiAgfSBlbHNlIGlmIChpc0FycmF5QnVmZmVyKG9iamVjdCkpIHtcbiAgICAvLyBCdWZmZXJTb3VyY2UvQXJyYXlCdWZmZXJcblxuICAgIC8vIFNldCBzb3VyY2UgdG8gYSBjb3B5IG9mIHRoZSBieXRlcyBoZWxkIGJ5IG9iamVjdC5cbiAgICBzb3VyY2UgPSBuZXcgVWludDhBcnJheShvYmplY3Quc2xpY2UoKSlcbiAgfSBlbHNlIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcob2JqZWN0KSkge1xuICAgIC8vIEJ1ZmZlclNvdXJjZS9BcnJheUJ1ZmZlclZpZXdcblxuICAgIC8vIFNldCBzb3VyY2UgdG8gYSBjb3B5IG9mIHRoZSBieXRlcyBoZWxkIGJ5IG9iamVjdC5cbiAgICBzb3VyY2UgPSBuZXcgVWludDhBcnJheShvYmplY3QuYnVmZmVyLnNsaWNlKG9iamVjdC5ieXRlT2Zmc2V0LCBvYmplY3QuYnl0ZU9mZnNldCArIG9iamVjdC5ieXRlTGVuZ3RoKSlcbiAgfSBlbHNlIGlmICh1dGlsLmlzRm9ybURhdGFMaWtlKG9iamVjdCkpIHtcbiAgICBjb25zdCBib3VuZGFyeSA9IGAtLS0tZm9ybWRhdGEtdW5kaWNpLTAke2Ake01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDFlMTEpfWAucGFkU3RhcnQoMTEsICcwJyl9YFxuICAgIGNvbnN0IHByZWZpeCA9IGAtLSR7Ym91bmRhcnl9XFxyXFxuQ29udGVudC1EaXNwb3NpdGlvbjogZm9ybS1kYXRhYFxuXG4gICAgLyohIGZvcm1kYXRhLXBvbHlmaWxsLiBNSVQgTGljZW5zZS4gSmltbXkgV8OkcnRpbmcgPGh0dHBzOi8vamltbXkud2FydGluZy5zZS9vcGVuc291cmNlPiAqL1xuICAgIGNvbnN0IGVzY2FwZSA9IChzdHIpID0+XG4gICAgICBzdHIucmVwbGFjZSgvXFxuL2csICclMEEnKS5yZXBsYWNlKC9cXHIvZywgJyUwRCcpLnJlcGxhY2UoL1wiL2csICclMjInKVxuICAgIGNvbnN0IG5vcm1hbGl6ZUxpbmVmZWVkcyA9ICh2YWx1ZSkgPT4gdmFsdWUucmVwbGFjZSgvXFxyP1xcbnxcXHIvZywgJ1xcclxcbicpXG5cbiAgICAvLyBTZXQgYWN0aW9uIHRvIHRoaXMgc3RlcDogcnVuIHRoZSBtdWx0aXBhcnQvZm9ybS1kYXRhXG4gICAgLy8gZW5jb2RpbmcgYWxnb3JpdGhtLCB3aXRoIG9iamVjdOKAmXMgZW50cnkgbGlzdCBhbmQgVVRGLTguXG4gICAgLy8gLSBUaGlzIGVuc3VyZXMgdGhhdCB0aGUgYm9keSBpcyBpbW11dGFibGUgYW5kIGNhbid0IGJlIGNoYW5nZWQgYWZ0ZXJ3b3Jkc1xuICAgIC8vIC0gVGhhdCB0aGUgY29udGVudC1sZW5ndGggaXMgY2FsY3VsYXRlZCBpbiBhZHZhbmNlLlxuICAgIC8vIC0gQW5kIHRoYXQgYWxsIHBhcnRzIGFyZSBwcmUtZW5jb2RlZCBhbmQgcmVhZHkgdG8gYmUgc2VudC5cblxuICAgIGNvbnN0IGJsb2JQYXJ0cyA9IFtdXG4gICAgY29uc3Qgcm4gPSBuZXcgVWludDhBcnJheShbMTMsIDEwXSkgLy8gJ1xcclxcbidcbiAgICBsZW5ndGggPSAwXG4gICAgbGV0IGhhc1Vua25vd25TaXplVmFsdWUgPSBmYWxzZVxuXG4gICAgZm9yIChjb25zdCBbbmFtZSwgdmFsdWVdIG9mIG9iamVjdCkge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgY29uc3QgY2h1bmsgPSB0ZXh0RW5jb2Rlci5lbmNvZGUocHJlZml4ICtcbiAgICAgICAgICBgOyBuYW1lPVwiJHtlc2NhcGUobm9ybWFsaXplTGluZWZlZWRzKG5hbWUpKX1cImAgK1xuICAgICAgICAgIGBcXHJcXG5cXHJcXG4ke25vcm1hbGl6ZUxpbmVmZWVkcyh2YWx1ZSl9XFxyXFxuYClcbiAgICAgICAgYmxvYlBhcnRzLnB1c2goY2h1bmspXG4gICAgICAgIGxlbmd0aCArPSBjaHVuay5ieXRlTGVuZ3RoXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBjaHVuayA9IHRleHRFbmNvZGVyLmVuY29kZShgJHtwcmVmaXh9OyBuYW1lPVwiJHtlc2NhcGUobm9ybWFsaXplTGluZWZlZWRzKG5hbWUpKX1cImAgK1xuICAgICAgICAgICh2YWx1ZS5uYW1lID8gYDsgZmlsZW5hbWU9XCIke2VzY2FwZSh2YWx1ZS5uYW1lKX1cImAgOiAnJykgKyAnXFxyXFxuJyArXG4gICAgICAgICAgYENvbnRlbnQtVHlwZTogJHtcbiAgICAgICAgICAgIHZhbHVlLnR5cGUgfHwgJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbSdcbiAgICAgICAgICB9XFxyXFxuXFxyXFxuYClcbiAgICAgICAgYmxvYlBhcnRzLnB1c2goY2h1bmssIHZhbHVlLCBybilcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZS5zaXplID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIGxlbmd0aCArPSBjaHVuay5ieXRlTGVuZ3RoICsgdmFsdWUuc2l6ZSArIHJuLmJ5dGVMZW5ndGhcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBoYXNVbmtub3duU2l6ZVZhbHVlID0gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgY2h1bmsgPSB0ZXh0RW5jb2Rlci5lbmNvZGUoYC0tJHtib3VuZGFyeX0tLWApXG4gICAgYmxvYlBhcnRzLnB1c2goY2h1bmspXG4gICAgbGVuZ3RoICs9IGNodW5rLmJ5dGVMZW5ndGhcbiAgICBpZiAoaGFzVW5rbm93blNpemVWYWx1ZSkge1xuICAgICAgbGVuZ3RoID0gbnVsbFxuICAgIH1cblxuICAgIC8vIFNldCBzb3VyY2UgdG8gb2JqZWN0LlxuICAgIHNvdXJjZSA9IG9iamVjdFxuXG4gICAgYWN0aW9uID0gYXN5bmMgZnVuY3Rpb24gKiAoKSB7XG4gICAgICBmb3IgKGNvbnN0IHBhcnQgb2YgYmxvYlBhcnRzKSB7XG4gICAgICAgIGlmIChwYXJ0LnN0cmVhbSkge1xuICAgICAgICAgIHlpZWxkICogcGFydC5zdHJlYW0oKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHlpZWxkIHBhcnRcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFNldCB0eXBlIHRvIGBtdWx0aXBhcnQvZm9ybS1kYXRhOyBib3VuZGFyeT1gLFxuICAgIC8vIGZvbGxvd2VkIGJ5IHRoZSBtdWx0aXBhcnQvZm9ybS1kYXRhIGJvdW5kYXJ5IHN0cmluZyBnZW5lcmF0ZWRcbiAgICAvLyBieSB0aGUgbXVsdGlwYXJ0L2Zvcm0tZGF0YSBlbmNvZGluZyBhbGdvcml0aG0uXG4gICAgdHlwZSA9IGBtdWx0aXBhcnQvZm9ybS1kYXRhOyBib3VuZGFyeT0ke2JvdW5kYXJ5fWBcbiAgfSBlbHNlIGlmIChpc0Jsb2JMaWtlKG9iamVjdCkpIHtcbiAgICAvLyBCbG9iXG5cbiAgICAvLyBTZXQgc291cmNlIHRvIG9iamVjdC5cbiAgICBzb3VyY2UgPSBvYmplY3RcblxuICAgIC8vIFNldCBsZW5ndGggdG8gb2JqZWN04oCZcyBzaXplLlxuICAgIGxlbmd0aCA9IG9iamVjdC5zaXplXG5cbiAgICAvLyBJZiBvYmplY3TigJlzIHR5cGUgYXR0cmlidXRlIGlzIG5vdCB0aGUgZW1wdHkgYnl0ZSBzZXF1ZW5jZSwgc2V0XG4gICAgLy8gdHlwZSB0byBpdHMgdmFsdWUuXG4gICAgaWYgKG9iamVjdC50eXBlKSB7XG4gICAgICB0eXBlID0gb2JqZWN0LnR5cGVcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIG9iamVjdFtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBJZiBrZWVwYWxpdmUgaXMgdHJ1ZSwgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgICBpZiAoa2VlcGFsaXZlKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdrZWVwYWxpdmUnKVxuICAgIH1cblxuICAgIC8vIElmIG9iamVjdCBpcyBkaXN0dXJiZWQgb3IgbG9ja2VkLCB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICAgIGlmICh1dGlsLmlzRGlzdHVyYmVkKG9iamVjdCkgfHwgb2JqZWN0LmxvY2tlZCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgJ1Jlc3BvbnNlIGJvZHkgb2JqZWN0IHNob3VsZCBub3QgYmUgZGlzdHVyYmVkIG9yIGxvY2tlZCdcbiAgICAgIClcbiAgICB9XG5cbiAgICBzdHJlYW0gPVxuICAgICAgb2JqZWN0IGluc3RhbmNlb2YgUmVhZGFibGVTdHJlYW0gPyBvYmplY3QgOiBSZWFkYWJsZVN0cmVhbUZyb20ob2JqZWN0KVxuICB9XG5cbiAgLy8gMTEuIElmIHNvdXJjZSBpcyBhIGJ5dGUgc2VxdWVuY2UsIHRoZW4gc2V0IGFjdGlvbiB0byBhXG4gIC8vIHN0ZXAgdGhhdCByZXR1cm5zIHNvdXJjZSBhbmQgbGVuZ3RoIHRvIHNvdXJjZeKAmXMgbGVuZ3RoLlxuICBpZiAodHlwZW9mIHNvdXJjZSA9PT0gJ3N0cmluZycgfHwgdXRpbC5pc0J1ZmZlcihzb3VyY2UpKSB7XG4gICAgbGVuZ3RoID0gQnVmZmVyLmJ5dGVMZW5ndGgoc291cmNlKVxuICB9XG5cbiAgLy8gMTIuIElmIGFjdGlvbiBpcyBub24tbnVsbCwgdGhlbiBydW4gdGhlc2Ugc3RlcHMgaW4gaW4gcGFyYWxsZWw6XG4gIGlmIChhY3Rpb24gIT0gbnVsbCkge1xuICAgIC8vIFJ1biBhY3Rpb24uXG4gICAgbGV0IGl0ZXJhdG9yXG4gICAgc3RyZWFtID0gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICAgIGFzeW5jIHN0YXJ0ICgpIHtcbiAgICAgICAgaXRlcmF0b3IgPSBhY3Rpb24ob2JqZWN0KVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKVxuICAgICAgfSxcbiAgICAgIGFzeW5jIHB1bGwgKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgY29uc3QgeyB2YWx1ZSwgZG9uZSB9ID0gYXdhaXQgaXRlcmF0b3IubmV4dCgpXG4gICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgLy8gV2hlbiBydW5uaW5nIGFjdGlvbiBpcyBkb25lLCBjbG9zZSBzdHJlYW0uXG4gICAgICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgICAgICAgY29udHJvbGxlci5jbG9zZSgpXG4gICAgICAgICAgICBjb250cm9sbGVyLmJ5b2JSZXF1ZXN0Py5yZXNwb25kKDApXG4gICAgICAgICAgfSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBXaGVuZXZlciBvbmUgb3IgbW9yZSBieXRlcyBhcmUgYXZhaWxhYmxlIGFuZCBzdHJlYW0gaXMgbm90IGVycm9yZWQsXG4gICAgICAgICAgLy8gZW5xdWV1ZSBhIFVpbnQ4QXJyYXkgd3JhcHBpbmcgYW4gQXJyYXlCdWZmZXIgY29udGFpbmluZyB0aGUgYXZhaWxhYmxlXG4gICAgICAgICAgLy8gYnl0ZXMgaW50byBzdHJlYW0uXG4gICAgICAgICAgaWYgKCFpc0Vycm9yZWQoc3RyZWFtKSkge1xuICAgICAgICAgICAgY29uc3QgYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkodmFsdWUpXG4gICAgICAgICAgICBpZiAoYnVmZmVyLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGJ1ZmZlcilcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXIuZGVzaXJlZFNpemUgPiAwXG4gICAgICB9LFxuICAgICAgYXN5bmMgY2FuY2VsIChyZWFzb24pIHtcbiAgICAgICAgYXdhaXQgaXRlcmF0b3IucmV0dXJuKClcbiAgICAgIH0sXG4gICAgICB0eXBlOiAnYnl0ZXMnXG4gICAgfSlcbiAgfVxuXG4gIC8vIDEzLiBMZXQgYm9keSBiZSBhIGJvZHkgd2hvc2Ugc3RyZWFtIGlzIHN0cmVhbSwgc291cmNlIGlzIHNvdXJjZSxcbiAgLy8gYW5kIGxlbmd0aCBpcyBsZW5ndGguXG4gIGNvbnN0IGJvZHkgPSB7IHN0cmVhbSwgc291cmNlLCBsZW5ndGggfVxuXG4gIC8vIDE0LiBSZXR1cm4gKGJvZHksIHR5cGUpLlxuICByZXR1cm4gW2JvZHksIHR5cGVdXG59XG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNib2R5aW5pdC1zYWZlbHktZXh0cmFjdFxuZnVuY3Rpb24gc2FmZWx5RXh0cmFjdEJvZHkgKG9iamVjdCwga2VlcGFsaXZlID0gZmFsc2UpIHtcbiAgLy8gVG8gc2FmZWx5IGV4dHJhY3QgYSBib2R5IGFuZCBhIGBDb250ZW50LVR5cGVgIHZhbHVlIGZyb21cbiAgLy8gYSBieXRlIHNlcXVlbmNlIG9yIEJvZHlJbml0IG9iamVjdCBvYmplY3QsIHJ1biB0aGVzZSBzdGVwczpcblxuICAvLyAxLiBJZiBvYmplY3QgaXMgYSBSZWFkYWJsZVN0cmVhbSBvYmplY3QsIHRoZW46XG4gIGlmIChvYmplY3QgaW5zdGFuY2VvZiBSZWFkYWJsZVN0cmVhbSkge1xuICAgIC8vIEFzc2VydDogb2JqZWN0IGlzIG5laXRoZXIgZGlzdHVyYmVkIG5vciBsb2NrZWQuXG4gICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICBhc3NlcnQoIXV0aWwuaXNEaXN0dXJiZWQob2JqZWN0KSwgJ1RoZSBib2R5IGhhcyBhbHJlYWR5IGJlZW4gY29uc3VtZWQuJylcbiAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICAgIGFzc2VydCghb2JqZWN0LmxvY2tlZCwgJ1RoZSBzdHJlYW0gaXMgbG9ja2VkLicpXG4gIH1cblxuICAvLyAyLiBSZXR1cm4gdGhlIHJlc3VsdHMgb2YgZXh0cmFjdGluZyBvYmplY3QuXG4gIHJldHVybiBleHRyYWN0Qm9keShvYmplY3QsIGtlZXBhbGl2ZSlcbn1cblxuZnVuY3Rpb24gY2xvbmVCb2R5IChib2R5KSB7XG4gIC8vIFRvIGNsb25lIGEgYm9keSBib2R5LCBydW4gdGhlc2Ugc3RlcHM6XG5cbiAgLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtYm9keS1jbG9uZVxuXG4gIC8vIDEuIExldCDCqyBvdXQxLCBvdXQyIMK7IGJlIHRoZSByZXN1bHQgb2YgdGVlaW5nIGJvZHnigJlzIHN0cmVhbS5cbiAgY29uc3QgW291dDEsIG91dDJdID0gYm9keS5zdHJlYW0udGVlKClcblxuICAvLyAyLiBTZXQgYm9keeKAmXMgc3RyZWFtIHRvIG91dDEuXG4gIGJvZHkuc3RyZWFtID0gb3V0MVxuXG4gIC8vIDMuIFJldHVybiBhIGJvZHkgd2hvc2Ugc3RyZWFtIGlzIG91dDIgYW5kIG90aGVyIG1lbWJlcnMgYXJlIGNvcGllZCBmcm9tIGJvZHkuXG4gIHJldHVybiB7XG4gICAgc3RyZWFtOiBvdXQyLFxuICAgIGxlbmd0aDogYm9keS5sZW5ndGgsXG4gICAgc291cmNlOiBib2R5LnNvdXJjZVxuICB9XG59XG5cbmZ1bmN0aW9uIHRocm93SWZBYm9ydGVkIChzdGF0ZSkge1xuICBpZiAoc3RhdGUuYWJvcnRlZCkge1xuICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oJ1RoZSBvcGVyYXRpb24gd2FzIGFib3J0ZWQuJywgJ0Fib3J0RXJyb3InKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJvZHlNaXhpbk1ldGhvZHMgKGluc3RhbmNlKSB7XG4gIGNvbnN0IG1ldGhvZHMgPSB7XG4gICAgYmxvYiAoKSB7XG4gICAgICAvLyBUaGUgYmxvYigpIG1ldGhvZCBzdGVwcyBhcmUgdG8gcmV0dXJuIHRoZSByZXN1bHQgb2ZcbiAgICAgIC8vIHJ1bm5pbmcgY29uc3VtZSBib2R5IHdpdGggdGhpcyBhbmQgdGhlIGZvbGxvd2luZyBzdGVwXG4gICAgICAvLyBnaXZlbiBhIGJ5dGUgc2VxdWVuY2UgYnl0ZXM6IHJldHVybiBhIEJsb2Igd2hvc2VcbiAgICAgIC8vIGNvbnRlbnRzIGFyZSBieXRlcyBhbmQgd2hvc2UgdHlwZSBhdHRyaWJ1dGUgaXMgdGhpc+KAmXNcbiAgICAgIC8vIE1JTUUgdHlwZS5cbiAgICAgIHJldHVybiBjb25zdW1lQm9keSh0aGlzLCAoYnl0ZXMpID0+IHtcbiAgICAgICAgbGV0IG1pbWVUeXBlID0gYm9keU1pbWVUeXBlKHRoaXMpXG5cbiAgICAgICAgaWYgKG1pbWVUeXBlID09PSBudWxsKSB7XG4gICAgICAgICAgbWltZVR5cGUgPSAnJ1xuICAgICAgICB9IGVsc2UgaWYgKG1pbWVUeXBlKSB7XG4gICAgICAgICAgbWltZVR5cGUgPSBzZXJpYWxpemVBTWltZVR5cGUobWltZVR5cGUpXG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZXR1cm4gYSBCbG9iIHdob3NlIGNvbnRlbnRzIGFyZSBieXRlcyBhbmQgdHlwZSBhdHRyaWJ1dGVcbiAgICAgICAgLy8gaXMgbWltZVR5cGUuXG4gICAgICAgIHJldHVybiBuZXcgQmxvYihbYnl0ZXNdLCB7IHR5cGU6IG1pbWVUeXBlIH0pXG4gICAgICB9LCBpbnN0YW5jZSlcbiAgICB9LFxuXG4gICAgYXJyYXlCdWZmZXIgKCkge1xuICAgICAgLy8gVGhlIGFycmF5QnVmZmVyKCkgbWV0aG9kIHN0ZXBzIGFyZSB0byByZXR1cm4gdGhlIHJlc3VsdFxuICAgICAgLy8gb2YgcnVubmluZyBjb25zdW1lIGJvZHkgd2l0aCB0aGlzIGFuZCB0aGUgZm9sbG93aW5nIHN0ZXBcbiAgICAgIC8vIGdpdmVuIGEgYnl0ZSBzZXF1ZW5jZSBieXRlczogcmV0dXJuIGEgbmV3IEFycmF5QnVmZmVyXG4gICAgICAvLyB3aG9zZSBjb250ZW50cyBhcmUgYnl0ZXMuXG4gICAgICByZXR1cm4gY29uc3VtZUJvZHkodGhpcywgKGJ5dGVzKSA9PiB7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShieXRlcykuYnVmZmVyXG4gICAgICB9LCBpbnN0YW5jZSlcbiAgICB9LFxuXG4gICAgdGV4dCAoKSB7XG4gICAgICAvLyBUaGUgdGV4dCgpIG1ldGhvZCBzdGVwcyBhcmUgdG8gcmV0dXJuIHRoZSByZXN1bHQgb2YgcnVubmluZ1xuICAgICAgLy8gY29uc3VtZSBib2R5IHdpdGggdGhpcyBhbmQgVVRGLTggZGVjb2RlLlxuICAgICAgcmV0dXJuIGNvbnN1bWVCb2R5KHRoaXMsIHV0ZjhEZWNvZGVCeXRlcywgaW5zdGFuY2UpXG4gICAgfSxcblxuICAgIGpzb24gKCkge1xuICAgICAgLy8gVGhlIGpzb24oKSBtZXRob2Qgc3RlcHMgYXJlIHRvIHJldHVybiB0aGUgcmVzdWx0IG9mIHJ1bm5pbmdcbiAgICAgIC8vIGNvbnN1bWUgYm9keSB3aXRoIHRoaXMgYW5kIHBhcnNlIEpTT04gZnJvbSBieXRlcy5cbiAgICAgIHJldHVybiBjb25zdW1lQm9keSh0aGlzLCBwYXJzZUpTT05Gcm9tQnl0ZXMsIGluc3RhbmNlKVxuICAgIH0sXG5cbiAgICBmb3JtRGF0YSAoKSB7XG4gICAgICAvLyBUaGUgZm9ybURhdGEoKSBtZXRob2Qgc3RlcHMgYXJlIHRvIHJldHVybiB0aGUgcmVzdWx0IG9mIHJ1bm5pbmdcbiAgICAgIC8vIGNvbnN1bWUgYm9keSB3aXRoIHRoaXMgYW5kIHRoZSBmb2xsb3dpbmcgc3RlcCBnaXZlbiBhIGJ5dGUgc2VxdWVuY2UgYnl0ZXM6XG4gICAgICByZXR1cm4gY29uc3VtZUJvZHkodGhpcywgKHZhbHVlKSA9PiB7XG4gICAgICAgIC8vIDEuIExldCBtaW1lVHlwZSBiZSB0aGUgcmVzdWx0IG9mIGdldCB0aGUgTUlNRSB0eXBlIHdpdGggdGhpcy5cbiAgICAgICAgY29uc3QgbWltZVR5cGUgPSBib2R5TWltZVR5cGUodGhpcylcblxuICAgICAgICAvLyAyLiBJZiBtaW1lVHlwZSBpcyBub24tbnVsbCwgdGhlbiBzd2l0Y2ggb24gbWltZVR5cGXigJlzIGVzc2VuY2UgYW5kIHJ1blxuICAgICAgICAvLyAgICB0aGUgY29ycmVzcG9uZGluZyBzdGVwczpcbiAgICAgICAgaWYgKG1pbWVUeXBlICE9PSBudWxsKSB7XG4gICAgICAgICAgc3dpdGNoIChtaW1lVHlwZS5lc3NlbmNlKSB7XG4gICAgICAgICAgICBjYXNlICdtdWx0aXBhcnQvZm9ybS1kYXRhJzoge1xuICAgICAgICAgICAgICAvLyAxLiAuLi4gW2xvbmcgc3RlcF1cbiAgICAgICAgICAgICAgY29uc3QgcGFyc2VkID0gbXVsdGlwYXJ0Rm9ybURhdGFQYXJzZXIodmFsdWUsIG1pbWVUeXBlKVxuXG4gICAgICAgICAgICAgIC8vIDIuIElmIHRoYXQgZmFpbHMgZm9yIHNvbWUgcmVhc29uLCB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICAgICAgICAgICAgICBpZiAocGFyc2VkID09PSAnZmFpbHVyZScpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGYWlsZWQgdG8gcGFyc2UgYm9keSBhcyBGb3JtRGF0YS4nKVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gMy4gUmV0dXJuIGEgbmV3IEZvcm1EYXRhIG9iamVjdCwgYXBwZW5kaW5nIGVhY2ggZW50cnksXG4gICAgICAgICAgICAgIC8vICAgIHJlc3VsdGluZyBmcm9tIHRoZSBwYXJzaW5nIG9wZXJhdGlvbiwgdG8gaXRzIGVudHJ5IGxpc3QuXG4gICAgICAgICAgICAgIGNvbnN0IGZkID0gbmV3IEZvcm1EYXRhKClcbiAgICAgICAgICAgICAgZmRba1N0YXRlXSA9IHBhcnNlZFxuXG4gICAgICAgICAgICAgIHJldHVybiBmZFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJzoge1xuICAgICAgICAgICAgICAvLyAxLiBMZXQgZW50cmllcyBiZSB0aGUgcmVzdWx0IG9mIHBhcnNpbmcgYnl0ZXMuXG4gICAgICAgICAgICAgIGNvbnN0IGVudHJpZXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHZhbHVlLnRvU3RyaW5nKCkpXG5cbiAgICAgICAgICAgICAgLy8gMi4gSWYgZW50cmllcyBpcyBmYWlsdXJlLCB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuXG4gICAgICAgICAgICAgIC8vIDMuIFJldHVybiBhIG5ldyBGb3JtRGF0YSBvYmplY3Qgd2hvc2UgZW50cnkgbGlzdCBpcyBlbnRyaWVzLlxuICAgICAgICAgICAgICBjb25zdCBmZCA9IG5ldyBGb3JtRGF0YSgpXG5cbiAgICAgICAgICAgICAgZm9yIChjb25zdCBbbmFtZSwgdmFsdWVdIG9mIGVudHJpZXMpIHtcbiAgICAgICAgICAgICAgICBmZC5hcHBlbmQobmFtZSwgdmFsdWUpXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gZmRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyAzLiBUaHJvdyBhIFR5cGVFcnJvci5cbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAnQ29udGVudC1UeXBlIHdhcyBub3Qgb25lIG9mIFwibXVsdGlwYXJ0L2Zvcm0tZGF0YVwiIG9yIFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIuJ1xuICAgICAgICApXG4gICAgICB9LCBpbnN0YW5jZSlcbiAgICB9LFxuXG4gICAgYnl0ZXMgKCkge1xuICAgICAgLy8gVGhlIGJ5dGVzKCkgbWV0aG9kIHN0ZXBzIGFyZSB0byByZXR1cm4gdGhlIHJlc3VsdCBvZiBydW5uaW5nIGNvbnN1bWUgYm9keVxuICAgICAgLy8gd2l0aCB0aGlzIGFuZCB0aGUgZm9sbG93aW5nIHN0ZXAgZ2l2ZW4gYSBieXRlIHNlcXVlbmNlIGJ5dGVzOiByZXR1cm4gdGhlXG4gICAgICAvLyByZXN1bHQgb2YgY3JlYXRpbmcgYSBVaW50OEFycmF5IGZyb20gYnl0ZXMgaW4gdGhpc+KAmXMgcmVsZXZhbnQgcmVhbG0uXG4gICAgICByZXR1cm4gY29uc3VtZUJvZHkodGhpcywgKGJ5dGVzKSA9PiB7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShieXRlcylcbiAgICAgIH0sIGluc3RhbmNlKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtZXRob2RzXG59XG5cbmZ1bmN0aW9uIG1peGluQm9keSAocHJvdG90eXBlKSB7XG4gIE9iamVjdC5hc3NpZ24ocHJvdG90eXBlLnByb3RvdHlwZSwgYm9keU1peGluTWV0aG9kcyhwcm90b3R5cGUpKVxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtYm9keS1jb25zdW1lLWJvZHlcbiAqIEBwYXJhbSB7UmVzcG9uc2V8UmVxdWVzdH0gb2JqZWN0XG4gKiBAcGFyYW0geyh2YWx1ZTogdW5rbm93bikgPT4gdW5rbm93bn0gY29udmVydEJ5dGVzVG9KU1ZhbHVlXG4gKiBAcGFyYW0ge1Jlc3BvbnNlfFJlcXVlc3R9IGluc3RhbmNlXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGNvbnN1bWVCb2R5IChvYmplY3QsIGNvbnZlcnRCeXRlc1RvSlNWYWx1ZSwgaW5zdGFuY2UpIHtcbiAgd2ViaWRsLmJyYW5kQ2hlY2sob2JqZWN0LCBpbnN0YW5jZSlcblxuICAvLyAxLiBJZiBvYmplY3QgaXMgdW51c2FibGUsIHRoZW4gcmV0dXJuIGEgcHJvbWlzZSByZWplY3RlZFxuICAvLyAgICB3aXRoIGEgVHlwZUVycm9yLlxuICBpZiAoYm9keVVudXNhYmxlKG9iamVjdFtrU3RhdGVdLmJvZHkpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQm9keSBpcyB1bnVzYWJsZTogQm9keSBoYXMgYWxyZWFkeSBiZWVuIHJlYWQnKVxuICB9XG5cbiAgdGhyb3dJZkFib3J0ZWQob2JqZWN0W2tTdGF0ZV0pXG5cbiAgLy8gMi4gTGV0IHByb21pc2UgYmUgYSBuZXcgcHJvbWlzZS5cbiAgY29uc3QgcHJvbWlzZSA9IGNyZWF0ZURlZmVycmVkUHJvbWlzZSgpXG5cbiAgLy8gMy4gTGV0IGVycm9yU3RlcHMgZ2l2ZW4gZXJyb3IgYmUgdG8gcmVqZWN0IHByb21pc2Ugd2l0aCBlcnJvci5cbiAgY29uc3QgZXJyb3JTdGVwcyA9IChlcnJvcikgPT4gcHJvbWlzZS5yZWplY3QoZXJyb3IpXG5cbiAgLy8gNC4gTGV0IHN1Y2Nlc3NTdGVwcyBnaXZlbiBhIGJ5dGUgc2VxdWVuY2UgZGF0YSBiZSB0byByZXNvbHZlXG4gIC8vICAgIHByb21pc2Ugd2l0aCB0aGUgcmVzdWx0IG9mIHJ1bm5pbmcgY29udmVydEJ5dGVzVG9KU1ZhbHVlXG4gIC8vICAgIHdpdGggZGF0YS4gSWYgdGhhdCB0aHJldyBhbiBleGNlcHRpb24sIHRoZW4gcnVuIGVycm9yU3RlcHNcbiAgLy8gICAgd2l0aCB0aGF0IGV4Y2VwdGlvbi5cbiAgY29uc3Qgc3VjY2Vzc1N0ZXBzID0gKGRhdGEpID0+IHtcbiAgICB0cnkge1xuICAgICAgcHJvbWlzZS5yZXNvbHZlKGNvbnZlcnRCeXRlc1RvSlNWYWx1ZShkYXRhKSlcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBlcnJvclN0ZXBzKGUpXG4gICAgfVxuICB9XG5cbiAgLy8gNS4gSWYgb2JqZWN04oCZcyBib2R5IGlzIG51bGwsIHRoZW4gcnVuIHN1Y2Nlc3NTdGVwcyB3aXRoIGFuXG4gIC8vICAgIGVtcHR5IGJ5dGUgc2VxdWVuY2UuXG4gIGlmIChvYmplY3Rba1N0YXRlXS5ib2R5ID09IG51bGwpIHtcbiAgICBzdWNjZXNzU3RlcHMoQnVmZmVyLmFsbG9jVW5zYWZlKDApKVxuICAgIHJldHVybiBwcm9taXNlLnByb21pc2VcbiAgfVxuXG4gIC8vIDYuIE90aGVyd2lzZSwgZnVsbHkgcmVhZCBvYmplY3TigJlzIGJvZHkgZ2l2ZW4gc3VjY2Vzc1N0ZXBzLFxuICAvLyAgICBlcnJvclN0ZXBzLCBhbmQgb2JqZWN04oCZcyByZWxldmFudCBnbG9iYWwgb2JqZWN0LlxuICBhd2FpdCBmdWxseVJlYWRCb2R5KG9iamVjdFtrU3RhdGVdLmJvZHksIHN1Y2Nlc3NTdGVwcywgZXJyb3JTdGVwcylcblxuICAvLyA3LiBSZXR1cm4gcHJvbWlzZS5cbiAgcmV0dXJuIHByb21pc2UucHJvbWlzZVxufVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jYm9keS11bnVzYWJsZVxuZnVuY3Rpb24gYm9keVVudXNhYmxlIChib2R5KSB7XG4gIC8vIEFuIG9iamVjdCBpbmNsdWRpbmcgdGhlIEJvZHkgaW50ZXJmYWNlIG1peGluIGlzXG4gIC8vIHNhaWQgdG8gYmUgdW51c2FibGUgaWYgaXRzIGJvZHkgaXMgbm9uLW51bGwgYW5kXG4gIC8vIGl0cyBib2R54oCZcyBzdHJlYW0gaXMgZGlzdHVyYmVkIG9yIGxvY2tlZC5cbiAgcmV0dXJuIGJvZHkgIT0gbnVsbCAmJiAoYm9keS5zdHJlYW0ubG9ja2VkIHx8IHV0aWwuaXNEaXN0dXJiZWQoYm9keS5zdHJlYW0pKVxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9pbmZyYS5zcGVjLndoYXR3Zy5vcmcvI3BhcnNlLWpzb24tYnl0ZXMtdG8tYS1qYXZhc2NyaXB0LXZhbHVlXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ5dGVzXG4gKi9cbmZ1bmN0aW9uIHBhcnNlSlNPTkZyb21CeXRlcyAoYnl0ZXMpIHtcbiAgcmV0dXJuIEpTT04ucGFyc2UodXRmOERlY29kZUJ5dGVzKGJ5dGVzKSlcbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LWJvZHktbWltZS10eXBlXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9yZXNwb25zZScpLlJlc3BvbnNlfGltcG9ydCgnLi9yZXF1ZXN0JykuUmVxdWVzdH0gcmVxdWVzdE9yUmVzcG9uc2VcbiAqL1xuZnVuY3Rpb24gYm9keU1pbWVUeXBlIChyZXF1ZXN0T3JSZXNwb25zZSkge1xuICAvLyAxLiBMZXQgaGVhZGVycyBiZSBudWxsLlxuICAvLyAyLiBJZiByZXF1ZXN0T3JSZXNwb25zZSBpcyBhIFJlcXVlc3Qgb2JqZWN0LCB0aGVuIHNldCBoZWFkZXJzIHRvIHJlcXVlc3RPclJlc3BvbnNl4oCZcyByZXF1ZXN04oCZcyBoZWFkZXIgbGlzdC5cbiAgLy8gMy4gT3RoZXJ3aXNlLCBzZXQgaGVhZGVycyB0byByZXF1ZXN0T3JSZXNwb25zZeKAmXMgcmVzcG9uc2XigJlzIGhlYWRlciBsaXN0LlxuICAvKiogQHR5cGUge2ltcG9ydCgnLi9oZWFkZXJzJykuSGVhZGVyc0xpc3R9ICovXG4gIGNvbnN0IGhlYWRlcnMgPSByZXF1ZXN0T3JSZXNwb25zZVtrU3RhdGVdLmhlYWRlcnNMaXN0XG5cbiAgLy8gNC4gTGV0IG1pbWVUeXBlIGJlIHRoZSByZXN1bHQgb2YgZXh0cmFjdGluZyBhIE1JTUUgdHlwZSBmcm9tIGhlYWRlcnMuXG4gIGNvbnN0IG1pbWVUeXBlID0gZXh0cmFjdE1pbWVUeXBlKGhlYWRlcnMpXG5cbiAgLy8gNS4gSWYgbWltZVR5cGUgaXMgZmFpbHVyZSwgdGhlbiByZXR1cm4gbnVsbC5cbiAgaWYgKG1pbWVUeXBlID09PSAnZmFpbHVyZScpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgLy8gNi4gUmV0dXJuIG1pbWVUeXBlLlxuICByZXR1cm4gbWltZVR5cGVcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGV4dHJhY3RCb2R5LFxuICBzYWZlbHlFeHRyYWN0Qm9keSxcbiAgY2xvbmVCb2R5LFxuICBtaXhpbkJvZHlcbn1cbiJdLCJuYW1lcyI6WyJ1dGlsIiwicmVxdWlyZSIsIlJlYWRhYmxlU3RyZWFtRnJvbSIsImlzQmxvYkxpa2UiLCJpc1JlYWRhYmxlU3RyZWFtTGlrZSIsInJlYWRhYmxlU3RyZWFtQ2xvc2UiLCJjcmVhdGVEZWZlcnJlZFByb21pc2UiLCJmdWxseVJlYWRCb2R5IiwiZXh0cmFjdE1pbWVUeXBlIiwidXRmOERlY29kZUJ5dGVzIiwiRm9ybURhdGEiLCJrU3RhdGUiLCJ3ZWJpZGwiLCJCbG9iIiwiYXNzZXJ0IiwiaXNFcnJvcmVkIiwiaXNBcnJheUJ1ZmZlciIsInNlcmlhbGl6ZUFNaW1lVHlwZSIsIm11bHRpcGFydEZvcm1EYXRhUGFyc2VyIiwidGV4dEVuY29kZXIiLCJUZXh0RW5jb2RlciIsImV4dHJhY3RCb2R5Iiwib2JqZWN0Iiwia2VlcGFsaXZlIiwic3RyZWFtIiwiUmVhZGFibGVTdHJlYW0iLCJwdWxsIiwiY29udHJvbGxlciIsImJ1ZmZlciIsInNvdXJjZSIsImVuY29kZSIsImJ5dGVMZW5ndGgiLCJlbnF1ZXVlIiwicXVldWVNaWNyb3Rhc2siLCJzdGFydCIsInR5cGUiLCJhY3Rpb24iLCJsZW5ndGgiLCJVUkxTZWFyY2hQYXJhbXMiLCJ0b1N0cmluZyIsIlVpbnQ4QXJyYXkiLCJzbGljZSIsIkFycmF5QnVmZmVyIiwiaXNWaWV3IiwiYnl0ZU9mZnNldCIsImlzRm9ybURhdGFMaWtlIiwiYm91bmRhcnkiLCJNYXRoIiwiZmxvb3IiLCJyYW5kb20iLCJwYWRTdGFydCIsInByZWZpeCIsImVzY2FwZSIsInN0ciIsInJlcGxhY2UiLCJub3JtYWxpemVMaW5lZmVlZHMiLCJ2YWx1ZSIsImJsb2JQYXJ0cyIsInJuIiwiaGFzVW5rbm93blNpemVWYWx1ZSIsIm5hbWUiLCJjaHVuayIsInB1c2giLCJzaXplIiwicGFydCIsIlN5bWJvbCIsImFzeW5jSXRlcmF0b3IiLCJUeXBlRXJyb3IiLCJpc0Rpc3R1cmJlZCIsImxvY2tlZCIsImlzQnVmZmVyIiwiQnVmZmVyIiwiaXRlcmF0b3IiLCJkb25lIiwibmV4dCIsImNsb3NlIiwiYnlvYlJlcXVlc3QiLCJyZXNwb25kIiwiZGVzaXJlZFNpemUiLCJjYW5jZWwiLCJyZWFzb24iLCJyZXR1cm4iLCJib2R5Iiwic2FmZWx5RXh0cmFjdEJvZHkiLCJjbG9uZUJvZHkiLCJvdXQxIiwib3V0MiIsInRlZSIsInRocm93SWZBYm9ydGVkIiwic3RhdGUiLCJhYm9ydGVkIiwiRE9NRXhjZXB0aW9uIiwiYm9keU1peGluTWV0aG9kcyIsImluc3RhbmNlIiwibWV0aG9kcyIsImJsb2IiLCJjb25zdW1lQm9keSIsImJ5dGVzIiwibWltZVR5cGUiLCJib2R5TWltZVR5cGUiLCJhcnJheUJ1ZmZlciIsInRleHQiLCJqc29uIiwicGFyc2VKU09ORnJvbUJ5dGVzIiwiZm9ybURhdGEiLCJlc3NlbmNlIiwicGFyc2VkIiwiZmQiLCJlbnRyaWVzIiwiYXBwZW5kIiwibWl4aW5Cb2R5IiwicHJvdG90eXBlIiwiT2JqZWN0IiwiYXNzaWduIiwiY29udmVydEJ5dGVzVG9KU1ZhbHVlIiwiYnJhbmRDaGVjayIsImJvZHlVbnVzYWJsZSIsInByb21pc2UiLCJlcnJvclN0ZXBzIiwiZXJyb3IiLCJyZWplY3QiLCJzdWNjZXNzU3RlcHMiLCJkYXRhIiwicmVzb2x2ZSIsImUiLCJhbGxvY1Vuc2FmZSIsIkpTT04iLCJwYXJzZSIsInJlcXVlc3RPclJlc3BvbnNlIiwiaGVhZGVycyIsImhlYWRlcnNMaXN0IiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/fetch/body.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/fetch/constants.js":
/*!********************************************************!*\
  !*** ./node_modules/undici/lib/web/fetch/constants.js ***!
  \********************************************************/
/***/ ((module) => {

eval("\nconst corsSafeListedMethods = [\n    \"GET\",\n    \"HEAD\",\n    \"POST\"\n];\nconst corsSafeListedMethodsSet = new Set(corsSafeListedMethods);\nconst nullBodyStatus = [\n    101,\n    204,\n    205,\n    304\n];\nconst redirectStatus = [\n    301,\n    302,\n    303,\n    307,\n    308\n];\nconst redirectStatusSet = new Set(redirectStatus);\n// https://fetch.spec.whatwg.org/#block-bad-port\nconst badPorts = [\n    \"1\",\n    \"7\",\n    \"9\",\n    \"11\",\n    \"13\",\n    \"15\",\n    \"17\",\n    \"19\",\n    \"20\",\n    \"21\",\n    \"22\",\n    \"23\",\n    \"25\",\n    \"37\",\n    \"42\",\n    \"43\",\n    \"53\",\n    \"69\",\n    \"77\",\n    \"79\",\n    \"87\",\n    \"95\",\n    \"101\",\n    \"102\",\n    \"103\",\n    \"104\",\n    \"109\",\n    \"110\",\n    \"111\",\n    \"113\",\n    \"115\",\n    \"117\",\n    \"119\",\n    \"123\",\n    \"135\",\n    \"137\",\n    \"139\",\n    \"143\",\n    \"161\",\n    \"179\",\n    \"389\",\n    \"427\",\n    \"465\",\n    \"512\",\n    \"513\",\n    \"514\",\n    \"515\",\n    \"526\",\n    \"530\",\n    \"531\",\n    \"532\",\n    \"540\",\n    \"548\",\n    \"554\",\n    \"556\",\n    \"563\",\n    \"587\",\n    \"601\",\n    \"636\",\n    \"989\",\n    \"990\",\n    \"993\",\n    \"995\",\n    \"1719\",\n    \"1720\",\n    \"1723\",\n    \"2049\",\n    \"3659\",\n    \"4045\",\n    \"4190\",\n    \"5060\",\n    \"5061\",\n    \"6000\",\n    \"6566\",\n    \"6665\",\n    \"6666\",\n    \"6667\",\n    \"6668\",\n    \"6669\",\n    \"6679\",\n    \"6697\",\n    \"10080\"\n];\nconst badPortsSet = new Set(badPorts);\n// https://w3c.github.io/webappsec-referrer-policy/#referrer-policies\nconst referrerPolicy = [\n    \"\",\n    \"no-referrer\",\n    \"no-referrer-when-downgrade\",\n    \"same-origin\",\n    \"origin\",\n    \"strict-origin\",\n    \"origin-when-cross-origin\",\n    \"strict-origin-when-cross-origin\",\n    \"unsafe-url\"\n];\nconst referrerPolicySet = new Set(referrerPolicy);\nconst requestRedirect = [\n    \"follow\",\n    \"manual\",\n    \"error\"\n];\nconst safeMethods = [\n    \"GET\",\n    \"HEAD\",\n    \"OPTIONS\",\n    \"TRACE\"\n];\nconst safeMethodsSet = new Set(safeMethods);\nconst requestMode = [\n    \"navigate\",\n    \"same-origin\",\n    \"no-cors\",\n    \"cors\"\n];\nconst requestCredentials = [\n    \"omit\",\n    \"same-origin\",\n    \"include\"\n];\nconst requestCache = [\n    \"default\",\n    \"no-store\",\n    \"reload\",\n    \"no-cache\",\n    \"force-cache\",\n    \"only-if-cached\"\n];\n// https://fetch.spec.whatwg.org/#request-body-header-name\nconst requestBodyHeader = [\n    \"content-encoding\",\n    \"content-language\",\n    \"content-location\",\n    \"content-type\",\n    // See https://github.com/nodejs/undici/issues/2021\n    // 'Content-Length' is a forbidden header name, which is typically\n    // removed in the Headers implementation. However, undici doesn't\n    // filter out headers, so we add it here.\n    \"content-length\"\n];\n// https://fetch.spec.whatwg.org/#enumdef-requestduplex\nconst requestDuplex = [\n    \"half\"\n];\n// http://fetch.spec.whatwg.org/#forbidden-method\nconst forbiddenMethods = [\n    \"CONNECT\",\n    \"TRACE\",\n    \"TRACK\"\n];\nconst forbiddenMethodsSet = new Set(forbiddenMethods);\nconst subresource = [\n    \"audio\",\n    \"audioworklet\",\n    \"font\",\n    \"image\",\n    \"manifest\",\n    \"paintworklet\",\n    \"script\",\n    \"style\",\n    \"track\",\n    \"video\",\n    \"xslt\",\n    \"\"\n];\nconst subresourceSet = new Set(subresource);\nmodule.exports = {\n    subresource,\n    forbiddenMethods,\n    requestBodyHeader,\n    referrerPolicy,\n    requestRedirect,\n    requestMode,\n    requestCredentials,\n    requestCache,\n    redirectStatus,\n    corsSafeListedMethods,\n    nullBodyStatus,\n    safeMethods,\n    badPorts,\n    requestDuplex,\n    subresourceSet,\n    badPortsSet,\n    redirectStatusSet,\n    corsSafeListedMethodsSet,\n    safeMethodsSet,\n    forbiddenMethodsSet,\n    referrerPolicySet\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZmV0Y2gvY29uc3RhbnRzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTUEsd0JBQXdCO0lBQUM7SUFBTztJQUFRO0NBQU87QUFDckQsTUFBTUMsMkJBQTJCLElBQUlDLElBQUlGO0FBRXpDLE1BQU1HLGlCQUFpQjtJQUFDO0lBQUs7SUFBSztJQUFLO0NBQUk7QUFFM0MsTUFBTUMsaUJBQWlCO0lBQUM7SUFBSztJQUFLO0lBQUs7SUFBSztDQUFJO0FBQ2hELE1BQU1DLG9CQUFvQixJQUFJSCxJQUFJRTtBQUVsQztBQUNBLE1BQU1FLFdBQVc7SUFDZjtJQUFLO0lBQUs7SUFBSztJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQy9HO0lBQU07SUFBTTtJQUFPO0lBQU87SUFBTztJQUFPO0lBQU87SUFBTztJQUFPO0lBQU87SUFBTztJQUFPO0lBQU87SUFBTztJQUFPO0lBQ3ZHO0lBQU87SUFBTztJQUFPO0lBQU87SUFBTztJQUFPO0lBQU87SUFBTztJQUFPO0lBQU87SUFBTztJQUFPO0lBQU87SUFBTztJQUNsRztJQUFPO0lBQU87SUFBTztJQUFPO0lBQU87SUFBTztJQUFPO0lBQU87SUFBTztJQUFPO0lBQU87SUFBTztJQUFRO0lBQVE7SUFDcEc7SUFBUTtJQUFRO0lBQVE7SUFBUTtJQUFRO0lBQVE7SUFBUTtJQUFRO0lBQVE7SUFBUTtJQUFRO0lBQVE7SUFBUTtJQUN4RztJQUFRO0NBQ1Q7QUFFRCxNQUFNQyxjQUFjLElBQUlMLElBQUlJO0FBRTVCO0FBQ0EsTUFBTUUsaUJBQWlCO0lBQ3JCO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtDQUNEO0FBQ0QsTUFBTUMsb0JBQW9CLElBQUlQLElBQUlNO0FBRWxDLE1BQU1FLGtCQUFrQjtJQUFDO0lBQVU7SUFBVTtDQUFRO0FBRXJELE1BQU1DLGNBQWM7SUFBQztJQUFPO0lBQVE7SUFBVztDQUFRO0FBQ3ZELE1BQU1DLGlCQUFpQixJQUFJVixJQUFJUztBQUUvQixNQUFNRSxjQUFjO0lBQUM7SUFBWTtJQUFlO0lBQVc7Q0FBTztBQUVsRSxNQUFNQyxxQkFBcUI7SUFBQztJQUFRO0lBQWU7Q0FBVTtBQUU3RCxNQUFNQyxlQUFlO0lBQ25CO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtDQUNEO0FBRUQ7QUFDQSxNQUFNQyxvQkFBb0I7SUFDeEI7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0NBQ0Q7QUFFRDtBQUNBLE1BQU1DLGdCQUFnQjtJQUNwQjtDQUNEO0FBRUQ7QUFDQSxNQUFNQyxtQkFBbUI7SUFBQztJQUFXO0lBQVM7Q0FBUTtBQUN0RCxNQUFNQyxzQkFBc0IsSUFBSWpCLElBQUlnQjtBQUVwQyxNQUFNRSxjQUFjO0lBQ2xCO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtDQUNEO0FBQ0QsTUFBTUMsaUJBQWlCLElBQUluQixJQUFJa0I7QUFFL0JFLE9BQU9DLE9BQU8sR0FBRztJQUNmSDtJQUNBRjtJQUNBRjtJQUNBUjtJQUNBRTtJQUNBRztJQUNBQztJQUNBQztJQUNBWDtJQUNBSjtJQUNBRztJQUNBUTtJQUNBTDtJQUNBVztJQUNBSTtJQUNBZDtJQUNBRjtJQUNBSjtJQUNBVztJQUNBTztJQUNBVjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbW9ja3VwZmxvdy8uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL3dlYi9mZXRjaC9jb25zdGFudHMuanM/OGVmMSIsIndlYnBhY2s6Ly9tb2NrdXBmbG93Ly4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvd2ViL2ZldGNoL2NvbnN0YW50cy5qcz84ZWYxKiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgY29yc1NhZmVMaXN0ZWRNZXRob2RzID0gWydHRVQnLCAnSEVBRCcsICdQT1NUJ11cbmNvbnN0IGNvcnNTYWZlTGlzdGVkTWV0aG9kc1NldCA9IG5ldyBTZXQoY29yc1NhZmVMaXN0ZWRNZXRob2RzKVxuXG5jb25zdCBudWxsQm9keVN0YXR1cyA9IFsxMDEsIDIwNCwgMjA1LCAzMDRdXG5cbmNvbnN0IHJlZGlyZWN0U3RhdHVzID0gWzMwMSwgMzAyLCAzMDMsIDMwNywgMzA4XVxuY29uc3QgcmVkaXJlY3RTdGF0dXNTZXQgPSBuZXcgU2V0KHJlZGlyZWN0U3RhdHVzKVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jYmxvY2stYmFkLXBvcnRcbmNvbnN0IGJhZFBvcnRzID0gW1xuICAnMScsICc3JywgJzknLCAnMTEnLCAnMTMnLCAnMTUnLCAnMTcnLCAnMTknLCAnMjAnLCAnMjEnLCAnMjInLCAnMjMnLCAnMjUnLCAnMzcnLCAnNDInLCAnNDMnLCAnNTMnLCAnNjknLCAnNzcnLCAnNzknLFxuICAnODcnLCAnOTUnLCAnMTAxJywgJzEwMicsICcxMDMnLCAnMTA0JywgJzEwOScsICcxMTAnLCAnMTExJywgJzExMycsICcxMTUnLCAnMTE3JywgJzExOScsICcxMjMnLCAnMTM1JywgJzEzNycsXG4gICcxMzknLCAnMTQzJywgJzE2MScsICcxNzknLCAnMzg5JywgJzQyNycsICc0NjUnLCAnNTEyJywgJzUxMycsICc1MTQnLCAnNTE1JywgJzUyNicsICc1MzAnLCAnNTMxJywgJzUzMicsXG4gICc1NDAnLCAnNTQ4JywgJzU1NCcsICc1NTYnLCAnNTYzJywgJzU4NycsICc2MDEnLCAnNjM2JywgJzk4OScsICc5OTAnLCAnOTkzJywgJzk5NScsICcxNzE5JywgJzE3MjAnLCAnMTcyMycsXG4gICcyMDQ5JywgJzM2NTknLCAnNDA0NScsICc0MTkwJywgJzUwNjAnLCAnNTA2MScsICc2MDAwJywgJzY1NjYnLCAnNjY2NScsICc2NjY2JywgJzY2NjcnLCAnNjY2OCcsICc2NjY5JywgJzY2NzknLFxuICAnNjY5NycsICcxMDA4MCdcbl1cblxuY29uc3QgYmFkUG9ydHNTZXQgPSBuZXcgU2V0KGJhZFBvcnRzKVxuXG4vLyBodHRwczovL3czYy5naXRodWIuaW8vd2ViYXBwc2VjLXJlZmVycmVyLXBvbGljeS8jcmVmZXJyZXItcG9saWNpZXNcbmNvbnN0IHJlZmVycmVyUG9saWN5ID0gW1xuICAnJyxcbiAgJ25vLXJlZmVycmVyJyxcbiAgJ25vLXJlZmVycmVyLXdoZW4tZG93bmdyYWRlJyxcbiAgJ3NhbWUtb3JpZ2luJyxcbiAgJ29yaWdpbicsXG4gICdzdHJpY3Qtb3JpZ2luJyxcbiAgJ29yaWdpbi13aGVuLWNyb3NzLW9yaWdpbicsXG4gICdzdHJpY3Qtb3JpZ2luLXdoZW4tY3Jvc3Mtb3JpZ2luJyxcbiAgJ3Vuc2FmZS11cmwnXG5dXG5jb25zdCByZWZlcnJlclBvbGljeVNldCA9IG5ldyBTZXQocmVmZXJyZXJQb2xpY3kpXG5cbmNvbnN0IHJlcXVlc3RSZWRpcmVjdCA9IFsnZm9sbG93JywgJ21hbnVhbCcsICdlcnJvciddXG5cbmNvbnN0IHNhZmVNZXRob2RzID0gWydHRVQnLCAnSEVBRCcsICdPUFRJT05TJywgJ1RSQUNFJ11cbmNvbnN0IHNhZmVNZXRob2RzU2V0ID0gbmV3IFNldChzYWZlTWV0aG9kcylcblxuY29uc3QgcmVxdWVzdE1vZGUgPSBbJ25hdmlnYXRlJywgJ3NhbWUtb3JpZ2luJywgJ25vLWNvcnMnLCAnY29ycyddXG5cbmNvbnN0IHJlcXVlc3RDcmVkZW50aWFscyA9IFsnb21pdCcsICdzYW1lLW9yaWdpbicsICdpbmNsdWRlJ11cblxuY29uc3QgcmVxdWVzdENhY2hlID0gW1xuICAnZGVmYXVsdCcsXG4gICduby1zdG9yZScsXG4gICdyZWxvYWQnLFxuICAnbm8tY2FjaGUnLFxuICAnZm9yY2UtY2FjaGUnLFxuICAnb25seS1pZi1jYWNoZWQnXG5dXG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNyZXF1ZXN0LWJvZHktaGVhZGVyLW5hbWVcbmNvbnN0IHJlcXVlc3RCb2R5SGVhZGVyID0gW1xuICAnY29udGVudC1lbmNvZGluZycsXG4gICdjb250ZW50LWxhbmd1YWdlJyxcbiAgJ2NvbnRlbnQtbG9jYXRpb24nLFxuICAnY29udGVudC10eXBlJyxcbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvdW5kaWNpL2lzc3Vlcy8yMDIxXG4gIC8vICdDb250ZW50LUxlbmd0aCcgaXMgYSBmb3JiaWRkZW4gaGVhZGVyIG5hbWUsIHdoaWNoIGlzIHR5cGljYWxseVxuICAvLyByZW1vdmVkIGluIHRoZSBIZWFkZXJzIGltcGxlbWVudGF0aW9uLiBIb3dldmVyLCB1bmRpY2kgZG9lc24ndFxuICAvLyBmaWx0ZXIgb3V0IGhlYWRlcnMsIHNvIHdlIGFkZCBpdCBoZXJlLlxuICAnY29udGVudC1sZW5ndGgnXG5dXG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNlbnVtZGVmLXJlcXVlc3RkdXBsZXhcbmNvbnN0IHJlcXVlc3REdXBsZXggPSBbXG4gICdoYWxmJ1xuXVxuXG4vLyBodHRwOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNmb3JiaWRkZW4tbWV0aG9kXG5jb25zdCBmb3JiaWRkZW5NZXRob2RzID0gWydDT05ORUNUJywgJ1RSQUNFJywgJ1RSQUNLJ11cbmNvbnN0IGZvcmJpZGRlbk1ldGhvZHNTZXQgPSBuZXcgU2V0KGZvcmJpZGRlbk1ldGhvZHMpXG5cbmNvbnN0IHN1YnJlc291cmNlID0gW1xuICAnYXVkaW8nLFxuICAnYXVkaW93b3JrbGV0JyxcbiAgJ2ZvbnQnLFxuICAnaW1hZ2UnLFxuICAnbWFuaWZlc3QnLFxuICAncGFpbnR3b3JrbGV0JyxcbiAgJ3NjcmlwdCcsXG4gICdzdHlsZScsXG4gICd0cmFjaycsXG4gICd2aWRlbycsXG4gICd4c2x0JyxcbiAgJydcbl1cbmNvbnN0IHN1YnJlc291cmNlU2V0ID0gbmV3IFNldChzdWJyZXNvdXJjZSlcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHN1YnJlc291cmNlLFxuICBmb3JiaWRkZW5NZXRob2RzLFxuICByZXF1ZXN0Qm9keUhlYWRlcixcbiAgcmVmZXJyZXJQb2xpY3ksXG4gIHJlcXVlc3RSZWRpcmVjdCxcbiAgcmVxdWVzdE1vZGUsXG4gIHJlcXVlc3RDcmVkZW50aWFscyxcbiAgcmVxdWVzdENhY2hlLFxuICByZWRpcmVjdFN0YXR1cyxcbiAgY29yc1NhZmVMaXN0ZWRNZXRob2RzLFxuICBudWxsQm9keVN0YXR1cyxcbiAgc2FmZU1ldGhvZHMsXG4gIGJhZFBvcnRzLFxuICByZXF1ZXN0RHVwbGV4LFxuICBzdWJyZXNvdXJjZVNldCxcbiAgYmFkUG9ydHNTZXQsXG4gIHJlZGlyZWN0U3RhdHVzU2V0LFxuICBjb3JzU2FmZUxpc3RlZE1ldGhvZHNTZXQsXG4gIHNhZmVNZXRob2RzU2V0LFxuICBmb3JiaWRkZW5NZXRob2RzU2V0LFxuICByZWZlcnJlclBvbGljeVNldFxufVxuIl0sIm5hbWVzIjpbImNvcnNTYWZlTGlzdGVkTWV0aG9kcyIsImNvcnNTYWZlTGlzdGVkTWV0aG9kc1NldCIsIlNldCIsIm51bGxCb2R5U3RhdHVzIiwicmVkaXJlY3RTdGF0dXMiLCJyZWRpcmVjdFN0YXR1c1NldCIsImJhZFBvcnRzIiwiYmFkUG9ydHNTZXQiLCJyZWZlcnJlclBvbGljeSIsInJlZmVycmVyUG9saWN5U2V0IiwicmVxdWVzdFJlZGlyZWN0Iiwic2FmZU1ldGhvZHMiLCJzYWZlTWV0aG9kc1NldCIsInJlcXVlc3RNb2RlIiwicmVxdWVzdENyZWRlbnRpYWxzIiwicmVxdWVzdENhY2hlIiwicmVxdWVzdEJvZHlIZWFkZXIiLCJyZXF1ZXN0RHVwbGV4IiwiZm9yYmlkZGVuTWV0aG9kcyIsImZvcmJpZGRlbk1ldGhvZHNTZXQiLCJzdWJyZXNvdXJjZSIsInN1YnJlc291cmNlU2V0IiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/fetch/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/fetch/data-url.js":
/*!*******************************************************!*\
  !*** ./node_modules/undici/lib/web/fetch/data-url.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\");\nconst encoder = new TextEncoder();\n/**\n * @see https://mimesniff.spec.whatwg.org/#http-token-code-point\n */ const HTTP_TOKEN_CODEPOINTS = /^[!#$%&'*+\\-.^_|~A-Za-z0-9]+$/;\nconst HTTP_WHITESPACE_REGEX = /[\\u000A\\u000D\\u0009\\u0020]/; // eslint-disable-line\nconst ASCII_WHITESPACE_REPLACE_REGEX = /[\\u0009\\u000A\\u000C\\u000D\\u0020]/g; // eslint-disable-line\n/**\n * @see https://mimesniff.spec.whatwg.org/#http-quoted-string-token-code-point\n */ const HTTP_QUOTED_STRING_TOKENS = /^[\\u0009\\u0020-\\u007E\\u0080-\\u00FF]+$/; // eslint-disable-line\n// https://fetch.spec.whatwg.org/#data-url-processor\n/** @param {URL} dataURL */ function dataURLProcessor(dataURL) {\n    // 1. Assert: dataURLs scheme is \"data\".\n    assert(dataURL.protocol === \"data:\");\n    // 2. Let input be the result of running the URL\n    // serializer on dataURL with exclude fragment\n    // set to true.\n    let input = URLSerializer(dataURL, true);\n    // 3. Remove the leading \"data:\" string from input.\n    input = input.slice(5);\n    // 4. Let position point at the start of input.\n    const position = {\n        position: 0\n    };\n    // 5. Let mimeType be the result of collecting a\n    // sequence of code points that are not equal\n    // to U+002C (,), given position.\n    let mimeType = collectASequenceOfCodePointsFast(\",\", input, position);\n    // 6. Strip leading and trailing ASCII whitespace\n    // from mimeType.\n    // Undici implementation note: we need to store the\n    // length because if the mimetype has spaces removed,\n    // the wrong amount will be sliced from the input in\n    // step #9\n    const mimeTypeLength = mimeType.length;\n    mimeType = removeASCIIWhitespace(mimeType, true, true);\n    // 7. If position is past the end of input, then\n    // return failure\n    if (position.position >= input.length) {\n        return \"failure\";\n    }\n    // 8. Advance position by 1.\n    position.position++;\n    // 9. Let encodedBody be the remainder of input.\n    const encodedBody = input.slice(mimeTypeLength + 1);\n    // 10. Let body be the percent-decoding of encodedBody.\n    let body = stringPercentDecode(encodedBody);\n    // 11. If mimeType ends with U+003B (;), followed by\n    // zero or more U+0020 SPACE, followed by an ASCII\n    // case-insensitive match for \"base64\", then:\n    if (/;(\\u0020){0,}base64$/i.test(mimeType)) {\n        // 1. Let stringBody be the isomorphic decode of body.\n        const stringBody = isomorphicDecode(body);\n        // 2. Set body to the forgiving-base64 decode of\n        // stringBody.\n        body = forgivingBase64(stringBody);\n        // 3. If body is failure, then return failure.\n        if (body === \"failure\") {\n            return \"failure\";\n        }\n        // 4. Remove the last 6 code points from mimeType.\n        mimeType = mimeType.slice(0, -6);\n        // 5. Remove trailing U+0020 SPACE code points from mimeType,\n        // if any.\n        mimeType = mimeType.replace(/(\\u0020)+$/, \"\");\n        // 6. Remove the last U+003B (;) code point from mimeType.\n        mimeType = mimeType.slice(0, -1);\n    }\n    // 12. If mimeType starts with U+003B (;), then prepend\n    // \"text/plain\" to mimeType.\n    if (mimeType.startsWith(\";\")) {\n        mimeType = \"text/plain\" + mimeType;\n    }\n    // 13. Let mimeTypeRecord be the result of parsing\n    // mimeType.\n    let mimeTypeRecord = parseMIMEType(mimeType);\n    // 14. If mimeTypeRecord is failure, then set\n    // mimeTypeRecord to text/plain;charset=US-ASCII.\n    if (mimeTypeRecord === \"failure\") {\n        mimeTypeRecord = parseMIMEType(\"text/plain;charset=US-ASCII\");\n    }\n    // 15. Return a new data: URL struct whose MIME\n    // type is mimeTypeRecord and body is body.\n    // https://fetch.spec.whatwg.org/#data-url-struct\n    return {\n        mimeType: mimeTypeRecord,\n        body\n    };\n}\n// https://url.spec.whatwg.org/#concept-url-serializer\n/**\n * @param {URL} url\n * @param {boolean} excludeFragment\n */ function URLSerializer(url, excludeFragment = false) {\n    if (!excludeFragment) {\n        return url.href;\n    }\n    const href = url.href;\n    const hashLength = url.hash.length;\n    const serialized = hashLength === 0 ? href : href.substring(0, href.length - hashLength);\n    if (!hashLength && href.endsWith(\"#\")) {\n        return serialized.slice(0, -1);\n    }\n    return serialized;\n}\n// https://infra.spec.whatwg.org/#collect-a-sequence-of-code-points\n/**\n * @param {(char: string) => boolean} condition\n * @param {string} input\n * @param {{ position: number }} position\n */ function collectASequenceOfCodePoints(condition, input, position) {\n    // 1. Let result be the empty string.\n    let result = \"\";\n    // 2. While position doesnt point past the end of input and the\n    // code point at position within input meets the condition condition:\n    while(position.position < input.length && condition(input[position.position])){\n        // 1. Append that code point to the end of result.\n        result += input[position.position];\n        // 2. Advance position by 1.\n        position.position++;\n    }\n    // 3. Return result.\n    return result;\n}\n/**\n * A faster collectASequenceOfCodePoints that only works when comparing a single character.\n * @param {string} char\n * @param {string} input\n * @param {{ position: number }} position\n */ function collectASequenceOfCodePointsFast(char, input, position) {\n    const idx = input.indexOf(char, position.position);\n    const start = position.position;\n    if (idx === -1) {\n        position.position = input.length;\n        return input.slice(start);\n    }\n    position.position = idx;\n    return input.slice(start, position.position);\n}\n// https://url.spec.whatwg.org/#string-percent-decode\n/** @param {string} input */ function stringPercentDecode(input) {\n    // 1. Let bytes be the UTF-8 encoding of input.\n    const bytes = encoder.encode(input);\n    // 2. Return the percent-decoding of bytes.\n    return percentDecode(bytes);\n}\n/**\n * @param {number} byte\n */ function isHexCharByte(byte) {\n    // 0-9 A-F a-f\n    return byte >= 0x30 && byte <= 0x39 || byte >= 0x41 && byte <= 0x46 || byte >= 0x61 && byte <= 0x66;\n}\n/**\n * @param {number} byte\n */ function hexByteToNumber(byte) {\n    return(// 0-9\n    byte >= 0x30 && byte <= 0x39 ? byte - 48 : (byte & 0xDF) - 55);\n}\n// https://url.spec.whatwg.org/#percent-decode\n/** @param {Uint8Array} input */ function percentDecode(input) {\n    const length = input.length;\n    // 1. Let output be an empty byte sequence.\n    /** @type {Uint8Array} */ const output = new Uint8Array(length);\n    let j = 0;\n    // 2. For each byte byte in input:\n    for(let i = 0; i < length; ++i){\n        const byte = input[i];\n        // 1. If byte is not 0x25 (%), then append byte to output.\n        if (byte !== 0x25) {\n            output[j++] = byte;\n        // 2. Otherwise, if byte is 0x25 (%) and the next two bytes\n        // after byte in input are not in the ranges\n        // 0x30 (0) to 0x39 (9), 0x41 (A) to 0x46 (F),\n        // and 0x61 (a) to 0x66 (f), all inclusive, append byte\n        // to output.\n        } else if (byte === 0x25 && !(isHexCharByte(input[i + 1]) && isHexCharByte(input[i + 2]))) {\n            output[j++] = 0x25;\n        // 3. Otherwise:\n        } else {\n            // 1. Let bytePoint be the two bytes after byte in input,\n            // decoded, and then interpreted as hexadecimal number.\n            // 2. Append a byte whose value is bytePoint to output.\n            output[j++] = hexByteToNumber(input[i + 1]) << 4 | hexByteToNumber(input[i + 2]);\n            // 3. Skip the next two bytes in input.\n            i += 2;\n        }\n    }\n    // 3. Return output.\n    return length === j ? output : output.subarray(0, j);\n}\n// https://mimesniff.spec.whatwg.org/#parse-a-mime-type\n/** @param {string} input */ function parseMIMEType(input) {\n    // 1. Remove any leading and trailing HTTP whitespace\n    // from input.\n    input = removeHTTPWhitespace(input, true, true);\n    // 2. Let position be a position variable for input,\n    // initially pointing at the start of input.\n    const position = {\n        position: 0\n    };\n    // 3. Let type be the result of collecting a sequence\n    // of code points that are not U+002F (/) from\n    // input, given position.\n    const type = collectASequenceOfCodePointsFast(\"/\", input, position);\n    // 4. If type is the empty string or does not solely\n    // contain HTTP token code points, then return failure.\n    // https://mimesniff.spec.whatwg.org/#http-token-code-point\n    if (type.length === 0 || !HTTP_TOKEN_CODEPOINTS.test(type)) {\n        return \"failure\";\n    }\n    // 5. If position is past the end of input, then return\n    // failure\n    if (position.position > input.length) {\n        return \"failure\";\n    }\n    // 6. Advance position by 1. (This skips past U+002F (/).)\n    position.position++;\n    // 7. Let subtype be the result of collecting a sequence of\n    // code points that are not U+003B (;) from input, given\n    // position.\n    let subtype = collectASequenceOfCodePointsFast(\";\", input, position);\n    // 8. Remove any trailing HTTP whitespace from subtype.\n    subtype = removeHTTPWhitespace(subtype, false, true);\n    // 9. If subtype is the empty string or does not solely\n    // contain HTTP token code points, then return failure.\n    if (subtype.length === 0 || !HTTP_TOKEN_CODEPOINTS.test(subtype)) {\n        return \"failure\";\n    }\n    const typeLowercase = type.toLowerCase();\n    const subtypeLowercase = subtype.toLowerCase();\n    // 10. Let mimeType be a new MIME type record whose type\n    // is type, in ASCII lowercase, and subtype is subtype,\n    // in ASCII lowercase.\n    // https://mimesniff.spec.whatwg.org/#mime-type\n    const mimeType = {\n        type: typeLowercase,\n        subtype: subtypeLowercase,\n        /** @type {Map<string, string>} */ parameters: new Map(),\n        // https://mimesniff.spec.whatwg.org/#mime-type-essence\n        essence: `${typeLowercase}/${subtypeLowercase}`\n    };\n    // 11. While position is not past the end of input:\n    while(position.position < input.length){\n        // 1. Advance position by 1. (This skips past U+003B (;).)\n        position.position++;\n        // 2. Collect a sequence of code points that are HTTP\n        // whitespace from input given position.\n        collectASequenceOfCodePoints(// https://fetch.spec.whatwg.org/#http-whitespace\n        (char)=>HTTP_WHITESPACE_REGEX.test(char), input, position);\n        // 3. Let parameterName be the result of collecting a\n        // sequence of code points that are not U+003B (;)\n        // or U+003D (=) from input, given position.\n        let parameterName = collectASequenceOfCodePoints((char)=>char !== \";\" && char !== \"=\", input, position);\n        // 4. Set parameterName to parameterName, in ASCII\n        // lowercase.\n        parameterName = parameterName.toLowerCase();\n        // 5. If position is not past the end of input, then:\n        if (position.position < input.length) {\n            // 1. If the code point at position within input is\n            // U+003B (;), then continue.\n            if (input[position.position] === \";\") {\n                continue;\n            }\n            // 2. Advance position by 1. (This skips past U+003D (=).)\n            position.position++;\n        }\n        // 6. If position is past the end of input, then break.\n        if (position.position > input.length) {\n            break;\n        }\n        // 7. Let parameterValue be null.\n        let parameterValue = null;\n        // 8. If the code point at position within input is\n        // U+0022 (\"), then:\n        if (input[position.position] === '\"') {\n            // 1. Set parameterValue to the result of collecting\n            // an HTTP quoted string from input, given position\n            // and the extract-value flag.\n            parameterValue = collectAnHTTPQuotedString(input, position, true);\n            // 2. Collect a sequence of code points that are not\n            // U+003B (;) from input, given position.\n            collectASequenceOfCodePointsFast(\";\", input, position);\n        // 9. Otherwise:\n        } else {\n            // 1. Set parameterValue to the result of collecting\n            // a sequence of code points that are not U+003B (;)\n            // from input, given position.\n            parameterValue = collectASequenceOfCodePointsFast(\";\", input, position);\n            // 2. Remove any trailing HTTP whitespace from parameterValue.\n            parameterValue = removeHTTPWhitespace(parameterValue, false, true);\n            // 3. If parameterValue is the empty string, then continue.\n            if (parameterValue.length === 0) {\n                continue;\n            }\n        }\n        // 10. If all of the following are true\n        // - parameterName is not the empty string\n        // - parameterName solely contains HTTP token code points\n        // - parameterValue solely contains HTTP quoted-string token code points\n        // - mimeTypes parameters[parameterName] does not exist\n        // then set mimeTypes parameters[parameterName] to parameterValue.\n        if (parameterName.length !== 0 && HTTP_TOKEN_CODEPOINTS.test(parameterName) && (parameterValue.length === 0 || HTTP_QUOTED_STRING_TOKENS.test(parameterValue)) && !mimeType.parameters.has(parameterName)) {\n            mimeType.parameters.set(parameterName, parameterValue);\n        }\n    }\n    // 12. Return mimeType.\n    return mimeType;\n}\n// https://infra.spec.whatwg.org/#forgiving-base64-decode\n/** @param {string} data */ function forgivingBase64(data) {\n    // 1. Remove all ASCII whitespace from data.\n    data = data.replace(ASCII_WHITESPACE_REPLACE_REGEX, \"\"); // eslint-disable-line\n    let dataLength = data.length;\n    // 2. If datas code point length divides by 4 leaving\n    // no remainder, then:\n    if (dataLength % 4 === 0) {\n        // 1. If data ends with one or two U+003D (=) code points,\n        // then remove them from data.\n        if (data.charCodeAt(dataLength - 1) === 0x003D) {\n            --dataLength;\n            if (data.charCodeAt(dataLength - 1) === 0x003D) {\n                --dataLength;\n            }\n        }\n    }\n    // 3. If datas code point length divides by 4 leaving\n    // a remainder of 1, then return failure.\n    if (dataLength % 4 === 1) {\n        return \"failure\";\n    }\n    // 4. If data contains a code point that is not one of\n    //  U+002B (+)\n    //  U+002F (/)\n    //  ASCII alphanumeric\n    // then return failure.\n    if (/[^+/0-9A-Za-z]/.test(data.length === dataLength ? data : data.substring(0, dataLength))) {\n        return \"failure\";\n    }\n    const buffer = Buffer.from(data, \"base64\");\n    return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n}\n// https://fetch.spec.whatwg.org/#collect-an-http-quoted-string\n// tests: https://fetch.spec.whatwg.org/#example-http-quoted-string\n/**\n * @param {string} input\n * @param {{ position: number }} position\n * @param {boolean?} extractValue\n */ function collectAnHTTPQuotedString(input, position, extractValue) {\n    // 1. Let positionStart be position.\n    const positionStart = position.position;\n    // 2. Let value be the empty string.\n    let value = \"\";\n    // 3. Assert: the code point at position within input\n    // is U+0022 (\").\n    assert(input[position.position] === '\"');\n    // 4. Advance position by 1.\n    position.position++;\n    // 5. While true:\n    while(true){\n        // 1. Append the result of collecting a sequence of code points\n        // that are not U+0022 (\") or U+005C (\\) from input, given\n        // position, to value.\n        value += collectASequenceOfCodePoints((char)=>char !== '\"' && char !== \"\\\\\", input, position);\n        // 2. If position is past the end of input, then break.\n        if (position.position >= input.length) {\n            break;\n        }\n        // 3. Let quoteOrBackslash be the code point at position within\n        // input.\n        const quoteOrBackslash = input[position.position];\n        // 4. Advance position by 1.\n        position.position++;\n        // 5. If quoteOrBackslash is U+005C (\\), then:\n        if (quoteOrBackslash === \"\\\\\") {\n            // 1. If position is past the end of input, then append\n            // U+005C (\\) to value and break.\n            if (position.position >= input.length) {\n                value += \"\\\\\";\n                break;\n            }\n            // 2. Append the code point at position within input to value.\n            value += input[position.position];\n            // 3. Advance position by 1.\n            position.position++;\n        // 6. Otherwise:\n        } else {\n            // 1. Assert: quoteOrBackslash is U+0022 (\").\n            assert(quoteOrBackslash === '\"');\n            break;\n        }\n    }\n    // 6. If the extract-value flag is set, then return value.\n    if (extractValue) {\n        return value;\n    }\n    // 7. Return the code points from positionStart to position,\n    // inclusive, within input.\n    return input.slice(positionStart, position.position);\n}\n/**\n * @see https://mimesniff.spec.whatwg.org/#serialize-a-mime-type\n */ function serializeAMimeType(mimeType) {\n    assert(mimeType !== \"failure\");\n    const { parameters, essence } = mimeType;\n    // 1. Let serialization be the concatenation of mimeTypes\n    //    type, U+002F (/), and mimeTypes subtype.\n    let serialization = essence;\n    // 2. For each name  value of mimeTypes parameters:\n    for (let [name, value] of parameters.entries()){\n        // 1. Append U+003B (;) to serialization.\n        serialization += \";\";\n        // 2. Append name to serialization.\n        serialization += name;\n        // 3. Append U+003D (=) to serialization.\n        serialization += \"=\";\n        // 4. If value does not solely contain HTTP token code\n        //    points or value is the empty string, then:\n        if (!HTTP_TOKEN_CODEPOINTS.test(value)) {\n            // 1. Precede each occurrence of U+0022 (\") or\n            //    U+005C (\\) in value with U+005C (\\).\n            value = value.replace(/(\\\\|\")/g, \"\\\\$1\");\n            // 2. Prepend U+0022 (\") to value.\n            value = '\"' + value;\n            // 3. Append U+0022 (\") to value.\n            value += '\"';\n        }\n        // 5. Append value to serialization.\n        serialization += value;\n    }\n    // 3. Return serialization.\n    return serialization;\n}\n/**\n * @see https://fetch.spec.whatwg.org/#http-whitespace\n * @param {number} char\n */ function isHTTPWhiteSpace(char) {\n    // \"\\r\\n\\t \"\n    return char === 0x00d || char === 0x00a || char === 0x009 || char === 0x020;\n}\n/**\n * @see https://fetch.spec.whatwg.org/#http-whitespace\n * @param {string} str\n * @param {boolean} [leading=true]\n * @param {boolean} [trailing=true]\n */ function removeHTTPWhitespace(str, leading = true, trailing = true) {\n    return removeChars(str, leading, trailing, isHTTPWhiteSpace);\n}\n/**\n * @see https://infra.spec.whatwg.org/#ascii-whitespace\n * @param {number} char\n */ function isASCIIWhitespace(char) {\n    // \"\\r\\n\\t\\f \"\n    return char === 0x00d || char === 0x00a || char === 0x009 || char === 0x00c || char === 0x020;\n}\n/**\n * @see https://infra.spec.whatwg.org/#strip-leading-and-trailing-ascii-whitespace\n * @param {string} str\n * @param {boolean} [leading=true]\n * @param {boolean} [trailing=true]\n */ function removeASCIIWhitespace(str, leading = true, trailing = true) {\n    return removeChars(str, leading, trailing, isASCIIWhitespace);\n}\n/**\n * @param {string} str\n * @param {boolean} leading\n * @param {boolean} trailing\n * @param {(charCode: number) => boolean} predicate\n * @returns\n */ function removeChars(str, leading, trailing, predicate) {\n    let lead = 0;\n    let trail = str.length - 1;\n    if (leading) {\n        while(lead < str.length && predicate(str.charCodeAt(lead)))lead++;\n    }\n    if (trailing) {\n        while(trail > 0 && predicate(str.charCodeAt(trail)))trail--;\n    }\n    return lead === 0 && trail === str.length - 1 ? str : str.slice(lead, trail + 1);\n}\n/**\n * @see https://infra.spec.whatwg.org/#isomorphic-decode\n * @param {Uint8Array} input\n * @returns {string}\n */ function isomorphicDecode(input) {\n    // 1. To isomorphic decode a byte sequence input, return a string whose code point\n    //    length is equal to inputs length and whose code points have the same values\n    //    as the values of inputs bytes, in the same order.\n    const length = input.length;\n    if ((2 << 15) - 1 > length) {\n        return String.fromCharCode.apply(null, input);\n    }\n    let result = \"\";\n    let i = 0;\n    let addition = (2 << 15) - 1;\n    while(i < length){\n        if (i + addition > length) {\n            addition = length - i;\n        }\n        result += String.fromCharCode.apply(null, input.subarray(i, i += addition));\n    }\n    return result;\n}\n/**\n * @see https://mimesniff.spec.whatwg.org/#minimize-a-supported-mime-type\n * @param {Exclude<ReturnType<typeof parseMIMEType>, 'failure'>} mimeType\n */ function minimizeSupportedMimeType(mimeType) {\n    switch(mimeType.essence){\n        case \"application/ecmascript\":\n        case \"application/javascript\":\n        case \"application/x-ecmascript\":\n        case \"application/x-javascript\":\n        case \"text/ecmascript\":\n        case \"text/javascript\":\n        case \"text/javascript1.0\":\n        case \"text/javascript1.1\":\n        case \"text/javascript1.2\":\n        case \"text/javascript1.3\":\n        case \"text/javascript1.4\":\n        case \"text/javascript1.5\":\n        case \"text/jscript\":\n        case \"text/livescript\":\n        case \"text/x-ecmascript\":\n        case \"text/x-javascript\":\n            // 1. If mimeType is a JavaScript MIME type, then return \"text/javascript\".\n            return \"text/javascript\";\n        case \"application/json\":\n        case \"text/json\":\n            // 2. If mimeType is a JSON MIME type, then return \"application/json\".\n            return \"application/json\";\n        case \"image/svg+xml\":\n            // 3. If mimeTypes essence is \"image/svg+xml\", then return \"image/svg+xml\".\n            return \"image/svg+xml\";\n        case \"text/xml\":\n        case \"application/xml\":\n            // 4. If mimeType is an XML MIME type, then return \"application/xml\".\n            return \"application/xml\";\n    }\n    // 2. If mimeType is a JSON MIME type, then return \"application/json\".\n    if (mimeType.subtype.endsWith(\"+json\")) {\n        return \"application/json\";\n    }\n    // 4. If mimeType is an XML MIME type, then return \"application/xml\".\n    if (mimeType.subtype.endsWith(\"+xml\")) {\n        return \"application/xml\";\n    }\n    // 5. If mimeType is supported by the user agent, then return mimeTypes essence.\n    // Technically, node doesn't support any mimetypes.\n    // 6. Return the empty string.\n    return \"\";\n}\nmodule.exports = {\n    dataURLProcessor,\n    URLSerializer,\n    collectASequenceOfCodePoints,\n    collectASequenceOfCodePointsFast,\n    stringPercentDecode,\n    parseMIMEType,\n    collectAnHTTPQuotedString,\n    serializeAMimeType,\n    removeChars,\n    removeHTTPWhitespace,\n    minimizeSupportedMimeType,\n    HTTP_TOKEN_CODEPOINTS,\n    isomorphicDecode\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZmV0Y2gvZGF0YS11cmwuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNQSxTQUFTQyxtQkFBT0EsQ0FBQztBQUV2QixNQUFNQyxVQUFVLElBQUlDO0FBRXBCOztDQUVBLEdBQ0EsTUFBTUMsd0JBQXdCO0FBQzlCLE1BQU1DLHdCQUF3Qiw4QkFBNkI7QUFDM0QsTUFBTUMsaUNBQWlDLHFDQUFvQztBQUMzRTs7Q0FFQSxHQUNBLE1BQU1DLDRCQUE0Qix5Q0FBd0M7QUFFMUU7QUFDQSw0QkFDQSxTQUFTQyxpQkFBa0JDLE9BQU87SUFDaEM7SUFDQVQsT0FBT1MsUUFBUUMsUUFBUSxLQUFLO0lBRTVCO0lBQ0E7SUFDQTtJQUNBLElBQUlDLFFBQVFDLGNBQWNILFNBQVM7SUFFbkM7SUFDQUUsUUFBUUEsTUFBTUUsS0FBSyxDQUFDO0lBRXBCO0lBQ0EsTUFBTUMsV0FBVztRQUFFQSxVQUFVO0lBQUU7SUFFL0I7SUFDQTtJQUNBO0lBQ0EsSUFBSUMsV0FBV0MsaUNBQ2IsS0FDQUwsT0FDQUc7SUFHRjtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSxNQUFNRyxpQkFBaUJGLFNBQVNHLE1BQU07SUFDdENILFdBQVdJLHNCQUFzQkosVUFBVSxNQUFNO0lBRWpEO0lBQ0E7SUFDQSxJQUFJRCxTQUFTQSxRQUFRLElBQUlILE1BQU1PLE1BQU0sRUFBRTtRQUNyQyxPQUFPO0lBQ1Q7SUFFQTtJQUNBSixTQUFTQSxRQUFRO0lBRWpCO0lBQ0EsTUFBTU0sY0FBY1QsTUFBTUUsS0FBSyxDQUFDSSxpQkFBaUI7SUFFakQ7SUFDQSxJQUFJSSxPQUFPQyxvQkFBb0JGO0lBRS9CO0lBQ0E7SUFDQTtJQUNBLElBQUksd0JBQXdCRyxJQUFJLENBQUNSLFdBQVc7UUFDMUM7UUFDQSxNQUFNUyxhQUFhQyxpQkFBaUJKO1FBRXBDO1FBQ0E7UUFDQUEsT0FBT0ssZ0JBQWdCRjtRQUV2QjtRQUNBLElBQUlILFNBQVMsV0FB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QUNBLE9BQU8xRDtBQUNUO0FBRUE7OztDQUdBLEdBQ0EsU0FBUzJELDBCQUEyQnJGLFFBQVE7SUFDMUMsT0FBUUEsU0FBU2tELE9BQU87UUFDdEIsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztZQUNIO1lBQ0EsT0FBTztRQUNULEtBQUs7UUFDTCxLQUFLO1lBQ0g7WUFDQSxPQUFPO1FBQ1QsS0FBSztZQUNIO1lBQ0EsT0FBTztRQUNULEtBQUs7UUFDTCxLQUFLO1lBQ0g7WUFDQSxPQUFPO0lBQ1g7SUFFQTtJQUNBLElBQUlsRCxTQUFTNEMsT0FBTyxDQUFDckIsUUFBUSxDQUFDLFVBQVU7UUFDdEMsT0FBTztJQUNUO0lBRUE7SUFDQSxJQUFJdkIsU0FBUzRDLE9BQU8sQ0FBQ3JCLFFBQVEsQ0FBQyxTQUFTO1FBQ3JDLE9BQU87SUFDVDtJQUVBO0lBQ0E7SUFFQTtJQUNBLE9BQU87QUFDVDtBQUVBK0QsT0FBT0MsT0FBTyxHQUFHO0lBQ2Y5RjtJQUNBSTtJQUNBMkI7SUFDQXZCO0lBQ0FNO0lBQ0FRO0lBQ0FzQztJQUNBZTtJQUNBUTtJQUNBbEM7SUFDQTJDO0lBQ0FoRztJQUNBcUI7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL21vY2t1cGZsb3cvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZmV0Y2gvZGF0YS11cmwuanM/ZTkxOSIsIndlYnBhY2s6Ly9tb2NrdXBmbG93Ly4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvd2ViL2ZldGNoL2RhdGEtdXJsLmpzP2U5MTkqIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdub2RlOmFzc2VydCcpXG5cbmNvbnN0IGVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9taW1lc25pZmYuc3BlYy53aGF0d2cub3JnLyNodHRwLXRva2VuLWNvZGUtcG9pbnRcbiAqL1xuY29uc3QgSFRUUF9UT0tFTl9DT0RFUE9JTlRTID0gL15bISMkJSYnKitcXC0uXl98fkEtWmEtejAtOV0rJC9cbmNvbnN0IEhUVFBfV0hJVEVTUEFDRV9SRUdFWCA9IC9bXFx1MDAwQVxcdTAwMERcXHUwMDA5XFx1MDAyMF0vIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbmNvbnN0IEFTQ0lJX1dISVRFU1BBQ0VfUkVQTEFDRV9SRUdFWCA9IC9bXFx1MDAwOVxcdTAwMEFcXHUwMDBDXFx1MDAwRFxcdTAwMjBdL2cgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vbWltZXNuaWZmLnNwZWMud2hhdHdnLm9yZy8jaHR0cC1xdW90ZWQtc3RyaW5nLXRva2VuLWNvZGUtcG9pbnRcbiAqL1xuY29uc3QgSFRUUF9RVU9URURfU1RSSU5HX1RPS0VOUyA9IC9eW1xcdTAwMDlcXHUwMDIwLVxcdTAwN0VcXHUwMDgwLVxcdTAwRkZdKyQvIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2RhdGEtdXJsLXByb2Nlc3NvclxuLyoqIEBwYXJhbSB7VVJMfSBkYXRhVVJMICovXG5mdW5jdGlvbiBkYXRhVVJMUHJvY2Vzc29yIChkYXRhVVJMKSB7XG4gIC8vIDEuIEFzc2VydDogZGF0YVVSTOKAmXMgc2NoZW1lIGlzIFwiZGF0YVwiLlxuICBhc3NlcnQoZGF0YVVSTC5wcm90b2NvbCA9PT0gJ2RhdGE6JylcblxuICAvLyAyLiBMZXQgaW5wdXQgYmUgdGhlIHJlc3VsdCBvZiBydW5uaW5nIHRoZSBVUkxcbiAgLy8gc2VyaWFsaXplciBvbiBkYXRhVVJMIHdpdGggZXhjbHVkZSBmcmFnbWVudFxuICAvLyBzZXQgdG8gdHJ1ZS5cbiAgbGV0IGlucHV0ID0gVVJMU2VyaWFsaXplcihkYXRhVVJMLCB0cnVlKVxuXG4gIC8vIDMuIFJlbW92ZSB0aGUgbGVhZGluZyBcImRhdGE6XCIgc3RyaW5nIGZyb20gaW5wdXQuXG4gIGlucHV0ID0gaW5wdXQuc2xpY2UoNSlcblxuICAvLyA0LiBMZXQgcG9zaXRpb24gcG9pbnQgYXQgdGhlIHN0YXJ0IG9mIGlucHV0LlxuICBjb25zdCBwb3NpdGlvbiA9IHsgcG9zaXRpb246IDAgfVxuXG4gIC8vIDUuIExldCBtaW1lVHlwZSBiZSB0aGUgcmVzdWx0IG9mIGNvbGxlY3RpbmcgYVxuICAvLyBzZXF1ZW5jZSBvZiBjb2RlIHBvaW50cyB0aGF0IGFyZSBub3QgZXF1YWxcbiAgLy8gdG8gVSswMDJDICgsKSwgZ2l2ZW4gcG9zaXRpb24uXG4gIGxldCBtaW1lVHlwZSA9IGNvbGxlY3RBU2VxdWVuY2VPZkNvZGVQb2ludHNGYXN0KFxuICAgICcsJyxcbiAgICBpbnB1dCxcbiAgICBwb3NpdGlvblxuICApXG5cbiAgLy8gNi4gU3RyaXAgbGVhZGluZyBhbmQgdHJhaWxpbmcgQVNDSUkgd2hpdGVzcGFjZVxuICAvLyBmcm9tIG1pbWVUeXBlLlxuICAvLyBVbmRpY2kgaW1wbGVtZW50YXRpb24gbm90ZTogd2UgbmVlZCB0byBzdG9yZSB0aGVcbiAgLy8gbGVuZ3RoIGJlY2F1c2UgaWYgdGhlIG1pbWV0eXBlIGhhcyBzcGFjZXMgcmVtb3ZlZCxcbiAgLy8gdGhlIHdyb25nIGFtb3VudCB3aWxsIGJlIHNsaWNlZCBmcm9tIHRoZSBpbnB1dCBpblxuICAvLyBzdGVwICM5XG4gIGNvbnN0IG1pbWVUeXBlTGVuZ3RoID0gbWltZVR5cGUubGVuZ3RoXG4gIG1pbWVUeXBlID0gcmVtb3ZlQVNDSUlXaGl0ZXNwYWNlKG1pbWVUeXBlLCB0cnVlLCB0cnVlKVxuXG4gIC8vIDcuIElmIHBvc2l0aW9uIGlzIHBhc3QgdGhlIGVuZCBvZiBpbnB1dCwgdGhlblxuICAvLyByZXR1cm4gZmFpbHVyZVxuICBpZiAocG9zaXRpb24ucG9zaXRpb24gPj0gaW5wdXQubGVuZ3RoKSB7XG4gICAgcmV0dXJuICdmYWlsdXJlJ1xuICB9XG5cbiAgLy8gOC4gQWR2YW5jZSBwb3NpdGlvbiBieSAxLlxuICBwb3NpdGlvbi5wb3NpdGlvbisrXG5cbiAgLy8gOS4gTGV0IGVuY29kZWRCb2R5IGJlIHRoZSByZW1haW5kZXIgb2YgaW5wdXQuXG4gIGNvbnN0IGVuY29kZWRCb2R5ID0gaW5wdXQuc2xpY2UobWltZVR5cGVMZW5ndGggKyAxKVxuXG4gIC8vIDEwLiBMZXQgYm9keSBiZSB0aGUgcGVyY2VudC1kZWNvZGluZyBvZiBlbmNvZGVkQm9keS5cbiAgbGV0IGJvZHkgPSBzdHJpbmdQZXJjZW50RGVjb2RlKGVuY29kZWRCb2R5KVxuXG4gIC8vIDExLiBJZiBtaW1lVHlwZSBlbmRzIHdpdGggVSswMDNCICg7KSwgZm9sbG93ZWQgYnlcbiAgLy8gemVybyBvciBtb3JlIFUrMDAyMCBTUEFDRSwgZm9sbG93ZWQgYnkgYW4gQVNDSUlcbiAgLy8gY2FzZS1pbnNlbnNpdGl2ZSBtYXRjaCBmb3IgXCJiYXNlNjRcIiwgdGhlbjpcbiAgaWYgKC87KFxcdTAwMjApezAsfWJhc2U2NCQvaS50ZXN0KG1pbWVUeXBlKSkge1xuICAgIC8vIDEuIExldCBzdHJpbmdCb2R5IGJlIHRoZSBpc29tb3JwaGljIGRlY29kZSBvZiBib2R5LlxuICAgIGNvbnN0IHN0cmluZ0JvZHkgPSBpc29tb3JwaGljRGVjb2RlKGJvZHkpXG5cbiAgICAvLyAyLiBTZXQgYm9keSB0byB0aGUgZm9yZ2l2aW5nLWJhc2U2NCBkZWNvZGUgb2ZcbiAgICAvLyBzdHJpbmdCb2R5LlxuICAgIGJvZHkgPSBmb3JnaXZpbmdCYXNlNjQoc3RyaW5nQm9keSlcblxuICAgIC8vIDMuIElmIGJvZHkgaXMgZmFpbHVyZSwgdGhlbiByZXR1cm4gZmFpbHVyZS5cbiAgICBpZiAoYm9keSA9PT0gJ2ZhaWx1cmUnKSB7XG4gICAgICByZXR1cm4gJ2ZhaWx1cmUnXG4gICAgfVxuXG4gICAgLy8gNC4gUmVtb3ZlIHRoZSBsYXN0IDYgY29kZSBwb2ludHMgZnJvbSBtaW1lVHlwZS5cbiAgICBtaW1lVHlwZSA9IG1pbWVUeXBlLnNsaWNlKDAsIC02KVxuXG4gICAgLy8gNS4gUmVtb3ZlIHRyYWlsaW5nIFUrMDAyMCBTUEFDRSBjb2RlIHBvaW50cyBmcm9tIG1pbWVUeXBlLFxuICAgIC8vIGlmIGFueS5cbiAgICBtaW1lVHlwZSA9IG1pbWVUeXBlLnJlcGxhY2UoLyhcXHUwMDIwKSskLywgJycpXG5cbiAgICAvLyA2LiBSZW1vdmUgdGhlIGxhc3QgVSswMDNCICg7KSBjb2RlIHBvaW50IGZyb20gbWltZVR5cGUuXG4gICAgbWltZVR5cGUgPSBtaW1lVHlwZS5zbGljZSgwLCAtMSlcbiAgfVxuXG4gIC8vIDEyLiBJZiBtaW1lVHlwZSBzdGFydHMgd2l0aCBVKzAwM0IgKDspLCB0aGVuIHByZXBlbmRcbiAgLy8gXCJ0ZXh0L3BsYWluXCIgdG8gbWltZVR5cGUuXG4gIGlmIChtaW1lVHlwZS5zdGFydHNXaXRoKCc7JykpIHtcbiAgICBtaW1lVHlwZSA9ICd0ZXh0L3BsYWluJyArIG1pbWVUeXBlXG4gIH1cblxuICAvLyAxMy4gTGV0IG1pbWVUeXBlUmVjb3JkIGJlIHRoZSByZXN1bHQgb2YgcGFyc2luZ1xuICAvLyBtaW1lVHlwZS5cbiAgbGV0IG1pbWVUeXBlUmVjb3JkID0gcGFyc2VNSU1FVHlwZShtaW1lVHlwZSlcblxuICAvLyAxNC4gSWYgbWltZVR5cGVSZWNvcmQgaXMgZmFpbHVyZSwgdGhlbiBzZXRcbiAgLy8gbWltZVR5cGVSZWNvcmQgdG8gdGV4dC9wbGFpbjtjaGFyc2V0PVVTLUFTQ0lJLlxuICBpZiAobWltZVR5cGVSZWNvcmQgPT09ICdmYWlsdXJlJykge1xuICAgIG1pbWVUeXBlUmVjb3JkID0gcGFyc2VNSU1FVHlwZSgndGV4dC9wbGFpbjtjaGFyc2V0PVVTLUFTQ0lJJylcbiAgfVxuXG4gIC8vIDE1LiBSZXR1cm4gYSBuZXcgZGF0YTogVVJMIHN0cnVjdCB3aG9zZSBNSU1FXG4gIC8vIHR5cGUgaXMgbWltZVR5cGVSZWNvcmQgYW5kIGJvZHkgaXMgYm9keS5cbiAgLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2RhdGEtdXJsLXN0cnVjdFxuICByZXR1cm4geyBtaW1lVHlwZTogbWltZVR5cGVSZWNvcmQsIGJvZHkgfVxufVxuXG4vLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtdXJsLXNlcmlhbGl6ZXJcbi8qKlxuICogQHBhcmFtIHtVUkx9IHVybFxuICogQHBhcmFtIHtib29sZWFufSBleGNsdWRlRnJhZ21lbnRcbiAqL1xuZnVuY3Rpb24gVVJMU2VyaWFsaXplciAodXJsLCBleGNsdWRlRnJhZ21lbnQgPSBmYWxzZSkge1xuICBpZiAoIWV4Y2x1ZGVGcmFnbWVudCkge1xuICAgIHJldHVybiB1cmwuaHJlZlxuICB9XG5cbiAgY29uc3QgaHJlZiA9IHVybC5ocmVmXG4gIGNvbnN0IGhhc2hMZW5ndGggPSB1cmwuaGFzaC5sZW5ndGhcblxuICBjb25zdCBzZXJpYWxpemVkID0gaGFzaExlbmd0aCA9PT0gMCA/IGhyZWYgOiBocmVmLnN1YnN0cmluZygwLCBocmVmLmxlbmd0aCAtIGhhc2hMZW5ndGgpXG5cbiAgaWYgKCFoYXNoTGVuZ3RoICYmIGhyZWYuZW5kc1dpdGgoJyMnKSkge1xuICAgIHJldHVybiBzZXJpYWxpemVkLnNsaWNlKDAsIC0xKVxuICB9XG5cbiAgcmV0dXJuIHNlcmlhbGl6ZWRcbn1cblxuLy8gaHR0cHM6Ly9pbmZyYS5zcGVjLndoYXR3Zy5vcmcvI2NvbGxlY3QtYS1zZXF1ZW5jZS1vZi1jb2RlLXBvaW50c1xuLyoqXG4gKiBAcGFyYW0geyhjaGFyOiBzdHJpbmcpID0+IGJvb2xlYW59IGNvbmRpdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IGlucHV0XG4gKiBAcGFyYW0ge3sgcG9zaXRpb246IG51bWJlciB9fSBwb3NpdGlvblxuICovXG5mdW5jdGlvbiBjb2xsZWN0QVNlcXVlbmNlT2ZDb2RlUG9pbnRzIChjb25kaXRpb24sIGlucHV0LCBwb3NpdGlvbikge1xuICAvLyAxLiBMZXQgcmVzdWx0IGJlIHRoZSBlbXB0eSBzdHJpbmcuXG4gIGxldCByZXN1bHQgPSAnJ1xuXG4gIC8vIDIuIFdoaWxlIHBvc2l0aW9uIGRvZXNu4oCZdCBwb2ludCBwYXN0IHRoZSBlbmQgb2YgaW5wdXQgYW5kIHRoZVxuICAvLyBjb2RlIHBvaW50IGF0IHBvc2l0aW9uIHdpdGhpbiBpbnB1dCBtZWV0cyB0aGUgY29uZGl0aW9uIGNvbmRpdGlvbjpcbiAgd2hpbGUgKHBvc2l0aW9uLnBvc2l0aW9uIDwgaW5wdXQubGVuZ3RoICYmIGNvbmRpdGlvbihpbnB1dFtwb3NpdGlvbi5wb3NpdGlvbl0pKSB7XG4gICAgLy8gMS4gQXBwZW5kIHRoYXQgY29kZSBwb2ludCB0byB0aGUgZW5kIG9mIHJlc3VsdC5cbiAgICByZXN1bHQgKz0gaW5wdXRbcG9zaXRpb24ucG9zaXRpb25dXG5cbiAgICAvLyAyLiBBZHZhbmNlIHBvc2l0aW9uIGJ5IDEuXG4gICAgcG9zaXRpb24ucG9zaXRpb24rK1xuICB9XG5cbiAgLy8gMy4gUmV0dXJuIHJlc3VsdC5cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG4vKipcbiAqIEEgZmFzdGVyIGNvbGxlY3RBU2VxdWVuY2VPZkNvZGVQb2ludHMgdGhhdCBvbmx5IHdvcmtzIHdoZW4gY29tcGFyaW5nIGEgc2luZ2xlIGNoYXJhY3Rlci5cbiAqIEBwYXJhbSB7c3RyaW5nfSBjaGFyXG4gKiBAcGFyYW0ge3N0cmluZ30gaW5wdXRcbiAqIEBwYXJhbSB7eyBwb3NpdGlvbjogbnVtYmVyIH19IHBvc2l0aW9uXG4gKi9cbmZ1bmN0aW9uIGNvbGxlY3RBU2VxdWVuY2VPZkNvZGVQb2ludHNGYXN0IChjaGFyLCBpbnB1dCwgcG9zaXRpb24pIHtcbiAgY29uc3QgaWR4ID0gaW5wdXQuaW5kZXhPZihjaGFyLCBwb3NpdGlvbi5wb3NpdGlvbilcbiAgY29uc3Qgc3RhcnQgPSBwb3NpdGlvbi5wb3NpdGlvblxuXG4gIGlmIChpZHggPT09IC0xKSB7XG4gICAgcG9zaXRpb24ucG9zaXRpb24gPSBpbnB1dC5sZW5ndGhcbiAgICByZXR1cm4gaW5wdXQuc2xpY2Uoc3RhcnQpXG4gIH1cblxuICBwb3NpdGlvbi5wb3NpdGlvbiA9IGlkeFxuICByZXR1cm4gaW5wdXQuc2xpY2Uoc3RhcnQsIHBvc2l0aW9uLnBvc2l0aW9uKVxufVxuXG4vLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI3N0cmluZy1wZXJjZW50LWRlY29kZVxuLyoqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dCAqL1xuZnVuY3Rpb24gc3RyaW5nUGVyY2VudERlY29kZSAoaW5wdXQpIHtcbiAgLy8gMS4gTGV0IGJ5dGVzIGJlIHRoZSBVVEYtOCBlbmNvZGluZyBvZiBpbnB1dC5cbiAgY29uc3QgYnl0ZXMgPSBlbmNvZGVyLmVuY29kZShpbnB1dClcblxuICAvLyAyLiBSZXR1cm4gdGhlIHBlcmNlbnQtZGVjb2Rpbmcgb2YgYnl0ZXMuXG4gIHJldHVybiBwZXJjZW50RGVjb2RlKGJ5dGVzKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBieXRlXG4gKi9cbmZ1bmN0aW9uIGlzSGV4Q2hhckJ5dGUgKGJ5dGUpIHtcbiAgLy8gMC05IEEtRiBhLWZcbiAgcmV0dXJuIChieXRlID49IDB4MzAgJiYgYnl0ZSA8PSAweDM5KSB8fCAoYnl0ZSA+PSAweDQxICYmIGJ5dGUgPD0gMHg0NikgfHwgKGJ5dGUgPj0gMHg2MSAmJiBieXRlIDw9IDB4NjYpXG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IGJ5dGVcbiAqL1xuZnVuY3Rpb24gaGV4Qnl0ZVRvTnVtYmVyIChieXRlKSB7XG4gIHJldHVybiAoXG4gICAgLy8gMC05XG4gICAgYnl0ZSA+PSAweDMwICYmIGJ5dGUgPD0gMHgzOVxuICAgICAgPyAoYnl0ZSAtIDQ4KVxuICAgIC8vIENvbnZlcnQgdG8gdXBwZXJjYXNlXG4gICAgLy8gKChieXRlICYgMHhERikgLSA2NSkgKyAxMFxuICAgICAgOiAoKGJ5dGUgJiAweERGKSAtIDU1KVxuICApXG59XG5cbi8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jcGVyY2VudC1kZWNvZGVcbi8qKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGlucHV0ICovXG5mdW5jdGlvbiBwZXJjZW50RGVjb2RlIChpbnB1dCkge1xuICBjb25zdCBsZW5ndGggPSBpbnB1dC5sZW5ndGhcbiAgLy8gMS4gTGV0IG91dHB1dCBiZSBhbiBlbXB0eSBieXRlIHNlcXVlbmNlLlxuICAvKiogQHR5cGUge1VpbnQ4QXJyYXl9ICovXG4gIGNvbnN0IG91dHB1dCA9IG5ldyBVaW50OEFycmF5KGxlbmd0aClcbiAgbGV0IGogPSAwXG4gIC8vIDIuIEZvciBlYWNoIGJ5dGUgYnl0ZSBpbiBpbnB1dDpcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGNvbnN0IGJ5dGUgPSBpbnB1dFtpXVxuXG4gICAgLy8gMS4gSWYgYnl0ZSBpcyBub3QgMHgyNSAoJSksIHRoZW4gYXBwZW5kIGJ5dGUgdG8gb3V0cHV0LlxuICAgIGlmIChieXRlICE9PSAweDI1KSB7XG4gICAgICBvdXRwdXRbaisrXSA9IGJ5dGVcblxuICAgIC8vIDIuIE90aGVyd2lzZSwgaWYgYnl0ZSBpcyAweDI1ICglKSBhbmQgdGhlIG5leHQgdHdvIGJ5dGVzXG4gICAgLy8gYWZ0ZXIgYnl0ZSBpbiBpbnB1dCBhcmUgbm90IGluIHRoZSByYW5nZXNcbiAgICAvLyAweDMwICgwKSB0byAweDM5ICg5KSwgMHg0MSAoQSkgdG8gMHg0NiAoRiksXG4gICAgLy8gYW5kIDB4NjEgKGEpIHRvIDB4NjYgKGYpLCBhbGwgaW5jbHVzaXZlLCBhcHBlbmQgYnl0ZVxuICAgIC8vIHRvIG91dHB1dC5cbiAgICB9IGVsc2UgaWYgKFxuICAgICAgYnl0ZSA9PT0gMHgyNSAmJlxuICAgICAgIShpc0hleENoYXJCeXRlKGlucHV0W2kgKyAxXSkgJiYgaXNIZXhDaGFyQnl0ZShpbnB1dFtpICsgMl0pKVxuICAgICkge1xuICAgICAgb3V0cHV0W2orK10gPSAweDI1XG5cbiAgICAvLyAzLiBPdGhlcndpc2U6XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIDEuIExldCBieXRlUG9pbnQgYmUgdGhlIHR3byBieXRlcyBhZnRlciBieXRlIGluIGlucHV0LFxuICAgICAgLy8gZGVjb2RlZCwgYW5kIHRoZW4gaW50ZXJwcmV0ZWQgYXMgaGV4YWRlY2ltYWwgbnVtYmVyLlxuICAgICAgLy8gMi4gQXBwZW5kIGEgYnl0ZSB3aG9zZSB2YWx1ZSBpcyBieXRlUG9pbnQgdG8gb3V0cHV0LlxuICAgICAgb3V0cHV0W2orK10gPSAoaGV4Qnl0ZVRvTnVtYmVyKGlucHV0W2kgKyAxXSkgPDwgNCkgfCBoZXhCeXRlVG9OdW1iZXIoaW5wdXRbaSArIDJdKVxuXG4gICAgICAvLyAzLiBTa2lwIHRoZSBuZXh0IHR3byBieXRlcyBpbiBpbnB1dC5cbiAgICAgIGkgKz0gMlxuICAgIH1cbiAgfVxuXG4gIC8vIDMuIFJldHVybiBvdXRwdXQuXG4gIHJldHVybiBsZW5ndGggPT09IGogPyBvdXRwdXQgOiBvdXRwdXQuc3ViYXJyYXkoMCwgailcbn1cblxuLy8gaHR0cHM6Ly9taW1lc25pZmYuc3BlYy53aGF0d2cub3JnLyNwYXJzZS1hLW1pbWUtdHlwZVxuLyoqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dCAqL1xuZnVuY3Rpb24gcGFyc2VNSU1FVHlwZSAoaW5wdXQpIHtcbiAgLy8gMS4gUmVtb3ZlIGFueSBsZWFkaW5nIGFuZCB0cmFpbGluZyBIVFRQIHdoaXRlc3BhY2VcbiAgLy8gZnJvbSBpbnB1dC5cbiAgaW5wdXQgPSByZW1vdmVIVFRQV2hpdGVzcGFjZShpbnB1dCwgdHJ1ZSwgdHJ1ZSlcblxuICAvLyAyLiBMZXQgcG9zaXRpb24gYmUgYSBwb3NpdGlvbiB2YXJpYWJsZSBmb3IgaW5wdXQsXG4gIC8vIGluaXRpYWxseSBwb2ludGluZyBhdCB0aGUgc3RhcnQgb2YgaW5wdXQuXG4gIGNvbnN0IHBvc2l0aW9uID0geyBwb3NpdGlvbjogMCB9XG5cbiAgLy8gMy4gTGV0IHR5cGUgYmUgdGhlIHJlc3VsdCBvZiBjb2xsZWN0aW5nIGEgc2VxdWVuY2VcbiAgLy8gb2YgY29kZSBwb2ludHMgdGhhdCBhcmUgbm90IFUrMDAyRiAoLykgZnJvbVxuICAvLyBpbnB1dCwgZ2l2ZW4gcG9zaXRpb24uXG4gIGNvbnN0IHR5cGUgPSBjb2xsZWN0QVNlcXVlbmNlT2ZDb2RlUG9pbnRzRmFzdChcbiAgICAnLycsXG4gICAgaW5wdXQsXG4gICAgcG9zaXRpb25cbiAgKVxuXG4gIC8vIDQuIElmIHR5cGUgaXMgdGhlIGVtcHR5IHN0cmluZyBvciBkb2VzIG5vdCBzb2xlbHlcbiAgLy8gY29udGFpbiBIVFRQIHRva2VuIGNvZGUgcG9pbnRzLCB0aGVuIHJldHVybiBmYWlsdXJlLlxuICAvLyBodHRwczovL21pbWVzbmlmZi5zcGVjLndoYXR3Zy5vcmcvI2h0dHAtdG9rZW4tY29kZS1wb2ludFxuICBpZiAodHlwZS5sZW5ndGggPT09IDAgfHwgIUhUVFBfVE9LRU5fQ09ERVBPSU5UUy50ZXN0KHR5cGUpKSB7XG4gICAgcmV0dXJuICdmYWlsdXJlJ1xuICB9XG5cbiAgLy8gNS4gSWYgcG9zaXRpb24gaXMgcGFzdCB0aGUgZW5kIG9mIGlucHV0LCB0aGVuIHJldHVyblxuICAvLyBmYWlsdXJlXG4gIGlmIChwb3NpdGlvbi5wb3NpdGlvbiA+IGlucHV0Lmxlbmd0aCkge1xuICAgIHJldHVybiAnZmFpbHVyZSdcbiAgfVxuXG4gIC8vIDYuIEFkdmFuY2UgcG9zaXRpb24gYnkgMS4gKFRoaXMgc2tpcHMgcGFzdCBVKzAwMkYgKC8pLilcbiAgcG9zaXRpb24ucG9zaXRpb24rK1xuXG4gIC8vIDcuIExldCBzdWJ0eXBlIGJlIHRoZSByZXN1bHQgb2YgY29sbGVjdGluZyBhIHNlcXVlbmNlIG9mXG4gIC8vIGNvZGUgcG9pbnRzIHRoYXQgYXJlIG5vdCBVKzAwM0IgKDspIGZyb20gaW5wdXQsIGdpdmVuXG4gIC8vIHBvc2l0aW9uLlxuICBsZXQgc3VidHlwZSA9IGNvbGxlY3RBU2VxdWVuY2VPZkNvZGVQb2ludHNGYXN0KFxuICAgICc7JyxcbiAgICBpbnB1dCxcbiAgICBwb3NpdGlvblxuICApXG5cbiAgLy8gOC4gUmVtb3ZlIGFueSB0cmFpbGluZyBIVFRQIHdoaXRlc3BhY2UgZnJvbSBzdWJ0eXBlLlxuICBzdWJ0eXBlID0gcmVtb3ZlSFRUUFdoaXRlc3BhY2Uoc3VidHlwZSwgZmFsc2UsIHRydWUpXG5cbiAgLy8gOS4gSWYgc3VidHlwZSBpcyB0aGUgZW1wdHkgc3RyaW5nIG9yIGRvZXMgbm90IHNvbGVseVxuICAvLyBjb250YWluIEhUVFAgdG9rZW4gY29kZSBwb2ludHMsIHRoZW4gcmV0dXJuIGZhaWx1cmUuXG4gIGlmIChzdWJ0eXBlLmxlbmd0aCA9PT0gMCB8fCAhSFRUUF9UT0tFTl9DT0RFUE9JTlRTLnRlc3Qoc3VidHlwZSkpIHtcbiAgICByZXR1cm4gJ2ZhaWx1cmUnXG4gIH1cblxuICBjb25zdCB0eXBlTG93ZXJjYXNlID0gdHlwZS50b0xvd2VyQ2FzZSgpXG4gIGNvbnN0IHN1YnR5cGVMb3dlcmNhc2UgPSBzdWJ0eXBlLnRvTG93ZXJDYXNlKClcblxuICAvLyAxMC4gTGV0IG1pbWVUeXBlIGJlIGEgbmV3IE1JTUUgdHlwZSByZWNvcmQgd2hvc2UgdHlwZVxuICAvLyBpcyB0eXBlLCBpbiBBU0NJSSBsb3dlcmNhc2UsIGFuZCBzdWJ0eXBlIGlzIHN1YnR5cGUsXG4gIC8vIGluIEFTQ0lJIGxvd2VyY2FzZS5cbiAgLy8gaHR0cHM6Ly9taW1lc25pZmYuc3BlYy53aGF0d2cub3JnLyNtaW1lLXR5cGVcbiAgY29uc3QgbWltZVR5cGUgPSB7XG4gICAgdHlwZTogdHlwZUxvd2VyY2FzZSxcbiAgICBzdWJ0eXBlOiBzdWJ0eXBlTG93ZXJjYXNlLFxuICAgIC8qKiBAdHlwZSB7TWFwPHN0cmluZywgc3RyaW5nPn0gKi9cbiAgICBwYXJhbWV0ZXJzOiBuZXcgTWFwKCksXG4gICAgLy8gaHR0cHM6Ly9taW1lc25pZmYuc3BlYy53aGF0d2cub3JnLyNtaW1lLXR5cGUtZXNzZW5jZVxuICAgIGVzc2VuY2U6IGAke3R5cGVMb3dlcmNhc2V9LyR7c3VidHlwZUxvd2VyY2FzZX1gXG4gIH1cblxuICAvLyAxMS4gV2hpbGUgcG9zaXRpb24gaXMgbm90IHBhc3QgdGhlIGVuZCBvZiBpbnB1dDpcbiAgd2hpbGUgKHBvc2l0aW9uLnBvc2l0aW9uIDwgaW5wdXQubGVuZ3RoKSB7XG4gICAgLy8gMS4gQWR2YW5jZSBwb3NpdGlvbiBieSAxLiAoVGhpcyBza2lwcyBwYXN0IFUrMDAzQiAoOykuKVxuICAgIHBvc2l0aW9uLnBvc2l0aW9uKytcblxuICAgIC8vIDIuIENvbGxlY3QgYSBzZXF1ZW5jZSBvZiBjb2RlIHBvaW50cyB0aGF0IGFyZSBIVFRQXG4gICAgLy8gd2hpdGVzcGFjZSBmcm9tIGlucHV0IGdpdmVuIHBvc2l0aW9uLlxuICAgIGNvbGxlY3RBU2VxdWVuY2VPZkNvZGVQb2ludHMoXG4gICAgICAvLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jaHR0cC13aGl0ZXNwYWNlXG4gICAgICBjaGFyID0+IEhUVFBfV0hJVEVTUEFDRV9SRUdFWC50ZXN0KGNoYXIpLFxuICAgICAgaW5wdXQsXG4gICAgICBwb3NpdGlvblxuICAgIClcblxuICAgIC8vIDMuIExldCBwYXJhbWV0ZXJOYW1lIGJlIHRoZSByZXN1bHQgb2YgY29sbGVjdGluZyBhXG4gICAgLy8gc2VxdWVuY2Ugb2YgY29kZSBwb2ludHMgdGhhdCBhcmUgbm90IFUrMDAzQiAoOylcbiAgICAvLyBvciBVKzAwM0QgKD0pIGZyb20gaW5wdXQsIGdpdmVuIHBvc2l0aW9uLlxuICAgIGxldCBwYXJhbWV0ZXJOYW1lID0gY29sbGVjdEFTZXF1ZW5jZU9mQ29kZVBvaW50cyhcbiAgICAgIChjaGFyKSA9PiBjaGFyICE9PSAnOycgJiYgY2hhciAhPT0gJz0nLFxuICAgICAgaW5wdXQsXG4gICAgICBwb3NpdGlvblxuICAgIClcblxuICAgIC8vIDQuIFNldCBwYXJhbWV0ZXJOYW1lIHRvIHBhcmFtZXRlck5hbWUsIGluIEFTQ0lJXG4gICAgLy8gbG93ZXJjYXNlLlxuICAgIHBhcmFtZXRlck5hbWUgPSBwYXJhbWV0ZXJOYW1lLnRvTG93ZXJDYXNlKClcblxuICAgIC8vIDUuIElmIHBvc2l0aW9uIGlzIG5vdCBwYXN0IHRoZSBlbmQgb2YgaW5wdXQsIHRoZW46XG4gICAgaWYgKHBvc2l0aW9uLnBvc2l0aW9uIDwgaW5wdXQubGVuZ3RoKSB7XG4gICAgICAvLyAxLiBJZiB0aGUgY29kZSBwb2ludCBhdCBwb3NpdGlvbiB3aXRoaW4gaW5wdXQgaXNcbiAgICAgIC8vIFUrMDAzQiAoOyksIHRoZW4gY29udGludWUuXG4gICAgICBpZiAoaW5wdXRbcG9zaXRpb24ucG9zaXRpb25dID09PSAnOycpIHtcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gMi4gQWR2YW5jZSBwb3NpdGlvbiBieSAxLiAoVGhpcyBza2lwcyBwYXN0IFUrMDAzRCAoPSkuKVxuICAgICAgcG9zaXRpb24ucG9zaXRpb24rK1xuICAgIH1cblxuICAgIC8vIDYuIElmIHBvc2l0aW9uIGlzIHBhc3QgdGhlIGVuZCBvZiBpbnB1dCwgdGhlbiBicmVhay5cbiAgICBpZiAocG9zaXRpb24ucG9zaXRpb24gPiBpbnB1dC5sZW5ndGgpIHtcbiAgICAgIGJyZWFrXG4gICAgfVxuXG4gICAgLy8gNy4gTGV0IHBhcmFtZXRlclZhbHVlIGJlIG51bGwuXG4gICAgbGV0IHBhcmFtZXRlclZhbHVlID0gbnVsbFxuXG4gICAgLy8gOC4gSWYgdGhlIGNvZGUgcG9pbnQgYXQgcG9zaXRpb24gd2l0aGluIGlucHV0IGlzXG4gICAgLy8gVSswMDIyIChcIiksIHRoZW46XG4gICAgaWYgKGlucHV0W3Bvc2l0aW9uLnBvc2l0aW9uXSA9PT0gJ1wiJykge1xuICAgICAgLy8gMS4gU2V0IHBhcmFtZXRlclZhbHVlIHRvIHRoZSByZXN1bHQgb2YgY29sbGVjdGluZ1xuICAgICAgLy8gYW4gSFRUUCBxdW90ZWQgc3RyaW5nIGZyb20gaW5wdXQsIGdpdmVuIHBvc2l0aW9uXG4gICAgICAvLyBhbmQgdGhlIGV4dHJhY3QtdmFsdWUgZmxhZy5cbiAgICAgIHBhcmFtZXRlclZhbHVlID0gY29sbGVjdEFuSFRUUFF1b3RlZFN0cmluZyhpbnB1dCwgcG9zaXRpb24sIHRydWUpXG5cbiAgICAgIC8vIDIuIENvbGxlY3QgYSBzZXF1ZW5jZSBvZiBjb2RlIHBvaW50cyB0aGF0IGFyZSBub3RcbiAgICAgIC8vIFUrMDAzQiAoOykgZnJvbSBpbnB1dCwgZ2l2ZW4gcG9zaXRpb24uXG4gICAgICBjb2xsZWN0QVNlcXVlbmNlT2ZDb2RlUG9pbnRzRmFzdChcbiAgICAgICAgJzsnLFxuICAgICAgICBpbnB1dCxcbiAgICAgICAgcG9zaXRpb25cbiAgICAgIClcblxuICAgIC8vIDkuIE90aGVyd2lzZTpcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gMS4gU2V0IHBhcmFtZXRlclZhbHVlIHRvIHRoZSByZXN1bHQgb2YgY29sbGVjdGluZ1xuICAgICAgLy8gYSBzZXF1ZW5jZSBvZiBjb2RlIHBvaW50cyB0aGF0IGFyZSBub3QgVSswMDNCICg7KVxuICAgICAgLy8gZnJvbSBpbnB1dCwgZ2l2ZW4gcG9zaXRpb24uXG4gICAgICBwYXJhbWV0ZXJWYWx1ZSA9IGNvbGxlY3RBU2VxdWVuY2VPZkNvZGVQb2ludHNGYXN0KFxuICAgICAgICAnOycsXG4gICAgICAgIGlucHV0LFxuICAgICAgICBwb3NpdGlvblxuICAgICAgKVxuXG4gICAgICAvLyAyLiBSZW1vdmUgYW55IHRyYWlsaW5nIEhUVFAgd2hpdGVzcGFjZSBmcm9tIHBhcmFtZXRlclZhbHVlLlxuICAgICAgcGFyYW1ldGVyVmFsdWUgPSByZW1vdmVIVFRQV2hpdGVzcGFjZShwYXJhbWV0ZXJWYWx1ZSwgZmFsc2UsIHRydWUpXG5cbiAgICAgIC8vIDMuIElmIHBhcmFtZXRlclZhbHVlIGlzIHRoZSBlbXB0eSBzdHJpbmcsIHRoZW4gY29udGludWUuXG4gICAgICBpZiAocGFyYW1ldGVyVmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gMTAuIElmIGFsbCBvZiB0aGUgZm9sbG93aW5nIGFyZSB0cnVlXG4gICAgLy8gLSBwYXJhbWV0ZXJOYW1lIGlzIG5vdCB0aGUgZW1wdHkgc3RyaW5nXG4gICAgLy8gLSBwYXJhbWV0ZXJOYW1lIHNvbGVseSBjb250YWlucyBIVFRQIHRva2VuIGNvZGUgcG9pbnRzXG4gICAgLy8gLSBwYXJhbWV0ZXJWYWx1ZSBzb2xlbHkgY29udGFpbnMgSFRUUCBxdW90ZWQtc3RyaW5nIHRva2VuIGNvZGUgcG9pbnRzXG4gICAgLy8gLSBtaW1lVHlwZeKAmXMgcGFyYW1ldGVyc1twYXJhbWV0ZXJOYW1lXSBkb2VzIG5vdCBleGlzdFxuICAgIC8vIHRoZW4gc2V0IG1pbWVUeXBl4oCZcyBwYXJhbWV0ZXJzW3BhcmFtZXRlck5hbWVdIHRvIHBhcmFtZXRlclZhbHVlLlxuICAgIGlmIChcbiAgICAgIHBhcmFtZXRlck5hbWUubGVuZ3RoICE9PSAwICYmXG4gICAgICBIVFRQX1RPS0VOX0NPREVQT0lOVFMudGVzdChwYXJhbWV0ZXJOYW1lKSAmJlxuICAgICAgKHBhcmFtZXRlclZhbHVlLmxlbmd0aCA9PT0gMCB8fCBIVFRQX1FVT1RFRF9TVFJJTkdfVE9LRU5TLnRlc3QocGFyYW1ldGVyVmFsdWUpKSAmJlxuICAgICAgIW1pbWVUeXBlLnBhcmFtZXRlcnMuaGFzKHBhcmFtZXRlck5hbWUpXG4gICAgKSB7XG4gICAgICBtaW1lVHlwZS5wYXJhbWV0ZXJzLnNldChwYXJhbWV0ZXJOYW1lLCBwYXJhbWV0ZXJWYWx1ZSlcbiAgICB9XG4gIH1cblxuICAvLyAxMi4gUmV0dXJuIG1pbWVUeXBlLlxuICByZXR1cm4gbWltZVR5cGVcbn1cblxuLy8gaHR0cHM6Ly9pbmZyYS5zcGVjLndoYXR3Zy5vcmcvI2ZvcmdpdmluZy1iYXNlNjQtZGVjb2RlXG4vKiogQHBhcmFtIHtzdHJpbmd9IGRhdGEgKi9cbmZ1bmN0aW9uIGZvcmdpdmluZ0Jhc2U2NCAoZGF0YSkge1xuICAvLyAxLiBSZW1vdmUgYWxsIEFTQ0lJIHdoaXRlc3BhY2UgZnJvbSBkYXRhLlxuICBkYXRhID0gZGF0YS5yZXBsYWNlKEFTQ0lJX1dISVRFU1BBQ0VfUkVQTEFDRV9SRUdFWCwgJycpICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbiAgbGV0IGRhdGFMZW5ndGggPSBkYXRhLmxlbmd0aFxuICAvLyAyLiBJZiBkYXRh4oCZcyBjb2RlIHBvaW50IGxlbmd0aCBkaXZpZGVzIGJ5IDQgbGVhdmluZ1xuICAvLyBubyByZW1haW5kZXIsIHRoZW46XG4gIGlmIChkYXRhTGVuZ3RoICUgNCA9PT0gMCkge1xuICAgIC8vIDEuIElmIGRhdGEgZW5kcyB3aXRoIG9uZSBvciB0d28gVSswMDNEICg9KSBjb2RlIHBvaW50cyxcbiAgICAvLyB0aGVuIHJlbW92ZSB0aGVtIGZyb20gZGF0YS5cbiAgICBpZiAoZGF0YS5jaGFyQ29kZUF0KGRhdGFMZW5ndGggLSAxKSA9PT0gMHgwMDNEKSB7XG4gICAgICAtLWRhdGFMZW5ndGhcbiAgICAgIGlmIChkYXRhLmNoYXJDb2RlQXQoZGF0YUxlbmd0aCAtIDEpID09PSAweDAwM0QpIHtcbiAgICAgICAgLS1kYXRhTGVuZ3RoXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gMy4gSWYgZGF0YeKAmXMgY29kZSBwb2ludCBsZW5ndGggZGl2aWRlcyBieSA0IGxlYXZpbmdcbiAgLy8gYSByZW1haW5kZXIgb2YgMSwgdGhlbiByZXR1cm4gZmFpbHVyZS5cbiAgaWYgKGRhdGFMZW5ndGggJSA0ID09PSAxKSB7XG4gICAgcmV0dXJuICdmYWlsdXJlJ1xuICB9XG5cbiAgLy8gNC4gSWYgZGF0YSBjb250YWlucyBhIGNvZGUgcG9pbnQgdGhhdCBpcyBub3Qgb25lIG9mXG4gIC8vICBVKzAwMkIgKCspXG4gIC8vICBVKzAwMkYgKC8pXG4gIC8vICBBU0NJSSBhbHBoYW51bWVyaWNcbiAgLy8gdGhlbiByZXR1cm4gZmFpbHVyZS5cbiAgaWYgKC9bXisvMC05QS1aYS16XS8udGVzdChkYXRhLmxlbmd0aCA9PT0gZGF0YUxlbmd0aCA/IGRhdGEgOiBkYXRhLnN1YnN0cmluZygwLCBkYXRhTGVuZ3RoKSkpIHtcbiAgICByZXR1cm4gJ2ZhaWx1cmUnXG4gIH1cblxuICBjb25zdCBidWZmZXIgPSBCdWZmZXIuZnJvbShkYXRhLCAnYmFzZTY0JylcbiAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGJ1ZmZlci5idWZmZXIsIGJ1ZmZlci5ieXRlT2Zmc2V0LCBidWZmZXIuYnl0ZUxlbmd0aClcbn1cblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbGxlY3QtYW4taHR0cC1xdW90ZWQtc3RyaW5nXG4vLyB0ZXN0czogaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2V4YW1wbGUtaHR0cC1xdW90ZWQtc3RyaW5nXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dFxuICogQHBhcmFtIHt7IHBvc2l0aW9uOiBudW1iZXIgfX0gcG9zaXRpb25cbiAqIEBwYXJhbSB7Ym9vbGVhbj99IGV4dHJhY3RWYWx1ZVxuICovXG5mdW5jdGlvbiBjb2xsZWN0QW5IVFRQUXVvdGVkU3RyaW5nIChpbnB1dCwgcG9zaXRpb24sIGV4dHJhY3RWYWx1ZSkge1xuICAvLyAxLiBMZXQgcG9zaXRpb25TdGFydCBiZSBwb3NpdGlvbi5cbiAgY29uc3QgcG9zaXRpb25TdGFydCA9IHBvc2l0aW9uLnBvc2l0aW9uXG5cbiAgLy8gMi4gTGV0IHZhbHVlIGJlIHRoZSBlbXB0eSBzdHJpbmcuXG4gIGxldCB2YWx1ZSA9ICcnXG5cbiAgLy8gMy4gQXNzZXJ0OiB0aGUgY29kZSBwb2ludCBhdCBwb3NpdGlvbiB3aXRoaW4gaW5wdXRcbiAgLy8gaXMgVSswMDIyIChcIikuXG4gIGFzc2VydChpbnB1dFtwb3NpdGlvbi5wb3NpdGlvbl0gPT09ICdcIicpXG5cbiAgLy8gNC4gQWR2YW5jZSBwb3NpdGlvbiBieSAxLlxuICBwb3NpdGlvbi5wb3NpdGlvbisrXG5cbiAgLy8gNS4gV2hpbGUgdHJ1ZTpcbiAgd2hpbGUgKHRydWUpIHtcbiAgICAvLyAxLiBBcHBlbmQgdGhlIHJlc3VsdCBvZiBjb2xsZWN0aW5nIGEgc2VxdWVuY2Ugb2YgY29kZSBwb2ludHNcbiAgICAvLyB0aGF0IGFyZSBub3QgVSswMDIyIChcIikgb3IgVSswMDVDIChcXCkgZnJvbSBpbnB1dCwgZ2l2ZW5cbiAgICAvLyBwb3NpdGlvbiwgdG8gdmFsdWUuXG4gICAgdmFsdWUgKz0gY29sbGVjdEFTZXF1ZW5jZU9mQ29kZVBvaW50cyhcbiAgICAgIChjaGFyKSA9PiBjaGFyICE9PSAnXCInICYmIGNoYXIgIT09ICdcXFxcJyxcbiAgICAgIGlucHV0LFxuICAgICAgcG9zaXRpb25cbiAgICApXG5cbiAgICAvLyAyLiBJZiBwb3NpdGlvbiBpcyBwYXN0IHRoZSBlbmQgb2YgaW5wdXQsIHRoZW4gYnJlYWsuXG4gICAgaWYgKHBvc2l0aW9uLnBvc2l0aW9uID49IGlucHV0Lmxlbmd0aCkge1xuICAgICAgYnJlYWtcbiAgICB9XG5cbiAgICAvLyAzLiBMZXQgcXVvdGVPckJhY2tzbGFzaCBiZSB0aGUgY29kZSBwb2ludCBhdCBwb3NpdGlvbiB3aXRoaW5cbiAgICAvLyBpbnB1dC5cbiAgICBjb25zdCBxdW90ZU9yQmFja3NsYXNoID0gaW5wdXRbcG9zaXRpb24ucG9zaXRpb25dXG5cbiAgICAvLyA0LiBBZHZhbmNlIHBvc2l0aW9uIGJ5IDEuXG4gICAgcG9zaXRpb24ucG9zaXRpb24rK1xuXG4gICAgLy8gNS4gSWYgcXVvdGVPckJhY2tzbGFzaCBpcyBVKzAwNUMgKFxcKSwgdGhlbjpcbiAgICBpZiAocXVvdGVPckJhY2tzbGFzaCA9PT0gJ1xcXFwnKSB7XG4gICAgICAvLyAxLiBJZiBwb3NpdGlvbiBpcyBwYXN0IHRoZSBlbmQgb2YgaW5wdXQsIHRoZW4gYXBwZW5kXG4gICAgICAvLyBVKzAwNUMgKFxcKSB0byB2YWx1ZSBhbmQgYnJlYWsuXG4gICAgICBpZiAocG9zaXRpb24ucG9zaXRpb24gPj0gaW5wdXQubGVuZ3RoKSB7XG4gICAgICAgIHZhbHVlICs9ICdcXFxcJ1xuICAgICAgICBicmVha1xuICAgICAgfVxuXG4gICAgICAvLyAyLiBBcHBlbmQgdGhlIGNvZGUgcG9pbnQgYXQgcG9zaXRpb24gd2l0aGluIGlucHV0IHRvIHZhbHVlLlxuICAgICAgdmFsdWUgKz0gaW5wdXRbcG9zaXRpb24ucG9zaXRpb25dXG5cbiAgICAgIC8vIDMuIEFkdmFuY2UgcG9zaXRpb24gYnkgMS5cbiAgICAgIHBvc2l0aW9uLnBvc2l0aW9uKytcblxuICAgIC8vIDYuIE90aGVyd2lzZTpcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gMS4gQXNzZXJ0OiBxdW90ZU9yQmFja3NsYXNoIGlzIFUrMDAyMiAoXCIpLlxuICAgICAgYXNzZXJ0KHF1b3RlT3JCYWNrc2xhc2ggPT09ICdcIicpXG5cbiAgICAgIC8vIDIuIEJyZWFrLlxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICAvLyA2LiBJZiB0aGUgZXh0cmFjdC12YWx1ZSBmbGFnIGlzIHNldCwgdGhlbiByZXR1cm4gdmFsdWUuXG4gIGlmIChleHRyYWN0VmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuXG4gIC8vIDcuIFJldHVybiB0aGUgY29kZSBwb2ludHMgZnJvbSBwb3NpdGlvblN0YXJ0IHRvIHBvc2l0aW9uLFxuICAvLyBpbmNsdXNpdmUsIHdpdGhpbiBpbnB1dC5cbiAgcmV0dXJuIGlucHV0LnNsaWNlKHBvc2l0aW9uU3RhcnQsIHBvc2l0aW9uLnBvc2l0aW9uKVxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9taW1lc25pZmYuc3BlYy53aGF0d2cub3JnLyNzZXJpYWxpemUtYS1taW1lLXR5cGVcbiAqL1xuZnVuY3Rpb24gc2VyaWFsaXplQU1pbWVUeXBlIChtaW1lVHlwZSkge1xuICBhc3NlcnQobWltZVR5cGUgIT09ICdmYWlsdXJlJylcbiAgY29uc3QgeyBwYXJhbWV0ZXJzLCBlc3NlbmNlIH0gPSBtaW1lVHlwZVxuXG4gIC8vIDEuIExldCBzZXJpYWxpemF0aW9uIGJlIHRoZSBjb25jYXRlbmF0aW9uIG9mIG1pbWVUeXBl4oCZc1xuICAvLyAgICB0eXBlLCBVKzAwMkYgKC8pLCBhbmQgbWltZVR5cGXigJlzIHN1YnR5cGUuXG4gIGxldCBzZXJpYWxpemF0aW9uID0gZXNzZW5jZVxuXG4gIC8vIDIuIEZvciBlYWNoIG5hbWUg4oaSIHZhbHVlIG9mIG1pbWVUeXBl4oCZcyBwYXJhbWV0ZXJzOlxuICBmb3IgKGxldCBbbmFtZSwgdmFsdWVdIG9mIHBhcmFtZXRlcnMuZW50cmllcygpKSB7XG4gICAgLy8gMS4gQXBwZW5kIFUrMDAzQiAoOykgdG8gc2VyaWFsaXphdGlvbi5cbiAgICBzZXJpYWxpemF0aW9uICs9ICc7J1xuXG4gICAgLy8gMi4gQXBwZW5kIG5hbWUgdG8gc2VyaWFsaXphdGlvbi5cbiAgICBzZXJpYWxpemF0aW9uICs9IG5hbWVcblxuICAgIC8vIDMuIEFwcGVuZCBVKzAwM0QgKD0pIHRvIHNlcmlhbGl6YXRpb24uXG4gICAgc2VyaWFsaXphdGlvbiArPSAnPSdcblxuICAgIC8vIDQuIElmIHZhbHVlIGRvZXMgbm90IHNvbGVseSBjb250YWluIEhUVFAgdG9rZW4gY29kZVxuICAgIC8vICAgIHBvaW50cyBvciB2YWx1ZSBpcyB0aGUgZW1wdHkgc3RyaW5nLCB0aGVuOlxuICAgIGlmICghSFRUUF9UT0tFTl9DT0RFUE9JTlRTLnRlc3QodmFsdWUpKSB7XG4gICAgICAvLyAxLiBQcmVjZWRlIGVhY2ggb2NjdXJyZW5jZSBvZiBVKzAwMjIgKFwiKSBvclxuICAgICAgLy8gICAgVSswMDVDIChcXCkgaW4gdmFsdWUgd2l0aCBVKzAwNUMgKFxcKS5cbiAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvKFxcXFx8XCIpL2csICdcXFxcJDEnKVxuXG4gICAgICAvLyAyLiBQcmVwZW5kIFUrMDAyMiAoXCIpIHRvIHZhbHVlLlxuICAgICAgdmFsdWUgPSAnXCInICsgdmFsdWVcblxuICAgICAgLy8gMy4gQXBwZW5kIFUrMDAyMiAoXCIpIHRvIHZhbHVlLlxuICAgICAgdmFsdWUgKz0gJ1wiJ1xuICAgIH1cblxuICAgIC8vIDUuIEFwcGVuZCB2YWx1ZSB0byBzZXJpYWxpemF0aW9uLlxuICAgIHNlcmlhbGl6YXRpb24gKz0gdmFsdWVcbiAgfVxuXG4gIC8vIDMuIFJldHVybiBzZXJpYWxpemF0aW9uLlxuICByZXR1cm4gc2VyaWFsaXphdGlvblxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2h0dHAtd2hpdGVzcGFjZVxuICogQHBhcmFtIHtudW1iZXJ9IGNoYXJcbiAqL1xuZnVuY3Rpb24gaXNIVFRQV2hpdGVTcGFjZSAoY2hhcikge1xuICAvLyBcIlxcclxcblxcdCBcIlxuICByZXR1cm4gY2hhciA9PT0gMHgwMGQgfHwgY2hhciA9PT0gMHgwMGEgfHwgY2hhciA9PT0gMHgwMDkgfHwgY2hhciA9PT0gMHgwMjBcbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNodHRwLXdoaXRlc3BhY2VcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2xlYWRpbmc9dHJ1ZV1cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3RyYWlsaW5nPXRydWVdXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUhUVFBXaGl0ZXNwYWNlIChzdHIsIGxlYWRpbmcgPSB0cnVlLCB0cmFpbGluZyA9IHRydWUpIHtcbiAgcmV0dXJuIHJlbW92ZUNoYXJzKHN0ciwgbGVhZGluZywgdHJhaWxpbmcsIGlzSFRUUFdoaXRlU3BhY2UpXG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL2luZnJhLnNwZWMud2hhdHdnLm9yZy8jYXNjaWktd2hpdGVzcGFjZVxuICogQHBhcmFtIHtudW1iZXJ9IGNoYXJcbiAqL1xuZnVuY3Rpb24gaXNBU0NJSVdoaXRlc3BhY2UgKGNoYXIpIHtcbiAgLy8gXCJcXHJcXG5cXHRcXGYgXCJcbiAgcmV0dXJuIGNoYXIgPT09IDB4MDBkIHx8IGNoYXIgPT09IDB4MDBhIHx8IGNoYXIgPT09IDB4MDA5IHx8IGNoYXIgPT09IDB4MDBjIHx8IGNoYXIgPT09IDB4MDIwXG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL2luZnJhLnNwZWMud2hhdHdnLm9yZy8jc3RyaXAtbGVhZGluZy1hbmQtdHJhaWxpbmctYXNjaWktd2hpdGVzcGFjZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICogQHBhcmFtIHtib29sZWFufSBbbGVhZGluZz10cnVlXVxuICogQHBhcmFtIHtib29sZWFufSBbdHJhaWxpbmc9dHJ1ZV1cbiAqL1xuZnVuY3Rpb24gcmVtb3ZlQVNDSUlXaGl0ZXNwYWNlIChzdHIsIGxlYWRpbmcgPSB0cnVlLCB0cmFpbGluZyA9IHRydWUpIHtcbiAgcmV0dXJuIHJlbW92ZUNoYXJzKHN0ciwgbGVhZGluZywgdHJhaWxpbmcsIGlzQVNDSUlXaGl0ZXNwYWNlKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gbGVhZGluZ1xuICogQHBhcmFtIHtib29sZWFufSB0cmFpbGluZ1xuICogQHBhcmFtIHsoY2hhckNvZGU6IG51bWJlcikgPT4gYm9vbGVhbn0gcHJlZGljYXRlXG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiByZW1vdmVDaGFycyAoc3RyLCBsZWFkaW5nLCB0cmFpbGluZywgcHJlZGljYXRlKSB7XG4gIGxldCBsZWFkID0gMFxuICBsZXQgdHJhaWwgPSBzdHIubGVuZ3RoIC0gMVxuXG4gIGlmIChsZWFkaW5nKSB7XG4gICAgd2hpbGUgKGxlYWQgPCBzdHIubGVuZ3RoICYmIHByZWRpY2F0ZShzdHIuY2hhckNvZGVBdChsZWFkKSkpIGxlYWQrK1xuICB9XG5cbiAgaWYgKHRyYWlsaW5nKSB7XG4gICAgd2hpbGUgKHRyYWlsID4gMCAmJiBwcmVkaWNhdGUoc3RyLmNoYXJDb2RlQXQodHJhaWwpKSkgdHJhaWwtLVxuICB9XG5cbiAgcmV0dXJuIGxlYWQgPT09IDAgJiYgdHJhaWwgPT09IHN0ci5sZW5ndGggLSAxID8gc3RyIDogc3RyLnNsaWNlKGxlYWQsIHRyYWlsICsgMSlcbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vaW5mcmEuc3BlYy53aGF0d2cub3JnLyNpc29tb3JwaGljLWRlY29kZVxuICogQHBhcmFtIHtVaW50OEFycmF5fSBpbnB1dFxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gaXNvbW9ycGhpY0RlY29kZSAoaW5wdXQpIHtcbiAgLy8gMS4gVG8gaXNvbW9ycGhpYyBkZWNvZGUgYSBieXRlIHNlcXVlbmNlIGlucHV0LCByZXR1cm4gYSBzdHJpbmcgd2hvc2UgY29kZSBwb2ludFxuICAvLyAgICBsZW5ndGggaXMgZXF1YWwgdG8gaW5wdXTigJlzIGxlbmd0aCBhbmQgd2hvc2UgY29kZSBwb2ludHMgaGF2ZSB0aGUgc2FtZSB2YWx1ZXNcbiAgLy8gICAgYXMgdGhlIHZhbHVlcyBvZiBpbnB1dOKAmXMgYnl0ZXMsIGluIHRoZSBzYW1lIG9yZGVyLlxuICBjb25zdCBsZW5ndGggPSBpbnB1dC5sZW5ndGhcbiAgaWYgKCgyIDw8IDE1KSAtIDEgPiBsZW5ndGgpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBpbnB1dClcbiAgfVxuICBsZXQgcmVzdWx0ID0gJyc7IGxldCBpID0gMFxuICBsZXQgYWRkaXRpb24gPSAoMiA8PCAxNSkgLSAxXG4gIHdoaWxlIChpIDwgbGVuZ3RoKSB7XG4gICAgaWYgKGkgKyBhZGRpdGlvbiA+IGxlbmd0aCkge1xuICAgICAgYWRkaXRpb24gPSBsZW5ndGggLSBpXG4gICAgfVxuICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGlucHV0LnN1YmFycmF5KGksIGkgKz0gYWRkaXRpb24pKVxuICB9XG4gIHJldHVybiByZXN1bHRcbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vbWltZXNuaWZmLnNwZWMud2hhdHdnLm9yZy8jbWluaW1pemUtYS1zdXBwb3J0ZWQtbWltZS10eXBlXG4gKiBAcGFyYW0ge0V4Y2x1ZGU8UmV0dXJuVHlwZTx0eXBlb2YgcGFyc2VNSU1FVHlwZT4sICdmYWlsdXJlJz59IG1pbWVUeXBlXG4gKi9cbmZ1bmN0aW9uIG1pbmltaXplU3VwcG9ydGVkTWltZVR5cGUgKG1pbWVUeXBlKSB7XG4gIHN3aXRjaCAobWltZVR5cGUuZXNzZW5jZSkge1xuICAgIGNhc2UgJ2FwcGxpY2F0aW9uL2VjbWFzY3JpcHQnOlxuICAgIGNhc2UgJ2FwcGxpY2F0aW9uL2phdmFzY3JpcHQnOlxuICAgIGNhc2UgJ2FwcGxpY2F0aW9uL3gtZWNtYXNjcmlwdCc6XG4gICAgY2FzZSAnYXBwbGljYXRpb24veC1qYXZhc2NyaXB0JzpcbiAgICBjYXNlICd0ZXh0L2VjbWFzY3JpcHQnOlxuICAgIGNhc2UgJ3RleHQvamF2YXNjcmlwdCc6XG4gICAgY2FzZSAndGV4dC9qYXZhc2NyaXB0MS4wJzpcbiAgICBjYXNlICd0ZXh0L2phdmFzY3JpcHQxLjEnOlxuICAgIGNhc2UgJ3RleHQvamF2YXNjcmlwdDEuMic6XG4gICAgY2FzZSAndGV4dC9qYXZhc2NyaXB0MS4zJzpcbiAgICBjYXNlICd0ZXh0L2phdmFzY3JpcHQxLjQnOlxuICAgIGNhc2UgJ3RleHQvamF2YXNjcmlwdDEuNSc6XG4gICAgY2FzZSAndGV4dC9qc2NyaXB0JzpcbiAgICBjYXNlICd0ZXh0L2xpdmVzY3JpcHQnOlxuICAgIGNhc2UgJ3RleHQveC1lY21hc2NyaXB0JzpcbiAgICBjYXNlICd0ZXh0L3gtamF2YXNjcmlwdCc6XG4gICAgICAvLyAxLiBJZiBtaW1lVHlwZSBpcyBhIEphdmFTY3JpcHQgTUlNRSB0eXBlLCB0aGVuIHJldHVybiBcInRleHQvamF2YXNjcmlwdFwiLlxuICAgICAgcmV0dXJuICd0ZXh0L2phdmFzY3JpcHQnXG4gICAgY2FzZSAnYXBwbGljYXRpb24vanNvbic6XG4gICAgY2FzZSAndGV4dC9qc29uJzpcbiAgICAgIC8vIDIuIElmIG1pbWVUeXBlIGlzIGEgSlNPTiBNSU1FIHR5cGUsIHRoZW4gcmV0dXJuIFwiYXBwbGljYXRpb24vanNvblwiLlxuICAgICAgcmV0dXJuICdhcHBsaWNhdGlvbi9qc29uJ1xuICAgIGNhc2UgJ2ltYWdlL3N2Zyt4bWwnOlxuICAgICAgLy8gMy4gSWYgbWltZVR5cGXigJlzIGVzc2VuY2UgaXMgXCJpbWFnZS9zdmcreG1sXCIsIHRoZW4gcmV0dXJuIFwiaW1hZ2Uvc3ZnK3htbFwiLlxuICAgICAgcmV0dXJuICdpbWFnZS9zdmcreG1sJ1xuICAgIGNhc2UgJ3RleHQveG1sJzpcbiAgICBjYXNlICdhcHBsaWNhdGlvbi94bWwnOlxuICAgICAgLy8gNC4gSWYgbWltZVR5cGUgaXMgYW4gWE1MIE1JTUUgdHlwZSwgdGhlbiByZXR1cm4gXCJhcHBsaWNhdGlvbi94bWxcIi5cbiAgICAgIHJldHVybiAnYXBwbGljYXRpb24veG1sJ1xuICB9XG5cbiAgLy8gMi4gSWYgbWltZVR5cGUgaXMgYSBKU09OIE1JTUUgdHlwZSwgdGhlbiByZXR1cm4gXCJhcHBsaWNhdGlvbi9qc29uXCIuXG4gIGlmIChtaW1lVHlwZS5zdWJ0eXBlLmVuZHNXaXRoKCcranNvbicpKSB7XG4gICAgcmV0dXJuICdhcHBsaWNhdGlvbi9qc29uJ1xuICB9XG5cbiAgLy8gNC4gSWYgbWltZVR5cGUgaXMgYW4gWE1MIE1JTUUgdHlwZSwgdGhlbiByZXR1cm4gXCJhcHBsaWNhdGlvbi94bWxcIi5cbiAgaWYgKG1pbWVUeXBlLnN1YnR5cGUuZW5kc1dpdGgoJyt4bWwnKSkge1xuICAgIHJldHVybiAnYXBwbGljYXRpb24veG1sJ1xuICB9XG5cbiAgLy8gNS4gSWYgbWltZVR5cGUgaXMgc3VwcG9ydGVkIGJ5IHRoZSB1c2VyIGFnZW50LCB0aGVuIHJldHVybiBtaW1lVHlwZeKAmXMgZXNzZW5jZS5cbiAgLy8gVGVjaG5pY2FsbHksIG5vZGUgZG9lc24ndCBzdXBwb3J0IGFueSBtaW1ldHlwZXMuXG5cbiAgLy8gNi4gUmV0dXJuIHRoZSBlbXB0eSBzdHJpbmcuXG4gIHJldHVybiAnJ1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZGF0YVVSTFByb2Nlc3NvcixcbiAgVVJMU2VyaWFsaXplcixcbiAgY29sbGVjdEFTZXF1ZW5jZU9mQ29kZVBvaW50cyxcbiAgY29sbGVjdEFTZXF1ZW5jZU9mQ29kZVBvaW50c0Zhc3QsXG4gIHN0cmluZ1BlcmNlbnREZWNvZGUsXG4gIHBhcnNlTUlNRVR5cGUsXG4gIGNvbGxlY3RBbkhUVFBRdW90ZWRTdHJpbmcsXG4gIHNlcmlhbGl6ZUFNaW1lVHlwZSxcbiAgcmVtb3ZlQ2hhcnMsXG4gIHJlbW92ZUhUVFBXaGl0ZXNwYWNlLFxuICBtaW5pbWl6ZVN1cHBvcnRlZE1pbWVUeXBlLFxuICBIVFRQX1RPS0VOX0NPREVQT0lOVFMsXG4gIGlzb21vcnBoaWNEZWNvZGVcbn1cbiJdLCJuYW1lcyI6WyJhc3NlcnQiLCJyZXF1aXJlIiwiZW5jb2RlciIsIlRleHRFbmNvZGVyIiwiSFRUUF9UT0tFTl9DT0RFUE9JTlRTIiwiSFRUUF9XSElURVNQQUNFX1JFR0VYIiwiQVNDSUlfV0hJVEVTUEFDRV9SRVBMQUNFX1JFR0VYIiwiSFRUUF9RVU9URURfU1RSSU5HX1RPS0VOUyIsImRhdGFVUkxQcm9jZXNzb3IiLCJkYXRhVVJMIiwicHJvdG9jb2wiLCJpbnB1dCIsIlVSTFNlcmlhbGl6ZXIiLCJzbGljZSIsInBvc2l0aW9uIiwibWltZVR5cGUiLCJjb2xsZWN0QVNlcXVlbmNlT2ZDb2RlUG9pbnRzRmFzdCIsIm1pbWVUeXBlTGVuZ3RoIiwibGVuZ3RoIiwicmVtb3ZlQVNDSUlXaGl0ZXNwYWNlIiwiZW5jb2RlZEJvZHkiLCJib2R5Iiwic3RyaW5nUGVyY2VudERlY29kZSIsInRlc3QiLCJzdHJpbmdCb2R5IiwiaXNvbW9ycGhpY0RlY29kZSIsImZvcmdpdmluZ0Jhc2U2NCIsInJlcGxhY2UiLCJzdGFydHNXaXRoIiwibWltZVR5cGVSZWNvcmQiLCJwYXJzZU1JTUVUeXBlIiwidXJsIiwiZXhjbHVkZUZyYWdtZW50IiwiaHJlZiIsImhhc2hMZW5ndGgiLCJoYXNoIiwic2VyaWFsaXplZCIsInN1YnN0cmluZyIsImVuZHNXaXRoIiwiY29sbGVjdEFTZXF1ZW5jZU9mQ29kZVBvaW50cyIsImNvbmRpdGlvbiIsInJlc3VsdCIsImNoYXIiLCJpZHgiLCJpbmRleE9mIiwic3RhcnQiLCJieXRlcyIsImVuY29kZSIsInBlcmNlbnREZWNvZGUiLCJpc0hleENoYXJCeXRlIiwiYnl0ZSIsImhleEJ5dGVUb051bWJlciIsIm91dHB1dCIsIlVpbnQ4QXJyYXkiLCJqIiwiaSIsInN1YmFycmF5IiwicmVtb3ZlSFRUUFdoaXRlc3BhY2UiLCJ0eXBlIiwic3VidHlwZSIsInR5cGVMb3dlcmNhc2UiLCJ0b0xvd2VyQ2FzZSIsInN1YnR5cGVMb3dlcmNhc2UiLCJwYXJhbWV0ZXJzIiwiTWFwIiwiZXNzZW5jZSIsInBhcmFtZXRlck5hbWUiLCJwYXJhbWV0ZXJWYWx1ZSIsImNvbGxlY3RBbkhUVFBRdW90ZWRTdHJpbmciLCJoYXMiLCJzZXQiLCJkYXRhIiwiZGF0YUxlbmd0aCIsImNoYXJDb2RlQXQiLCJidWZmZXIiLCJCdWZmZXIiLCJmcm9tIiwiYnl0ZU9mZnNldCIsImJ5dGVMZW5ndGgiLCJleHRyYWN0VmFsdWUiLCJwb3NpdGlvblN0YXJ0IiwidmFsdWUiLCJxdW90ZU9yQmFja3NsYXNoIiwic2VyaWFsaXplQU1pbWVUeXBlIiwic2VyaWFsaXphdGlvbiIsIm5hbWUiLCJlbnRyaWVzIiwiaXNIVFRQV2hpdGVTcGFjZSIsInN0ciIsImxlYWRpbmciLCJ0cmFpbGluZyIsInJlbW92ZUNoYXJzIiwiaXNBU0NJSVdoaXRlc3BhY2UiLCJwcmVkaWNhdGUiLCJsZWFkIiwidHJhaWwiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJhcHBseSIsImFkZGl0aW9uIiwibWluaW1pemVTdXBwb3J0ZWRNaW1lVHlwZSIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/fetch/data-url.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/fetch/dispatcher-weakref.js":
/*!*****************************************************************!*\
  !*** ./node_modules/undici/lib/web/fetch/dispatcher-weakref.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { kConnected, kSize } = __webpack_require__(/*! ../../core/symbols */ \"(ssr)/./node_modules/undici/lib/core/symbols.js\");\nclass CompatWeakRef {\n    constructor(value){\n        this.value = value;\n    }\n    deref() {\n        return this.value[kConnected] === 0 && this.value[kSize] === 0 ? undefined : this.value;\n    }\n}\nclass CompatFinalizer {\n    constructor(finalizer){\n        this.finalizer = finalizer;\n    }\n    register(dispatcher, key) {\n        if (dispatcher.on) {\n            dispatcher.on(\"disconnect\", ()=>{\n                if (dispatcher[kConnected] === 0 && dispatcher[kSize] === 0) {\n                    this.finalizer(key);\n                }\n            });\n        }\n    }\n    unregister(key) {}\n}\nmodule.exports = function() {\n    // FIXME: remove workaround when the Node bug is backported to v18\n    // https://github.com/nodejs/node/issues/49344#issuecomment-1741776308\n    if (process.env.NODE_V8_COVERAGE && process.version.startsWith(\"v18\")) {\n        process._rawDebug(\"Using compatibility WeakRef and FinalizationRegistry\");\n        return {\n            WeakRef: CompatWeakRef,\n            FinalizationRegistry: CompatFinalizer\n        };\n    }\n    return {\n        WeakRef,\n        FinalizationRegistry\n    };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZmV0Y2gvZGlzcGF0Y2hlci13ZWFrcmVmLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTSxFQUFFQSxVQUFVLEVBQUVDLEtBQUFBLEVBQU8sR0FBR0MsbUJBQU9BLENBQUM7QUFFdEMsTUFBTUM7SUFDSkMsWUFBYUMsS0FBSyxDQUFFO1FBQ2xCLElBQUksQ0FBQ0EsS0FBSyxHQUFHQTtJQUNmO0lBRUFDLFFBQVM7UUFDUCxPQUFPLElBQUksQ0FBQ0QsS0FBSyxDQUFDTCxXQUFXLEtBQUssS0FBSyxJQUFJLENBQUNLLEtBQUssQ0FBQ0osTUFBTSxLQUFLLElBQ3pETSxZQUNBLElBQUksQ0FBQ0YsS0FBSztJQUNoQjtBQUNGO0FBRUEsTUFBTUc7SUFDSkosWUFBYUssU0FBUyxDQUFFO1FBQ3RCLElBQUksQ0FBQ0EsU0FBUyxHQUFHQTtJQUNuQjtJQUVBQyxTQUFVQyxVQUFVLEVBQUVDLEdBQUcsRUFBRTtRQUN6QixJQUFJRCxXQUFXRSxFQUFFLEVBQUU7WUFDakJGLFdBQVdFLEVBQUUsQ0FBQyxjQUFjO2dCQUMxQixJQUFJRixVQUFVLENBQUNYLFdBQVcsS0FBSyxLQUFLVyxVQUFVLENBQUNWLE1BQU0sS0FBSyxHQUFHO29CQUMzRCxJQUFJLENBQUNRLFNBQVMsQ0FBQ0c7Z0JBQ2pCO1lBQ0Y7UUFDRjtJQUNGO0lBRUFFLFdBQVlGLEdBQUcsRUFBRSxDQUFDO0FBQ3BCO0FBRUFHLE9BQU9DLE9BQU8sR0FBRztJQUNmO0lBQ0E7SUFDQSxJQUFJQyxRQUFRQyxHQUFHLENBQUNDLGdCQUFnQixJQUFJRixRQUFRRyxPQUFPLENBQUNDLFVBQVUsQ0FBQyxRQUFRO1FBQ3JFSixRQUFRSyxTQUFTLENBQUM7UUFDbEIsT0FBTztZQUNMQyxTQUFTcEI7WUFDVHFCLHNCQUFzQmhCO1FBQ3hCO0lBQ0Y7SUFDQSxPQUFPO1FBQUVlO1FBQVNDO0lBQXFCO0FBQ3pDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbW9ja3VwZmxvdy8uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL3dlYi9mZXRjaC9kaXNwYXRjaGVyLXdlYWtyZWYuanM/ZWI1ZCIsIndlYnBhY2s6Ly9tb2NrdXBmbG93Ly4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvd2ViL2ZldGNoL2Rpc3BhdGNoZXItd2Vha3JlZi5qcz9lYjVkKiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyBrQ29ubmVjdGVkLCBrU2l6ZSB9ID0gcmVxdWlyZSgnLi4vLi4vY29yZS9zeW1ib2xzJylcblxuY2xhc3MgQ29tcGF0V2Vha1JlZiB7XG4gIGNvbnN0cnVjdG9yICh2YWx1ZSkge1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZVxuICB9XG5cbiAgZGVyZWYgKCkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlW2tDb25uZWN0ZWRdID09PSAwICYmIHRoaXMudmFsdWVba1NpemVdID09PSAwXG4gICAgICA/IHVuZGVmaW5lZFxuICAgICAgOiB0aGlzLnZhbHVlXG4gIH1cbn1cblxuY2xhc3MgQ29tcGF0RmluYWxpemVyIHtcbiAgY29uc3RydWN0b3IgKGZpbmFsaXplcikge1xuICAgIHRoaXMuZmluYWxpemVyID0gZmluYWxpemVyXG4gIH1cblxuICByZWdpc3RlciAoZGlzcGF0Y2hlciwga2V5KSB7XG4gICAgaWYgKGRpc3BhdGNoZXIub24pIHtcbiAgICAgIGRpc3BhdGNoZXIub24oJ2Rpc2Nvbm5lY3QnLCAoKSA9PiB7XG4gICAgICAgIGlmIChkaXNwYXRjaGVyW2tDb25uZWN0ZWRdID09PSAwICYmIGRpc3BhdGNoZXJba1NpemVdID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5maW5hbGl6ZXIoa2V5KVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIHVucmVnaXN0ZXIgKGtleSkge31cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIEZJWE1FOiByZW1vdmUgd29ya2Fyb3VuZCB3aGVuIHRoZSBOb2RlIGJ1ZyBpcyBiYWNrcG9ydGVkIHRvIHYxOFxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvaXNzdWVzLzQ5MzQ0I2lzc3VlY29tbWVudC0xNzQxNzc2MzA4XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX1Y4X0NPVkVSQUdFICYmIHByb2Nlc3MudmVyc2lvbi5zdGFydHNXaXRoKCd2MTgnKSkge1xuICAgIHByb2Nlc3MuX3Jhd0RlYnVnKCdVc2luZyBjb21wYXRpYmlsaXR5IFdlYWtSZWYgYW5kIEZpbmFsaXphdGlvblJlZ2lzdHJ5JylcbiAgICByZXR1cm4ge1xuICAgICAgV2Vha1JlZjogQ29tcGF0V2Vha1JlZixcbiAgICAgIEZpbmFsaXphdGlvblJlZ2lzdHJ5OiBDb21wYXRGaW5hbGl6ZXJcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHsgV2Vha1JlZiwgRmluYWxpemF0aW9uUmVnaXN0cnkgfVxufVxuIl0sIm5hbWVzIjpbImtDb25uZWN0ZWQiLCJrU2l6ZSIsInJlcXVpcmUiLCJDb21wYXRXZWFrUmVmIiwiY29uc3RydWN0b3IiLCJ2YWx1ZSIsImRlcmVmIiwidW5kZWZpbmVkIiwiQ29tcGF0RmluYWxpemVyIiwiZmluYWxpemVyIiwicmVnaXN0ZXIiLCJkaXNwYXRjaGVyIiwia2V5Iiwib24iLCJ1bnJlZ2lzdGVyIiwibW9kdWxlIiwiZXhwb3J0cyIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX1Y4X0NPVkVSQUdFIiwidmVyc2lvbiIsInN0YXJ0c1dpdGgiLCJfcmF3RGVidWciLCJXZWFrUmVmIiwiRmluYWxpemF0aW9uUmVnaXN0cnkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/fetch/dispatcher-weakref.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/fetch/file.js":
/*!***************************************************!*\
  !*** ./node_modules/undici/lib/web/fetch/file.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { Blob, File } = __webpack_require__(/*! node:buffer */ \"node:buffer\");\nconst { kState } = __webpack_require__(/*! ./symbols */ \"(ssr)/./node_modules/undici/lib/web/fetch/symbols.js\");\nconst { webidl } = __webpack_require__(/*! ./webidl */ \"(ssr)/./node_modules/undici/lib/web/fetch/webidl.js\");\n// TODO(@KhafraDev): remove\nclass FileLike {\n    constructor(blobLike, fileName, options = {}){\n        // TODO: argument idl type check\n        // The File constructor is invoked with two or three parameters, depending\n        // on whether the optional dictionary parameter is used. When the File()\n        // constructor is invoked, user agents must run the following steps:\n        // 1. Let bytes be the result of processing blob parts given fileBits and\n        // options.\n        // 2. Let n be the fileName argument to the constructor.\n        const n = fileName;\n        // 3. Process FilePropertyBag dictionary argument by running the following\n        // substeps:\n        //    1. If the type member is provided and is not the empty string, let t\n        //    be set to the type dictionary member. If t contains any characters\n        //    outside the range U+0020 to U+007E, then set t to the empty string\n        //    and return from these substeps.\n        //    TODO\n        const t = options.type;\n        //    2. Convert every character in t to ASCII lowercase.\n        //    TODO\n        //    3. If the lastModified member is provided, let d be set to the\n        //    lastModified dictionary member. If it is not provided, set d to the\n        //    current date and time represented as the number of milliseconds since\n        //    the Unix Epoch (which is the equivalent of Date.now() [ECMA-262]).\n        const d = options.lastModified ?? Date.now();\n        // 4. Return a new File object F such that:\n        // F refers to the bytes byte sequence.\n        // F.size is set to the number of total bytes in bytes.\n        // F.name is set to n.\n        // F.type is set to t.\n        // F.lastModified is set to d.\n        this[kState] = {\n            blobLike,\n            name: n,\n            type: t,\n            lastModified: d\n        };\n    }\n    stream(...args) {\n        webidl.brandCheck(this, FileLike);\n        return this[kState].blobLike.stream(...args);\n    }\n    arrayBuffer(...args) {\n        webidl.brandCheck(this, FileLike);\n        return this[kState].blobLike.arrayBuffer(...args);\n    }\n    slice(...args) {\n        webidl.brandCheck(this, FileLike);\n        return this[kState].blobLike.slice(...args);\n    }\n    text(...args) {\n        webidl.brandCheck(this, FileLike);\n        return this[kState].blobLike.text(...args);\n    }\n    get size() {\n        webidl.brandCheck(this, FileLike);\n        return this[kState].blobLike.size;\n    }\n    get type() {\n        webidl.brandCheck(this, FileLike);\n        return this[kState].blobLike.type;\n    }\n    get name() {\n        webidl.brandCheck(this, FileLike);\n        return this[kState].name;\n    }\n    get lastModified() {\n        webidl.brandCheck(this, FileLike);\n        return this[kState].lastModified;\n    }\n    get [Symbol.toStringTag]() {\n        return \"File\";\n    }\n}\nwebidl.converters.Blob = webidl.interfaceConverter(Blob);\n// If this function is moved to ./util.js, some tools (such as\n// rollup) will warn about circular dependencies. See:\n// https://github.com/nodejs/undici/issues/1629\nfunction isFileLike(object) {\n    return object instanceof File || object && (typeof object.stream === \"function\" || typeof object.arrayBuffer === \"function\") && object[Symbol.toStringTag] === \"File\";\n}\nmodule.exports = {\n    FileLike,\n    isFileLike\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZmV0Y2gvZmlsZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU0sRUFBRUEsSUFBSSxFQUFFQyxJQUFBQSxFQUFNLEdBQUdDLG1CQUFPQSxDQUFDO0FBQy9CLE1BQU0sRUFBRUMsTUFBQUEsRUFBUSxHQUFHRCxtQkFBT0EsQ0FBQztBQUMzQixNQUFNLEVBQUVFLE1BQUFBLEVBQVEsR0FBR0YsbUJBQU9BLENBQUM7QUFFM0I7QUFDQSxNQUFNRztJQUNKQyxZQUFhQyxRQUFRLEVBQUVDLFFBQVEsRUFBRUMsVUFBVSxDQUFDLENBQUMsQ0FBRTtRQUM3QztRQUVBO1FBQ0E7UUFDQTtRQUVBO1FBQ0E7UUFFQTtRQUNBLE1BQU1DLElBQUlGO1FBRVY7UUFDQTtRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQSxNQUFNRyxJQUFJRixRQUFRRyxJQUFJO1FBRXRCO1FBQ0E7UUFFQTtRQUNBO1FBQ0E7UUFDQTtRQUNBLE1BQU1DLElBQUlKLFFBQVFLLFlBQVksSUFBSUMsS0FBS0MsR0FBRztRQUUxQztRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFFQSxJQUFJLENBQUNiLE9BQU8sR0FBRztZQUNiSTtZQUNBVSxNQUFNUDtZQUNORSxNQUFNRDtZQUNORyxjQUFjRDtRQUNoQjtJQUNGO0lBRUFLLE9BQVEsR0FBR0MsSUFBSSxFQUFFO1FBQ2ZmLE9BQU9nQixVQUFVLENBQUMsSUFBSSxFQUFFZjtRQUV4QixPQUFPLElBQUksQ0FBQ0YsT0FBTyxDQUFDSSxRQUFRLENBQUNXLE1BQU0sSUFBSUM7SUFDekM7SUFFQUUsWUFBYSxHQUFHRixJQUFJLEVBQUU7UUFDcEJmLE9BQU9nQixVQUFVLENBQUMsSUFBSSxFQUFFZjtRQUV4QixPQUFPLElBQUksQ0FBQ0YsT0FBTyxDQUFDSSxRQUFRLENBQUNjLFdBQVcsSUFBSUY7SUFDOUM7SUFFQUcsTUFBTyxHQUFHSCxJQUFJLEVBQUU7UUFDZGYsT0FBT2dCLFVBQVUsQ0FBQyxJQUFJLEVBQUVmO1FBRXhCLE9BQU8sSUFBSSxDQUFDRixPQUFPLENBQUNJLFFBQVEsQ0FBQ2UsS0FBSyxJQUFJSDtJQUN4QztJQUVBSSxLQUFNLEdBQUdKLElBQUksRUFBRTtRQUNiZixPQUFPZ0IsVUFBVSxDQUFDLElBQUksRUFBRWY7UUFFeEIsT0FBTyxJQUFJLENBQUNGLE9BQU8sQ0FBQ0ksUUFBUSxDQUFDZ0IsSUFBSSxJQUFJSjtJQUN2QztJQUVBLElBQUlLLE9BQVE7UUFDVnBCLE9BQU9nQixVQUFVLENBQUMsSUFBSSxFQUFFZjtRQUV4QixPQUFPLElBQUksQ0FBQ0YsT0FBTyxDQUFDSSxRQUFRLENBQUNpQixJQUFJO0lBQ25DO0lBRUEsSUFBSVosT0FBUTtRQUNWUixPQUFPZ0IsVUFBVSxDQUFDLElBQUksRUFBRWY7UUFFeEIsT0FBTyxJQUFJLENBQUNGLE9BQU8sQ0FBQ0ksUUFBUSxDQUFDSyxJQUFJO0lBQ25DO0lBRUEsSUFBSUssT0FBUTtRQUNWYixPQUFPZ0IsVUFBVSxDQUFDLElBQUksRUFBRWY7UUFFeEIsT0FBTyxJQUFJLENBQUNGLE9BQU8sQ0FBQ2MsSUFBSTtJQUMxQjtJQUVBLElBQUlILGVBQWdCO1FBQ2xCVixPQUFPZ0IsVUFBVSxDQUFDLElBQUksRUFBRWY7UUFFeEIsT0FBTyxJQUFJLENBQUNGLE9BQU8sQ0FBQ1csWUFBWTtJQUNsQztJQUVBLEtBQUtXLE9BQU9DLFdBQVcsSUFBSztRQUMxQixPQUFPO0lBQ1Q7QUFDRjtBQUVBdEIsT0FBT3VCLFVBQVUsQ0FBQzNCLElBQUksR0FBR0ksT0FBT3dCLGtCQUFrQixDQUFDNUI7QUFFbkQ7QUFDQTtBQUNBO0FBQ0EsU0FBUzZCLFdBQVlDLE1BQU07SUFDekIsT0FDR0Esa0JBQWtCN0IsUUFFakI2QixVQUNDLFFBQU9BLE9BQU9aLE1BQU0sS0FBSyxjQUMxQixPQUFPWSxPQUFPVCxXQUFXLEtBQUssZUFDOUJTLE1BQU0sQ0FBQ0wsT0FBT0MsV0FBVyxDQUFDLEtBQUs7QUFHckM7QUFFQUssT0FBT0MsT0FBTyxHQUFHO0lBQUUzQjtJQUFVd0I7QUFBVyIsInNvdXJjZXMiOlsid2VicGFjazovL21vY2t1cGZsb3cvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZmV0Y2gvZmlsZS5qcz9mN2MyIiwid2VicGFjazovL21vY2t1cGZsb3cvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZmV0Y2gvZmlsZS5qcz9mN2MyKiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyBCbG9iLCBGaWxlIH0gPSByZXF1aXJlKCdub2RlOmJ1ZmZlcicpXG5jb25zdCB7IGtTdGF0ZSB9ID0gcmVxdWlyZSgnLi9zeW1ib2xzJylcbmNvbnN0IHsgd2ViaWRsIH0gPSByZXF1aXJlKCcuL3dlYmlkbCcpXG5cbi8vIFRPRE8oQEtoYWZyYURldik6IHJlbW92ZVxuY2xhc3MgRmlsZUxpa2Uge1xuICBjb25zdHJ1Y3RvciAoYmxvYkxpa2UsIGZpbGVOYW1lLCBvcHRpb25zID0ge30pIHtcbiAgICAvLyBUT0RPOiBhcmd1bWVudCBpZGwgdHlwZSBjaGVja1xuXG4gICAgLy8gVGhlIEZpbGUgY29uc3RydWN0b3IgaXMgaW52b2tlZCB3aXRoIHR3byBvciB0aHJlZSBwYXJhbWV0ZXJzLCBkZXBlbmRpbmdcbiAgICAvLyBvbiB3aGV0aGVyIHRoZSBvcHRpb25hbCBkaWN0aW9uYXJ5IHBhcmFtZXRlciBpcyB1c2VkLiBXaGVuIHRoZSBGaWxlKClcbiAgICAvLyBjb25zdHJ1Y3RvciBpcyBpbnZva2VkLCB1c2VyIGFnZW50cyBtdXN0IHJ1biB0aGUgZm9sbG93aW5nIHN0ZXBzOlxuXG4gICAgLy8gMS4gTGV0IGJ5dGVzIGJlIHRoZSByZXN1bHQgb2YgcHJvY2Vzc2luZyBibG9iIHBhcnRzIGdpdmVuIGZpbGVCaXRzIGFuZFxuICAgIC8vIG9wdGlvbnMuXG5cbiAgICAvLyAyLiBMZXQgbiBiZSB0aGUgZmlsZU5hbWUgYXJndW1lbnQgdG8gdGhlIGNvbnN0cnVjdG9yLlxuICAgIGNvbnN0IG4gPSBmaWxlTmFtZVxuXG4gICAgLy8gMy4gUHJvY2VzcyBGaWxlUHJvcGVydHlCYWcgZGljdGlvbmFyeSBhcmd1bWVudCBieSBydW5uaW5nIHRoZSBmb2xsb3dpbmdcbiAgICAvLyBzdWJzdGVwczpcblxuICAgIC8vICAgIDEuIElmIHRoZSB0eXBlIG1lbWJlciBpcyBwcm92aWRlZCBhbmQgaXMgbm90IHRoZSBlbXB0eSBzdHJpbmcsIGxldCB0XG4gICAgLy8gICAgYmUgc2V0IHRvIHRoZSB0eXBlIGRpY3Rpb25hcnkgbWVtYmVyLiBJZiB0IGNvbnRhaW5zIGFueSBjaGFyYWN0ZXJzXG4gICAgLy8gICAgb3V0c2lkZSB0aGUgcmFuZ2UgVSswMDIwIHRvIFUrMDA3RSwgdGhlbiBzZXQgdCB0byB0aGUgZW1wdHkgc3RyaW5nXG4gICAgLy8gICAgYW5kIHJldHVybiBmcm9tIHRoZXNlIHN1YnN0ZXBzLlxuICAgIC8vICAgIFRPRE9cbiAgICBjb25zdCB0ID0gb3B0aW9ucy50eXBlXG5cbiAgICAvLyAgICAyLiBDb252ZXJ0IGV2ZXJ5IGNoYXJhY3RlciBpbiB0IHRvIEFTQ0lJIGxvd2VyY2FzZS5cbiAgICAvLyAgICBUT0RPXG5cbiAgICAvLyAgICAzLiBJZiB0aGUgbGFzdE1vZGlmaWVkIG1lbWJlciBpcyBwcm92aWRlZCwgbGV0IGQgYmUgc2V0IHRvIHRoZVxuICAgIC8vICAgIGxhc3RNb2RpZmllZCBkaWN0aW9uYXJ5IG1lbWJlci4gSWYgaXQgaXMgbm90IHByb3ZpZGVkLCBzZXQgZCB0byB0aGVcbiAgICAvLyAgICBjdXJyZW50IGRhdGUgYW5kIHRpbWUgcmVwcmVzZW50ZWQgYXMgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgc2luY2VcbiAgICAvLyAgICB0aGUgVW5peCBFcG9jaCAod2hpY2ggaXMgdGhlIGVxdWl2YWxlbnQgb2YgRGF0ZS5ub3coKSBbRUNNQS0yNjJdKS5cbiAgICBjb25zdCBkID0gb3B0aW9ucy5sYXN0TW9kaWZpZWQgPz8gRGF0ZS5ub3coKVxuXG4gICAgLy8gNC4gUmV0dXJuIGEgbmV3IEZpbGUgb2JqZWN0IEYgc3VjaCB0aGF0OlxuICAgIC8vIEYgcmVmZXJzIHRvIHRoZSBieXRlcyBieXRlIHNlcXVlbmNlLlxuICAgIC8vIEYuc2l6ZSBpcyBzZXQgdG8gdGhlIG51bWJlciBvZiB0b3RhbCBieXRlcyBpbiBieXRlcy5cbiAgICAvLyBGLm5hbWUgaXMgc2V0IHRvIG4uXG4gICAgLy8gRi50eXBlIGlzIHNldCB0byB0LlxuICAgIC8vIEYubGFzdE1vZGlmaWVkIGlzIHNldCB0byBkLlxuXG4gICAgdGhpc1trU3RhdGVdID0ge1xuICAgICAgYmxvYkxpa2UsXG4gICAgICBuYW1lOiBuLFxuICAgICAgdHlwZTogdCxcbiAgICAgIGxhc3RNb2RpZmllZDogZFxuICAgIH1cbiAgfVxuXG4gIHN0cmVhbSAoLi4uYXJncykge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEZpbGVMaWtlKVxuXG4gICAgcmV0dXJuIHRoaXNba1N0YXRlXS5ibG9iTGlrZS5zdHJlYW0oLi4uYXJncylcbiAgfVxuXG4gIGFycmF5QnVmZmVyICguLi5hcmdzKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRmlsZUxpa2UpXG5cbiAgICByZXR1cm4gdGhpc1trU3RhdGVdLmJsb2JMaWtlLmFycmF5QnVmZmVyKC4uLmFyZ3MpXG4gIH1cblxuICBzbGljZSAoLi4uYXJncykge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEZpbGVMaWtlKVxuXG4gICAgcmV0dXJuIHRoaXNba1N0YXRlXS5ibG9iTGlrZS5zbGljZSguLi5hcmdzKVxuICB9XG5cbiAgdGV4dCAoLi4uYXJncykge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEZpbGVMaWtlKVxuXG4gICAgcmV0dXJuIHRoaXNba1N0YXRlXS5ibG9iTGlrZS50ZXh0KC4uLmFyZ3MpXG4gIH1cblxuICBnZXQgc2l6ZSAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRmlsZUxpa2UpXG5cbiAgICByZXR1cm4gdGhpc1trU3RhdGVdLmJsb2JMaWtlLnNpemVcbiAgfVxuXG4gIGdldCB0eXBlICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBGaWxlTGlrZSlcblxuICAgIHJldHVybiB0aGlzW2tTdGF0ZV0uYmxvYkxpa2UudHlwZVxuICB9XG5cbiAgZ2V0IG5hbWUgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEZpbGVMaWtlKVxuXG4gICAgcmV0dXJuIHRoaXNba1N0YXRlXS5uYW1lXG4gIH1cblxuICBnZXQgbGFzdE1vZGlmaWVkICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBGaWxlTGlrZSlcblxuICAgIHJldHVybiB0aGlzW2tTdGF0ZV0ubGFzdE1vZGlmaWVkXG4gIH1cblxuICBnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10gKCkge1xuICAgIHJldHVybiAnRmlsZSdcbiAgfVxufVxuXG53ZWJpZGwuY29udmVydGVycy5CbG9iID0gd2ViaWRsLmludGVyZmFjZUNvbnZlcnRlcihCbG9iKVxuXG4vLyBJZiB0aGlzIGZ1bmN0aW9uIGlzIG1vdmVkIHRvIC4vdXRpbC5qcywgc29tZSB0b29scyAoc3VjaCBhc1xuLy8gcm9sbHVwKSB3aWxsIHdhcm4gYWJvdXQgY2lyY3VsYXIgZGVwZW5kZW5jaWVzLiBTZWU6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL3VuZGljaS9pc3N1ZXMvMTYyOVxuZnVuY3Rpb24gaXNGaWxlTGlrZSAob2JqZWN0KSB7XG4gIHJldHVybiAoXG4gICAgKG9iamVjdCBpbnN0YW5jZW9mIEZpbGUpIHx8XG4gICAgKFxuICAgICAgb2JqZWN0ICYmXG4gICAgICAodHlwZW9mIG9iamVjdC5zdHJlYW0gPT09ICdmdW5jdGlvbicgfHxcbiAgICAgIHR5cGVvZiBvYmplY3QuYXJyYXlCdWZmZXIgPT09ICdmdW5jdGlvbicpICYmXG4gICAgICBvYmplY3RbU3ltYm9sLnRvU3RyaW5nVGFnXSA9PT0gJ0ZpbGUnXG4gICAgKVxuICApXG59XG5cbm1vZHVsZS5leHBvcnRzID0geyBGaWxlTGlrZSwgaXNGaWxlTGlrZSB9XG4iXSwibmFtZXMiOlsiQmxvYiIsIkZpbGUiLCJyZXF1aXJlIiwia1N0YXRlIiwid2ViaWRsIiwiRmlsZUxpa2UiLCJjb25zdHJ1Y3RvciIsImJsb2JMaWtlIiwiZmlsZU5hbWUiLCJvcHRpb25zIiwibiIsInQiLCJ0eXBlIiwiZCIsImxhc3RNb2RpZmllZCIsIkRhdGUiLCJub3ciLCJuYW1lIiwic3RyZWFtIiwiYXJncyIsImJyYW5kQ2hlY2siLCJhcnJheUJ1ZmZlciIsInNsaWNlIiwidGV4dCIsInNpemUiLCJTeW1ib2wiLCJ0b1N0cmluZ1RhZyIsImNvbnZlcnRlcnMiLCJpbnRlcmZhY2VDb252ZXJ0ZXIiLCJpc0ZpbGVMaWtlIiwib2JqZWN0IiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/fetch/file.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/fetch/formdata-parser.js":
/*!**************************************************************!*\
  !*** ./node_modules/undici/lib/web/fetch/formdata-parser.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { isUSVString, bufferToLowerCasedHeaderName } = __webpack_require__(/*! ../../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\");\nconst { utf8DecodeBytes } = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/undici/lib/web/fetch/util.js\");\nconst { HTTP_TOKEN_CODEPOINTS, isomorphicDecode } = __webpack_require__(/*! ./data-url */ \"(ssr)/./node_modules/undici/lib/web/fetch/data-url.js\");\nconst { isFileLike } = __webpack_require__(/*! ./file */ \"(ssr)/./node_modules/undici/lib/web/fetch/file.js\");\nconst { makeEntry } = __webpack_require__(/*! ./formdata */ \"(ssr)/./node_modules/undici/lib/web/fetch/formdata.js\");\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\");\nconst { File: NodeFile } = __webpack_require__(/*! node:buffer */ \"node:buffer\");\nconst File = globalThis.File ?? NodeFile;\nconst formDataNameBuffer = Buffer.from('form-data; name=\"');\nconst filenameBuffer = Buffer.from(\"; filename\");\nconst dd = Buffer.from(\"--\");\nconst ddcrlf = Buffer.from(\"--\\r\\n\");\n/**\n * @param {string} chars\n */ function isAsciiString(chars) {\n    for(let i = 0; i < chars.length; ++i){\n        if ((chars.charCodeAt(i) & ~0x7F) !== 0) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * @see https://andreubotella.github.io/multipart-form-data/#multipart-form-data-boundary\n * @param {string} boundary\n */ function validateBoundary(boundary) {\n    const length = boundary.length;\n    // - its length is greater or equal to 27 and lesser or equal to 70, and\n    if (length < 27 || length > 70) {\n        return false;\n    }\n    // - it is composed by bytes in the ranges 0x30 to 0x39, 0x41 to 0x5A, or\n    //   0x61 to 0x7A, inclusive (ASCII alphanumeric), or which are 0x27 ('),\n    //   0x2D (-) or 0x5F (_).\n    for(let i = 0; i < length; ++i){\n        const cp = boundary.charCodeAt(i);\n        if (!(cp >= 0x30 && cp <= 0x39 || cp >= 0x41 && cp <= 0x5a || cp >= 0x61 && cp <= 0x7a || cp === 0x27 || cp === 0x2d || cp === 0x5f)) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * @see https://andreubotella.github.io/multipart-form-data/#multipart-form-data-parser\n * @param {Buffer} input\n * @param {ReturnType<import('./data-url')['parseMIMEType']>} mimeType\n */ function multipartFormDataParser(input, mimeType) {\n    // 1. Assert: mimeTypes essence is \"multipart/form-data\".\n    assert(mimeType !== \"failure\" && mimeType.essence === \"multipart/form-data\");\n    const boundaryString = mimeType.parameters.get(\"boundary\");\n    // 2. If mimeTypes parameters[\"boundary\"] does not exist, return failure.\n    //    Otherwise, let boundary be the result of UTF-8 decoding mimeTypes\n    //    parameters[\"boundary\"].\n    if (boundaryString === undefined) {\n        return \"failure\";\n    }\n    const boundary = Buffer.from(`--${boundaryString}`, \"utf8\");\n    // 3. Let entry list be an empty entry list.\n    const entryList = [];\n    // 4. Let position be a pointer to a byte in input, initially pointing at\n    //    the first byte.\n    const position = {\n        position: 0\n    };\n    // Note: undici addition, allow \\r\\n before the body.\n    if (input[0] === 0x0d && input[1] === 0x0a) {\n        position.position += 2;\n    }\n    // 5. While true:\n    while(true){\n        // 5.1. If position points to a sequence of bytes starting with 0x2D 0x2D\n        //      (`--`) followed by boundary, advance position by 2 + the length of\n        //      boundary. Otherwise, return failure.\n        // Note: boundary is padded with 2 dashes already, no need to add 2.\n        if (input.subarray(position.position, position.position + boundary.length).equals(boundary)) {\n            position.position += boundary.length;\n        } else {\n            return \"failure\";\n        }\n        // 5.2. If position points to the sequence of bytes 0x2D 0x2D 0x0D 0x0A\n        //      (`--` followed by CR LF) followed by the end of input, return entry list.\n        // Note: a body does NOT need to end with CRLF. It can end with --.\n        if (position.position === input.length - 2 && bufferStartsWith(input, dd, position) || position.position === input.length - 4 && bufferStartsWith(input, ddcrlf, position)) {\n            return entryList;\n        }\n        // 5.3. If position does not point to a sequence of bytes starting with 0x0D\n        //      0x0A (CR LF), return failure.\n        if (input[position.position] !== 0x0d || input[position.position + 1] !== 0x0a) {\n            return \"failure\";\n        }\n        // 5.4. Advance position by 2. (This skips past the newline.)\n        position.position += 2;\n        // 5.5. Let name, filename and contentType be the result of parsing\n        //      multipart/form-data headers on input and position, if the result\n        //      is not failure. Otherwise, return failure.\n        const result = parseMultipartFormDataHeaders(input, position);\n        if (result === \"failure\") {\n            return \"failure\";\n        }\n        let { name, filename, contentType, encoding } = result;\n        // 5.6. Advance position by 2. (This skips past the empty line that marks\n        //      the end of the headers.)\n        position.position += 2;\n        // 5.7. Let body be the empty byte sequence.\n        let body;\n        // 5.8. Body loop: While position is not past the end of input:\n        // TODO: the steps here are completely wrong\n        {\n            const boundaryIndex = input.indexOf(boundary.subarray(2), position.position);\n            if (boundaryIndex === -1) {\n                return \"failure\";\n            }\n            body = input.subarray(position.position, boundaryIndex - 4);\n            position.position += body.length;\n            // Note: position must be advanced by the body's length before being\n            // decoded, otherwise the parsing will fail.\n            if (encoding === \"base64\") {\n                body = Buffer.from(body.toString(), \"base64\");\n            }\n        }\n        // 5.9. If position does not point to a sequence of bytes starting with\n        //      0x0D 0x0A (CR LF), return failure. Otherwise, advance position by 2.\n        if (input[position.position] !== 0x0d || input[position.position + 1] !== 0x0a) {\n            return \"failure\";\n        } else {\n            position.position += 2;\n        }\n        // 5.10. If filename is not null:\n        let value;\n        if (filename !== null) {\n            // 5.10.1. If contentType is null, set contentType to \"text/plain\".\n            contentType ??= \"text/plain\";\n            // 5.10.2. If contentType is not an ASCII string, set contentType to the empty string.\n            // Note: `buffer.isAscii` can be used at zero-cost, but converting a string to a buffer is a high overhead.\n            // Content-Type is a relatively small string, so it is faster to use `String#charCodeAt`.\n            if (!isAsciiString(contentType)) {\n                contentType = \"\";\n            }\n            // 5.10.3. Let value be a new File object with name filename, type contentType, and body body.\n            value = new File([\n                body\n            ], filename, {\n                type: contentType\n            });\n        } else {\n            // 5.11. Otherwise:\n            // 5.11.1. Let value be the UTF-8 decoding without BOM of body.\n            value = utf8DecodeBytes(Buffer.from(body));\n        }\n        // 5.12. Assert: name is a scalar value string and value is either a scalar value string or a File object.\n        assert(isUSVString(name));\n        assert(typeof value === \"string\" && isUSVString(value) || isFileLike(value));\n        // 5.13. Create an entry with name and value, and append it to entry list.\n        entryList.push(makeEntry(name, value, filename));\n    }\n}\n/**\n * @see https://andreubotella.github.io/multipart-form-data/#parse-multipart-form-data-headers\n * @param {Buffer} input\n * @param {{ position: number }} position\n */ function parseMultipartFormDataHeaders(input, position) {\n    // 1. Let name, filename and contentType be null.\n    let name = null;\n    let filename = null;\n    let contentType = null;\n    let encoding = null;\n    // 2. While true:\n    while(true){\n        // 2.1. If position points to a sequence of bytes starting with 0x0D 0x0A (CR LF):\n        if (input[position.position] === 0x0d && input[position.position + 1] === 0x0a) {\n            // 2.1.1. If name is null, return failure.\n            if (name === null) {\n                return \"failure\";\n            }\n            // 2.1.2. Return name, filename and contentType.\n            return {\n                name,\n                filename,\n                contentType,\n                encoding\n            };\n        }\n        // 2.2. Let header name be the result of collecting a sequence of bytes that are\n        //      not 0x0A (LF), 0x0D (CR) or 0x3A (:), given position.\n        let headerName = collectASequenceOfBytes((char)=>char !== 0x0a && char !== 0x0d && char !== 0x3a, input, position);\n        // 2.3. Remove any HTTP tab or space bytes from the start or end of header name.\n        headerName = removeChars(headerName, true, true, (char)=>char === 0x9 || char === 0x20);\n        // 2.4. If header name does not match the field-name token production, return failure.\n        if (!HTTP_TOKEN_CODEPOINTS.test(headerName.toString())) {\n            return \"failure\";\n        }\n        // 2.5. If the byte at position is not 0x3A (:), return failure.\n        if (input[position.position] !== 0x3a) {\n            return \"failure\";\n        }\n        // 2.6. Advance position by 1.\n        position.position++;\n        // 2.7. Collect a sequence of bytes that are HTTP tab or space bytes given position.\n        //      (Do nothing with those bytes.)\n        collectASequenceOfBytes((char)=>char === 0x20 || char === 0x09, input, position);\n        // 2.8. Byte-lowercase header name and switch on the result:\n        switch(bufferToLowerCasedHeaderName(headerName)){\n            case \"content-disposition\":\n                {\n                    // 1. Set name and filename to null.\n                    name = filename = null;\n                    // 2. If position does not point to a sequence of bytes starting with\n                    //    `form-data; name=\"`, return failure.\n                    if (!bufferStartsWith(input, formDataNameBuffer, position)) {\n                        return \"failure\";\n                    }\n                    // 3. Advance position so it points at the byte after the next 0x22 (\")\n                    //    byte (the one in the sequence of bytes matched above).\n                    position.position += 17;\n                    // 4. Set name to the result of parsing a multipart/form-data name given\n                    //    input and position, if the result is not failure. Otherwise, return\n                    //    failure.\n                    name = parseMultipartFormDataName(input, position);\n                    if (name === null) {\n                        return \"failure\";\n                    }\n                    // 5. If position points to a sequence of bytes starting with `; filename=\"`:\n                    if (bufferStartsWith(input, filenameBuffer, position)) {\n                        // Note: undici also handles filename*\n                        let check = position.position + filenameBuffer.length;\n                        if (input[check] === 0x2a) {\n                            position.position += 1;\n                            check += 1;\n                        }\n                        if (input[check] !== 0x3d || input[check + 1] !== 0x22) {\n                            // =\"\n                            return \"failure\";\n                        }\n                        // 1. Advance position so it points at the byte after the next 0x22 (\") byte\n                        //    (the one in the sequence of bytes matched above).\n                        position.position += 12;\n                        // 2. Set filename to the result of parsing a multipart/form-data name given\n                        //    input and position, if the result is not failure. Otherwise, return failure.\n                        filename = parseMultipartFormDataName(input, position);\n                        if (filename === null) {\n                            return \"failure\";\n                        }\n                    }\n                    break;\n                }\n            case \"content-type\":\n                {\n                    // 1. Let header value be the result of collecting a sequence of bytes that are\n                    //    not 0x0A (LF) or 0x0D (CR), given position.\n                    let headerValue = collectASequenceOfBytes((char)=>char !== 0x0a && char !== 0x0d, input, position);\n                    // 2. Remove any HTTP tab or space bytes from the end of header value.\n                    headerValue = removeChars(headerValue, false, true, (char)=>char === 0x9 || char === 0x20);\n                    // 3. Set contentType to the isomorphic decoding of header value.\n                    contentType = isomorphicDecode(headerValue);\n                    break;\n                }\n            case \"content-transfer-encoding\":\n                {\n                    let headerValue = collectASequenceOfBytes((char)=>char !== 0x0a && char !== 0x0d, input, position);\n                    headerValue = removeChars(headerValue, false, true, (char)=>char === 0x9 || char === 0x20);\n                    encoding = isomorphicDecode(headerValue);\n                    break;\n                }\n            default:\n                {\n                    // Collect a sequence of bytes that are not 0x0A (LF) or 0x0D (CR), given position.\n                    // (Do nothing with those bytes.)\n                    collectASequenceOfBytes((char)=>char !== 0x0a && char !== 0x0d, input, position);\n                }\n        }\n        // 2.9. If position does not point to a sequence of bytes starting with 0x0D 0x0A\n        //      (CR LF), return failure. Otherwise, advance position by 2 (past the newline).\n        if (input[position.position] !== 0x0d && input[position.position + 1] !== 0x0a) {\n            return \"failure\";\n        } else {\n            position.position += 2;\n        }\n    }\n}\n/**\n * @see https://andreubotella.github.io/multipart-form-data/#parse-a-multipart-form-data-name\n * @param {Buffer} input\n * @param {{ position: number }} position\n */ function parseMultipartFormDataName(input, position) {\n    // 1. Assert: The byte at (position - 1) is 0x22 (\").\n    assert(input[position.position - 1] === 0x22);\n    // 2. Let name be the result of collecting a sequence of bytes that are not 0x0A (LF), 0x0D (CR) or 0x22 (\"), given position.\n    /** @type {string | Buffer} */ let name = collectASequenceOfBytes((char)=>char !== 0x0a && char !== 0x0d && char !== 0x22, input, position);\n    // 3. If the byte at position is not 0x22 (\"), return failure. Otherwise, advance position by 1.\n    if (input[position.position] !== 0x22) {\n        return null; // name could be 'failure'\n    } else {\n        position.position++;\n    }\n    // 4. Replace any occurrence of the following subsequences in name with the given byte:\n    // - `%0A`: 0x0A (LF)\n    // - `%0D`: 0x0D (CR)\n    // - `%22`: 0x22 (\")\n    name = new TextDecoder().decode(name).replace(/%0A/ig, \"\\n\").replace(/%0D/ig, \"\\r\").replace(/%22/g, '\"');\n    // 5. Return the UTF-8 decoding without BOM of name.\n    return name;\n}\n/**\n * @param {(char: number) => boolean} condition\n * @param {Buffer} input\n * @param {{ position: number }} position\n */ function collectASequenceOfBytes(condition, input, position) {\n    let start = position.position;\n    while(start < input.length && condition(input[start])){\n        ++start;\n    }\n    return input.subarray(position.position, position.position = start);\n}\n/**\n * @param {Buffer} buf\n * @param {boolean} leading\n * @param {boolean} trailing\n * @param {(charCode: number) => boolean} predicate\n * @returns {Buffer}\n */ function removeChars(buf, leading, trailing, predicate) {\n    let lead = 0;\n    let trail = buf.length - 1;\n    if (leading) {\n        while(lead < buf.length && predicate(buf[lead]))lead++;\n    }\n    if (trailing) {\n        while(trail > 0 && predicate(buf[trail]))trail--;\n    }\n    return lead === 0 && trail === buf.length - 1 ? buf : buf.subarray(lead, trail + 1);\n}\n/**\n * Checks if {@param buffer} starts with {@param start}\n * @param {Buffer} buffer\n * @param {Buffer} start\n * @param {{ position: number }} position\n */ function bufferStartsWith(buffer, start, position) {\n    if (buffer.length < start.length) {\n        return false;\n    }\n    for(let i = 0; i < start.length; i++){\n        if (start[i] !== buffer[position.position + i]) {\n            return false;\n        }\n    }\n    return true;\n}\nmodule.exports = {\n    multipartFormDataParser,\n    validateBoundary\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZmV0Y2gvZm9ybWRhdGEtcGFyc2VyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTSxFQUFFQSxXQUFXLEVBQUVDLDRCQUFBQSxFQUE4QixHQUFHQyxtQkFBT0EsQ0FBQztBQUM5RCxNQUFNLEVBQUVDLGVBQUFBLEVBQWlCLEdBQUdELG1CQUFPQSxDQUFDO0FBQ3BDLE1BQU0sRUFBRUUscUJBQXFCLEVBQUVDLGdCQUFBQSxFQUFrQixHQUFHSCxtQkFBT0EsQ0FBQztBQUM1RCxNQUFNLEVBQUVJLFVBQUFBLEVBQVksR0FBR0osbUJBQU9BLENBQUM7QUFDL0IsTUFBTSxFQUFFSyxTQUFBQSxFQUFXLEdBQUdMLG1CQUFPQSxDQUFDO0FBQzlCLE1BQU1NLFNBQVNOLG1CQUFPQSxDQUFDO0FBQ3ZCLE1BQU0sRUFBRU8sTUFBTUMsUUFBQUEsRUFBVSxHQUFHUixtQkFBT0EsQ0FBQztBQUVuQyxNQUFNTyxPQUFPRSxXQUFXRixJQUFJLElBQUlDO0FBRWhDLE1BQU1FLHFCQUFxQkMsT0FBT0MsSUFBSSxDQUFDO0FBQ3ZDLE1BQU1DLGlCQUFpQkYsT0FBT0MsSUFBSSxDQUFDO0FBQ25DLE1BQU1FLEtBQUtILE9BQU9DLElBQUksQ0FBQztBQUN2QixNQUFNRyxTQUFTSixPQUFPQyxJQUFJLENBQUM7QUFFM0I7O0NBRUEsR0FDQSxTQUFTSSxjQUFlQyxLQUFLO0lBQzNCLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJRCxNQUFNRSxNQUFNLEVBQUUsRUFBRUQsRUFBRztRQUNyQyxJQUFJLENBQUNELE1BQU1HLFVBQVUsQ0FBQ0YsS0FBSyxDQUFDLFVBQVUsR0FBRztZQUN2QyxPQUFPO1FBQ1Q7SUFDRjtJQUNBLE9BQU87QUFDVDtBQUVBOzs7Q0FHQSxHQUNBLFNBQVNHLGlCQUFrQkMsUUFBUTtJQUNqQyxNQUFNSCxTQUFTRyxTQUFTSCxNQUFNO0lBRTlCO0lBQ0EsSUFBSUEsU0FBUyxNQUFNQSxTQUFTLElB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RjtBQUVBOzs7OztDQUtBLEdBQ0EsU0FBU2hDLGlCQUFrQmlDLE1BQU0sRUFBRVAsS0FBSyxFQUFFN0IsUUFBUTtJQUNoRCxJQUFJb0MsT0FBT2xELE1BQU0sR0FBRzJDLE1BQU0zQyxNQUFNLEVBQUU7UUFDaEMsT0FBTztJQUNUO0lBRUEsSUFBSyxJQUFJRCxJQUFJLEdBQUdBLElBQUk0QyxNQUFNM0MsTUFBTSxFQUFFRCxJQUFLO1FBQ3JDLElBQUk0QyxLQUFLLENBQUM1QyxFQUFFLEtBQUttRCxNQUFNLENBQUNwQyxTQUFTQSxRQUFRLEdBQUdmLEVBQUUsRUFBRTtZQUM5QyxPQUFPO1FBQ1Q7SUFDRjtJQUVBLE9BQU87QUFDVDtBQUVBb0QsT0FBT0MsT0FBTyxHQUFHO0lBQ2YvQztJQUNBSDtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbW9ja3VwZmxvdy8uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL3dlYi9mZXRjaC9mb3JtZGF0YS1wYXJzZXIuanM/NTQ1NiIsIndlYnBhY2s6Ly9tb2NrdXBmbG93Ly4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvd2ViL2ZldGNoL2Zvcm1kYXRhLXBhcnNlci5qcz81NDU2KiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyBpc1VTVlN0cmluZywgYnVmZmVyVG9Mb3dlckNhc2VkSGVhZGVyTmFtZSB9ID0gcmVxdWlyZSgnLi4vLi4vY29yZS91dGlsJylcbmNvbnN0IHsgdXRmOERlY29kZUJ5dGVzIH0gPSByZXF1aXJlKCcuL3V0aWwnKVxuY29uc3QgeyBIVFRQX1RPS0VOX0NPREVQT0lOVFMsIGlzb21vcnBoaWNEZWNvZGUgfSA9IHJlcXVpcmUoJy4vZGF0YS11cmwnKVxuY29uc3QgeyBpc0ZpbGVMaWtlIH0gPSByZXF1aXJlKCcuL2ZpbGUnKVxuY29uc3QgeyBtYWtlRW50cnkgfSA9IHJlcXVpcmUoJy4vZm9ybWRhdGEnKVxuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZSgnbm9kZTphc3NlcnQnKVxuY29uc3QgeyBGaWxlOiBOb2RlRmlsZSB9ID0gcmVxdWlyZSgnbm9kZTpidWZmZXInKVxuXG5jb25zdCBGaWxlID0gZ2xvYmFsVGhpcy5GaWxlID8/IE5vZGVGaWxlXG5cbmNvbnN0IGZvcm1EYXRhTmFtZUJ1ZmZlciA9IEJ1ZmZlci5mcm9tKCdmb3JtLWRhdGE7IG5hbWU9XCInKVxuY29uc3QgZmlsZW5hbWVCdWZmZXIgPSBCdWZmZXIuZnJvbSgnOyBmaWxlbmFtZScpXG5jb25zdCBkZCA9IEJ1ZmZlci5mcm9tKCctLScpXG5jb25zdCBkZGNybGYgPSBCdWZmZXIuZnJvbSgnLS1cXHJcXG4nKVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBjaGFyc1xuICovXG5mdW5jdGlvbiBpc0FzY2lpU3RyaW5nIChjaGFycykge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGNoYXJzLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKChjaGFycy5jaGFyQ29kZUF0KGkpICYgfjB4N0YpICE9PSAwKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vYW5kcmV1Ym90ZWxsYS5naXRodWIuaW8vbXVsdGlwYXJ0LWZvcm0tZGF0YS8jbXVsdGlwYXJ0LWZvcm0tZGF0YS1ib3VuZGFyeVxuICogQHBhcmFtIHtzdHJpbmd9IGJvdW5kYXJ5XG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlQm91bmRhcnkgKGJvdW5kYXJ5KSB7XG4gIGNvbnN0IGxlbmd0aCA9IGJvdW5kYXJ5Lmxlbmd0aFxuXG4gIC8vIC0gaXRzIGxlbmd0aCBpcyBncmVhdGVyIG9yIGVxdWFsIHRvIDI3IGFuZCBsZXNzZXIgb3IgZXF1YWwgdG8gNzAsIGFuZFxuICBpZiAobGVuZ3RoIDwgMjcgfHwgbGVuZ3RoID4gNzApIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8vIC0gaXQgaXMgY29tcG9zZWQgYnkgYnl0ZXMgaW4gdGhlIHJhbmdlcyAweDMwIHRvIDB4MzksIDB4NDEgdG8gMHg1QSwgb3JcbiAgLy8gICAweDYxIHRvIDB4N0EsIGluY2x1c2l2ZSAoQVNDSUkgYWxwaGFudW1lcmljKSwgb3Igd2hpY2ggYXJlIDB4MjcgKCcpLFxuICAvLyAgIDB4MkQgKC0pIG9yIDB4NUYgKF8pLlxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgY29uc3QgY3AgPSBib3VuZGFyeS5jaGFyQ29kZUF0KGkpXG5cbiAgICBpZiAoIShcbiAgICAgIChjcCA+PSAweDMwICYmIGNwIDw9IDB4MzkpIHx8XG4gICAgICAoY3AgPj0gMHg0MSAmJiBjcCA8PSAweDVhKSB8fFxuICAgICAgKGNwID49IDB4NjEgJiYgY3AgPD0gMHg3YSkgfHxcbiAgICAgIGNwID09PSAweDI3IHx8XG4gICAgICBjcCA9PT0gMHgyZCB8fFxuICAgICAgY3AgPT09IDB4NWZcbiAgICApKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9hbmRyZXVib3RlbGxhLmdpdGh1Yi5pby9tdWx0aXBhcnQtZm9ybS1kYXRhLyNtdWx0aXBhcnQtZm9ybS1kYXRhLXBhcnNlclxuICogQHBhcmFtIHtCdWZmZXJ9IGlucHV0XG4gKiBAcGFyYW0ge1JldHVyblR5cGU8aW1wb3J0KCcuL2RhdGEtdXJsJylbJ3BhcnNlTUlNRVR5cGUnXT59IG1pbWVUeXBlXG4gKi9cbmZ1bmN0aW9uIG11bHRpcGFydEZvcm1EYXRhUGFyc2VyIChpbnB1dCwgbWltZVR5cGUpIHtcbiAgLy8gMS4gQXNzZXJ0OiBtaW1lVHlwZeKAmXMgZXNzZW5jZSBpcyBcIm11bHRpcGFydC9mb3JtLWRhdGFcIi5cbiAgYXNzZXJ0KG1pbWVUeXBlICE9PSAnZmFpbHVyZScgJiYgbWltZVR5cGUuZXNzZW5jZSA9PT0gJ211bHRpcGFydC9mb3JtLWRhdGEnKVxuXG4gIGNvbnN0IGJvdW5kYXJ5U3RyaW5nID0gbWltZVR5cGUucGFyYW1ldGVycy5nZXQoJ2JvdW5kYXJ5JylcblxuICAvLyAyLiBJZiBtaW1lVHlwZeKAmXMgcGFyYW1ldGVyc1tcImJvdW5kYXJ5XCJdIGRvZXMgbm90IGV4aXN0LCByZXR1cm4gZmFpbHVyZS5cbiAgLy8gICAgT3RoZXJ3aXNlLCBsZXQgYm91bmRhcnkgYmUgdGhlIHJlc3VsdCBvZiBVVEYtOCBkZWNvZGluZyBtaW1lVHlwZeKAmXNcbiAgLy8gICAgcGFyYW1ldGVyc1tcImJvdW5kYXJ5XCJdLlxuICBpZiAoYm91bmRhcnlTdHJpbmcgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiAnZmFpbHVyZSdcbiAgfVxuXG4gIGNvbnN0IGJvdW5kYXJ5ID0gQnVmZmVyLmZyb20oYC0tJHtib3VuZGFyeVN0cmluZ31gLCAndXRmOCcpXG5cbiAgLy8gMy4gTGV0IGVudHJ5IGxpc3QgYmUgYW4gZW1wdHkgZW50cnkgbGlzdC5cbiAgY29uc3QgZW50cnlMaXN0ID0gW11cblxuICAvLyA0LiBMZXQgcG9zaXRpb24gYmUgYSBwb2ludGVyIHRvIGEgYnl0ZSBpbiBpbnB1dCwgaW5pdGlhbGx5IHBvaW50aW5nIGF0XG4gIC8vICAgIHRoZSBmaXJzdCBieXRlLlxuICBjb25zdCBwb3NpdGlvbiA9IHsgcG9zaXRpb246IDAgfVxuXG4gIC8vIE5vdGU6IHVuZGljaSBhZGRpdGlvbiwgYWxsb3cgXFxyXFxuIGJlZm9yZSB0aGUgYm9keS5cbiAgaWYgKGlucHV0WzBdID09PSAweDBkICYmIGlucHV0WzFdID09PSAweDBhKSB7XG4gICAgcG9zaXRpb24ucG9zaXRpb24gKz0gMlxuICB9XG5cbiAgLy8gNS4gV2hpbGUgdHJ1ZTpcbiAgd2hpbGUgKHRydWUpIHtcbiAgICAvLyA1LjEuIElmIHBvc2l0aW9uIHBvaW50cyB0byBhIHNlcXVlbmNlIG9mIGJ5dGVzIHN0YXJ0aW5nIHdpdGggMHgyRCAweDJEXG4gICAgLy8gICAgICAoYC0tYCkgZm9sbG93ZWQgYnkgYm91bmRhcnksIGFkdmFuY2UgcG9zaXRpb24gYnkgMiArIHRoZSBsZW5ndGggb2ZcbiAgICAvLyAgICAgIGJvdW5kYXJ5LiBPdGhlcndpc2UsIHJldHVybiBmYWlsdXJlLlxuICAgIC8vIE5vdGU6IGJvdW5kYXJ5IGlzIHBhZGRlZCB3aXRoIDIgZGFzaGVzIGFscmVhZHksIG5vIG5lZWQgdG8gYWRkIDIuXG4gICAgaWYgKGlucHV0LnN1YmFycmF5KHBvc2l0aW9uLnBvc2l0aW9uLCBwb3NpdGlvbi5wb3NpdGlvbiArIGJvdW5kYXJ5Lmxlbmd0aCkuZXF1YWxzKGJvdW5kYXJ5KSkge1xuICAgICAgcG9zaXRpb24ucG9zaXRpb24gKz0gYm91bmRhcnkubGVuZ3RoXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAnZmFpbHVyZSdcbiAgICB9XG5cbiAgICAvLyA1LjIuIElmIHBvc2l0aW9uIHBvaW50cyB0byB0aGUgc2VxdWVuY2Ugb2YgYnl0ZXMgMHgyRCAweDJEIDB4MEQgMHgwQVxuICAgIC8vICAgICAgKGAtLWAgZm9sbG93ZWQgYnkgQ1IgTEYpIGZvbGxvd2VkIGJ5IHRoZSBlbmQgb2YgaW5wdXQsIHJldHVybiBlbnRyeSBsaXN0LlxuICAgIC8vIE5vdGU6IGEgYm9keSBkb2VzIE5PVCBuZWVkIHRvIGVuZCB3aXRoIENSTEYuIEl0IGNhbiBlbmQgd2l0aCAtLS5cbiAgICBpZiAoXG4gICAgICAocG9zaXRpb24ucG9zaXRpb24gPT09IGlucHV0Lmxlbmd0aCAtIDIgJiYgYnVmZmVyU3RhcnRzV2l0aChpbnB1dCwgZGQsIHBvc2l0aW9uKSkgfHxcbiAgICAgIChwb3NpdGlvbi5wb3NpdGlvbiA9PT0gaW5wdXQubGVuZ3RoIC0gNCAmJiBidWZmZXJTdGFydHNXaXRoKGlucHV0LCBkZGNybGYsIHBvc2l0aW9uKSlcbiAgICApIHtcbiAgICAgIHJldHVybiBlbnRyeUxpc3RcbiAgICB9XG5cbiAgICAvLyA1LjMuIElmIHBvc2l0aW9uIGRvZXMgbm90IHBvaW50IHRvIGEgc2VxdWVuY2Ugb2YgYnl0ZXMgc3RhcnRpbmcgd2l0aCAweDBEXG4gICAgLy8gICAgICAweDBBIChDUiBMRiksIHJldHVybiBmYWlsdXJlLlxuICAgIGlmIChpbnB1dFtwb3NpdGlvbi5wb3NpdGlvbl0gIT09IDB4MGQgfHwgaW5wdXRbcG9zaXRpb24ucG9zaXRpb24gKyAxXSAhPT0gMHgwYSkge1xuICAgICAgcmV0dXJuICdmYWlsdXJlJ1xuICAgIH1cblxuICAgIC8vIDUuNC4gQWR2YW5jZSBwb3NpdGlvbiBieSAyLiAoVGhpcyBza2lwcyBwYXN0IHRoZSBuZXdsaW5lLilcbiAgICBwb3NpdGlvbi5wb3NpdGlvbiArPSAyXG5cbiAgICAvLyA1LjUuIExldCBuYW1lLCBmaWxlbmFtZSBhbmQgY29udGVudFR5cGUgYmUgdGhlIHJlc3VsdCBvZiBwYXJzaW5nXG4gICAgLy8gICAgICBtdWx0aXBhcnQvZm9ybS1kYXRhIGhlYWRlcnMgb24gaW5wdXQgYW5kIHBvc2l0aW9uLCBpZiB0aGUgcmVzdWx0XG4gICAgLy8gICAgICBpcyBub3QgZmFpbHVyZS4gT3RoZXJ3aXNlLCByZXR1cm4gZmFpbHVyZS5cbiAgICBjb25zdCByZXN1bHQgPSBwYXJzZU11bHRpcGFydEZvcm1EYXRhSGVhZGVycyhpbnB1dCwgcG9zaXRpb24pXG5cbiAgICBpZiAocmVzdWx0ID09PSAnZmFpbHVyZScpIHtcbiAgICAgIHJldHVybiAnZmFpbHVyZSdcbiAgICB9XG5cbiAgICBsZXQgeyBuYW1lLCBmaWxlbmFtZSwgY29udGVudFR5cGUsIGVuY29kaW5nIH0gPSByZXN1bHRcblxuICAgIC8vIDUuNi4gQWR2YW5jZSBwb3NpdGlvbiBieSAyLiAoVGhpcyBza2lwcyBwYXN0IHRoZSBlbXB0eSBsaW5lIHRoYXQgbWFya3NcbiAgICAvLyAgICAgIHRoZSBlbmQgb2YgdGhlIGhlYWRlcnMuKVxuICAgIHBvc2l0aW9uLnBvc2l0aW9uICs9IDJcblxuICAgIC8vIDUuNy4gTGV0IGJvZHkgYmUgdGhlIGVtcHR5IGJ5dGUgc2VxdWVuY2UuXG4gICAgbGV0IGJvZHlcblxuICAgIC8vIDUuOC4gQm9keSBsb29wOiBXaGlsZSBwb3NpdGlvbiBpcyBub3QgcGFzdCB0aGUgZW5kIG9mIGlucHV0OlxuICAgIC8vIFRPRE86IHRoZSBzdGVwcyBoZXJlIGFyZSBjb21wbGV0ZWx5IHdyb25nXG4gICAge1xuICAgICAgY29uc3QgYm91bmRhcnlJbmRleCA9IGlucHV0LmluZGV4T2YoYm91bmRhcnkuc3ViYXJyYXkoMiksIHBvc2l0aW9uLnBvc2l0aW9uKVxuXG4gICAgICBpZiAoYm91bmRhcnlJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuICdmYWlsdXJlJ1xuICAgICAgfVxuXG4gICAgICBib2R5ID0gaW5wdXQuc3ViYXJyYXkocG9zaXRpb24ucG9zaXRpb24sIGJvdW5kYXJ5SW5kZXggLSA0KVxuXG4gICAgICBwb3NpdGlvbi5wb3NpdGlvbiArPSBib2R5Lmxlbmd0aFxuXG4gICAgICAvLyBOb3RlOiBwb3NpdGlvbiBtdXN0IGJlIGFkdmFuY2VkIGJ5IHRoZSBib2R5J3MgbGVuZ3RoIGJlZm9yZSBiZWluZ1xuICAgICAgLy8gZGVjb2RlZCwgb3RoZXJ3aXNlIHRoZSBwYXJzaW5nIHdpbGwgZmFpbC5cbiAgICAgIGlmIChlbmNvZGluZyA9PT0gJ2Jhc2U2NCcpIHtcbiAgICAgICAgYm9keSA9IEJ1ZmZlci5mcm9tKGJvZHkudG9TdHJpbmcoKSwgJ2Jhc2U2NCcpXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gNS45LiBJZiBwb3NpdGlvbiBkb2VzIG5vdCBwb2ludCB0byBhIHNlcXVlbmNlIG9mIGJ5dGVzIHN0YXJ0aW5nIHdpdGhcbiAgICAvLyAgICAgIDB4MEQgMHgwQSAoQ1IgTEYpLCByZXR1cm4gZmFpbHVyZS4gT3RoZXJ3aXNlLCBhZHZhbmNlIHBvc2l0aW9uIGJ5IDIuXG4gICAgaWYgKGlucHV0W3Bvc2l0aW9uLnBvc2l0aW9uXSAhPT0gMHgwZCB8fCBpbnB1dFtwb3NpdGlvbi5wb3NpdGlvbiArIDFdICE9PSAweDBhKSB7XG4gICAgICByZXR1cm4gJ2ZhaWx1cmUnXG4gICAgfSBlbHNlIHtcbiAgICAgIHBvc2l0aW9uLnBvc2l0aW9uICs9IDJcbiAgICB9XG5cbiAgICAvLyA1LjEwLiBJZiBmaWxlbmFtZSBpcyBub3QgbnVsbDpcbiAgICBsZXQgdmFsdWVcblxuICAgIGlmIChmaWxlbmFtZSAhPT0gbnVsbCkge1xuICAgICAgLy8gNS4xMC4xLiBJZiBjb250ZW50VHlwZSBpcyBudWxsLCBzZXQgY29udGVudFR5cGUgdG8gXCJ0ZXh0L3BsYWluXCIuXG4gICAgICBjb250ZW50VHlwZSA/Pz0gJ3RleHQvcGxhaW4nXG5cbiAgICAgIC8vIDUuMTAuMi4gSWYgY29udGVudFR5cGUgaXMgbm90IGFuIEFTQ0lJIHN0cmluZywgc2V0IGNvbnRlbnRUeXBlIHRvIHRoZSBlbXB0eSBzdHJpbmcuXG5cbiAgICAgIC8vIE5vdGU6IGBidWZmZXIuaXNBc2NpaWAgY2FuIGJlIHVzZWQgYXQgemVyby1jb3N0LCBidXQgY29udmVydGluZyBhIHN0cmluZyB0byBhIGJ1ZmZlciBpcyBhIGhpZ2ggb3ZlcmhlYWQuXG4gICAgICAvLyBDb250ZW50LVR5cGUgaXMgYSByZWxhdGl2ZWx5IHNtYWxsIHN0cmluZywgc28gaXQgaXMgZmFzdGVyIHRvIHVzZSBgU3RyaW5nI2NoYXJDb2RlQXRgLlxuICAgICAgaWYgKCFpc0FzY2lpU3RyaW5nKGNvbnRlbnRUeXBlKSkge1xuICAgICAgICBjb250ZW50VHlwZSA9ICcnXG4gICAgICB9XG5cbiAgICAgIC8vIDUuMTAuMy4gTGV0IHZhbHVlIGJlIGEgbmV3IEZpbGUgb2JqZWN0IHdpdGggbmFtZSBmaWxlbmFtZSwgdHlwZSBjb250ZW50VHlwZSwgYW5kIGJvZHkgYm9keS5cbiAgICAgIHZhbHVlID0gbmV3IEZpbGUoW2JvZHldLCBmaWxlbmFtZSwgeyB0eXBlOiBjb250ZW50VHlwZSB9KVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyA1LjExLiBPdGhlcndpc2U6XG5cbiAgICAgIC8vIDUuMTEuMS4gTGV0IHZhbHVlIGJlIHRoZSBVVEYtOCBkZWNvZGluZyB3aXRob3V0IEJPTSBvZiBib2R5LlxuICAgICAgdmFsdWUgPSB1dGY4RGVjb2RlQnl0ZXMoQnVmZmVyLmZyb20oYm9keSkpXG4gICAgfVxuXG4gICAgLy8gNS4xMi4gQXNzZXJ0OiBuYW1lIGlzIGEgc2NhbGFyIHZhbHVlIHN0cmluZyBhbmQgdmFsdWUgaXMgZWl0aGVyIGEgc2NhbGFyIHZhbHVlIHN0cmluZyBvciBhIEZpbGUgb2JqZWN0LlxuICAgIGFzc2VydChpc1VTVlN0cmluZyhuYW1lKSlcbiAgICBhc3NlcnQoKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgaXNVU1ZTdHJpbmcodmFsdWUpKSB8fCBpc0ZpbGVMaWtlKHZhbHVlKSlcblxuICAgIC8vIDUuMTMuIENyZWF0ZSBhbiBlbnRyeSB3aXRoIG5hbWUgYW5kIHZhbHVlLCBhbmQgYXBwZW5kIGl0IHRvIGVudHJ5IGxpc3QuXG4gICAgZW50cnlMaXN0LnB1c2gobWFrZUVudHJ5KG5hbWUsIHZhbHVlLCBmaWxlbmFtZSkpXG4gIH1cbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vYW5kcmV1Ym90ZWxsYS5naXRodWIuaW8vbXVsdGlwYXJ0LWZvcm0tZGF0YS8jcGFyc2UtbXVsdGlwYXJ0LWZvcm0tZGF0YS1oZWFkZXJzXG4gKiBAcGFyYW0ge0J1ZmZlcn0gaW5wdXRcbiAqIEBwYXJhbSB7eyBwb3NpdGlvbjogbnVtYmVyIH19IHBvc2l0aW9uXG4gKi9cbmZ1bmN0aW9uIHBhcnNlTXVsdGlwYXJ0Rm9ybURhdGFIZWFkZXJzIChpbnB1dCwgcG9zaXRpb24pIHtcbiAgLy8gMS4gTGV0IG5hbWUsIGZpbGVuYW1lIGFuZCBjb250ZW50VHlwZSBiZSBudWxsLlxuICBsZXQgbmFtZSA9IG51bGxcbiAgbGV0IGZpbGVuYW1lID0gbnVsbFxuICBsZXQgY29udGVudFR5cGUgPSBudWxsXG4gIGxldCBlbmNvZGluZyA9IG51bGxcblxuICAvLyAyLiBXaGlsZSB0cnVlOlxuICB3aGlsZSAodHJ1ZSkge1xuICAgIC8vIDIuMS4gSWYgcG9zaXRpb24gcG9pbnRzIHRvIGEgc2VxdWVuY2Ugb2YgYnl0ZXMgc3RhcnRpbmcgd2l0aCAweDBEIDB4MEEgKENSIExGKTpcbiAgICBpZiAoaW5wdXRbcG9zaXRpb24ucG9zaXRpb25dID09PSAweDBkICYmIGlucHV0W3Bvc2l0aW9uLnBvc2l0aW9uICsgMV0gPT09IDB4MGEpIHtcbiAgICAgIC8vIDIuMS4xLiBJZiBuYW1lIGlzIG51bGwsIHJldHVybiBmYWlsdXJlLlxuICAgICAgaWYgKG5hbWUgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuICdmYWlsdXJlJ1xuICAgICAgfVxuXG4gICAgICAvLyAyLjEuMi4gUmV0dXJuIG5hbWUsIGZpbGVuYW1lIGFuZCBjb250ZW50VHlwZS5cbiAgICAgIHJldHVybiB7IG5hbWUsIGZpbGVuYW1lLCBjb250ZW50VHlwZSwgZW5jb2RpbmcgfVxuICAgIH1cblxuICAgIC8vIDIuMi4gTGV0IGhlYWRlciBuYW1lIGJlIHRoZSByZXN1bHQgb2YgY29sbGVjdGluZyBhIHNlcXVlbmNlIG9mIGJ5dGVzIHRoYXQgYXJlXG4gICAgLy8gICAgICBub3QgMHgwQSAoTEYpLCAweDBEIChDUikgb3IgMHgzQSAoOiksIGdpdmVuIHBvc2l0aW9uLlxuICAgIGxldCBoZWFkZXJOYW1lID0gY29sbGVjdEFTZXF1ZW5jZU9mQnl0ZXMoXG4gICAgICAoY2hhcikgPT4gY2hhciAhPT0gMHgwYSAmJiBjaGFyICE9PSAweDBkICYmIGNoYXIgIT09IDB4M2EsXG4gICAgICBpbnB1dCxcbiAgICAgIHBvc2l0aW9uXG4gICAgKVxuXG4gICAgLy8gMi4zLiBSZW1vdmUgYW55IEhUVFAgdGFiIG9yIHNwYWNlIGJ5dGVzIGZyb20gdGhlIHN0YXJ0IG9yIGVuZCBvZiBoZWFkZXIgbmFtZS5cbiAgICBoZWFkZXJOYW1lID0gcmVtb3ZlQ2hhcnMoaGVhZGVyTmFtZSwgdHJ1ZSwgdHJ1ZSwgKGNoYXIpID0+IGNoYXIgPT09IDB4OSB8fCBjaGFyID09PSAweDIwKVxuXG4gICAgLy8gMi40LiBJZiBoZWFkZXIgbmFtZSBkb2VzIG5vdCBtYXRjaCB0aGUgZmllbGQtbmFtZSB0b2tlbiBwcm9kdWN0aW9uLCByZXR1cm4gZmFpbHVyZS5cbiAgICBpZiAoIUhUVFBfVE9LRU5fQ09ERVBPSU5UUy50ZXN0KGhlYWRlck5hbWUudG9TdHJpbmcoKSkpIHtcbiAgICAgIHJldHVybiAnZmFpbHVyZSdcbiAgICB9XG5cbiAgICAvLyAyLjUuIElmIHRoZSBieXRlIGF0IHBvc2l0aW9uIGlzIG5vdCAweDNBICg6KSwgcmV0dXJuIGZhaWx1cmUuXG4gICAgaWYgKGlucHV0W3Bvc2l0aW9uLnBvc2l0aW9uXSAhPT0gMHgzYSkge1xuICAgICAgcmV0dXJuICdmYWlsdXJlJ1xuICAgIH1cblxuICAgIC8vIDIuNi4gQWR2YW5jZSBwb3NpdGlvbiBieSAxLlxuICAgIHBvc2l0aW9uLnBvc2l0aW9uKytcblxuICAgIC8vIDIuNy4gQ29sbGVjdCBhIHNlcXVlbmNlIG9mIGJ5dGVzIHRoYXQgYXJlIEhUVFAgdGFiIG9yIHNwYWNlIGJ5dGVzIGdpdmVuIHBvc2l0aW9uLlxuICAgIC8vICAgICAgKERvIG5vdGhpbmcgd2l0aCB0aG9zZSBieXRlcy4pXG4gICAgY29sbGVjdEFTZXF1ZW5jZU9mQnl0ZXMoXG4gICAgICAoY2hhcikgPT4gY2hhciA9PT0gMHgyMCB8fCBjaGFyID09PSAweDA5LFxuICAgICAgaW5wdXQsXG4gICAgICBwb3NpdGlvblxuICAgIClcblxuICAgIC8vIDIuOC4gQnl0ZS1sb3dlcmNhc2UgaGVhZGVyIG5hbWUgYW5kIHN3aXRjaCBvbiB0aGUgcmVzdWx0OlxuICAgIHN3aXRjaCAoYnVmZmVyVG9Mb3dlckNhc2VkSGVhZGVyTmFtZShoZWFkZXJOYW1lKSkge1xuICAgICAgY2FzZSAnY29udGVudC1kaXNwb3NpdGlvbic6IHtcbiAgICAgICAgLy8gMS4gU2V0IG5hbWUgYW5kIGZpbGVuYW1lIHRvIG51bGwuXG4gICAgICAgIG5hbWUgPSBmaWxlbmFtZSA9IG51bGxcblxuICAgICAgICAvLyAyLiBJZiBwb3NpdGlvbiBkb2VzIG5vdCBwb2ludCB0byBhIHNlcXVlbmNlIG9mIGJ5dGVzIHN0YXJ0aW5nIHdpdGhcbiAgICAgICAgLy8gICAgYGZvcm0tZGF0YTsgbmFtZT1cImAsIHJldHVybiBmYWlsdXJlLlxuICAgICAgICBpZiAoIWJ1ZmZlclN0YXJ0c1dpdGgoaW5wdXQsIGZvcm1EYXRhTmFtZUJ1ZmZlciwgcG9zaXRpb24pKSB7XG4gICAgICAgICAgcmV0dXJuICdmYWlsdXJlJ1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gMy4gQWR2YW5jZSBwb3NpdGlvbiBzbyBpdCBwb2ludHMgYXQgdGhlIGJ5dGUgYWZ0ZXIgdGhlIG5leHQgMHgyMiAoXCIpXG4gICAgICAgIC8vICAgIGJ5dGUgKHRoZSBvbmUgaW4gdGhlIHNlcXVlbmNlIG9mIGJ5dGVzIG1hdGNoZWQgYWJvdmUpLlxuICAgICAgICBwb3NpdGlvbi5wb3NpdGlvbiArPSAxN1xuXG4gICAgICAgIC8vIDQuIFNldCBuYW1lIHRvIHRoZSByZXN1bHQgb2YgcGFyc2luZyBhIG11bHRpcGFydC9mb3JtLWRhdGEgbmFtZSBnaXZlblxuICAgICAgICAvLyAgICBpbnB1dCBhbmQgcG9zaXRpb24sIGlmIHRoZSByZXN1bHQgaXMgbm90IGZhaWx1cmUuIE90aGVyd2lzZSwgcmV0dXJuXG4gICAgICAgIC8vICAgIGZhaWx1cmUuXG4gICAgICAgIG5hbWUgPSBwYXJzZU11bHRpcGFydEZvcm1EYXRhTmFtZShpbnB1dCwgcG9zaXRpb24pXG5cbiAgICAgICAgaWYgKG5hbWUgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gJ2ZhaWx1cmUnXG4gICAgICAgIH1cblxuICAgICAgICAvLyA1LiBJZiBwb3NpdGlvbiBwb2ludHMgdG8gYSBzZXF1ZW5jZSBvZiBieXRlcyBzdGFydGluZyB3aXRoIGA7IGZpbGVuYW1lPVwiYDpcbiAgICAgICAgaWYgKGJ1ZmZlclN0YXJ0c1dpdGgoaW5wdXQsIGZpbGVuYW1lQnVmZmVyLCBwb3NpdGlvbikpIHtcbiAgICAgICAgICAvLyBOb3RlOiB1bmRpY2kgYWxzbyBoYW5kbGVzIGZpbGVuYW1lKlxuICAgICAgICAgIGxldCBjaGVjayA9IHBvc2l0aW9uLnBvc2l0aW9uICsgZmlsZW5hbWVCdWZmZXIubGVuZ3RoXG5cbiAgICAgICAgICBpZiAoaW5wdXRbY2hlY2tdID09PSAweDJhKSB7XG4gICAgICAgICAgICBwb3NpdGlvbi5wb3NpdGlvbiArPSAxXG4gICAgICAgICAgICBjaGVjayArPSAxXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGlucHV0W2NoZWNrXSAhPT0gMHgzZCB8fCBpbnB1dFtjaGVjayArIDFdICE9PSAweDIyKSB7IC8vID1cIlxuICAgICAgICAgICAgcmV0dXJuICdmYWlsdXJlJ1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIDEuIEFkdmFuY2UgcG9zaXRpb24gc28gaXQgcG9pbnRzIGF0IHRoZSBieXRlIGFmdGVyIHRoZSBuZXh0IDB4MjIgKFwiKSBieXRlXG4gICAgICAgICAgLy8gICAgKHRoZSBvbmUgaW4gdGhlIHNlcXVlbmNlIG9mIGJ5dGVzIG1hdGNoZWQgYWJvdmUpLlxuICAgICAgICAgIHBvc2l0aW9uLnBvc2l0aW9uICs9IDEyXG5cbiAgICAgICAgICAvLyAyLiBTZXQgZmlsZW5hbWUgdG8gdGhlIHJlc3VsdCBvZiBwYXJzaW5nIGEgbXVsdGlwYXJ0L2Zvcm0tZGF0YSBuYW1lIGdpdmVuXG4gICAgICAgICAgLy8gICAgaW5wdXQgYW5kIHBvc2l0aW9uLCBpZiB0aGUgcmVzdWx0IGlzIG5vdCBmYWlsdXJlLiBPdGhlcndpc2UsIHJldHVybiBmYWlsdXJlLlxuICAgICAgICAgIGZpbGVuYW1lID0gcGFyc2VNdWx0aXBhcnRGb3JtRGF0YU5hbWUoaW5wdXQsIHBvc2l0aW9uKVxuXG4gICAgICAgICAgaWYgKGZpbGVuYW1lID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2ZhaWx1cmUnXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGNhc2UgJ2NvbnRlbnQtdHlwZSc6IHtcbiAgICAgICAgLy8gMS4gTGV0IGhlYWRlciB2YWx1ZSBiZSB0aGUgcmVzdWx0IG9mIGNvbGxlY3RpbmcgYSBzZXF1ZW5jZSBvZiBieXRlcyB0aGF0IGFyZVxuICAgICAgICAvLyAgICBub3QgMHgwQSAoTEYpIG9yIDB4MEQgKENSKSwgZ2l2ZW4gcG9zaXRpb24uXG4gICAgICAgIGxldCBoZWFkZXJWYWx1ZSA9IGNvbGxlY3RBU2VxdWVuY2VPZkJ5dGVzKFxuICAgICAgICAgIChjaGFyKSA9PiBjaGFyICE9PSAweDBhICYmIGNoYXIgIT09IDB4MGQsXG4gICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgcG9zaXRpb25cbiAgICAgICAgKVxuXG4gICAgICAgIC8vIDIuIFJlbW92ZSBhbnkgSFRUUCB0YWIgb3Igc3BhY2UgYnl0ZXMgZnJvbSB0aGUgZW5kIG9mIGhlYWRlciB2YWx1ZS5cbiAgICAgICAgaGVhZGVyVmFsdWUgPSByZW1vdmVDaGFycyhoZWFkZXJWYWx1ZSwgZmFsc2UsIHRydWUsIChjaGFyKSA9PiBjaGFyID09PSAweDkgfHwgY2hhciA9PT0gMHgyMClcblxuICAgICAgICAvLyAzLiBTZXQgY29udGVudFR5cGUgdG8gdGhlIGlzb21vcnBoaWMgZGVjb2Rpbmcgb2YgaGVhZGVyIHZhbHVlLlxuICAgICAgICBjb250ZW50VHlwZSA9IGlzb21vcnBoaWNEZWNvZGUoaGVhZGVyVmFsdWUpXG5cbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGNhc2UgJ2NvbnRlbnQtdHJhbnNmZXItZW5jb2RpbmcnOiB7XG4gICAgICAgIGxldCBoZWFkZXJWYWx1ZSA9IGNvbGxlY3RBU2VxdWVuY2VPZkJ5dGVzKFxuICAgICAgICAgIChjaGFyKSA9PiBjaGFyICE9PSAweDBhICYmIGNoYXIgIT09IDB4MGQsXG4gICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgcG9zaXRpb25cbiAgICAgICAgKVxuXG4gICAgICAgIGhlYWRlclZhbHVlID0gcmVtb3ZlQ2hhcnMoaGVhZGVyVmFsdWUsIGZhbHNlLCB0cnVlLCAoY2hhcikgPT4gY2hhciA9PT0gMHg5IHx8IGNoYXIgPT09IDB4MjApXG5cbiAgICAgICAgZW5jb2RpbmcgPSBpc29tb3JwaGljRGVjb2RlKGhlYWRlclZhbHVlKVxuXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBkZWZhdWx0OiB7XG4gICAgICAgIC8vIENvbGxlY3QgYSBzZXF1ZW5jZSBvZiBieXRlcyB0aGF0IGFyZSBub3QgMHgwQSAoTEYpIG9yIDB4MEQgKENSKSwgZ2l2ZW4gcG9zaXRpb24uXG4gICAgICAgIC8vIChEbyBub3RoaW5nIHdpdGggdGhvc2UgYnl0ZXMuKVxuICAgICAgICBjb2xsZWN0QVNlcXVlbmNlT2ZCeXRlcyhcbiAgICAgICAgICAoY2hhcikgPT4gY2hhciAhPT0gMHgwYSAmJiBjaGFyICE9PSAweDBkLFxuICAgICAgICAgIGlucHV0LFxuICAgICAgICAgIHBvc2l0aW9uXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyAyLjkuIElmIHBvc2l0aW9uIGRvZXMgbm90IHBvaW50IHRvIGEgc2VxdWVuY2Ugb2YgYnl0ZXMgc3RhcnRpbmcgd2l0aCAweDBEIDB4MEFcbiAgICAvLyAgICAgIChDUiBMRiksIHJldHVybiBmYWlsdXJlLiBPdGhlcndpc2UsIGFkdmFuY2UgcG9zaXRpb24gYnkgMiAocGFzdCB0aGUgbmV3bGluZSkuXG4gICAgaWYgKGlucHV0W3Bvc2l0aW9uLnBvc2l0aW9uXSAhPT0gMHgwZCAmJiBpbnB1dFtwb3NpdGlvbi5wb3NpdGlvbiArIDFdICE9PSAweDBhKSB7XG4gICAgICByZXR1cm4gJ2ZhaWx1cmUnXG4gICAgfSBlbHNlIHtcbiAgICAgIHBvc2l0aW9uLnBvc2l0aW9uICs9IDJcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vYW5kcmV1Ym90ZWxsYS5naXRodWIuaW8vbXVsdGlwYXJ0LWZvcm0tZGF0YS8jcGFyc2UtYS1tdWx0aXBhcnQtZm9ybS1kYXRhLW5hbWVcbiAqIEBwYXJhbSB7QnVmZmVyfSBpbnB1dFxuICogQHBhcmFtIHt7IHBvc2l0aW9uOiBudW1iZXIgfX0gcG9zaXRpb25cbiAqL1xuZnVuY3Rpb24gcGFyc2VNdWx0aXBhcnRGb3JtRGF0YU5hbWUgKGlucHV0LCBwb3NpdGlvbikge1xuICAvLyAxLiBBc3NlcnQ6IFRoZSBieXRlIGF0IChwb3NpdGlvbiAtIDEpIGlzIDB4MjIgKFwiKS5cbiAgYXNzZXJ0KGlucHV0W3Bvc2l0aW9uLnBvc2l0aW9uIC0gMV0gPT09IDB4MjIpXG5cbiAgLy8gMi4gTGV0IG5hbWUgYmUgdGhlIHJlc3VsdCBvZiBjb2xsZWN0aW5nIGEgc2VxdWVuY2Ugb2YgYnl0ZXMgdGhhdCBhcmUgbm90IDB4MEEgKExGKSwgMHgwRCAoQ1IpIG9yIDB4MjIgKFwiKSwgZ2l2ZW4gcG9zaXRpb24uXG4gIC8qKiBAdHlwZSB7c3RyaW5nIHwgQnVmZmVyfSAqL1xuICBsZXQgbmFtZSA9IGNvbGxlY3RBU2VxdWVuY2VPZkJ5dGVzKFxuICAgIChjaGFyKSA9PiBjaGFyICE9PSAweDBhICYmIGNoYXIgIT09IDB4MGQgJiYgY2hhciAhPT0gMHgyMixcbiAgICBpbnB1dCxcbiAgICBwb3NpdGlvblxuICApXG5cbiAgLy8gMy4gSWYgdGhlIGJ5dGUgYXQgcG9zaXRpb24gaXMgbm90IDB4MjIgKFwiKSwgcmV0dXJuIGZhaWx1cmUuIE90aGVyd2lzZSwgYWR2YW5jZSBwb3NpdGlvbiBieSAxLlxuICBpZiAoaW5wdXRbcG9zaXRpb24ucG9zaXRpb25dICE9PSAweDIyKSB7XG4gICAgcmV0dXJuIG51bGwgLy8gbmFtZSBjb3VsZCBiZSAnZmFpbHVyZSdcbiAgfSBlbHNlIHtcbiAgICBwb3NpdGlvbi5wb3NpdGlvbisrXG4gIH1cblxuICAvLyA0LiBSZXBsYWNlIGFueSBvY2N1cnJlbmNlIG9mIHRoZSBmb2xsb3dpbmcgc3Vic2VxdWVuY2VzIGluIG5hbWUgd2l0aCB0aGUgZ2l2ZW4gYnl0ZTpcbiAgLy8gLSBgJTBBYDogMHgwQSAoTEYpXG4gIC8vIC0gYCUwRGA6IDB4MEQgKENSKVxuICAvLyAtIGAlMjJgOiAweDIyIChcIilcbiAgbmFtZSA9IG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShuYW1lKVxuICAgIC5yZXBsYWNlKC8lMEEvaWcsICdcXG4nKVxuICAgIC5yZXBsYWNlKC8lMEQvaWcsICdcXHInKVxuICAgIC5yZXBsYWNlKC8lMjIvZywgJ1wiJylcblxuICAvLyA1LiBSZXR1cm4gdGhlIFVURi04IGRlY29kaW5nIHdpdGhvdXQgQk9NIG9mIG5hbWUuXG4gIHJldHVybiBuYW1lXG59XG5cbi8qKlxuICogQHBhcmFtIHsoY2hhcjogbnVtYmVyKSA9PiBib29sZWFufSBjb25kaXRpb25cbiAqIEBwYXJhbSB7QnVmZmVyfSBpbnB1dFxuICogQHBhcmFtIHt7IHBvc2l0aW9uOiBudW1iZXIgfX0gcG9zaXRpb25cbiAqL1xuZnVuY3Rpb24gY29sbGVjdEFTZXF1ZW5jZU9mQnl0ZXMgKGNvbmRpdGlvbiwgaW5wdXQsIHBvc2l0aW9uKSB7XG4gIGxldCBzdGFydCA9IHBvc2l0aW9uLnBvc2l0aW9uXG5cbiAgd2hpbGUgKHN0YXJ0IDwgaW5wdXQubGVuZ3RoICYmIGNvbmRpdGlvbihpbnB1dFtzdGFydF0pKSB7XG4gICAgKytzdGFydFxuICB9XG5cbiAgcmV0dXJuIGlucHV0LnN1YmFycmF5KHBvc2l0aW9uLnBvc2l0aW9uLCAocG9zaXRpb24ucG9zaXRpb24gPSBzdGFydCkpXG59XG5cbi8qKlxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZlxuICogQHBhcmFtIHtib29sZWFufSBsZWFkaW5nXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHRyYWlsaW5nXG4gKiBAcGFyYW0geyhjaGFyQ29kZTogbnVtYmVyKSA9PiBib29sZWFufSBwcmVkaWNhdGVcbiAqIEByZXR1cm5zIHtCdWZmZXJ9XG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUNoYXJzIChidWYsIGxlYWRpbmcsIHRyYWlsaW5nLCBwcmVkaWNhdGUpIHtcbiAgbGV0IGxlYWQgPSAwXG4gIGxldCB0cmFpbCA9IGJ1Zi5sZW5ndGggLSAxXG5cbiAgaWYgKGxlYWRpbmcpIHtcbiAgICB3aGlsZSAobGVhZCA8IGJ1Zi5sZW5ndGggJiYgcHJlZGljYXRlKGJ1ZltsZWFkXSkpIGxlYWQrK1xuICB9XG5cbiAgaWYgKHRyYWlsaW5nKSB7XG4gICAgd2hpbGUgKHRyYWlsID4gMCAmJiBwcmVkaWNhdGUoYnVmW3RyYWlsXSkpIHRyYWlsLS1cbiAgfVxuXG4gIHJldHVybiBsZWFkID09PSAwICYmIHRyYWlsID09PSBidWYubGVuZ3RoIC0gMSA/IGJ1ZiA6IGJ1Zi5zdWJhcnJheShsZWFkLCB0cmFpbCArIDEpXG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIHtAcGFyYW0gYnVmZmVyfSBzdGFydHMgd2l0aCB7QHBhcmFtIHN0YXJ0fVxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZmZlclxuICogQHBhcmFtIHtCdWZmZXJ9IHN0YXJ0XG4gKiBAcGFyYW0ge3sgcG9zaXRpb246IG51bWJlciB9fSBwb3NpdGlvblxuICovXG5mdW5jdGlvbiBidWZmZXJTdGFydHNXaXRoIChidWZmZXIsIHN0YXJ0LCBwb3NpdGlvbikge1xuICBpZiAoYnVmZmVyLmxlbmd0aCA8IHN0YXJ0Lmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGFydC5sZW5ndGg7IGkrKykge1xuICAgIGlmIChzdGFydFtpXSAhPT0gYnVmZmVyW3Bvc2l0aW9uLnBvc2l0aW9uICsgaV0pIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBtdWx0aXBhcnRGb3JtRGF0YVBhcnNlcixcbiAgdmFsaWRhdGVCb3VuZGFyeVxufVxuIl0sIm5hbWVzIjpbImlzVVNWU3RyaW5nIiwiYnVmZmVyVG9Mb3dlckNhc2VkSGVhZGVyTmFtZSIsInJlcXVpcmUiLCJ1dGY4RGVjb2RlQnl0ZXMiLCJIVFRQX1RPS0VOX0NPREVQT0lOVFMiLCJpc29tb3JwaGljRGVjb2RlIiwiaXNGaWxlTGlrZSIsIm1ha2VFbnRyeSIsImFzc2VydCIsIkZpbGUiLCJOb2RlRmlsZSIsImdsb2JhbFRoaXMiLCJmb3JtRGF0YU5hbWVCdWZmZXIiLCJCdWZmZXIiLCJmcm9tIiwiZmlsZW5hbWVCdWZmZXIiLCJkZCIsImRkY3JsZiIsImlzQXNjaWlTdHJpbmciLCJjaGFycyIsImkiLCJsZW5ndGgiLCJjaGFyQ29kZUF0IiwidmFsaWRhdGVCb3VuZGFyeSIsImJvdW5kYXJ5IiwiY3AiLCJtdWx0aXBhcnRGb3JtRGF0YVBhcnNlciIsImlucHV0IiwibWltZVR5cGUiLCJlc3NlbmNlIiwiYm91bmRhcnlTdHJpbmciLCJwYXJhbWV0ZXJzIiwiZ2V0IiwidW5kZWZpbmVkIiwiZW50cnlMaXN0IiwicG9zaXRpb24iLCJzdWJhcnJheSIsImVxdWFscyIsImJ1ZmZlclN0YXJ0c1dpdGgiLCJyZXN1bHQiLCJwYXJzZU11bHRpcGFydEZvcm1EYXRhSGVhZGVycyIsIm5hbWUiLCJmaWxlbmFtZSIsImNvbnRlbnRUeXBlIiwiZW5jb2RpbmciLCJib2R5IiwiYm91bmRhcnlJbmRleCIsImluZGV4T2YiLCJ0b1N0cmluZyIsInZhbHVlIiwidHlwZSIsInB1c2giLCJoZWFkZXJOYW1lIiwiY29sbGVjdEFTZXF1ZW5jZU9mQnl0ZXMiLCJjaGFyIiwicmVtb3ZlQ2hhcnMiLCJ0ZXN0IiwicGFyc2VNdWx0aXBhcnRGb3JtRGF0YU5hbWUiLCJjaGVjayIsImhlYWRlclZhbHVlIiwiVGV4dERlY29kZXIiLCJkZWNvZGUiLCJyZXBsYWNlIiwiY29uZGl0aW9uIiwic3RhcnQiLCJidWYiLCJsZWFkaW5nIiwidHJhaWxpbmciLCJwcmVkaWNhdGUiLCJsZWFkIiwidHJhaWwiLCJidWZmZXIiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/fetch/formdata-parser.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/fetch/formdata.js":
/*!*******************************************************!*\
  !*** ./node_modules/undici/lib/web/fetch/formdata.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { isBlobLike, iteratorMixin } = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/undici/lib/web/fetch/util.js\");\nconst { kState } = __webpack_require__(/*! ./symbols */ \"(ssr)/./node_modules/undici/lib/web/fetch/symbols.js\");\nconst { kEnumerableProperty } = __webpack_require__(/*! ../../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\");\nconst { FileLike, isFileLike } = __webpack_require__(/*! ./file */ \"(ssr)/./node_modules/undici/lib/web/fetch/file.js\");\nconst { webidl } = __webpack_require__(/*! ./webidl */ \"(ssr)/./node_modules/undici/lib/web/fetch/webidl.js\");\nconst { File: NativeFile } = __webpack_require__(/*! node:buffer */ \"node:buffer\");\nconst nodeUtil = __webpack_require__(/*! node:util */ \"node:util\");\n/** @type {globalThis['File']} */ const File = globalThis.File ?? NativeFile;\n// https://xhr.spec.whatwg.org/#formdata\nclass FormData {\n    constructor(form){\n        if (form !== undefined) {\n            throw webidl.errors.conversionFailed({\n                prefix: \"FormData constructor\",\n                argument: \"Argument 1\",\n                types: [\n                    \"undefined\"\n                ]\n            });\n        }\n        this[kState] = [];\n    }\n    append(name, value, filename = undefined) {\n        webidl.brandCheck(this, FormData);\n        const prefix = \"FormData.append\";\n        webidl.argumentLengthCheck(arguments, 2, prefix);\n        if (arguments.length === 3 && !isBlobLike(value)) {\n            throw new TypeError(\"Failed to execute 'append' on 'FormData': parameter 2 is not of type 'Blob'\");\n        }\n        // 1. Let value be value if given; otherwise blobValue.\n        name = webidl.converters.USVString(name, prefix, \"name\");\n        value = isBlobLike(value) ? webidl.converters.Blob(value, prefix, \"value\", {\n            strict: false\n        }) : webidl.converters.USVString(value, prefix, \"value\");\n        filename = arguments.length === 3 ? webidl.converters.USVString(filename, prefix, \"filename\") : undefined;\n        // 2. Let entry be the result of creating an entry with\n        // name, value, and filename if given.\n        const entry = makeEntry(name, value, filename);\n        // 3. Append entry to thiss entry list.\n        this[kState].push(entry);\n    }\n    delete(name) {\n        webidl.brandCheck(this, FormData);\n        const prefix = \"FormData.delete\";\n        webidl.argumentLengthCheck(arguments, 1, prefix);\n        name = webidl.converters.USVString(name, prefix, \"name\");\n        // The delete(name) method steps are to remove all entries whose name\n        // is name from thiss entry list.\n        this[kState] = this[kState].filter((entry)=>entry.name !== name);\n    }\n    get(name) {\n        webidl.brandCheck(this, FormData);\n        const prefix = \"FormData.get\";\n        webidl.argumentLengthCheck(arguments, 1, prefix);\n        name = webidl.converters.USVString(name, prefix, \"name\");\n        // 1. If there is no entry whose name is name in thiss entry list,\n        // then return null.\n        const idx = this[kState].findIndex((entry)=>entry.name === name);\n        if (idx === -1) {\n            return null;\n        }\n        // 2. Return the value of the first entry whose name is name from\n        // thiss entry list.\n        return this[kState][idx].value;\n    }\n    getAll(name) {\n        webidl.brandCheck(this, FormData);\n        const prefix = \"FormData.getAll\";\n        webidl.argumentLengthCheck(arguments, 1, prefix);\n        name = webidl.converters.USVString(name, prefix, \"name\");\n        // 1. If there is no entry whose name is name in thiss entry list,\n        // then return the empty list.\n        // 2. Return the values of all entries whose name is name, in order,\n        // from thiss entry list.\n        return this[kState].filter((entry)=>entry.name === name).map((entry)=>entry.value);\n    }\n    has(name) {\n        webidl.brandCheck(this, FormData);\n        const prefix = \"FormData.has\";\n        webidl.argumentLengthCheck(arguments, 1, prefix);\n        name = webidl.converters.USVString(name, prefix, \"name\");\n        // The has(name) method steps are to return true if there is an entry\n        // whose name is name in thiss entry list; otherwise false.\n        return this[kState].findIndex((entry)=>entry.name === name) !== -1;\n    }\n    set(name, value, filename = undefined) {\n        webidl.brandCheck(this, FormData);\n        const prefix = \"FormData.set\";\n        webidl.argumentLengthCheck(arguments, 2, prefix);\n        if (arguments.length === 3 && !isBlobLike(value)) {\n            throw new TypeError(\"Failed to execute 'set' on 'FormData': parameter 2 is not of type 'Blob'\");\n        }\n        // The set(name, value) and set(name, blobValue, filename) method steps\n        // are:\n        // 1. Let value be value if given; otherwise blobValue.\n        name = webidl.converters.USVString(name, prefix, \"name\");\n        value = isBlobLike(value) ? webidl.converters.Blob(value, prefix, \"name\", {\n            strict: false\n        }) : webidl.converters.USVString(value, prefix, \"name\");\n        filename = arguments.length === 3 ? webidl.converters.USVString(filename, prefix, \"name\") : undefined;\n        // 2. Let entry be the result of creating an entry with name, value, and\n        // filename if given.\n        const entry = makeEntry(name, value, filename);\n        // 3. If there are entries in thiss entry list whose name is name, then\n        // replace the first such entry with entry and remove the others.\n        const idx = this[kState].findIndex((entry)=>entry.name === name);\n        if (idx !== -1) {\n            this[kState] = [\n                ...this[kState].slice(0, idx),\n                entry,\n                ...this[kState].slice(idx + 1).filter((entry)=>entry.name !== name)\n            ];\n        } else {\n            // 4. Otherwise, append entry to thiss entry list.\n            this[kState].push(entry);\n        }\n    }\n    [nodeUtil.inspect.custom](depth, options) {\n        const state = this[kState].reduce((a, b)=>{\n            if (a[b.name]) {\n                if (Array.isArray(a[b.name])) {\n                    a[b.name].push(b.value);\n                } else {\n                    a[b.name] = [\n                        a[b.name],\n                        b.value\n                    ];\n                }\n            } else {\n                a[b.name] = b.value;\n            }\n            return a;\n        }, {\n            __proto__: null\n        });\n        options.depth ??= depth;\n        options.colors ??= true;\n        const output = nodeUtil.formatWithOptions(options, state);\n        // remove [Object null prototype]\n        return `FormData ${output.slice(output.indexOf(\"]\") + 2)}`;\n    }\n}\niteratorMixin(\"FormData\", FormData, kState, \"name\", \"value\");\nObject.defineProperties(FormData.prototype, {\n    append: kEnumerableProperty,\n    delete: kEnumerableProperty,\n    get: kEnumerableProperty,\n    getAll: kEnumerableProperty,\n    has: kEnumerableProperty,\n    set: kEnumerableProperty,\n    [Symbol.toStringTag]: {\n        value: \"FormData\",\n        configurable: true\n    }\n});\n/**\n * @see https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#create-an-entry\n * @param {string} name\n * @param {string|Blob} value\n * @param {?string} filename\n * @returns\n */ function makeEntry(name, value, filename) {\n    // 1. Set name to the result of converting name into a scalar value string.\n    // Note: This operation was done by the webidl converter USVString.\n    // 2. If value is a string, then set value to the result of converting\n    //    value into a scalar value string.\n    if (typeof value === \"string\") {\n    // Note: This operation was done by the webidl converter USVString.\n    } else {\n        // 3. Otherwise:\n        // 1. If value is not a File object, then set value to a new File object,\n        //    representing the same bytes, whose name attribute value is \"blob\"\n        if (!isFileLike(value)) {\n            value = value instanceof Blob ? new File([\n                value\n            ], \"blob\", {\n                type: value.type\n            }) : new FileLike(value, \"blob\", {\n                type: value.type\n            });\n        }\n        // 2. If filename is given, then set value to a new File object,\n        //    representing the same bytes, whose name attribute is filename.\n        if (filename !== undefined) {\n            /** @type {FilePropertyBag} */ const options = {\n                type: value.type,\n                lastModified: value.lastModified\n            };\n            value = value instanceof NativeFile ? new File([\n                value\n            ], filename, options) : new FileLike(value, filename, options);\n        }\n    }\n    // 4. Return an entry whose name is name and whose value is value.\n    return {\n        name,\n        value\n    };\n}\nmodule.exports = {\n    FormData,\n    makeEntry\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZmV0Y2gvZm9ybWRhdGEuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNLEVBQUVBLFVBQVUsRUFBRUMsYUFBQUEsRUFBZSxHQUFHQyxtQkFBT0EsQ0FBQztBQUM5QyxNQUFNLEVBQUVDLE1BQUFBLEVBQVEsR0FBR0QsbUJBQU9BLENBQUM7QUFDM0IsTUFBTSxFQUFFRSxtQkFBQUEsRUFBcUIsR0FBR0YsbUJBQU9BLENBQUM7QUFDeEMsTUFBTSxFQUFFRyxRQUFRLEVBQUVDLFVBQUFBLEVBQVksR0FBR0osbUJBQU9BLENBQUM7QUFDekMsTUFBTSxFQUFFSyxNQUFBQSxFQUFRLEdBQUdMLG1CQUFPQSxDQUFDO0FBQzNCLE1BQU0sRUFBRU0sTUFBTUMsVUFBQUEsRUFBWSxHQUFHUCxtQkFBT0EsQ0FBQztBQUNyQyxNQUFNUSxXQUFXUixtQkFBT0EsQ0FBQztBQUV6QixrQ0FDQSxNQUFNTSxPQUFPRyxXQUFXSCxJQUFJLElBQUlDO0FBRWhDO0FBQ0EsTUFBTUc7SUFDSkMsWUFBYUMsSUFBSSxDQUFFO1FBQ2pCLElBQUlBLFNBQVNDLFdBQVc7WUFDdEIsTUFBTVIsT0FBT1MsTUFBTSxDQUFDQyxnQkFBZ0IsQ0FBQztnQkFDbkNDLFFBQVE7Z0JBQ1JDLFVBQVU7Z0JBQ1ZDLE9BQU87b0JBQUM7aUJBQVc7WUFDckI7UUFDRjtRQUVBLElBQUksQ0FBQ2pCLE9BQU8sR0FBRyxFQUFFO0lBQ25CO0lBRUFrQixPQUFRQyxJQUFJLEVBQUVDLEtBQUssRUFBRUMsV0FBV1QsU0FBUyxFQUFFO1FBQ3pDUixPQUFPa0IsVUFBVSxDQUFDLElBQUksRUFBRWI7UUFFeEIsTUFBTU0sU0FBUztRQUNmWCxPQUFPbUIsbUJBQW1CLENBQUNDLFdBQVcsR0FBR1Q7UUFFekMsSUFBSVMsVUFBVUMsTUFBTSxLQUFLLEtBQUssQ0FBQzVCLFdBQVd1QixRQUFRO1lBQ2hELE1BQU0sSUFBSU0sVUFDUjtRQUVKO1FBRUE7UUFFQVAs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QVFBLGlCQUFpQlMsT0FDckIsSUFBSXhCLEtBQUs7Z0JBQUNlO2FBQU0sRUFBRSxRQUFRO2dCQUFFNkMsTUFBTTdDLE1BQU02QyxJQUFBQTtZQUFLLEtBQzdDLElBQUkvRCxTQUFTa0IsT0FBTyxRQUFRO2dCQUFFNkMsTUFBTTdDLE1BQU02QyxJQUFBQTtZQUFLO1FBQ3JEO1FBRUE7UUFDQTtRQUNBLElBQUk1QyxhQUFhVCxXQUFXO1lBQzFCLCtCQUNBLE1BQU1tQyxVQUFVO2dCQUNka0IsTUFBTTdDLE1BQU02QyxJQUFJO2dCQUNoQkMsY0FBYzlDLE1BQU04QyxZQUFBQTtZQUN0QjtZQUVBOUMsUUFBUUEsaUJBQWlCZCxhQUNyQixJQUFJRCxLQUFLO2dCQUFDZTthQUFNLEVBQUVDLFVBQVUwQixXQUM1QixJQUFJN0MsU0FBU2tCLE9BQU9DLFVBQVUwQjtRQUNwQztJQUNGO0lBRUE7SUFDQSxPQUFPO1FBQUU1QjtRQUFNQztJQUFNO0FBQ3ZCO0FBRUErQyxPQUFPQyxPQUFPLEdBQUc7SUFBRTNEO0lBQVV1QjtBQUFVIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbW9ja3VwZmxvdy8uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL3dlYi9mZXRjaC9mb3JtZGF0YS5qcz84N2M0Iiwid2VicGFjazovL21vY2t1cGZsb3cvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZmV0Y2gvZm9ybWRhdGEuanM/ODdjNCoiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgaXNCbG9iTGlrZSwgaXRlcmF0b3JNaXhpbiB9ID0gcmVxdWlyZSgnLi91dGlsJylcbmNvbnN0IHsga1N0YXRlIH0gPSByZXF1aXJlKCcuL3N5bWJvbHMnKVxuY29uc3QgeyBrRW51bWVyYWJsZVByb3BlcnR5IH0gPSByZXF1aXJlKCcuLi8uLi9jb3JlL3V0aWwnKVxuY29uc3QgeyBGaWxlTGlrZSwgaXNGaWxlTGlrZSB9ID0gcmVxdWlyZSgnLi9maWxlJylcbmNvbnN0IHsgd2ViaWRsIH0gPSByZXF1aXJlKCcuL3dlYmlkbCcpXG5jb25zdCB7IEZpbGU6IE5hdGl2ZUZpbGUgfSA9IHJlcXVpcmUoJ25vZGU6YnVmZmVyJylcbmNvbnN0IG5vZGVVdGlsID0gcmVxdWlyZSgnbm9kZTp1dGlsJylcblxuLyoqIEB0eXBlIHtnbG9iYWxUaGlzWydGaWxlJ119ICovXG5jb25zdCBGaWxlID0gZ2xvYmFsVGhpcy5GaWxlID8/IE5hdGl2ZUZpbGVcblxuLy8gaHR0cHM6Ly94aHIuc3BlYy53aGF0d2cub3JnLyNmb3JtZGF0YVxuY2xhc3MgRm9ybURhdGEge1xuICBjb25zdHJ1Y3RvciAoZm9ybSkge1xuICAgIGlmIChmb3JtICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IHdlYmlkbC5lcnJvcnMuY29udmVyc2lvbkZhaWxlZCh7XG4gICAgICAgIHByZWZpeDogJ0Zvcm1EYXRhIGNvbnN0cnVjdG9yJyxcbiAgICAgICAgYXJndW1lbnQ6ICdBcmd1bWVudCAxJyxcbiAgICAgICAgdHlwZXM6IFsndW5kZWZpbmVkJ11cbiAgICAgIH0pXG4gICAgfVxuXG4gICAgdGhpc1trU3RhdGVdID0gW11cbiAgfVxuXG4gIGFwcGVuZCAobmFtZSwgdmFsdWUsIGZpbGVuYW1lID0gdW5kZWZpbmVkKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRm9ybURhdGEpXG5cbiAgICBjb25zdCBwcmVmaXggPSAnRm9ybURhdGEuYXBwZW5kJ1xuICAgIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMiwgcHJlZml4KVxuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMgJiYgIWlzQmxvYkxpa2UodmFsdWUpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICBcIkZhaWxlZCB0byBleGVjdXRlICdhcHBlbmQnIG9uICdGb3JtRGF0YSc6IHBhcmFtZXRlciAyIGlzIG5vdCBvZiB0eXBlICdCbG9iJ1wiXG4gICAgICApXG4gICAgfVxuXG4gICAgLy8gMS4gTGV0IHZhbHVlIGJlIHZhbHVlIGlmIGdpdmVuOyBvdGhlcndpc2UgYmxvYlZhbHVlLlxuXG4gICAgbmFtZSA9IHdlYmlkbC5jb252ZXJ0ZXJzLlVTVlN0cmluZyhuYW1lLCBwcmVmaXgsICduYW1lJylcbiAgICB2YWx1ZSA9IGlzQmxvYkxpa2UodmFsdWUpXG4gICAgICA/IHdlYmlkbC5jb252ZXJ0ZXJzLkJsb2IodmFsdWUsIHByZWZpeCwgJ3ZhbHVlJywgeyBzdHJpY3Q6IGZhbHNlIH0pXG4gICAgICA6IHdlYmlkbC5jb252ZXJ0ZXJzLlVTVlN0cmluZyh2YWx1ZSwgcHJlZml4LCAndmFsdWUnKVxuICAgIGZpbGVuYW1lID0gYXJndW1lbnRzLmxlbmd0aCA9PT0gM1xuICAgICAgPyB3ZWJpZGwuY29udmVydGVycy5VU1ZTdHJpbmcoZmlsZW5hbWUsIHByZWZpeCwgJ2ZpbGVuYW1lJylcbiAgICAgIDogdW5kZWZpbmVkXG5cbiAgICAvLyAyLiBMZXQgZW50cnkgYmUgdGhlIHJlc3VsdCBvZiBjcmVhdGluZyBhbiBlbnRyeSB3aXRoXG4gICAgLy8gbmFtZSwgdmFsdWUsIGFuZCBmaWxlbmFtZSBpZiBnaXZlbi5cbiAgICBjb25zdCBlbnRyeSA9IG1ha2VFbnRyeShuYW1lLCB2YWx1ZSwgZmlsZW5hbWUpXG5cbiAgICAvLyAzLiBBcHBlbmQgZW50cnkgdG8gdGhpc+KAmXMgZW50cnkgbGlzdC5cbiAgICB0aGlzW2tTdGF0ZV0ucHVzaChlbnRyeSlcbiAgfVxuXG4gIGRlbGV0ZSAobmFtZSkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEZvcm1EYXRhKVxuXG4gICAgY29uc3QgcHJlZml4ID0gJ0Zvcm1EYXRhLmRlbGV0ZSdcbiAgICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDEsIHByZWZpeClcblxuICAgIG5hbWUgPSB3ZWJpZGwuY29udmVydGVycy5VU1ZTdHJpbmcobmFtZSwgcHJlZml4LCAnbmFtZScpXG5cbiAgICAvLyBUaGUgZGVsZXRlKG5hbWUpIG1ldGhvZCBzdGVwcyBhcmUgdG8gcmVtb3ZlIGFsbCBlbnRyaWVzIHdob3NlIG5hbWVcbiAgICAvLyBpcyBuYW1lIGZyb20gdGhpc+KAmXMgZW50cnkgbGlzdC5cbiAgICB0aGlzW2tTdGF0ZV0gPSB0aGlzW2tTdGF0ZV0uZmlsdGVyKGVudHJ5ID0+IGVudHJ5Lm5hbWUgIT09IG5hbWUpXG4gIH1cblxuICBnZXQgKG5hbWUpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBGb3JtRGF0YSlcblxuICAgIGNvbnN0IHByZWZpeCA9ICdGb3JtRGF0YS5nZXQnXG4gICAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAxLCBwcmVmaXgpXG5cbiAgICBuYW1lID0gd2ViaWRsLmNvbnZlcnRlcnMuVVNWU3RyaW5nKG5hbWUsIHByZWZpeCwgJ25hbWUnKVxuXG4gICAgLy8gMS4gSWYgdGhlcmUgaXMgbm8gZW50cnkgd2hvc2UgbmFtZSBpcyBuYW1lIGluIHRoaXPigJlzIGVudHJ5IGxpc3QsXG4gICAgLy8gdGhlbiByZXR1cm4gbnVsbC5cbiAgICBjb25zdCBpZHggPSB0aGlzW2tTdGF0ZV0uZmluZEluZGV4KChlbnRyeSkgPT4gZW50cnkubmFtZSA9PT0gbmFtZSlcbiAgICBpZiAoaWR4ID09PSAtMSkge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICAvLyAyLiBSZXR1cm4gdGhlIHZhbHVlIG9mIHRoZSBmaXJzdCBlbnRyeSB3aG9zZSBuYW1lIGlzIG5hbWUgZnJvbVxuICAgIC8vIHRoaXPigJlzIGVudHJ5IGxpc3QuXG4gICAgcmV0dXJuIHRoaXNba1N0YXRlXVtpZHhdLnZhbHVlXG4gIH1cblxuICBnZXRBbGwgKG5hbWUpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBGb3JtRGF0YSlcblxuICAgIGNvbnN0IHByZWZpeCA9ICdGb3JtRGF0YS5nZXRBbGwnXG4gICAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAxLCBwcmVmaXgpXG5cbiAgICBuYW1lID0gd2ViaWRsLmNvbnZlcnRlcnMuVVNWU3RyaW5nKG5hbWUsIHByZWZpeCwgJ25hbWUnKVxuXG4gICAgLy8gMS4gSWYgdGhlcmUgaXMgbm8gZW50cnkgd2hvc2UgbmFtZSBpcyBuYW1lIGluIHRoaXPigJlzIGVudHJ5IGxpc3QsXG4gICAgLy8gdGhlbiByZXR1cm4gdGhlIGVtcHR5IGxpc3QuXG4gICAgLy8gMi4gUmV0dXJuIHRoZSB2YWx1ZXMgb2YgYWxsIGVudHJpZXMgd2hvc2UgbmFtZSBpcyBuYW1lLCBpbiBvcmRlcixcbiAgICAvLyBmcm9tIHRoaXPigJlzIGVudHJ5IGxpc3QuXG4gICAgcmV0dXJuIHRoaXNba1N0YXRlXVxuICAgICAgLmZpbHRlcigoZW50cnkpID0+IGVudHJ5Lm5hbWUgPT09IG5hbWUpXG4gICAgICAubWFwKChlbnRyeSkgPT4gZW50cnkudmFsdWUpXG4gIH1cblxuICBoYXMgKG5hbWUpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBGb3JtRGF0YSlcblxuICAgIGNvbnN0IHByZWZpeCA9ICdGb3JtRGF0YS5oYXMnXG4gICAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAxLCBwcmVmaXgpXG5cbiAgICBuYW1lID0gd2ViaWRsLmNvbnZlcnRlcnMuVVNWU3RyaW5nKG5hbWUsIHByZWZpeCwgJ25hbWUnKVxuXG4gICAgLy8gVGhlIGhhcyhuYW1lKSBtZXRob2Qgc3RlcHMgYXJlIHRvIHJldHVybiB0cnVlIGlmIHRoZXJlIGlzIGFuIGVudHJ5XG4gICAgLy8gd2hvc2UgbmFtZSBpcyBuYW1lIGluIHRoaXPigJlzIGVudHJ5IGxpc3Q7IG90aGVyd2lzZSBmYWxzZS5cbiAgICByZXR1cm4gdGhpc1trU3RhdGVdLmZpbmRJbmRleCgoZW50cnkpID0+IGVudHJ5Lm5hbWUgPT09IG5hbWUpICE9PSAtMVxuICB9XG5cbiAgc2V0IChuYW1lLCB2YWx1ZSwgZmlsZW5hbWUgPSB1bmRlZmluZWQpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBGb3JtRGF0YSlcblxuICAgIGNvbnN0IHByZWZpeCA9ICdGb3JtRGF0YS5zZXQnXG4gICAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAyLCBwcmVmaXgpXG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMyAmJiAhaXNCbG9iTGlrZSh2YWx1ZSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgIFwiRmFpbGVkIHRvIGV4ZWN1dGUgJ3NldCcgb24gJ0Zvcm1EYXRhJzogcGFyYW1ldGVyIDIgaXMgbm90IG9mIHR5cGUgJ0Jsb2InXCJcbiAgICAgIClcbiAgICB9XG5cbiAgICAvLyBUaGUgc2V0KG5hbWUsIHZhbHVlKSBhbmQgc2V0KG5hbWUsIGJsb2JWYWx1ZSwgZmlsZW5hbWUpIG1ldGhvZCBzdGVwc1xuICAgIC8vIGFyZTpcblxuICAgIC8vIDEuIExldCB2YWx1ZSBiZSB2YWx1ZSBpZiBnaXZlbjsgb3RoZXJ3aXNlIGJsb2JWYWx1ZS5cblxuICAgIG5hbWUgPSB3ZWJpZGwuY29udmVydGVycy5VU1ZTdHJpbmcobmFtZSwgcHJlZml4LCAnbmFtZScpXG4gICAgdmFsdWUgPSBpc0Jsb2JMaWtlKHZhbHVlKVxuICAgICAgPyB3ZWJpZGwuY29udmVydGVycy5CbG9iKHZhbHVlLCBwcmVmaXgsICduYW1lJywgeyBzdHJpY3Q6IGZhbHNlIH0pXG4gICAgICA6IHdlYmlkbC5jb252ZXJ0ZXJzLlVTVlN0cmluZyh2YWx1ZSwgcHJlZml4LCAnbmFtZScpXG4gICAgZmlsZW5hbWUgPSBhcmd1bWVudHMubGVuZ3RoID09PSAzXG4gICAgICA/IHdlYmlkbC5jb252ZXJ0ZXJzLlVTVlN0cmluZyhmaWxlbmFtZSwgcHJlZml4LCAnbmFtZScpXG4gICAgICA6IHVuZGVmaW5lZFxuXG4gICAgLy8gMi4gTGV0IGVudHJ5IGJlIHRoZSByZXN1bHQgb2YgY3JlYXRpbmcgYW4gZW50cnkgd2l0aCBuYW1lLCB2YWx1ZSwgYW5kXG4gICAgLy8gZmlsZW5hbWUgaWYgZ2l2ZW4uXG4gICAgY29uc3QgZW50cnkgPSBtYWtlRW50cnkobmFtZSwgdmFsdWUsIGZpbGVuYW1lKVxuXG4gICAgLy8gMy4gSWYgdGhlcmUgYXJlIGVudHJpZXMgaW4gdGhpc+KAmXMgZW50cnkgbGlzdCB3aG9zZSBuYW1lIGlzIG5hbWUsIHRoZW5cbiAgICAvLyByZXBsYWNlIHRoZSBmaXJzdCBzdWNoIGVudHJ5IHdpdGggZW50cnkgYW5kIHJlbW92ZSB0aGUgb3RoZXJzLlxuICAgIGNvbnN0IGlkeCA9IHRoaXNba1N0YXRlXS5maW5kSW5kZXgoKGVudHJ5KSA9PiBlbnRyeS5uYW1lID09PSBuYW1lKVxuICAgIGlmIChpZHggIT09IC0xKSB7XG4gICAgICB0aGlzW2tTdGF0ZV0gPSBbXG4gICAgICAgIC4uLnRoaXNba1N0YXRlXS5zbGljZSgwLCBpZHgpLFxuICAgICAgICBlbnRyeSxcbiAgICAgICAgLi4udGhpc1trU3RhdGVdLnNsaWNlKGlkeCArIDEpLmZpbHRlcigoZW50cnkpID0+IGVudHJ5Lm5hbWUgIT09IG5hbWUpXG4gICAgICBdXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIDQuIE90aGVyd2lzZSwgYXBwZW5kIGVudHJ5IHRvIHRoaXPigJlzIGVudHJ5IGxpc3QuXG4gICAgICB0aGlzW2tTdGF0ZV0ucHVzaChlbnRyeSlcbiAgICB9XG4gIH1cblxuICBbbm9kZVV0aWwuaW5zcGVjdC5jdXN0b21dIChkZXB0aCwgb3B0aW9ucykge1xuICAgIGNvbnN0IHN0YXRlID0gdGhpc1trU3RhdGVdLnJlZHVjZSgoYSwgYikgPT4ge1xuICAgICAgaWYgKGFbYi5uYW1lXSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhW2IubmFtZV0pKSB7XG4gICAgICAgICAgYVtiLm5hbWVdLnB1c2goYi52YWx1ZSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhW2IubmFtZV0gPSBbYVtiLm5hbWVdLCBiLnZhbHVlXVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhW2IubmFtZV0gPSBiLnZhbHVlXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhXG4gICAgfSwgeyBfX3Byb3RvX186IG51bGwgfSlcblxuICAgIG9wdGlvbnMuZGVwdGggPz89IGRlcHRoXG4gICAgb3B0aW9ucy5jb2xvcnMgPz89IHRydWVcblxuICAgIGNvbnN0IG91dHB1dCA9IG5vZGVVdGlsLmZvcm1hdFdpdGhPcHRpb25zKG9wdGlvbnMsIHN0YXRlKVxuXG4gICAgLy8gcmVtb3ZlIFtPYmplY3QgbnVsbCBwcm90b3R5cGVdXG4gICAgcmV0dXJuIGBGb3JtRGF0YSAke291dHB1dC5zbGljZShvdXRwdXQuaW5kZXhPZignXScpICsgMil9YFxuICB9XG59XG5cbml0ZXJhdG9yTWl4aW4oJ0Zvcm1EYXRhJywgRm9ybURhdGEsIGtTdGF0ZSwgJ25hbWUnLCAndmFsdWUnKVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhGb3JtRGF0YS5wcm90b3R5cGUsIHtcbiAgYXBwZW5kOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBkZWxldGU6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGdldDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgZ2V0QWxsOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBoYXM6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIHNldDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgW1N5bWJvbC50b1N0cmluZ1RhZ106IHtcbiAgICB2YWx1ZTogJ0Zvcm1EYXRhJyxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfVxufSlcblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Zvcm0tY29udHJvbC1pbmZyYXN0cnVjdHVyZS5odG1sI2NyZWF0ZS1hbi1lbnRyeVxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7c3RyaW5nfEJsb2J9IHZhbHVlXG4gKiBAcGFyYW0gez9zdHJpbmd9IGZpbGVuYW1lXG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiBtYWtlRW50cnkgKG5hbWUsIHZhbHVlLCBmaWxlbmFtZSkge1xuICAvLyAxLiBTZXQgbmFtZSB0byB0aGUgcmVzdWx0IG9mIGNvbnZlcnRpbmcgbmFtZSBpbnRvIGEgc2NhbGFyIHZhbHVlIHN0cmluZy5cbiAgLy8gTm90ZTogVGhpcyBvcGVyYXRpb24gd2FzIGRvbmUgYnkgdGhlIHdlYmlkbCBjb252ZXJ0ZXIgVVNWU3RyaW5nLlxuXG4gIC8vIDIuIElmIHZhbHVlIGlzIGEgc3RyaW5nLCB0aGVuIHNldCB2YWx1ZSB0byB0aGUgcmVzdWx0IG9mIGNvbnZlcnRpbmdcbiAgLy8gICAgdmFsdWUgaW50byBhIHNjYWxhciB2YWx1ZSBzdHJpbmcuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgLy8gTm90ZTogVGhpcyBvcGVyYXRpb24gd2FzIGRvbmUgYnkgdGhlIHdlYmlkbCBjb252ZXJ0ZXIgVVNWU3RyaW5nLlxuICB9IGVsc2Uge1xuICAgIC8vIDMuIE90aGVyd2lzZTpcblxuICAgIC8vIDEuIElmIHZhbHVlIGlzIG5vdCBhIEZpbGUgb2JqZWN0LCB0aGVuIHNldCB2YWx1ZSB0byBhIG5ldyBGaWxlIG9iamVjdCxcbiAgICAvLyAgICByZXByZXNlbnRpbmcgdGhlIHNhbWUgYnl0ZXMsIHdob3NlIG5hbWUgYXR0cmlidXRlIHZhbHVlIGlzIFwiYmxvYlwiXG4gICAgaWYgKCFpc0ZpbGVMaWtlKHZhbHVlKSkge1xuICAgICAgdmFsdWUgPSB2YWx1ZSBpbnN0YW5jZW9mIEJsb2JcbiAgICAgICAgPyBuZXcgRmlsZShbdmFsdWVdLCAnYmxvYicsIHsgdHlwZTogdmFsdWUudHlwZSB9KVxuICAgICAgICA6IG5ldyBGaWxlTGlrZSh2YWx1ZSwgJ2Jsb2InLCB7IHR5cGU6IHZhbHVlLnR5cGUgfSlcbiAgICB9XG5cbiAgICAvLyAyLiBJZiBmaWxlbmFtZSBpcyBnaXZlbiwgdGhlbiBzZXQgdmFsdWUgdG8gYSBuZXcgRmlsZSBvYmplY3QsXG4gICAgLy8gICAgcmVwcmVzZW50aW5nIHRoZSBzYW1lIGJ5dGVzLCB3aG9zZSBuYW1lIGF0dHJpYnV0ZSBpcyBmaWxlbmFtZS5cbiAgICBpZiAoZmlsZW5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgLyoqIEB0eXBlIHtGaWxlUHJvcGVydHlCYWd9ICovXG4gICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICB0eXBlOiB2YWx1ZS50eXBlLFxuICAgICAgICBsYXN0TW9kaWZpZWQ6IHZhbHVlLmxhc3RNb2RpZmllZFxuICAgICAgfVxuXG4gICAgICB2YWx1ZSA9IHZhbHVlIGluc3RhbmNlb2YgTmF0aXZlRmlsZVxuICAgICAgICA/IG5ldyBGaWxlKFt2YWx1ZV0sIGZpbGVuYW1lLCBvcHRpb25zKVxuICAgICAgICA6IG5ldyBGaWxlTGlrZSh2YWx1ZSwgZmlsZW5hbWUsIG9wdGlvbnMpXG4gICAgfVxuICB9XG5cbiAgLy8gNC4gUmV0dXJuIGFuIGVudHJ5IHdob3NlIG5hbWUgaXMgbmFtZSBhbmQgd2hvc2UgdmFsdWUgaXMgdmFsdWUuXG4gIHJldHVybiB7IG5hbWUsIHZhbHVlIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7IEZvcm1EYXRhLCBtYWtlRW50cnkgfVxuIl0sIm5hbWVzIjpbImlzQmxvYkxpa2UiLCJpdGVyYXRvck1peGluIiwicmVxdWlyZSIsImtTdGF0ZSIsImtFbnVtZXJhYmxlUHJvcGVydHkiLCJGaWxlTGlrZSIsImlzRmlsZUxpa2UiLCJ3ZWJpZGwiLCJGaWxlIiwiTmF0aXZlRmlsZSIsIm5vZGVVdGlsIiwiZ2xvYmFsVGhpcyIsIkZvcm1EYXRhIiwiY29uc3RydWN0b3IiLCJmb3JtIiwidW5kZWZpbmVkIiwiZXJyb3JzIiwiY29udmVyc2lvbkZhaWxlZCIsInByZWZpeCIsImFyZ3VtZW50IiwidHlwZXMiLCJhcHBlbmQiLCJuYW1lIiwidmFsdWUiLCJmaWxlbmFtZSIsImJyYW5kQ2hlY2siLCJhcmd1bWVudExlbmd0aENoZWNrIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwiVHlwZUVycm9yIiwiY29udmVydGVycyIsIlVTVlN0cmluZyIsIkJsb2IiLCJzdHJpY3QiLCJlbnRyeSIsIm1ha2VFbnRyeSIsInB1c2giLCJkZWxldGUiLCJmaWx0ZXIiLCJnZXQiLCJpZHgiLCJmaW5kSW5kZXgiLCJnZXRBbGwiLCJtYXAiLCJoYXMiLCJzZXQiLCJzbGljZSIsImluc3BlY3QiLCJjdXN0b20iLCJkZXB0aCIsIm9wdGlvbnMiLCJzdGF0ZSIsInJlZHVjZSIsImEiLCJiIiwiQXJyYXkiLCJpc0FycmF5IiwiX19wcm90b19fIiwiY29sb3JzIiwib3V0cHV0IiwiZm9ybWF0V2l0aE9wdGlvbnMiLCJpbmRleE9mIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydGllcyIsInByb3RvdHlwZSIsIlN5bWJvbCIsInRvU3RyaW5nVGFnIiwiY29uZmlndXJhYmxlIiwidHlwZSIsImxhc3RNb2RpZmllZCIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/fetch/formdata.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/fetch/global.js":
/*!*****************************************************!*\
  !*** ./node_modules/undici/lib/web/fetch/global.js ***!
  \*****************************************************/
/***/ ((module) => {

eval("\n// In case of breaking changes, increase the version\n// number to avoid conflicts.\nconst globalOrigin = Symbol.for(\"undici.globalOrigin.1\");\nfunction getGlobalOrigin() {\n    return globalThis[globalOrigin];\n}\nfunction setGlobalOrigin(newOrigin) {\n    if (newOrigin === undefined) {\n        Object.defineProperty(globalThis, globalOrigin, {\n            value: undefined,\n            writable: true,\n            enumerable: false,\n            configurable: false\n        });\n        return;\n    }\n    const parsedURL = new URL(newOrigin);\n    if (parsedURL.protocol !== \"http:\" && parsedURL.protocol !== \"https:\") {\n        throw new TypeError(`Only http & https urls are allowed, received ${parsedURL.protocol}`);\n    }\n    Object.defineProperty(globalThis, globalOrigin, {\n        value: parsedURL,\n        writable: true,\n        enumerable: false,\n        configurable: false\n    });\n}\nmodule.exports = {\n    getGlobalOrigin,\n    setGlobalOrigin\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZmV0Y2gvZ2xvYmFsLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUE7QUFDQTtBQUNBLE1BQU1BLGVBQWVDLE9BQU9DLEdBQUcsQ0FBQztBQUVoQyxTQUFTQztJQUNQLE9BQU9DLFVBQVUsQ0FBQ0osYUFBYTtBQUNqQztBQUVBLFNBQVNLLGdCQUFpQkMsU0FBUztJQUNqQyxJQUFJQSxjQUFjQyxXQUFXO1FBQzNCQyxPQUFPQyxjQUFjLENBQUNMLFlBQVlKLGNBQWM7WUFDOUNVLE9BQU9IO1lBQ1BJLFVBQVU7WUFDVkMsWUFBWTtZQUNaQyxjQUFjO1FBQ2hCO1FBRUE7SUFDRjtJQUVBLE1BQU1DLFlBQVksSUFBSUMsSUFBSVQ7SUFFMUIsSUFBSVEsVUFBVUUsUUFBUSxLQUFLLFdBQVdGLFVBQVVFLFFBQVEsS0FBSyxVQUFVO1FBQ3JFLE1BQU0sSUFBSUMsVUFBVSxnREFBZ0RILFVBQVVFLFFBQVEsRUFBRTtJQUMxRjtJQUVBUixPQUFPQyxjQUFjLENBQUNMLFlBQVlKLGNBQWM7UUFDOUNVLE9BQU9JO1FBQ1BILFVBQVU7UUFDVkMsWUFBWTtRQUNaQyxjQUFjO0lBQ2hCO0FBQ0Y7QUFFQUssT0FBT0MsT0FBTyxHQUFHO0lBQ2ZoQjtJQUNBRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbW9ja3VwZmxvdy8uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL3dlYi9mZXRjaC9nbG9iYWwuanM/MTRiMyIsIndlYnBhY2s6Ly9tb2NrdXBmbG93Ly4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvd2ViL2ZldGNoL2dsb2JhbC5qcz8xNGIzKiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuLy8gSW4gY2FzZSBvZiBicmVha2luZyBjaGFuZ2VzLCBpbmNyZWFzZSB0aGUgdmVyc2lvblxuLy8gbnVtYmVyIHRvIGF2b2lkIGNvbmZsaWN0cy5cbmNvbnN0IGdsb2JhbE9yaWdpbiA9IFN5bWJvbC5mb3IoJ3VuZGljaS5nbG9iYWxPcmlnaW4uMScpXG5cbmZ1bmN0aW9uIGdldEdsb2JhbE9yaWdpbiAoKSB7XG4gIHJldHVybiBnbG9iYWxUaGlzW2dsb2JhbE9yaWdpbl1cbn1cblxuZnVuY3Rpb24gc2V0R2xvYmFsT3JpZ2luIChuZXdPcmlnaW4pIHtcbiAgaWYgKG5ld09yaWdpbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGdsb2JhbFRoaXMsIGdsb2JhbE9yaWdpbiwge1xuICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlXG4gICAgfSlcblxuICAgIHJldHVyblxuICB9XG5cbiAgY29uc3QgcGFyc2VkVVJMID0gbmV3IFVSTChuZXdPcmlnaW4pXG5cbiAgaWYgKHBhcnNlZFVSTC5wcm90b2NvbCAhPT0gJ2h0dHA6JyAmJiBwYXJzZWRVUkwucHJvdG9jb2wgIT09ICdodHRwczonKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgT25seSBodHRwICYgaHR0cHMgdXJscyBhcmUgYWxsb3dlZCwgcmVjZWl2ZWQgJHtwYXJzZWRVUkwucHJvdG9jb2x9YClcbiAgfVxuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShnbG9iYWxUaGlzLCBnbG9iYWxPcmlnaW4sIHtcbiAgICB2YWx1ZTogcGFyc2VkVVJMLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogZmFsc2VcbiAgfSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGdldEdsb2JhbE9yaWdpbixcbiAgc2V0R2xvYmFsT3JpZ2luXG59XG4iXSwibmFtZXMiOlsiZ2xvYmFsT3JpZ2luIiwiU3ltYm9sIiwiZm9yIiwiZ2V0R2xvYmFsT3JpZ2luIiwiZ2xvYmFsVGhpcyIsInNldEdsb2JhbE9yaWdpbiIsIm5ld09yaWdpbiIsInVuZGVmaW5lZCIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwidmFsdWUiLCJ3cml0YWJsZSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJwYXJzZWRVUkwiLCJVUkwiLCJwcm90b2NvbCIsIlR5cGVFcnJvciIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/fetch/global.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/fetch/headers.js":
/*!******************************************************!*\
  !*** ./node_modules/undici/lib/web/fetch/headers.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// https://github.com/Ethan-Arrowood/undici-fetch\n\nconst { kConstruct } = __webpack_require__(/*! ../../core/symbols */ \"(ssr)/./node_modules/undici/lib/core/symbols.js\");\nconst { kEnumerableProperty } = __webpack_require__(/*! ../../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\");\nconst { iteratorMixin, isValidHeaderName, isValidHeaderValue } = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/undici/lib/web/fetch/util.js\");\nconst { webidl } = __webpack_require__(/*! ./webidl */ \"(ssr)/./node_modules/undici/lib/web/fetch/webidl.js\");\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\");\nconst util = __webpack_require__(/*! node:util */ \"node:util\");\nconst kHeadersMap = Symbol(\"headers map\");\nconst kHeadersSortedMap = Symbol(\"headers map sorted\");\n/**\n * @param {number} code\n */ function isHTTPWhiteSpaceCharCode(code) {\n    return code === 0x00a || code === 0x00d || code === 0x009 || code === 0x020;\n}\n/**\n * @see https://fetch.spec.whatwg.org/#concept-header-value-normalize\n * @param {string} potentialValue\n */ function headerValueNormalize(potentialValue) {\n    //  To normalize a byte sequence potentialValue, remove\n    //  any leading and trailing HTTP whitespace bytes from\n    //  potentialValue.\n    let i = 0;\n    let j = potentialValue.length;\n    while(j > i && isHTTPWhiteSpaceCharCode(potentialValue.charCodeAt(j - 1)))--j;\n    while(j > i && isHTTPWhiteSpaceCharCode(potentialValue.charCodeAt(i)))++i;\n    return i === 0 && j === potentialValue.length ? potentialValue : potentialValue.substring(i, j);\n}\nfunction fill(headers, object) {\n    // To fill a Headers object headers with a given object object, run these steps:\n    // 1. If object is a sequence, then for each header in object:\n    // Note: webidl conversion to array has already been done.\n    if (Array.isArray(object)) {\n        for(let i = 0; i < object.length; ++i){\n            const header = object[i];\n            // 1. If header does not contain exactly two items, then throw a TypeError.\n            if (header.length !== 2) {\n                throw webidl.errors.exception({\n                    header: \"Headers constructor\",\n                    message: `expected name/value pair to be length 2, found ${header.length}.`\n                });\n            }\n            // 2. Append (headers first item, headers second item) to headers.\n            appendHeader(headers, header[0], header[1]);\n        }\n    } else if (typeof object === \"object\" && object !== null) {\n        // Note: null should throw\n        // 2. Otherwise, object is a record, then for each key  value in object,\n        //    append (key, value) to headers\n        const keys = Object.keys(object);\n        for(let i = 0; i < keys.length; ++i){\n            appendHeader(headers, keys[i], object[keys[i]]);\n        }\n    } else {\n        throw webidl.errors.conversionFailed({\n            prefix: \"Headers constructor\",\n            argument: \"Argument 1\",\n            types: [\n                \"sequence<sequence<ByteString>>\",\n                \"record<ByteString, ByteString>\"\n            ]\n        });\n    }\n}\n/**\n * @see https://fetch.spec.whatwg.org/#concept-headers-append\n */ function appendHeader(headers, name, value) {\n    // 1. Normalize value.\n    value = headerValueNormalize(value);\n    // 2. If name is not a header name or value is not a\n    //    header value, then throw a TypeError.\n    if (!isValidHeaderName(name)) {\n        throw webidl.errors.invalidArgument({\n            prefix: \"Headers.append\",\n            value: name,\n            type: \"header name\"\n        });\n    } else if (!isValidHeaderValue(value)) {\n        throw webidl.errors.invalidArgument({\n            prefix: \"Headers.append\",\n            value,\n            type: \"header value\"\n        });\n    }\n    // 3. If headerss guard is \"immutable\", then throw a TypeError.\n    // 4. Otherwise, if headerss guard is \"request\" and name is a\n    //    forbidden header name, return.\n    // 5. Otherwise, if headerss guard is \"request-no-cors\":\n    //    TODO\n    // Note: undici does not implement forbidden header names\n    if (getHeadersGuard(headers) === \"immutable\") {\n        throw new TypeError(\"immutable\");\n    }\n    // 6. Otherwise, if headerss guard is \"response\" and name is a\n    //    forbidden response-header name, return.\n    // 7. Append (name, value) to headerss header list.\n    return getHeadersList(headers).append(name, value, false);\n// 8. If headerss guard is \"request-no-cors\", then remove\n//    privileged no-CORS request headers from headers\n}\nfunction compareHeaderName(a, b) {\n    return a[0] < b[0] ? -1 : 1;\n}\nclass HeadersList {\n    constructor(init){\n        /** @type {[string, string][]|null} */ this.cookies = null;\n        if (init instanceof HeadersList) {\n            this[kHeadersMap] = new Map(init[kHeadersMap]);\n            this[kHeadersSortedMap] = init[kHeadersSortedMap];\n            this.cookies = init.cookies === null ? null : [\n                ...init.cookies\n            ];\n        } else {\n            this[kHeadersMap] = new Map(init);\n            this[kHeadersSortedMap] = null;\n        }\n    }\n    /**\n   * @see https://fetch.spec.whatwg.org/#header-list-contains\n   * @param {string} name\n   * @param {boolean} isLowerCase\n   */ contains(name, isLowerCase) {\n        // A header list list contains a header name name if list\n        // contains a header whose name is a byte-case-insensitive\n        // match for name.\n        return this[kHeadersMap].has(isLowerCase ? name : name.toLowerCase());\n    }\n    clear() {\n        this[kHeadersMap].clear();\n        this[kHeadersSortedMap] = null;\n        this.cookies = null;\n    }\n    /**\n   * @see https://fetch.spec.whatwg.org/#concept-header-list-append\n   * @param {string} name\n   * @param {string} value\n   * @param {boolean} isLowerCase\n   */ append(name, value, isLowerCase) {\n        this[kHeadersSortedMap] = null;\n        // 1. If list contains name, then set name to the first such\n        //    headers name.\n        const lowercaseName = isLowerCase ? name : name.toLowerCase();\n        const exists = this[kHeadersMap].get(lowercaseName);\n        // 2. Append (name, value) to list.\n        if (exists) {\n            const delimiter = lowercaseName === \"cookie\" ? \"; \" : \", \";\n            this[kHeadersMap].set(lowercaseName, {\n                name: exists.name,\n                value: `${exists.value}${delimiter}${value}`\n            });\n        } else {\n            this[kHeadersMap].set(lowercaseName, {\n                name,\n                value\n            });\n        }\n        if (lowercaseName === \"set-cookie\") {\n            (this.cookies ??= []).push(value);\n        }\n    }\n    /**\n   * @see https://fetch.spec.whatwg.org/#concept-header-list-set\n   * @param {string} name\n   * @param {string} value\n   * @param {boolean} isLowerCase\n   */ set(name, value, isLowerCase) {\n        this[kHeadersSortedMap] = null;\n        const lowercaseName = isLowerCase ? name : name.toLowerCase();\n        if (lowercaseName === \"set-cookie\") {\n            this.cookies = [\n                value\n            ];\n        }\n        // 1. If list contains name, then set the value of\n        //    the first such header to value and remove the\n        //    others.\n        // 2. Otherwise, append header (name, value) to list.\n        this[kHeadersMap].set(lowercaseName, {\n            name,\n            value\n        });\n    }\n    /**\n   * @see https://fetch.spec.whatwg.org/#concept-header-list-delete\n   * @param {string} name\n   * @param {boolean} isLowerCase\n   */ delete(name, isLowerCase) {\n        this[kHeadersSortedMap] = null;\n        if (!isLowerCase) name = name.toLowerCase();\n        if (name === \"set-cookie\") {\n            this.cookies = null;\n        }\n        this[kHeadersMap].delete(name);\n    }\n    /**\n   * @see https://fetch.spec.whatwg.org/#concept-header-list-get\n   * @param {string} name\n   * @param {boolean} isLowerCase\n   * @returns {string | null}\n   */ get(name, isLowerCase) {\n        // 1. If list does not contain name, then return null.\n        // 2. Return the values of all headers in list whose name\n        //    is a byte-case-insensitive match for name,\n        //    separated from each other by 0x2C 0x20, in order.\n        return this[kHeadersMap].get(isLowerCase ? name : name.toLowerCase())?.value ?? null;\n    }\n    *[Symbol.iterator]() {\n        // use the lowercased name\n        for (const { 0: name, 1: { value } } of this[kHeadersMap]){\n            yield [\n                name,\n                value\n            ];\n        }\n    }\n    get entries() {\n        const headers = {};\n        if (this[kHeadersMap].size !== 0) {\n            for (const { name, value } of this[kHeadersMap].values()){\n                headers[name] = value;\n            }\n        }\n        return headers;\n    }\n    rawValues() {\n        return this[kHeadersMap].values();\n    }\n    get entriesList() {\n        const headers = [];\n        if (this[kHeadersMap].size !== 0) {\n            for (const { 0: lowerName, 1: { name, value } } of this[kHeadersMap]){\n                if (lowerName === \"set-cookie\") {\n                    for (const cookie of this.cookies){\n                        headers.push([\n                            name,\n                            cookie\n                        ]);\n                    }\n                } else {\n                    headers.push([\n                        name,\n                        value\n                    ]);\n                }\n            }\n        }\n        return headers;\n    }\n    // https://fetch.spec.whatwg.org/#convert-header-names-to-a-sorted-lowercase-set\n    toSortedArray() {\n        const size = this[kHeadersMap].size;\n        const array = new Array(size);\n        // In most cases, you will use the fast-path.\n        // fast-path: Use binary insertion sort for small arrays.\n        if (size <= 32) {\n            if (size === 0) {\n                // If empty, it is an empty array. To avoid the first index assignment.\n                return array;\n            }\n            // Improve performance by unrolling loop and avoiding double-loop.\n            // Double-loop-less version of the binary insertion sort.\n            const iterator = this[kHeadersMap][Symbol.iterator]();\n            const firstValue = iterator.next().value;\n            // set [name, value] to first index.\n            array[0] = [\n                firstValue[0],\n                firstValue[1].value\n            ];\n            // https://fetch.spec.whatwg.org/#concept-header-list-sort-and-combine\n            // 3.2.2. Assert: value is non-null.\n            assert(firstValue[1].value !== null);\n            for(let i = 1, j = 0, right = 0, left = 0, pivot = 0, x, value; i < size; ++i){\n                // get next value\n                value = iterator.next().value;\n                // set [name, value] to current index.\n                x = array[i] = [\n                    value[0],\n                    value[1].value\n                ];\n                // https://fetch.spec.whatwg.org/#concept-header-list-sort-and-combine\n                // 3.2.2. Assert: value is non-null.\n                assert(x[1] !== null);\n                left = 0;\n                right = i;\n                // binary search\n                while(left < right){\n                    // middle index\n                    pivot = left + (right - left >> 1);\n                    // compare header name\n                    if (array[pivot][0] <= x[0]) {\n                        left = pivot + 1;\n                    } else {\n                        right = pivot;\n                    }\n                }\n                if (i !== pivot) {\n                    j = i;\n                    while(j > left){\n                        array[j] = array[--j];\n                    }\n                    array[left] = x;\n                }\n            }\n            /* c8 ignore next 4 */ if (!iterator.next().done) {\n                // This is for debugging and will never be called.\n                throw new TypeError(\"Unreachable\");\n            }\n            return array;\n        } else {\n            // This case would be a rare occurrence.\n            // slow-path: fallback\n            let i = 0;\n            for (const { 0: name, 1: { value } } of this[kHeadersMap]){\n                array[i++] = [\n                    name,\n                    value\n                ];\n                // https://fetch.spec.whatwg.org/#concept-header-list-sort-and-combine\n                // 3.2.2. Assert: value is non-null.\n                assert(value !== null);\n            }\n            return array.sort(compareHeaderName);\n        }\n    }\n}\n// https://fetch.spec.whatwg.org/#headers-class\nclass Headers {\n    #guard;\n    #headersList;\n    constructor(init = undefined){\n        if (init === kConstruct) {\n            return;\n        }\n        this.#headersList = new HeadersList();\n        // The new Headers(init) constructor steps are:\n        // 1. Set thiss guard to \"none\".\n        this.#guard = \"none\";\n        // 2. If init is given, then fill this with init.\n        if (init !== undefined) {\n            init = webidl.converters.HeadersInit(init, \"Headers contructor\", \"init\");\n            fill(this, init);\n        }\n    }\n    // https://fetch.spec.whatwg.org/#dom-headers-append\n    append(name, value) {\n        webidl.brandCheck(this, Headers);\n        webidl.argumentLengthCheck(arguments, 2, \"Headers.append\");\n        const prefix = \"Headers.append\";\n        name = webidl.converters.ByteString(name, prefix, \"name\");\n        value = webidl.converters.ByteString(value, prefix, \"value\");\n        return appendHeader(this, name, value);\n    }\n    // https://fetch.spec.whatwg.org/#dom-headers-delete\n    delete(name) {\n        webidl.brandCheck(this, Headers);\n        webidl.argumentLengthCheck(arguments, 1, \"Headers.delete\");\n        const prefix = \"Headers.delete\";\n        name = webidl.converters.ByteString(name, prefix, \"name\");\n        // 1. If name is not a header name, then throw a TypeError.\n        if (!isValidHeaderName(name)) {\n            throw webidl.errors.invalidArgument({\n                prefix: \"Headers.delete\",\n                value: name,\n                type: \"header name\"\n            });\n        }\n        // 2. If thiss guard is \"immutable\", then throw a TypeError.\n        // 3. Otherwise, if thiss guard is \"request\" and name is a\n        //    forbidden header name, return.\n        // 4. Otherwise, if thiss guard is \"request-no-cors\", name\n        //    is not a no-CORS-safelisted request-header name, and\n        //    name is not a privileged no-CORS request-header name,\n        //    return.\n        // 5. Otherwise, if thiss guard is \"response\" and name is\n        //    a forbidden response-header name, return.\n        // Note: undici does not implement forbidden header names\n        if (this.#guard === \"immutable\") {\n            throw new TypeError(\"immutable\");\n        }\n        // 6. If thiss header list does not contain name, then\n        //    return.\n        if (!this.#headersList.contains(name, false)) {\n            return;\n        }\n        // 7. Delete name from thiss header list.\n        // 8. If thiss guard is \"request-no-cors\", then remove\n        //    privileged no-CORS request headers from this.\n        this.#headersList.delete(name, false);\n    }\n    // https://fetch.spec.whatwg.org/#dom-headers-get\n    get(name) {\n        webidl.brandCheck(this, Headers);\n        webidl.argumentLengthCheck(arguments, 1, \"Headers.get\");\n        const prefix = \"Headers.get\";\n        name = webidl.converters.ByteString(name, prefix, \"name\");\n        // 1. If name is not a header name, then throw a TypeError.\n        if (!isValidHeaderName(name)) {\n            throw webidl.errors.invalidArgument({\n                prefix,\n                value: name,\n                type: \"header name\"\n            });\n        }\n        // 2. Return the result of getting name from thiss header\n        //    list.\n        return this.#headersList.get(name, false);\n    }\n    // https://fetch.spec.whatwg.org/#dom-headers-has\n    has(name) {\n        webidl.brandCheck(this, Headers);\n        webidl.argumentLengthCheck(arguments, 1, \"Headers.has\");\n        const prefix = \"Headers.has\";\n        name = webidl.converters.ByteString(name, prefix, \"name\");\n        // 1. If name is not a header name, then throw a TypeError.\n        if (!isValidHeaderName(name)) {\n            throw webidl.errors.invalidArgument({\n                prefix,\n                value: name,\n                type: \"header name\"\n            });\n        }\n        // 2. Return true if thiss header list contains name;\n        //    otherwise false.\n        return this.#headersList.contains(name, false);\n    }\n    // https://fetch.spec.whatwg.org/#dom-headers-set\n    set(name, value) {\n        webidl.brandCheck(this, Headers);\n        webidl.argumentLengthCheck(arguments, 2, \"Headers.set\");\n        const prefix = \"Headers.set\";\n        name = webidl.converters.ByteString(name, prefix, \"name\");\n        value = webidl.converters.ByteString(value, prefix, \"value\");\n        // 1. Normalize value.\n        value = headerValueNormalize(value);\n        // 2. If name is not a header name or value is not a\n        //    header value, then throw a TypeError.\n        if (!isValidHeaderName(name)) {\n            throw webidl.errors.invalidArgument({\n                prefix,\n                value: name,\n                type: \"header name\"\n            });\n        } else if (!isValidHeaderValue(value)) {\n            throw webidl.errors.invalidArgument({\n                prefix,\n                value,\n                type: \"header value\"\n            });\n        }\n        // 3. If thiss guard is \"immutable\", then throw a TypeError.\n        // 4. Otherwise, if thiss guard is \"request\" and name is a\n        //    forbidden header name, return.\n        // 5. Otherwise, if thiss guard is \"request-no-cors\" and\n        //    name/value is not a no-CORS-safelisted request-header,\n        //    return.\n        // 6. Otherwise, if thiss guard is \"response\" and name is a\n        //    forbidden response-header name, return.\n        // Note: undici does not implement forbidden header names\n        if (this.#guard === \"immutable\") {\n            throw new TypeError(\"immutable\");\n        }\n        // 7. Set (name, value) in thiss header list.\n        // 8. If thiss guard is \"request-no-cors\", then remove\n        //    privileged no-CORS request headers from this\n        this.#headersList.set(name, value, false);\n    }\n    // https://fetch.spec.whatwg.org/#dom-headers-getsetcookie\n    getSetCookie() {\n        webidl.brandCheck(this, Headers);\n        // 1. If thiss header list does not contain `Set-Cookie`, then return  .\n        // 2. Return the values of all headers in thiss header list whose name is\n        //    a byte-case-insensitive match for `Set-Cookie`, in order.\n        const list = this.#headersList.cookies;\n        if (list) {\n            return [\n                ...list\n            ];\n        }\n        return [];\n    }\n    // https://fetch.spec.whatwg.org/#concept-header-list-sort-and-combine\n    get [kHeadersSortedMap]() {\n        if (this.#headersList[kHeadersSortedMap]) {\n            return this.#headersList[kHeadersSortedMap];\n        }\n        // 1. Let headers be an empty list of headers with the key being the name\n        //    and value the value.\n        const headers = [];\n        // 2. Let names be the result of convert header names to a sorted-lowercase\n        //    set with all the names of the headers in list.\n        const names = this.#headersList.toSortedArray();\n        const cookies = this.#headersList.cookies;\n        // fast-path\n        if (cookies === null || cookies.length === 1) {\n            // Note: The non-null assertion of value has already been done by `HeadersList#toSortedArray`\n            return this.#headersList[kHeadersSortedMap] = names;\n        }\n        // 3. For each name of names:\n        for(let i = 0; i < names.length; ++i){\n            const { 0: name, 1: value } = names[i];\n            // 1. If name is `set-cookie`, then:\n            if (name === \"set-cookie\") {\n                // 1. Let values be a list of all values of headers in list whose name\n                //    is a byte-case-insensitive match for name, in order.\n                // 2. For each value of values:\n                // 1. Append (name, value) to headers.\n                for(let j = 0; j < cookies.length; ++j){\n                    headers.push([\n                        name,\n                        cookies[j]\n                    ]);\n                }\n            } else {\n                // 2. Otherwise:\n                // 1. Let value be the result of getting name from list.\n                // 2. Assert: value is non-null.\n                // Note: This operation was done by `HeadersList#toSortedArray`.\n                // 3. Append (name, value) to headers.\n                headers.push([\n                    name,\n                    value\n                ]);\n            }\n        }\n        // 4. Return headers.\n        return this.#headersList[kHeadersSortedMap] = headers;\n    }\n    [util.inspect.custom](depth, options) {\n        options.depth ??= depth;\n        return `Headers ${util.formatWithOptions(options, this.#headersList.entries)}`;\n    }\n    static getHeadersGuard(o) {\n        return o.#guard;\n    }\n    static setHeadersGuard(o, guard) {\n        o.#guard = guard;\n    }\n    static getHeadersList(o) {\n        return o.#headersList;\n    }\n    static setHeadersList(o, list) {\n        o.#headersList = list;\n    }\n}\nconst { getHeadersGuard, setHeadersGuard, getHeadersList, setHeadersList } = Headers;\nReflect.deleteProperty(Headers, \"getHeadersGuard\");\nReflect.deleteProperty(Headers, \"setHeadersGuard\");\nReflect.deleteProperty(Headers, \"getHeadersList\");\nReflect.deleteProperty(Headers, \"setHeadersList\");\niteratorMixin(\"Headers\", Headers, kHeadersSortedMap, 0, 1);\nObject.defineProperties(Headers.prototype, {\n    append: kEnumerableProperty,\n    delete: kEnumerableProperty,\n    get: kEnumerableProperty,\n    has: kEnumerableProperty,\n    set: kEnumerableProperty,\n    getSetCookie: kEnumerableProperty,\n    [Symbol.toStringTag]: {\n        value: \"Headers\",\n        configurable: true\n    },\n    [util.inspect.custom]: {\n        enumerable: false\n    }\n});\nwebidl.converters.HeadersInit = function(V, prefix, argument) {\n    if (webidl.util.Type(V) === \"Object\") {\n        const iterator = Reflect.get(V, Symbol.iterator);\n        // A work-around to ensure we send the properly-cased Headers when V is a Headers object.\n        // Read https://github.com/nodejs/undici/pull/3159#issuecomment-2075537226 before touching, please.\n        if (!util.types.isProxy(V) && iterator === Headers.prototype.entries) {\n            // Headers object\n            try {\n                return getHeadersList(V).entriesList;\n            } catch  {\n            // fall-through\n            }\n        }\n        if (typeof iterator === \"function\") {\n            return webidl.converters[\"sequence<sequence<ByteString>>\"](V, prefix, argument, iterator.bind(V));\n        }\n        return webidl.converters[\"record<ByteString, ByteString>\"](V, prefix, argument);\n    }\n    throw webidl.errors.conversionFailed({\n        prefix: \"Headers constructor\",\n        argument: \"Argument 1\",\n        types: [\n            \"sequence<sequence<ByteString>>\",\n            \"record<ByteString, ByteString>\"\n        ]\n    });\n};\nmodule.exports = {\n    fill,\n    // for test.\n    compareHeaderName,\n    Headers,\n    HeadersList,\n    getHeadersGuard,\n    setHeadersGuard,\n    setHeadersList,\n    getHeadersList\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZmV0Y2gvaGVhZGVycy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBO0FBRUEsTUFBTSxFQUFFQSxVQUFBQSxFQUFZLEdBQUdDLG1CQUFPQSxDQUFDO0FBQy9CLE1BQU0sRUFBRUMsbUJBQUFBLEVBQXFCLEdBQUdELG1CQUFPQSxDQUFDO0FBQ3hDLE1BQU0sRUFDSkUsYUFBYSxFQUNiQyxpQkFBaUIsRUFDakJDLGtCQUFBQSxFQUNELEdBQUdKLG1CQUFPQSxDQUFDO0FBQ1osTUFBTSxFQUFFSyxNQUFBQSxFQUFRLEdBQUdMLG1CQUFPQSxDQUFDO0FBQzNCLE1BQU1NLFNBQVNOLG1CQUFPQSxDQUFDO0FBQ3ZCLE1BQU1PLE9BQU9QLG1CQUFPQSxDQUFDO0FBRXJCLE1BQU1RLGNBQWNDLE9BQU87QUFDM0IsTUFBTUMsb0JBQW9CRCxPQUFPO0FBRWpDOztDQUVBLEdBQ0EsU0FBU0UseUJBQTBCQyxJQUFJO0lBQ3JDLE9BQU9BLFNBQVMsU0FBU0EsU0FBUyxTQUFTQSxTQUFTLFNBQVNBLFNBQVM7QUFDeEU7QUFFQTs7O0NBR0EsR0FDQSxTQUFTQyxxQkFBc0JDLGNBQWM7SUFDM0M7SUFDQTtJQUNBO0lBQ0EsSUFBSUMsSUFBSTtJQUFHLElBQUlDLElBQUlGLGVBQWVHLE1BQU07SUFFeEMsTUFBT0QsSUFBSUQsS0FBS0oseUJBQXlCRyxlQUFlSSxVQUFVLENBQUNGLElBQUksSUFBSyxFQUFFQTtJQUM5RSxNQUFPQSxJQUFJRCxLQUFLSix5QkFBeUJHLGVBQWVJLFVBQVUsQ0FBQ0gsSUFBSyxFQUFFQTtJQUUxRSxPQUFPQSxNQUFNLEtBQUtDLE1BQU1GLGVBQWVHLE1BQU0sR0FBR0gsaUJBQWlCQSxlQUFlSyxTQUFTLENBQUNKLEdBQUdDO0FBQy9GO0FBRUEsU0FBU0ksS0FBTUMsT0FBTyxFQUFFQyxNQUFNO0lBQzVCO0lBRUE7SUFDQTtJQUNBLElBQUlDLE1BQU1DLE9BQU8sQ0FBQ0YsU0FBUztRQUN6QixJ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Ly9tb2NrdXBmbG93Ly4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvd2ViL2ZldGNoL2hlYWRlcnMuanM/ODg1NCIsIndlYnBhY2s6Ly9tb2NrdXBmbG93Ly4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvd2ViL2ZldGNoL2hlYWRlcnMuanM/ODg1NCoiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gaHR0cHM6Ly9naXRodWIuY29tL0V0aGFuLUFycm93b29kL3VuZGljaS1mZXRjaFxuXG4ndXNlIHN0cmljdCdcblxuY29uc3QgeyBrQ29uc3RydWN0IH0gPSByZXF1aXJlKCcuLi8uLi9jb3JlL3N5bWJvbHMnKVxuY29uc3QgeyBrRW51bWVyYWJsZVByb3BlcnR5IH0gPSByZXF1aXJlKCcuLi8uLi9jb3JlL3V0aWwnKVxuY29uc3Qge1xuICBpdGVyYXRvck1peGluLFxuICBpc1ZhbGlkSGVhZGVyTmFtZSxcbiAgaXNWYWxpZEhlYWRlclZhbHVlXG59ID0gcmVxdWlyZSgnLi91dGlsJylcbmNvbnN0IHsgd2ViaWRsIH0gPSByZXF1aXJlKCcuL3dlYmlkbCcpXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdub2RlOmFzc2VydCcpXG5jb25zdCB1dGlsID0gcmVxdWlyZSgnbm9kZTp1dGlsJylcblxuY29uc3Qga0hlYWRlcnNNYXAgPSBTeW1ib2woJ2hlYWRlcnMgbWFwJylcbmNvbnN0IGtIZWFkZXJzU29ydGVkTWFwID0gU3ltYm9sKCdoZWFkZXJzIG1hcCBzb3J0ZWQnKVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBjb2RlXG4gKi9cbmZ1bmN0aW9uIGlzSFRUUFdoaXRlU3BhY2VDaGFyQ29kZSAoY29kZSkge1xuICByZXR1cm4gY29kZSA9PT0gMHgwMGEgfHwgY29kZSA9PT0gMHgwMGQgfHwgY29kZSA9PT0gMHgwMDkgfHwgY29kZSA9PT0gMHgwMjBcbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LWhlYWRlci12YWx1ZS1ub3JtYWxpemVcbiAqIEBwYXJhbSB7c3RyaW5nfSBwb3RlbnRpYWxWYWx1ZVxuICovXG5mdW5jdGlvbiBoZWFkZXJWYWx1ZU5vcm1hbGl6ZSAocG90ZW50aWFsVmFsdWUpIHtcbiAgLy8gIFRvIG5vcm1hbGl6ZSBhIGJ5dGUgc2VxdWVuY2UgcG90ZW50aWFsVmFsdWUsIHJlbW92ZVxuICAvLyAgYW55IGxlYWRpbmcgYW5kIHRyYWlsaW5nIEhUVFAgd2hpdGVzcGFjZSBieXRlcyBmcm9tXG4gIC8vICBwb3RlbnRpYWxWYWx1ZS5cbiAgbGV0IGkgPSAwOyBsZXQgaiA9IHBvdGVudGlhbFZhbHVlLmxlbmd0aFxuXG4gIHdoaWxlIChqID4gaSAmJiBpc0hUVFBXaGl0ZVNwYWNlQ2hhckNvZGUocG90ZW50aWFsVmFsdWUuY2hhckNvZGVBdChqIC0gMSkpKSAtLWpcbiAgd2hpbGUgKGogPiBpICYmIGlzSFRUUFdoaXRlU3BhY2VDaGFyQ29kZShwb3RlbnRpYWxWYWx1ZS5jaGFyQ29kZUF0KGkpKSkgKytpXG5cbiAgcmV0dXJuIGkgPT09IDAgJiYgaiA9PT0gcG90ZW50aWFsVmFsdWUubGVuZ3RoID8gcG90ZW50aWFsVmFsdWUgOiBwb3RlbnRpYWxWYWx1ZS5zdWJzdHJpbmcoaSwgailcbn1cblxuZnVuY3Rpb24gZmlsbCAoaGVhZGVycywgb2JqZWN0KSB7XG4gIC8vIFRvIGZpbGwgYSBIZWFkZXJzIG9iamVjdCBoZWFkZXJzIHdpdGggYSBnaXZlbiBvYmplY3Qgb2JqZWN0LCBydW4gdGhlc2Ugc3RlcHM6XG5cbiAgLy8gMS4gSWYgb2JqZWN0IGlzIGEgc2VxdWVuY2UsIHRoZW4gZm9yIGVhY2ggaGVhZGVyIGluIG9iamVjdDpcbiAgLy8gTm90ZTogd2ViaWRsIGNvbnZlcnNpb24gdG8gYXJyYXkgaGFzIGFscmVhZHkgYmVlbiBkb25lLlxuICBpZiAoQXJyYXkuaXNBcnJheShvYmplY3QpKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvYmplY3QubGVuZ3RoOyArK2kpIHtcbiAgICAgIGNvbnN0IGhlYWRlciA9IG9iamVjdFtpXVxuICAgICAgLy8gMS4gSWYgaGVhZGVyIGRvZXMgbm90IGNvbnRhaW4gZXhhY3RseSB0d28gaXRlbXMsIHRoZW4gdGhyb3cgYSBUeXBlRXJyb3IuXG4gICAgICBpZiAoaGVhZGVyLmxlbmd0aCAhPT0gMikge1xuICAgICAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICAgICAgaGVhZGVyOiAnSGVhZGVycyBjb25zdHJ1Y3RvcicsXG4gICAgICAgICAgbWVzc2FnZTogYGV4cGVjdGVkIG5hbWUvdmFsdWUgcGFpciB0byBiZSBsZW5ndGggMiwgZm91bmQgJHtoZWFkZXIubGVuZ3RofS5gXG4gICAgICAgIH0pXG4gICAgICB9XG5cbiAgICAgIC8vIDIuIEFwcGVuZCAoaGVhZGVy4oCZcyBmaXJzdCBpdGVtLCBoZWFkZXLigJlzIHNlY29uZCBpdGVtKSB0byBoZWFkZXJzLlxuICAgICAgYXBwZW5kSGVhZGVyKGhlYWRlcnMsIGhlYWRlclswXSwgaGVhZGVyWzFdKVxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwpIHtcbiAgICAvLyBOb3RlOiBudWxsIHNob3VsZCB0aHJvd1xuXG4gICAgLy8gMi4gT3RoZXJ3aXNlLCBvYmplY3QgaXMgYSByZWNvcmQsIHRoZW4gZm9yIGVhY2gga2V5IOKGkiB2YWx1ZSBpbiBvYmplY3QsXG4gICAgLy8gICAgYXBwZW5kIChrZXksIHZhbHVlKSB0byBoZWFkZXJzXG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdClcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGFwcGVuZEhlYWRlcihoZWFkZXJzLCBrZXlzW2ldLCBvYmplY3Rba2V5c1tpXV0pXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IHdlYmlkbC5lcnJvcnMuY29udmVyc2lvbkZhaWxlZCh7XG4gICAgICBwcmVmaXg6ICdIZWFkZXJzIGNvbnN0cnVjdG9yJyxcbiAgICAgIGFyZ3VtZW50OiAnQXJndW1lbnQgMScsXG4gICAgICB0eXBlczogWydzZXF1ZW5jZTxzZXF1ZW5jZTxCeXRlU3RyaW5nPj4nLCAncmVjb3JkPEJ5dGVTdHJpbmcsIEJ5dGVTdHJpbmc+J11cbiAgICB9KVxuICB9XG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1oZWFkZXJzLWFwcGVuZFxuICovXG5mdW5jdGlvbiBhcHBlbmRIZWFkZXIgKGhlYWRlcnMsIG5hbWUsIHZhbHVlKSB7XG4gIC8vIDEuIE5vcm1hbGl6ZSB2YWx1ZS5cbiAgdmFsdWUgPSBoZWFkZXJWYWx1ZU5vcm1hbGl6ZSh2YWx1ZSlcblxuICAvLyAyLiBJZiBuYW1lIGlzIG5vdCBhIGhlYWRlciBuYW1lIG9yIHZhbHVlIGlzIG5vdCBhXG4gIC8vICAgIGhlYWRlciB2YWx1ZSwgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgaWYgKCFpc1ZhbGlkSGVhZGVyTmFtZShuYW1lKSkge1xuICAgIHRocm93IHdlYmlkbC5lcnJvcnMuaW52YWxpZEFyZ3VtZW50KHtcbiAgICAgIHByZWZpeDogJ0hlYWRlcnMuYXBwZW5kJyxcbiAgICAgIHZhbHVlOiBuYW1lLFxuICAgICAgdHlwZTogJ2hlYWRlciBuYW1lJ1xuICAgIH0pXG4gIH0gZWxzZSBpZiAoIWlzVmFsaWRIZWFkZXJWYWx1ZSh2YWx1ZSkpIHtcbiAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmludmFsaWRBcmd1bWVudCh7XG4gICAgICBwcmVmaXg6ICdIZWFkZXJzLmFwcGVuZCcsXG4gICAgICB2YWx1ZSxcbiAgICAgIHR5cGU6ICdoZWFkZXIgdmFsdWUnXG4gICAgfSlcbiAgfVxuXG4gIC8vIDMuIElmIGhlYWRlcnPigJlzIGd1YXJkIGlzIFwiaW1tdXRhYmxlXCIsIHRoZW4gdGhyb3cgYSBUeXBlRXJyb3IuXG4gIC8vIDQuIE90aGVyd2lzZSwgaWYgaGVhZGVyc+KAmXMgZ3VhcmQgaXMgXCJyZXF1ZXN0XCIgYW5kIG5hbWUgaXMgYVxuICAvLyAgICBmb3JiaWRkZW4gaGVhZGVyIG5hbWUsIHJldHVybi5cbiAgLy8gNS4gT3RoZXJ3aXNlLCBpZiBoZWFkZXJz4oCZcyBndWFyZCBpcyBcInJlcXVlc3Qtbm8tY29yc1wiOlxuICAvLyAgICBUT0RPXG4gIC8vIE5vdGU6IHVuZGljaSBkb2VzIG5vdCBpbXBsZW1lbnQgZm9yYmlkZGVuIGhlYWRlciBuYW1lc1xuICBpZiAoZ2V0SGVhZGVyc0d1YXJkKGhlYWRlcnMpID09PSAnaW1tdXRhYmxlJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ltbXV0YWJsZScpXG4gIH1cblxuICAvLyA2LiBPdGhlcndpc2UsIGlmIGhlYWRlcnPigJlzIGd1YXJkIGlzIFwicmVzcG9uc2VcIiBhbmQgbmFtZSBpcyBhXG4gIC8vICAgIGZvcmJpZGRlbiByZXNwb25zZS1oZWFkZXIgbmFtZSwgcmV0dXJuLlxuXG4gIC8vIDcuIEFwcGVuZCAobmFtZSwgdmFsdWUpIHRvIGhlYWRlcnPigJlzIGhlYWRlciBsaXN0LlxuICByZXR1cm4gZ2V0SGVhZGVyc0xpc3QoaGVhZGVycykuYXBwZW5kKG5hbWUsIHZhbHVlLCBmYWxzZSlcblxuICAvLyA4LiBJZiBoZWFkZXJz4oCZcyBndWFyZCBpcyBcInJlcXVlc3Qtbm8tY29yc1wiLCB0aGVuIHJlbW92ZVxuICAvLyAgICBwcml2aWxlZ2VkIG5vLUNPUlMgcmVxdWVzdCBoZWFkZXJzIGZyb20gaGVhZGVyc1xufVxuXG5mdW5jdGlvbiBjb21wYXJlSGVhZGVyTmFtZSAoYSwgYikge1xuICByZXR1cm4gYVswXSA8IGJbMF0gPyAtMSA6IDFcbn1cblxuY2xhc3MgSGVhZGVyc0xpc3Qge1xuICAvKiogQHR5cGUge1tzdHJpbmcsIHN0cmluZ11bXXxudWxsfSAqL1xuICBjb29raWVzID0gbnVsbFxuXG4gIGNvbnN0cnVjdG9yIChpbml0KSB7XG4gICAgaWYgKGluaXQgaW5zdGFuY2VvZiBIZWFkZXJzTGlzdCkge1xuICAgICAgdGhpc1trSGVhZGVyc01hcF0gPSBuZXcgTWFwKGluaXRba0hlYWRlcnNNYXBdKVxuICAgICAgdGhpc1trSGVhZGVyc1NvcnRlZE1hcF0gPSBpbml0W2tIZWFkZXJzU29ydGVkTWFwXVxuICAgICAgdGhpcy5jb29raWVzID0gaW5pdC5jb29raWVzID09PSBudWxsID8gbnVsbCA6IFsuLi5pbml0LmNvb2tpZXNdXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXNba0hlYWRlcnNNYXBdID0gbmV3IE1hcChpbml0KVxuICAgICAgdGhpc1trSGVhZGVyc1NvcnRlZE1hcF0gPSBudWxsXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBzZWUgaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2hlYWRlci1saXN0LWNvbnRhaW5zXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNMb3dlckNhc2VcbiAgICovXG4gIGNvbnRhaW5zIChuYW1lLCBpc0xvd2VyQ2FzZSkge1xuICAgIC8vIEEgaGVhZGVyIGxpc3QgbGlzdCBjb250YWlucyBhIGhlYWRlciBuYW1lIG5hbWUgaWYgbGlzdFxuICAgIC8vIGNvbnRhaW5zIGEgaGVhZGVyIHdob3NlIG5hbWUgaXMgYSBieXRlLWNhc2UtaW5zZW5zaXRpdmVcbiAgICAvLyBtYXRjaCBmb3IgbmFtZS5cblxuICAgIHJldHVybiB0aGlzW2tIZWFkZXJzTWFwXS5oYXMoaXNMb3dlckNhc2UgPyBuYW1lIDogbmFtZS50b0xvd2VyQ2FzZSgpKVxuICB9XG5cbiAgY2xlYXIgKCkge1xuICAgIHRoaXNba0hlYWRlcnNNYXBdLmNsZWFyKClcbiAgICB0aGlzW2tIZWFkZXJzU29ydGVkTWFwXSA9IG51bGxcbiAgICB0aGlzLmNvb2tpZXMgPSBudWxsXG4gIH1cblxuICAvKipcbiAgICogQHNlZSBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1oZWFkZXItbGlzdC1hcHBlbmRcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNMb3dlckNhc2VcbiAgICovXG4gIGFwcGVuZCAobmFtZSwgdmFsdWUsIGlzTG93ZXJDYXNlKSB7XG4gICAgdGhpc1trSGVhZGVyc1NvcnRlZE1hcF0gPSBudWxsXG5cbiAgICAvLyAxLiBJZiBsaXN0IGNvbnRhaW5zIG5hbWUsIHRoZW4gc2V0IG5hbWUgdG8gdGhlIGZpcnN0IHN1Y2hcbiAgICAvLyAgICBoZWFkZXLigJlzIG5hbWUuXG4gICAgY29uc3QgbG93ZXJjYXNlTmFtZSA9IGlzTG93ZXJDYXNlID8gbmFtZSA6IG5hbWUudG9Mb3dlckNhc2UoKVxuICAgIGNvbnN0IGV4aXN0cyA9IHRoaXNba0hlYWRlcnNNYXBdLmdldChsb3dlcmNhc2VOYW1lKVxuXG4gICAgLy8gMi4gQXBwZW5kIChuYW1lLCB2YWx1ZSkgdG8gbGlzdC5cbiAgICBpZiAoZXhpc3RzKSB7XG4gICAgICBjb25zdCBkZWxpbWl0ZXIgPSBsb3dlcmNhc2VOYW1lID09PSAnY29va2llJyA/ICc7ICcgOiAnLCAnXG4gICAgICB0aGlzW2tIZWFkZXJzTWFwXS5zZXQobG93ZXJjYXNlTmFtZSwge1xuICAgICAgICBuYW1lOiBleGlzdHMubmFtZSxcbiAgICAgICAgdmFsdWU6IGAke2V4aXN0cy52YWx1ZX0ke2RlbGltaXRlcn0ke3ZhbHVlfWBcbiAgICAgIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXNba0hlYWRlcnNNYXBdLnNldChsb3dlcmNhc2VOYW1lLCB7IG5hbWUsIHZhbHVlIH0pXG4gICAgfVxuXG4gICAgaWYgKGxvd2VyY2FzZU5hbWUgPT09ICdzZXQtY29va2llJykge1xuICAgICAgKHRoaXMuY29va2llcyA/Pz0gW10pLnB1c2godmFsdWUpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBzZWUgaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtaGVhZGVyLWxpc3Qtc2V0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzTG93ZXJDYXNlXG4gICAqL1xuICBzZXQgKG5hbWUsIHZhbHVlLCBpc0xvd2VyQ2FzZSkge1xuICAgIHRoaXNba0hlYWRlcnNTb3J0ZWRNYXBdID0gbnVsbFxuICAgIGNvbnN0IGxvd2VyY2FzZU5hbWUgPSBpc0xvd2VyQ2FzZSA/IG5hbWUgOiBuYW1lLnRvTG93ZXJDYXNlKClcblxuICAgIGlmIChsb3dlcmNhc2VOYW1lID09PSAnc2V0LWNvb2tpZScpIHtcbiAgICAgIHRoaXMuY29va2llcyA9IFt2YWx1ZV1cbiAgICB9XG5cbiAgICAvLyAxLiBJZiBsaXN0IGNvbnRhaW5zIG5hbWUsIHRoZW4gc2V0IHRoZSB2YWx1ZSBvZlxuICAgIC8vICAgIHRoZSBmaXJzdCBzdWNoIGhlYWRlciB0byB2YWx1ZSBhbmQgcmVtb3ZlIHRoZVxuICAgIC8vICAgIG90aGVycy5cbiAgICAvLyAyLiBPdGhlcndpc2UsIGFwcGVuZCBoZWFkZXIgKG5hbWUsIHZhbHVlKSB0byBsaXN0LlxuICAgIHRoaXNba0hlYWRlcnNNYXBdLnNldChsb3dlcmNhc2VOYW1lLCB7IG5hbWUsIHZhbHVlIH0pXG4gIH1cblxuICAvKipcbiAgICogQHNlZSBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1oZWFkZXItbGlzdC1kZWxldGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHtib29sZWFufSBpc0xvd2VyQ2FzZVxuICAgKi9cbiAgZGVsZXRlIChuYW1lLCBpc0xvd2VyQ2FzZSkge1xuICAgIHRoaXNba0hlYWRlcnNTb3J0ZWRNYXBdID0gbnVsbFxuICAgIGlmICghaXNMb3dlckNhc2UpIG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKClcblxuICAgIGlmIChuYW1lID09PSAnc2V0LWNvb2tpZScpIHtcbiAgICAgIHRoaXMuY29va2llcyA9IG51bGxcbiAgICB9XG5cbiAgICB0aGlzW2tIZWFkZXJzTWFwXS5kZWxldGUobmFtZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAc2VlIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LWhlYWRlci1saXN0LWdldFxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzTG93ZXJDYXNlXG4gICAqIEByZXR1cm5zIHtzdHJpbmcgfCBudWxsfVxuICAgKi9cbiAgZ2V0IChuYW1lLCBpc0xvd2VyQ2FzZSkge1xuICAgIC8vIDEuIElmIGxpc3QgZG9lcyBub3QgY29udGFpbiBuYW1lLCB0aGVuIHJldHVybiBudWxsLlxuICAgIC8vIDIuIFJldHVybiB0aGUgdmFsdWVzIG9mIGFsbCBoZWFkZXJzIGluIGxpc3Qgd2hvc2UgbmFtZVxuICAgIC8vICAgIGlzIGEgYnl0ZS1jYXNlLWluc2Vuc2l0aXZlIG1hdGNoIGZvciBuYW1lLFxuICAgIC8vICAgIHNlcGFyYXRlZCBmcm9tIGVhY2ggb3RoZXIgYnkgMHgyQyAweDIwLCBpbiBvcmRlci5cbiAgICByZXR1cm4gdGhpc1trSGVhZGVyc01hcF0uZ2V0KGlzTG93ZXJDYXNlID8gbmFtZSA6IG5hbWUudG9Mb3dlckNhc2UoKSk/LnZhbHVlID8/IG51bGxcbiAgfVxuXG4gICogW1N5bWJvbC5pdGVyYXRvcl0gKCkge1xuICAgIC8vIHVzZSB0aGUgbG93ZXJjYXNlZCBuYW1lXG4gICAgZm9yIChjb25zdCB7IDA6IG5hbWUsIDE6IHsgdmFsdWUgfSB9IG9mIHRoaXNba0hlYWRlcnNNYXBdKSB7XG4gICAgICB5aWVsZCBbbmFtZSwgdmFsdWVdXG4gICAgfVxuICB9XG5cbiAgZ2V0IGVudHJpZXMgKCkge1xuICAgIGNvbnN0IGhlYWRlcnMgPSB7fVxuXG4gICAgaWYgKHRoaXNba0hlYWRlcnNNYXBdLnNpemUgIT09IDApIHtcbiAgICAgIGZvciAoY29uc3QgeyBuYW1lLCB2YWx1ZSB9IG9mIHRoaXNba0hlYWRlcnNNYXBdLnZhbHVlcygpKSB7XG4gICAgICAgIGhlYWRlcnNbbmFtZV0gPSB2YWx1ZVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBoZWFkZXJzXG4gIH1cblxuICByYXdWYWx1ZXMgKCkge1xuICAgIHJldHVybiB0aGlzW2tIZWFkZXJzTWFwXS52YWx1ZXMoKVxuICB9XG5cbiAgZ2V0IGVudHJpZXNMaXN0ICgpIHtcbiAgICBjb25zdCBoZWFkZXJzID0gW11cblxuICAgIGlmICh0aGlzW2tIZWFkZXJzTWFwXS5zaXplICE9PSAwKSB7XG4gICAgICBmb3IgKGNvbnN0IHsgMDogbG93ZXJOYW1lLCAxOiB7IG5hbWUsIHZhbHVlIH0gfSBvZiB0aGlzW2tIZWFkZXJzTWFwXSkge1xuICAgICAgICBpZiAobG93ZXJOYW1lID09PSAnc2V0LWNvb2tpZScpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IGNvb2tpZSBvZiB0aGlzLmNvb2tpZXMpIHtcbiAgICAgICAgICAgIGhlYWRlcnMucHVzaChbbmFtZSwgY29va2llXSlcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaGVhZGVycy5wdXNoKFtuYW1lLCB2YWx1ZV0pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaGVhZGVyc1xuICB9XG5cbiAgLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbnZlcnQtaGVhZGVyLW5hbWVzLXRvLWEtc29ydGVkLWxvd2VyY2FzZS1zZXRcbiAgdG9Tb3J0ZWRBcnJheSAoKSB7XG4gICAgY29uc3Qgc2l6ZSA9IHRoaXNba0hlYWRlcnNNYXBdLnNpemVcbiAgICBjb25zdCBhcnJheSA9IG5ldyBBcnJheShzaXplKVxuICAgIC8vIEluIG1vc3QgY2FzZXMsIHlvdSB3aWxsIHVzZSB0aGUgZmFzdC1wYXRoLlxuICAgIC8vIGZhc3QtcGF0aDogVXNlIGJpbmFyeSBpbnNlcnRpb24gc29ydCBmb3Igc21hbGwgYXJyYXlzLlxuICAgIGlmIChzaXplIDw9IDMyKSB7XG4gICAgICBpZiAoc2l6ZSA9PT0gMCkge1xuICAgICAgICAvLyBJZiBlbXB0eSwgaXQgaXMgYW4gZW1wdHkgYXJyYXkuIFRvIGF2b2lkIHRoZSBmaXJzdCBpbmRleCBhc3NpZ25tZW50LlxuICAgICAgICByZXR1cm4gYXJyYXlcbiAgICAgIH1cbiAgICAgIC8vIEltcHJvdmUgcGVyZm9ybWFuY2UgYnkgdW5yb2xsaW5nIGxvb3AgYW5kIGF2b2lkaW5nIGRvdWJsZS1sb29wLlxuICAgICAgLy8gRG91YmxlLWxvb3AtbGVzcyB2ZXJzaW9uIG9mIHRoZSBiaW5hcnkgaW5zZXJ0aW9uIHNvcnQuXG4gICAgICBjb25zdCBpdGVyYXRvciA9IHRoaXNba0hlYWRlcnNNYXBdW1N5bWJvbC5pdGVyYXRvcl0oKVxuICAgICAgY29uc3QgZmlyc3RWYWx1ZSA9IGl0ZXJhdG9yLm5leHQoKS52YWx1ZVxuICAgICAgLy8gc2V0IFtuYW1lLCB2YWx1ZV0gdG8gZmlyc3QgaW5kZXguXG4gICAgICBhcnJheVswXSA9IFtmaXJzdFZhbHVlWzBdLCBmaXJzdFZhbHVlWzFdLnZhbHVlXVxuICAgICAgLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtaGVhZGVyLWxpc3Qtc29ydC1hbmQtY29tYmluZVxuICAgICAgLy8gMy4yLjIuIEFzc2VydDogdmFsdWUgaXMgbm9uLW51bGwuXG4gICAgICBhc3NlcnQoZmlyc3RWYWx1ZVsxXS52YWx1ZSAhPT0gbnVsbClcbiAgICAgIGZvciAoXG4gICAgICAgIGxldCBpID0gMSwgaiA9IDAsIHJpZ2h0ID0gMCwgbGVmdCA9IDAsIHBpdm90ID0gMCwgeCwgdmFsdWU7XG4gICAgICAgIGkgPCBzaXplO1xuICAgICAgICArK2lcbiAgICAgICkge1xuICAgICAgICAvLyBnZXQgbmV4dCB2YWx1ZVxuICAgICAgICB2YWx1ZSA9IGl0ZXJhdG9yLm5leHQoKS52YWx1ZVxuICAgICAgICAvLyBzZXQgW25hbWUsIHZhbHVlXSB0byBjdXJyZW50IGluZGV4LlxuICAgICAgICB4ID0gYXJyYXlbaV0gPSBbdmFsdWVbMF0sIHZhbHVlWzFdLnZhbHVlXVxuICAgICAgICAvLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1oZWFkZXItbGlzdC1zb3J0LWFuZC1jb21iaW5lXG4gICAgICAgIC8vIDMuMi4yLiBBc3NlcnQ6IHZhbHVlIGlzIG5vbi1udWxsLlxuICAgICAgICBhc3NlcnQoeFsxXSAhPT0gbnVsbClcbiAgICAgICAgbGVmdCA9IDBcbiAgICAgICAgcmlnaHQgPSBpXG4gICAgICAgIC8vIGJpbmFyeSBzZWFyY2hcbiAgICAgICAgd2hpbGUgKGxlZnQgPCByaWdodCkge1xuICAgICAgICAgIC8vIG1pZGRsZSBpbmRleFxuICAgICAgICAgIHBpdm90ID0gbGVmdCArICgocmlnaHQgLSBsZWZ0KSA+PiAxKVxuICAgICAgICAgIC8vIGNvbXBhcmUgaGVhZGVyIG5hbWVcbiAgICAgICAgICBpZiAoYXJyYXlbcGl2b3RdWzBdIDw9IHhbMF0pIHtcbiAgICAgICAgICAgIGxlZnQgPSBwaXZvdCArIDFcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmlnaHQgPSBwaXZvdFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaSAhPT0gcGl2b3QpIHtcbiAgICAgICAgICBqID0gaVxuICAgICAgICAgIHdoaWxlIChqID4gbGVmdCkge1xuICAgICAgICAgICAgYXJyYXlbal0gPSBhcnJheVstLWpdXG4gICAgICAgICAgfVxuICAgICAgICAgIGFycmF5W2xlZnRdID0geFxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvKiBjOCBpZ25vcmUgbmV4dCA0ICovXG4gICAgICBpZiAoIWl0ZXJhdG9yLm5leHQoKS5kb25lKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgZm9yIGRlYnVnZ2luZyBhbmQgd2lsbCBuZXZlciBiZSBjYWxsZWQuXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1VucmVhY2hhYmxlJylcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGlzIGNhc2Ugd291bGQgYmUgYSByYXJlIG9jY3VycmVuY2UuXG4gICAgICAvLyBzbG93LXBhdGg6IGZhbGxiYWNrXG4gICAgICBsZXQgaSA9IDBcbiAgICAgIGZvciAoY29uc3QgeyAwOiBuYW1lLCAxOiB7IHZhbHVlIH0gfSBvZiB0aGlzW2tIZWFkZXJzTWFwXSkge1xuICAgICAgICBhcnJheVtpKytdID0gW25hbWUsIHZhbHVlXVxuICAgICAgICAvLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1oZWFkZXItbGlzdC1zb3J0LWFuZC1jb21iaW5lXG4gICAgICAgIC8vIDMuMi4yLiBBc3NlcnQ6IHZhbHVlIGlzIG5vbi1udWxsLlxuICAgICAgICBhc3NlcnQodmFsdWUgIT09IG51bGwpXG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyYXkuc29ydChjb21wYXJlSGVhZGVyTmFtZSlcbiAgICB9XG4gIH1cbn1cblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2hlYWRlcnMtY2xhc3NcbmNsYXNzIEhlYWRlcnMge1xuICAjZ3VhcmRcbiAgI2hlYWRlcnNMaXN0XG5cbiAgY29uc3RydWN0b3IgKGluaXQgPSB1bmRlZmluZWQpIHtcbiAgICBpZiAoaW5pdCA9PT0ga0NvbnN0cnVjdCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpcy4jaGVhZGVyc0xpc3QgPSBuZXcgSGVhZGVyc0xpc3QoKVxuXG4gICAgLy8gVGhlIG5ldyBIZWFkZXJzKGluaXQpIGNvbnN0cnVjdG9yIHN0ZXBzIGFyZTpcblxuICAgIC8vIDEuIFNldCB0aGlz4oCZcyBndWFyZCB0byBcIm5vbmVcIi5cbiAgICB0aGlzLiNndWFyZCA9ICdub25lJ1xuXG4gICAgLy8gMi4gSWYgaW5pdCBpcyBnaXZlbiwgdGhlbiBmaWxsIHRoaXMgd2l0aCBpbml0LlxuICAgIGlmIChpbml0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGluaXQgPSB3ZWJpZGwuY29udmVydGVycy5IZWFkZXJzSW5pdChpbml0LCAnSGVhZGVycyBjb250cnVjdG9yJywgJ2luaXQnKVxuICAgICAgZmlsbCh0aGlzLCBpbml0KVxuICAgIH1cbiAgfVxuXG4gIC8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNkb20taGVhZGVycy1hcHBlbmRcbiAgYXBwZW5kIChuYW1lLCB2YWx1ZSkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEhlYWRlcnMpXG5cbiAgICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDIsICdIZWFkZXJzLmFwcGVuZCcpXG5cbiAgICBjb25zdCBwcmVmaXggPSAnSGVhZGVycy5hcHBlbmQnXG4gICAgbmFtZSA9IHdlYmlkbC5jb252ZXJ0ZXJzLkJ5dGVTdHJpbmcobmFtZSwgcHJlZml4LCAnbmFtZScpXG4gICAgdmFsdWUgPSB3ZWJpZGwuY29udmVydGVycy5CeXRlU3RyaW5nKHZhbHVlLCBwcmVmaXgsICd2YWx1ZScpXG5cbiAgICByZXR1cm4gYXBwZW5kSGVhZGVyKHRoaXMsIG5hbWUsIHZhbHVlKVxuICB9XG5cbiAgLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2RvbS1oZWFkZXJzLWRlbGV0ZVxuICBkZWxldGUgKG5hbWUpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBIZWFkZXJzKVxuXG4gICAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAxLCAnSGVhZGVycy5kZWxldGUnKVxuXG4gICAgY29uc3QgcHJlZml4ID0gJ0hlYWRlcnMuZGVsZXRlJ1xuICAgIG5hbWUgPSB3ZWJpZGwuY29udmVydGVycy5CeXRlU3RyaW5nKG5hbWUsIHByZWZpeCwgJ25hbWUnKVxuXG4gICAgLy8gMS4gSWYgbmFtZSBpcyBub3QgYSBoZWFkZXIgbmFtZSwgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgICBpZiAoIWlzVmFsaWRIZWFkZXJOYW1lKG5hbWUpKSB7XG4gICAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmludmFsaWRBcmd1bWVudCh7XG4gICAgICAgIHByZWZpeDogJ0hlYWRlcnMuZGVsZXRlJyxcbiAgICAgICAgdmFsdWU6IG5hbWUsXG4gICAgICAgIHR5cGU6ICdoZWFkZXIgbmFtZSdcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgLy8gMi4gSWYgdGhpc+KAmXMgZ3VhcmQgaXMgXCJpbW11dGFibGVcIiwgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgICAvLyAzLiBPdGhlcndpc2UsIGlmIHRoaXPigJlzIGd1YXJkIGlzIFwicmVxdWVzdFwiIGFuZCBuYW1lIGlzIGFcbiAgICAvLyAgICBmb3JiaWRkZW4gaGVhZGVyIG5hbWUsIHJldHVybi5cbiAgICAvLyA0LiBPdGhlcndpc2UsIGlmIHRoaXPigJlzIGd1YXJkIGlzIFwicmVxdWVzdC1uby1jb3JzXCIsIG5hbWVcbiAgICAvLyAgICBpcyBub3QgYSBuby1DT1JTLXNhZmVsaXN0ZWQgcmVxdWVzdC1oZWFkZXIgbmFtZSwgYW5kXG4gICAgLy8gICAgbmFtZSBpcyBub3QgYSBwcml2aWxlZ2VkIG5vLUNPUlMgcmVxdWVzdC1oZWFkZXIgbmFtZSxcbiAgICAvLyAgICByZXR1cm4uXG4gICAgLy8gNS4gT3RoZXJ3aXNlLCBpZiB0aGlz4oCZcyBndWFyZCBpcyBcInJlc3BvbnNlXCIgYW5kIG5hbWUgaXNcbiAgICAvLyAgICBhIGZvcmJpZGRlbiByZXNwb25zZS1oZWFkZXIgbmFtZSwgcmV0dXJuLlxuICAgIC8vIE5vdGU6IHVuZGljaSBkb2VzIG5vdCBpbXBsZW1lbnQgZm9yYmlkZGVuIGhlYWRlciBuYW1lc1xuICAgIGlmICh0aGlzLiNndWFyZCA9PT0gJ2ltbXV0YWJsZScpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ltbXV0YWJsZScpXG4gICAgfVxuXG4gICAgLy8gNi4gSWYgdGhpc+KAmXMgaGVhZGVyIGxpc3QgZG9lcyBub3QgY29udGFpbiBuYW1lLCB0aGVuXG4gICAgLy8gICAgcmV0dXJuLlxuICAgIGlmICghdGhpcy4jaGVhZGVyc0xpc3QuY29udGFpbnMobmFtZSwgZmFsc2UpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyA3LiBEZWxldGUgbmFtZSBmcm9tIHRoaXPigJlzIGhlYWRlciBsaXN0LlxuICAgIC8vIDguIElmIHRoaXPigJlzIGd1YXJkIGlzIFwicmVxdWVzdC1uby1jb3JzXCIsIHRoZW4gcmVtb3ZlXG4gICAgLy8gICAgcHJpdmlsZWdlZCBuby1DT1JTIHJlcXVlc3QgaGVhZGVycyBmcm9tIHRoaXMuXG4gICAgdGhpcy4jaGVhZGVyc0xpc3QuZGVsZXRlKG5hbWUsIGZhbHNlKVxuICB9XG5cbiAgLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2RvbS1oZWFkZXJzLWdldFxuICBnZXQgKG5hbWUpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBIZWFkZXJzKVxuXG4gICAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAxLCAnSGVhZGVycy5nZXQnKVxuXG4gICAgY29uc3QgcHJlZml4ID0gJ0hlYWRlcnMuZ2V0J1xuICAgIG5hbWUgPSB3ZWJpZGwuY29udmVydGVycy5CeXRlU3RyaW5nKG5hbWUsIHByZWZpeCwgJ25hbWUnKVxuXG4gICAgLy8gMS4gSWYgbmFtZSBpcyBub3QgYSBoZWFkZXIgbmFtZSwgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgICBpZiAoIWlzVmFsaWRIZWFkZXJOYW1lKG5hbWUpKSB7XG4gICAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmludmFsaWRBcmd1bWVudCh7XG4gICAgICAgIHByZWZpeCxcbiAgICAgICAgdmFsdWU6IG5hbWUsXG4gICAgICAgIHR5cGU6ICdoZWFkZXIgbmFtZSdcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgLy8gMi4gUmV0dXJuIHRoZSByZXN1bHQgb2YgZ2V0dGluZyBuYW1lIGZyb20gdGhpc+KAmXMgaGVhZGVyXG4gICAgLy8gICAgbGlzdC5cbiAgICByZXR1cm4gdGhpcy4jaGVhZGVyc0xpc3QuZ2V0KG5hbWUsIGZhbHNlKVxuICB9XG5cbiAgLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2RvbS1oZWFkZXJzLWhhc1xuICBoYXMgKG5hbWUpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBIZWFkZXJzKVxuXG4gICAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAxLCAnSGVhZGVycy5oYXMnKVxuXG4gICAgY29uc3QgcHJlZml4ID0gJ0hlYWRlcnMuaGFzJ1xuICAgIG5hbWUgPSB3ZWJpZGwuY29udmVydGVycy5CeXRlU3RyaW5nKG5hbWUsIHByZWZpeCwgJ25hbWUnKVxuXG4gICAgLy8gMS4gSWYgbmFtZSBpcyBub3QgYSBoZWFkZXIgbmFtZSwgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgICBpZiAoIWlzVmFsaWRIZWFkZXJOYW1lKG5hbWUpKSB7XG4gICAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmludmFsaWRBcmd1bWVudCh7XG4gICAgICAgIHByZWZpeCxcbiAgICAgICAgdmFsdWU6IG5hbWUsXG4gICAgICAgIHR5cGU6ICdoZWFkZXIgbmFtZSdcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgLy8gMi4gUmV0dXJuIHRydWUgaWYgdGhpc+KAmXMgaGVhZGVyIGxpc3QgY29udGFpbnMgbmFtZTtcbiAgICAvLyAgICBvdGhlcndpc2UgZmFsc2UuXG4gICAgcmV0dXJuIHRoaXMuI2hlYWRlcnNMaXN0LmNvbnRhaW5zKG5hbWUsIGZhbHNlKVxuICB9XG5cbiAgLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2RvbS1oZWFkZXJzLXNldFxuICBzZXQgKG5hbWUsIHZhbHVlKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgSGVhZGVycylcblxuICAgIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMiwgJ0hlYWRlcnMuc2V0JylcblxuICAgIGNvbnN0IHByZWZpeCA9ICdIZWFkZXJzLnNldCdcbiAgICBuYW1lID0gd2ViaWRsLmNvbnZlcnRlcnMuQnl0ZVN0cmluZyhuYW1lLCBwcmVmaXgsICduYW1lJylcbiAgICB2YWx1ZSA9IHdlYmlkbC5jb252ZXJ0ZXJzLkJ5dGVTdHJpbmcodmFsdWUsIHByZWZpeCwgJ3ZhbHVlJylcblxuICAgIC8vIDEuIE5vcm1hbGl6ZSB2YWx1ZS5cbiAgICB2YWx1ZSA9IGhlYWRlclZhbHVlTm9ybWFsaXplKHZhbHVlKVxuXG4gICAgLy8gMi4gSWYgbmFtZSBpcyBub3QgYSBoZWFkZXIgbmFtZSBvciB2YWx1ZSBpcyBub3QgYVxuICAgIC8vICAgIGhlYWRlciB2YWx1ZSwgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgICBpZiAoIWlzVmFsaWRIZWFkZXJOYW1lKG5hbWUpKSB7XG4gICAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmludmFsaWRBcmd1bWVudCh7XG4gICAgICAgIHByZWZpeCxcbiAgICAgICAgdmFsdWU6IG5hbWUsXG4gICAgICAgIHR5cGU6ICdoZWFkZXIgbmFtZSdcbiAgICAgIH0pXG4gICAgfSBlbHNlIGlmICghaXNWYWxpZEhlYWRlclZhbHVlKHZhbHVlKSkge1xuICAgICAgdGhyb3cgd2ViaWRsLmVycm9ycy5pbnZhbGlkQXJndW1lbnQoe1xuICAgICAgICBwcmVmaXgsXG4gICAgICAgIHZhbHVlLFxuICAgICAgICB0eXBlOiAnaGVhZGVyIHZhbHVlJ1xuICAgICAgfSlcbiAgICB9XG5cbiAgICAvLyAzLiBJZiB0aGlz4oCZcyBndWFyZCBpcyBcImltbXV0YWJsZVwiLCB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICAgIC8vIDQuIE90aGVyd2lzZSwgaWYgdGhpc+KAmXMgZ3VhcmQgaXMgXCJyZXF1ZXN0XCIgYW5kIG5hbWUgaXMgYVxuICAgIC8vICAgIGZvcmJpZGRlbiBoZWFkZXIgbmFtZSwgcmV0dXJuLlxuICAgIC8vIDUuIE90aGVyd2lzZSwgaWYgdGhpc+KAmXMgZ3VhcmQgaXMgXCJyZXF1ZXN0LW5vLWNvcnNcIiBhbmRcbiAgICAvLyAgICBuYW1lL3ZhbHVlIGlzIG5vdCBhIG5vLUNPUlMtc2FmZWxpc3RlZCByZXF1ZXN0LWhlYWRlcixcbiAgICAvLyAgICByZXR1cm4uXG4gICAgLy8gNi4gT3RoZXJ3aXNlLCBpZiB0aGlz4oCZcyBndWFyZCBpcyBcInJlc3BvbnNlXCIgYW5kIG5hbWUgaXMgYVxuICAgIC8vICAgIGZvcmJpZGRlbiByZXNwb25zZS1oZWFkZXIgbmFtZSwgcmV0dXJuLlxuICAgIC8vIE5vdGU6IHVuZGljaSBkb2VzIG5vdCBpbXBsZW1lbnQgZm9yYmlkZGVuIGhlYWRlciBuYW1lc1xuICAgIGlmICh0aGlzLiNndWFyZCA9PT0gJ2ltbXV0YWJsZScpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ltbXV0YWJsZScpXG4gICAgfVxuXG4gICAgLy8gNy4gU2V0IChuYW1lLCB2YWx1ZSkgaW4gdGhpc+KAmXMgaGVhZGVyIGxpc3QuXG4gICAgLy8gOC4gSWYgdGhpc+KAmXMgZ3VhcmQgaXMgXCJyZXF1ZXN0LW5vLWNvcnNcIiwgdGhlbiByZW1vdmVcbiAgICAvLyAgICBwcml2aWxlZ2VkIG5vLUNPUlMgcmVxdWVzdCBoZWFkZXJzIGZyb20gdGhpc1xuICAgIHRoaXMuI2hlYWRlcnNMaXN0LnNldChuYW1lLCB2YWx1ZSwgZmFsc2UpXG4gIH1cblxuICAvLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jZG9tLWhlYWRlcnMtZ2V0c2V0Y29va2llXG4gIGdldFNldENvb2tpZSAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgSGVhZGVycylcblxuICAgIC8vIDEuIElmIHRoaXPigJlzIGhlYWRlciBsaXN0IGRvZXMgbm90IGNvbnRhaW4gYFNldC1Db29raWVgLCB0aGVuIHJldHVybiDCqyDCuy5cbiAgICAvLyAyLiBSZXR1cm4gdGhlIHZhbHVlcyBvZiBhbGwgaGVhZGVycyBpbiB0aGlz4oCZcyBoZWFkZXIgbGlzdCB3aG9zZSBuYW1lIGlzXG4gICAgLy8gICAgYSBieXRlLWNhc2UtaW5zZW5zaXRpdmUgbWF0Y2ggZm9yIGBTZXQtQ29va2llYCwgaW4gb3JkZXIuXG5cbiAgICBjb25zdCBsaXN0ID0gdGhpcy4jaGVhZGVyc0xpc3QuY29va2llc1xuXG4gICAgaWYgKGxpc3QpIHtcbiAgICAgIHJldHVybiBbLi4ubGlzdF1cbiAgICB9XG5cbiAgICByZXR1cm4gW11cbiAgfVxuXG4gIC8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LWhlYWRlci1saXN0LXNvcnQtYW5kLWNvbWJpbmVcbiAgZ2V0IFtrSGVhZGVyc1NvcnRlZE1hcF0gKCkge1xuICAgIGlmICh0aGlzLiNoZWFkZXJzTGlzdFtrSGVhZGVyc1NvcnRlZE1hcF0pIHtcbiAgICAgIHJldHVybiB0aGlzLiNoZWFkZXJzTGlzdFtrSGVhZGVyc1NvcnRlZE1hcF1cbiAgICB9XG5cbiAgICAvLyAxLiBMZXQgaGVhZGVycyBiZSBhbiBlbXB0eSBsaXN0IG9mIGhlYWRlcnMgd2l0aCB0aGUga2V5IGJlaW5nIHRoZSBuYW1lXG4gICAgLy8gICAgYW5kIHZhbHVlIHRoZSB2YWx1ZS5cbiAgICBjb25zdCBoZWFkZXJzID0gW11cblxuICAgIC8vIDIuIExldCBuYW1lcyBiZSB0aGUgcmVzdWx0IG9mIGNvbnZlcnQgaGVhZGVyIG5hbWVzIHRvIGEgc29ydGVkLWxvd2VyY2FzZVxuICAgIC8vICAgIHNldCB3aXRoIGFsbCB0aGUgbmFtZXMgb2YgdGhlIGhlYWRlcnMgaW4gbGlzdC5cbiAgICBjb25zdCBuYW1lcyA9IHRoaXMuI2hlYWRlcnNMaXN0LnRvU29ydGVkQXJyYXkoKVxuXG4gICAgY29uc3QgY29va2llcyA9IHRoaXMuI2hlYWRlcnNMaXN0LmNvb2tpZXNcblxuICAgIC8vIGZhc3QtcGF0aFxuICAgIGlmIChjb29raWVzID09PSBudWxsIHx8IGNvb2tpZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAvLyBOb3RlOiBUaGUgbm9uLW51bGwgYXNzZXJ0aW9uIG9mIHZhbHVlIGhhcyBhbHJlYWR5IGJlZW4gZG9uZSBieSBgSGVhZGVyc0xpc3QjdG9Tb3J0ZWRBcnJheWBcbiAgICAgIHJldHVybiAodGhpcy4jaGVhZGVyc0xpc3Rba0hlYWRlcnNTb3J0ZWRNYXBdID0gbmFtZXMpXG4gICAgfVxuXG4gICAgLy8gMy4gRm9yIGVhY2ggbmFtZSBvZiBuYW1lczpcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICBjb25zdCB7IDA6IG5hbWUsIDE6IHZhbHVlIH0gPSBuYW1lc1tpXVxuICAgICAgLy8gMS4gSWYgbmFtZSBpcyBgc2V0LWNvb2tpZWAsIHRoZW46XG4gICAgICBpZiAobmFtZSA9PT0gJ3NldC1jb29raWUnKSB7XG4gICAgICAgIC8vIDEuIExldCB2YWx1ZXMgYmUgYSBsaXN0IG9mIGFsbCB2YWx1ZXMgb2YgaGVhZGVycyBpbiBsaXN0IHdob3NlIG5hbWVcbiAgICAgICAgLy8gICAgaXMgYSBieXRlLWNhc2UtaW5zZW5zaXRpdmUgbWF0Y2ggZm9yIG5hbWUsIGluIG9yZGVyLlxuXG4gICAgICAgIC8vIDIuIEZvciBlYWNoIHZhbHVlIG9mIHZhbHVlczpcbiAgICAgICAgLy8gMS4gQXBwZW5kIChuYW1lLCB2YWx1ZSkgdG8gaGVhZGVycy5cbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjb29raWVzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgaGVhZGVycy5wdXNoKFtuYW1lLCBjb29raWVzW2pdXSlcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gMi4gT3RoZXJ3aXNlOlxuXG4gICAgICAgIC8vIDEuIExldCB2YWx1ZSBiZSB0aGUgcmVzdWx0IG9mIGdldHRpbmcgbmFtZSBmcm9tIGxpc3QuXG5cbiAgICAgICAgLy8gMi4gQXNzZXJ0OiB2YWx1ZSBpcyBub24tbnVsbC5cbiAgICAgICAgLy8gTm90ZTogVGhpcyBvcGVyYXRpb24gd2FzIGRvbmUgYnkgYEhlYWRlcnNMaXN0I3RvU29ydGVkQXJyYXlgLlxuXG4gICAgICAgIC8vIDMuIEFwcGVuZCAobmFtZSwgdmFsdWUpIHRvIGhlYWRlcnMuXG4gICAgICAgIGhlYWRlcnMucHVzaChbbmFtZSwgdmFsdWVdKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIDQuIFJldHVybiBoZWFkZXJzLlxuICAgIHJldHVybiAodGhpcy4jaGVhZGVyc0xpc3Rba0hlYWRlcnNTb3J0ZWRNYXBdID0gaGVhZGVycylcbiAgfVxuXG4gIFt1dGlsLmluc3BlY3QuY3VzdG9tXSAoZGVwdGgsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zLmRlcHRoID8/PSBkZXB0aFxuXG4gICAgcmV0dXJuIGBIZWFkZXJzICR7dXRpbC5mb3JtYXRXaXRoT3B0aW9ucyhvcHRpb25zLCB0aGlzLiNoZWFkZXJzTGlzdC5lbnRyaWVzKX1gXG4gIH1cblxuICBzdGF0aWMgZ2V0SGVhZGVyc0d1YXJkIChvKSB7XG4gICAgcmV0dXJuIG8uI2d1YXJkXG4gIH1cblxuICBzdGF0aWMgc2V0SGVhZGVyc0d1YXJkIChvLCBndWFyZCkge1xuICAgIG8uI2d1YXJkID0gZ3VhcmRcbiAgfVxuXG4gIHN0YXRpYyBnZXRIZWFkZXJzTGlzdCAobykge1xuICAgIHJldHVybiBvLiNoZWFkZXJzTGlzdFxuICB9XG5cbiAgc3RhdGljIHNldEhlYWRlcnNMaXN0IChvLCBsaXN0KSB7XG4gICAgby4jaGVhZGVyc0xpc3QgPSBsaXN0XG4gIH1cbn1cblxuY29uc3QgeyBnZXRIZWFkZXJzR3VhcmQsIHNldEhlYWRlcnNHdWFyZCwgZ2V0SGVhZGVyc0xpc3QsIHNldEhlYWRlcnNMaXN0IH0gPSBIZWFkZXJzXG5SZWZsZWN0LmRlbGV0ZVByb3BlcnR5KEhlYWRlcnMsICdnZXRIZWFkZXJzR3VhcmQnKVxuUmVmbGVjdC5kZWxldGVQcm9wZXJ0eShIZWFkZXJzLCAnc2V0SGVhZGVyc0d1YXJkJylcblJlZmxlY3QuZGVsZXRlUHJvcGVydHkoSGVhZGVycywgJ2dldEhlYWRlcnNMaXN0JylcblJlZmxlY3QuZGVsZXRlUHJvcGVydHkoSGVhZGVycywgJ3NldEhlYWRlcnNMaXN0JylcblxuaXRlcmF0b3JNaXhpbignSGVhZGVycycsIEhlYWRlcnMsIGtIZWFkZXJzU29ydGVkTWFwLCAwLCAxKVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhIZWFkZXJzLnByb3RvdHlwZSwge1xuICBhcHBlbmQ6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGRlbGV0ZToga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgZ2V0OiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBoYXM6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIHNldDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgZ2V0U2V0Q29va2llOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBbU3ltYm9sLnRvU3RyaW5nVGFnXToge1xuICAgIHZhbHVlOiAnSGVhZGVycycsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0sXG4gIFt1dGlsLmluc3BlY3QuY3VzdG9tXToge1xuICAgIGVudW1lcmFibGU6IGZhbHNlXG4gIH1cbn0pXG5cbndlYmlkbC5jb252ZXJ0ZXJzLkhlYWRlcnNJbml0ID0gZnVuY3Rpb24gKFYsIHByZWZpeCwgYXJndW1lbnQpIHtcbiAgaWYgKHdlYmlkbC51dGlsLlR5cGUoVikgPT09ICdPYmplY3QnKSB7XG4gICAgY29uc3QgaXRlcmF0b3IgPSBSZWZsZWN0LmdldChWLCBTeW1ib2wuaXRlcmF0b3IpXG5cbiAgICAvLyBBIHdvcmstYXJvdW5kIHRvIGVuc3VyZSB3ZSBzZW5kIHRoZSBwcm9wZXJseS1jYXNlZCBIZWFkZXJzIHdoZW4gViBpcyBhIEhlYWRlcnMgb2JqZWN0LlxuICAgIC8vIFJlYWQgaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy91bmRpY2kvcHVsbC8zMTU5I2lzc3VlY29tbWVudC0yMDc1NTM3MjI2IGJlZm9yZSB0b3VjaGluZywgcGxlYXNlLlxuICAgIGlmICghdXRpbC50eXBlcy5pc1Byb3h5KFYpICYmIGl0ZXJhdG9yID09PSBIZWFkZXJzLnByb3RvdHlwZS5lbnRyaWVzKSB7IC8vIEhlYWRlcnMgb2JqZWN0XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gZ2V0SGVhZGVyc0xpc3QoVikuZW50cmllc0xpc3RcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgICAvLyBmYWxsLXRocm91Z2hcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGl0ZXJhdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gd2ViaWRsLmNvbnZlcnRlcnNbJ3NlcXVlbmNlPHNlcXVlbmNlPEJ5dGVTdHJpbmc+PiddKFYsIHByZWZpeCwgYXJndW1lbnQsIGl0ZXJhdG9yLmJpbmQoVikpXG4gICAgfVxuXG4gICAgcmV0dXJuIHdlYmlkbC5jb252ZXJ0ZXJzWydyZWNvcmQ8Qnl0ZVN0cmluZywgQnl0ZVN0cmluZz4nXShWLCBwcmVmaXgsIGFyZ3VtZW50KVxuICB9XG5cbiAgdGhyb3cgd2ViaWRsLmVycm9ycy5jb252ZXJzaW9uRmFpbGVkKHtcbiAgICBwcmVmaXg6ICdIZWFkZXJzIGNvbnN0cnVjdG9yJyxcbiAgICBhcmd1bWVudDogJ0FyZ3VtZW50IDEnLFxuICAgIHR5cGVzOiBbJ3NlcXVlbmNlPHNlcXVlbmNlPEJ5dGVTdHJpbmc+PicsICdyZWNvcmQ8Qnl0ZVN0cmluZywgQnl0ZVN0cmluZz4nXVxuICB9KVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZmlsbCxcbiAgLy8gZm9yIHRlc3QuXG4gIGNvbXBhcmVIZWFkZXJOYW1lLFxuICBIZWFkZXJzLFxuICBIZWFkZXJzTGlzdCxcbiAgZ2V0SGVhZGVyc0d1YXJkLFxuICBzZXRIZWFkZXJzR3VhcmQsXG4gIHNldEhlYWRlcnNMaXN0LFxuICBnZXRIZWFkZXJzTGlzdFxufVxuIl0sIm5hbWVzIjpbImtDb25zdHJ1Y3QiLCJyZXF1aXJlIiwia0VudW1lcmFibGVQcm9wZXJ0eSIsIml0ZXJhdG9yTWl4aW4iLCJpc1ZhbGlkSGVhZGVyTmFtZSIsImlzVmFsaWRIZWFkZXJWYWx1ZSIsIndlYmlkbCIsImFzc2VydCIsInV0aWwiLCJrSGVhZGVyc01hcCIsIlN5bWJvbCIsImtIZWFkZXJzU29ydGVkTWFwIiwiaXNIVFRQV2hpdGVTcGFjZUNoYXJDb2RlIiwiY29kZSIsImhlYWRlclZhbHVlTm9ybWFsaXplIiwicG90ZW50aWFsVmFsdWUiLCJpIiwiaiIsImxlbmd0aCIsImNoYXJDb2RlQXQiLCJzdWJzdHJpbmciLCJmaWxsIiwiaGVhZGVycyIsIm9iamVjdCIsIkFycmF5IiwiaXNBcnJheSIsImhlYWRlciIsImVycm9ycyIsImV4Y2VwdGlvbiIsIm1lc3NhZ2UiLCJhcHBlbmRIZWFkZXIiLCJrZXlzIiwiT2JqZWN0IiwiY29udmVyc2lvbkZhaWxlZCIsInByZWZpeCIsImFyZ3VtZW50IiwidHlwZXMiLCJuYW1lIiwidmFsdWUiLCJpbnZhbGlkQXJndW1lbnQiLCJ0eXBlIiwiZ2V0SGVhZGVyc0d1YXJkIiwiVHlwZUVycm9yIiwiZ2V0SGVhZGVyc0xpc3QiLCJhcHBlbmQiLCJjb21wYXJlSGVhZGVyTmFtZSIsImEiLCJiIiwiSGVhZGVyc0xpc3QiLCJjb25zdHJ1Y3RvciIsImluaXQiLCJjb29raWVzIiwiTWFwIiwiY29udGFpbnMiLCJpc0xvd2VyQ2FzZSIsImhhcyIsInRvTG93ZXJDYXNlIiwiY2xlYXIiLCJsb3dlcmNhc2VOYW1lIiwiZXhpc3RzIiwiZ2V0IiwiZGVsaW1pdGVyIiwic2V0IiwicHVzaCIsImRlbGV0ZSIsIml0ZXJhdG9yIiwiZW50cmllcyIsInNpemUiLCJ2YWx1ZXMiLCJyYXdWYWx1ZXMiLCJlbnRyaWVzTGlzdCIsImxvd2VyTmFtZSIsImNvb2tpZSIsInRvU29ydGVkQXJyYXkiLCJhcnJheSIsImZpcnN0VmFsdWUiLCJuZXh0IiwicmlnaHQiLCJsZWZ0IiwicGl2b3QiLCJ4IiwiZG9uZSIsInNvcnQiLCJIZWFkZXJzIiwiZ3VhcmQiLCJoZWFkZXJzTGlzdCIsInVuZGVmaW5lZCIsImNvbnZlcnRlcnMiLCJIZWFkZXJzSW5pdCIsImJyYW5kQ2hlY2siLCJhcmd1bWVudExlbmd0aENoZWNrIiwiYXJndW1lbnRzIiwiQnl0ZVN0cmluZyIsImdldFNldENvb2tpZSIsImxpc3QiLCJuYW1lcyIsImluc3BlY3QiLCJjdXN0b20iLCJkZXB0aCIsIm9wdGlvbnMiLCJmb3JtYXRXaXRoT3B0aW9ucyIsIm8iLCJzZXRIZWFkZXJzR3VhcmQiLCJzZXRIZWFkZXJzTGlzdCIsIlJlZmxlY3QiLCJkZWxldGVQcm9wZXJ0eSIsImRlZmluZVByb3BlcnRpZXMiLCJwcm90b3R5cGUiLCJ0b1N0cmluZ1RhZyIsImNvbmZpZ3VyYWJsZSIsImVudW1lcmFibGUiLCJWIiwiVHlwZSIsImlzUHJveHkiLCJiaW5kIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/fetch/headers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/fetch/index.js":
/*!****************************************************!*\
  !*** ./node_modules/undici/lib/web/fetch/index.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// https://github.com/Ethan-Arrowood/undici-fetch\n\nconst { makeNetworkError, makeAppropriateNetworkError, filterResponse, makeResponse, fromInnerResponse } = __webpack_require__(/*! ./response */ \"(ssr)/./node_modules/undici/lib/web/fetch/response.js\");\nconst { HeadersList } = __webpack_require__(/*! ./headers */ \"(ssr)/./node_modules/undici/lib/web/fetch/headers.js\");\nconst { Request, cloneRequest } = __webpack_require__(/*! ./request */ \"(ssr)/./node_modules/undici/lib/web/fetch/request.js\");\nconst zlib = __webpack_require__(/*! node:zlib */ \"node:zlib\");\nconst { bytesMatch, makePolicyContainer, clonePolicyContainer, requestBadPort, TAOCheck, appendRequestOriginHeader, responseLocationURL, requestCurrentURL, setRequestReferrerPolicyOnRedirect, tryUpgradeRequestToAPotentiallyTrustworthyURL, createOpaqueTimingInfo, appendFetchMetadata, corsCheck, crossOriginResourcePolicyCheck, determineRequestsReferrer, coarsenedSharedCurrentTime, createDeferredPromise, isBlobLike, sameOrigin, isCancelled, isAborted, isErrorLike, fullyReadBody, readableStreamClose, isomorphicEncode, urlIsLocal, urlIsHttpHttpsScheme, urlHasHttpsScheme, clampAndCoarsenConnectionTimingInfo, simpleRangeHeaderValue, buildContentRange, createInflate, extractMimeType } = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/undici/lib/web/fetch/util.js\");\nconst { kState, kDispatcher } = __webpack_require__(/*! ./symbols */ \"(ssr)/./node_modules/undici/lib/web/fetch/symbols.js\");\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\");\nconst { safelyExtractBody, extractBody } = __webpack_require__(/*! ./body */ \"(ssr)/./node_modules/undici/lib/web/fetch/body.js\");\nconst { redirectStatusSet, nullBodyStatus, safeMethodsSet, requestBodyHeader, subresourceSet } = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/undici/lib/web/fetch/constants.js\");\nconst EE = __webpack_require__(/*! node:events */ \"node:events\");\nconst { Readable, pipeline, finished } = __webpack_require__(/*! node:stream */ \"node:stream\");\nconst { addAbortListener, isErrored, isReadable, bufferToLowerCasedHeaderName } = __webpack_require__(/*! ../../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\");\nconst { dataURLProcessor, serializeAMimeType, minimizeSupportedMimeType } = __webpack_require__(/*! ./data-url */ \"(ssr)/./node_modules/undici/lib/web/fetch/data-url.js\");\nconst { getGlobalDispatcher } = __webpack_require__(/*! ../../global */ \"(ssr)/./node_modules/undici/lib/global.js\");\nconst { webidl } = __webpack_require__(/*! ./webidl */ \"(ssr)/./node_modules/undici/lib/web/fetch/webidl.js\");\nconst { STATUS_CODES } = __webpack_require__(/*! node:http */ \"node:http\");\nconst GET_OR_HEAD = [\n    \"GET\",\n    \"HEAD\"\n];\nconst defaultUserAgent = typeof __UNDICI_IS_NODE__ !== \"undefined\" || typeof esbuildDetection !== \"undefined\" ? \"node\" : \"undici\";\n/** @type {import('buffer').resolveObjectURL} */ let resolveObjectURL;\nclass Fetch extends EE {\n    constructor(dispatcher){\n        super();\n        this.dispatcher = dispatcher;\n        this.connection = null;\n        this.dump = false;\n        this.state = \"ongoing\";\n    }\n    terminate(reason) {\n        if (this.state !== \"ongoing\") {\n            return;\n        }\n        this.state = \"terminated\";\n        this.connection?.destroy(reason);\n        this.emit(\"terminated\", reason);\n    }\n    // https://fetch.spec.whatwg.org/#fetch-controller-abort\n    abort(error) {\n        if (this.state !== \"ongoing\") {\n            return;\n        }\n        // 1. Set controllers state to \"aborted\".\n        this.state = \"aborted\";\n        // 2. Let fallbackError be an \"AbortError\" DOMException.\n        // 3. Set error to fallbackError if it is not given.\n        if (!error) {\n            error = new DOMException(\"The operation was aborted.\", \"AbortError\");\n        }\n        // 4. Let serializedError be StructuredSerialize(error).\n        //    If that threw an exception, catch it, and let\n        //    serializedError be StructuredSerialize(fallbackError).\n        // 5. Set controllers serialized abort reason to serializedError.\n        this.serializedAbortReason = error;\n        this.connection?.destroy(error);\n        this.emit(\"terminated\", error);\n    }\n}\nfunction handleFetchDone(response) {\n    finalizeAndReportTiming(response, \"fetch\");\n}\n// https://fetch.spec.whatwg.org/#fetch-method\nfunction fetch(input, init = undefined) {\n    webidl.argumentLengthCheck(arguments, 1, \"globalThis.fetch\");\n    // 1. Let p be a new promise.\n    let p = createDeferredPromise();\n    // 2. Let requestObject be the result of invoking the initial value of\n    // Request as constructor with input and init as arguments. If this throws\n    // an exception, reject p with it and return p.\n    let requestObject;\n    try {\n        requestObject = new Request(input, init);\n    } catch (e) {\n        p.reject(e);\n        return p.promise;\n    }\n    // 3. Let request be requestObjects request.\n    const request = requestObject[kState];\n    // 4. If requestObjects signals aborted flag is set, then:\n    if (requestObject.signal.aborted) {\n        // 1. Abort the fetch() call with p, request, null, and\n        //    requestObjects signals abort reason.\n        abortFetch(p, request, null, requestObject.signal.reason);\n        // 2. Return p.\n        return p.promise;\n    }\n    // 5. Let globalObject be requests clients global object.\n    const globalObject = request.client.globalObject;\n    // 6. If globalObject is a ServiceWorkerGlobalScope object, then set\n    // requests service-workers mode to \"none\".\n    if (globalObject?.constructor?.name === \"ServiceWorkerGlobalScope\") {\n        request.serviceWorkers = \"none\";\n    }\n    // 7. Let responseObject be null.\n    let responseObject = null;\n    // 8. Let relevantRealm be thiss relevant Realm.\n    // 9. Let locallyAborted be false.\n    let locallyAborted = false;\n    // 10. Let controller be null.\n    let controller = null;\n    // 11. Add the following abort steps to requestObjects signal:\n    addAbortListener(requestObject.signal, ()=>{\n        // 1. Set locallyAborted to true.\n        locallyAborted = true;\n        // 2. Assert: controller is non-null.\n        assert(controller != null);\n        // 3. Abort controller with requestObjects signals abort reason.\n        controller.abort(requestObject.signal.reason);\n        const realResponse = responseObject?.deref();\n        // 4. Abort the fetch() call with p, request, responseObject,\n        //    and requestObjects signals abort reason.\n        abortFetch(p, request, realResponse, requestObject.signal.reason);\n    });\n    // 12. Let handleFetchDone given response response be to finalize and\n    // report timing with response, globalObject, and \"fetch\".\n    // see function handleFetchDone\n    // 13. Set controller to the result of calling fetch given request,\n    // with processResponseEndOfBody set to handleFetchDone, and processResponse\n    // given response being these substeps:\n    const processResponse = (response)=>{\n        // 1. If locallyAborted is true, terminate these substeps.\n        if (locallyAborted) {\n            return;\n        }\n        // 2. If responses aborted flag is set, then:\n        if (response.aborted) {\n            // 1. Let deserializedError be the result of deserialize a serialized\n            //    abort reason given controllers serialized abort reason and\n            //    relevantRealm.\n            // 2. Abort the fetch() call with p, request, responseObject, and\n            //    deserializedError.\n            abortFetch(p, request, responseObject, controller.serializedAbortReason);\n            return;\n        }\n        // 3. If response is a network error, then reject p with a TypeError\n        // and terminate these substeps.\n        if (response.type === \"error\") {\n            p.reject(new TypeError(\"fetch failed\", {\n                cause: response.error\n            }));\n            return;\n        }\n        // 4. Set responseObject to the result of creating a Response object,\n        // given response, \"immutable\", and relevantRealm.\n        responseObject = new WeakRef(fromInnerResponse(response, \"immutable\"));\n        // 5. Resolve p with responseObject.\n        p.resolve(responseObject.deref());\n        p = null;\n    };\n    controller = fetching({\n        request,\n        processResponseEndOfBody: handleFetchDone,\n        processResponse,\n        dispatcher: requestObject[kDispatcher] // undici\n    });\n    // 14. Return p.\n    return p.promise;\n}\n// https://fetch.spec.whatwg.org/#finalize-and-report-timing\nfunction finalizeAndReportTiming(response, initiatorType = \"other\") {\n    // 1. If response is an aborted network error, then return.\n    if (response.type === \"error\" && response.aborted) {\n        return;\n    }\n    // 2. If responses URL list is null or empty, then return.\n    if (!response.urlList?.length) {\n        return;\n    }\n    // 3. Let originalURL be responses URL list[0].\n    const originalURL = response.urlList[0];\n    // 4. Let timingInfo be responses timing info.\n    let timingInfo = response.timingInfo;\n    // 5. Let cacheState be responses cache state.\n    let cacheState = response.cacheState;\n    // 6. If originalURLs scheme is not an HTTP(S) scheme, then return.\n    if (!urlIsHttpHttpsScheme(originalURL)) {\n        return;\n    }\n    // 7. If timingInfo is null, then return.\n    if (timingInfo === null) {\n        return;\n    }\n    // 8. If responses timing allow passed flag is not set, then:\n    if (!response.timingAllowPassed) {\n        //  1. Set timingInfo to a the result of creating an opaque timing info for timingInfo.\n        timingInfo = createOpaqueTimingInfo({\n            startTime: timingInfo.startTime\n        });\n        //  2. Set cacheState to the empty string.\n        cacheState = \"\";\n    }\n    // 9. Set timingInfos end time to the coarsened shared current time\n    // given globals relevant settings objects cross-origin isolated\n    // capability.\n    // TODO: given globals relevant settings objects cross-origin isolated\n    // capability?\n    timingInfo.endTime = coarsenedSharedCurrentTime();\n    // 10. Set responses timing info to timingInfo.\n    response.timingInfo = timingInfo;\n    // 11. Mark resource timing for timingInfo, originalURL, initiatorType,\n    // global, and cacheState.\n    markResourceTiming(timingInfo, originalURL.href, initiatorType, globalThis, cacheState);\n}\n// https://w3c.github.io/resource-timing/#dfn-mark-resource-timing\nconst markResourceTiming = performance.markResourceTiming;\n// https://fetch.spec.whatwg.org/#abort-fetch\nfunction abortFetch(p, request, responseObject, error) {\n    // 1. Reject promise with error.\n    if (p) {\n        // We might have already resolved the promise at this stage\n        p.reject(error);\n    }\n    // 2. If requests body is not null and is readable, then cancel requests\n    // body with error.\n    if (request.body != null && isReadable(request.body?.stream)) {\n        request.body.stream.cancel(error).catch((err)=>{\n            if (err.code === \"ERR_INVALID_STATE\") {\n                // Node bug?\n                return;\n            }\n            throw err;\n        });\n    }\n    // 3. If responseObject is null, then return.\n    if (responseObject == null) {\n        return;\n    }\n    // 4. Let response be responseObjects response.\n    const response = responseObject[kState];\n    // 5. If responses body is not null and is readable, then error responses\n    // body with error.\n    if (response.body != null && isReadable(response.body?.stream)) {\n        response.body.stream.cancel(error).catch((err)=>{\n            if (err.code === \"ERR_INVALID_STATE\") {\n                // Node bug?\n                return;\n            }\n            throw err;\n        });\n    }\n}\n// https://fetch.spec.whatwg.org/#fetching\nfunction fetching({ request, processRequestBodyChunkLength, processRequestEndOfBody, processResponse, processResponseEndOfBody, processResponseConsumeBody, useParallelQueue = false, dispatcher = getGlobalDispatcher() // undici\n }) {\n    // Ensure that the dispatcher is set accordingly\n    assert(dispatcher);\n    // 1. Let taskDestination be null.\n    let taskDestination = null;\n    // 2. Let crossOriginIsolatedCapability be false.\n    let crossOriginIsolatedCapability = false;\n    // 3. If requests client is non-null, then:\n    if (request.client != null) {\n        // 1. Set taskDestination to requests clients global object.\n        taskDestination = request.client.globalObject;\n        // 2. Set crossOriginIsolatedCapability to requests clients cross-origin\n        // isolated capability.\n        crossOriginIsolatedCapability = request.client.crossOriginIsolatedCapability;\n    }\n    // 4. If useParallelQueue is true, then set taskDestination to the result of\n    // starting a new parallel queue.\n    // TODO\n    // 5. Let timingInfo be a new fetch timing info whose start time and\n    // post-redirect start time are the coarsened shared current time given\n    // crossOriginIsolatedCapability.\n    const currentTime = coarsenedSharedCurrentTime(crossOriginIsolatedCapability);\n    const timingInfo = createOpaqueTimingInfo({\n        startTime: currentTime\n    });\n    // 6. Let fetchParams be a new fetch params whose\n    // request is request,\n    // timing info is timingInfo,\n    // process request body chunk length is processRequestBodyChunkLength,\n    // process request end-of-body is processRequestEndOfBody,\n    // process response is processResponse,\n    // process response consume body is processResponseConsumeBody,\n    // process response end-of-body is processResponseEndOfBody,\n    // task destination is taskDestination,\n    // and cross-origin isolated capability is crossOriginIsolatedCapability.\n    const fetchParams = {\n        controller: new Fetch(dispatcher),\n        request,\n        timingInfo,\n        processRequestBodyChunkLength,\n        processRequestEndOfBody,\n        processResponse,\n        processResponseConsumeBody,\n        processResponseEndOfBody,\n        taskDestination,\n        crossOriginIsolatedCapability\n    };\n    // 7. If requests body is a byte sequence, then set requests body to\n    //    requests body as a body.\n    // NOTE: Since fetching is only called from fetch, body should already be\n    // extracted.\n    assert(!request.body || request.body.stream);\n    // 8. If requests window is \"client\", then set requests window to requests\n    // client, if requests clients global object is a Window object; otherwise\n    // \"no-window\".\n    if (request.window === \"client\") {\n        // TODO: What if request.client is null?\n        request.window = request.client?.globalObject?.constructor?.name === \"Window\" ? request.client : \"no-window\";\n    }\n    // 9. If requests origin is \"client\", then set requests origin to requests\n    // clients origin.\n    if (request.origin === \"client\") {\n        request.origin = request.client.origin;\n    }\n    // 10. If all of the following conditions are true:\n    // TODO\n    // 11. If requests policy container is \"client\", then:\n    if (request.policyContainer === \"client\") {\n        // 1. If requests client is non-null, then set requests policy\n        // container to a clone of requests clients policy container. [HTML]\n        if (request.client != null) {\n            request.policyContainer = clonePolicyContainer(request.client.policyContainer);\n        } else {\n            // 2. Otherwise, set requests policy container to a new policy\n            // container.\n            request.policyContainer = makePolicyContainer();\n        }\n    }\n    // 12. If requests header list does not contain `Accept`, then:\n    if (!request.headersList.contains(\"accept\", true)) {\n        // 1. Let value be `*/*`.\n        const value = \"*/*\";\n        // 2. A user agent should set value to the first matching statement, if\n        // any, switching on requests destination:\n        // \"document\"\n        // \"frame\"\n        // \"iframe\"\n        // `text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8`\n        // \"image\"\n        // `image/png,image/svg+xml,image/*;q=0.8,*/*;q=0.5`\n        // \"style\"\n        // `text/css,*/*;q=0.1`\n        // TODO\n        // 3. Append `Accept`/value to requests header list.\n        request.headersList.append(\"accept\", value, true);\n    }\n    // 13. If requests header list does not contain `Accept-Language`, then\n    // user agents should append `Accept-Language`/an appropriate value to\n    // requests header list.\n    if (!request.headersList.contains(\"accept-language\", true)) {\n        request.headersList.append(\"accept-language\", \"*\", true);\n    }\n    // 14. If requests priority is null, then use requests initiator and\n    // destination appropriately in setting requests priority to a\n    // user-agent-defined object.\n    if (request.priority === null) {\n    // TODO\n    }\n    // 15. If request is a subresource request, then:\n    if (subresourceSet.has(request.destination)) {\n    // TODO\n    }\n    // 16. Run main fetch given fetchParams.\n    mainFetch(fetchParams).catch((err)=>{\n        fetchParams.controller.terminate(err);\n    });\n    // 17. Return fetchParam's controller\n    return fetchParams.controller;\n}\n// https://fetch.spec.whatwg.org/#concept-main-fetch\nasync function mainFetch(fetchParams, recursive = false) {\n    // 1. Let request be fetchParamss request.\n    const request = fetchParams.request;\n    // 2. Let response be null.\n    let response = null;\n    // 3. If requests local-URLs-only flag is set and requests current URL is\n    // not local, then set response to a network error.\n    if (request.localURLsOnly && !urlIsLocal(requestCurrentURL(request))) {\n        response = makeNetworkError(\"local URLs only\");\n    }\n    // 4. Run report Content Security Policy violations for request.\n    // TODO\n    // 5. Upgrade request to a potentially trustworthy URL, if appropriate.\n    tryUpgradeRequestToAPotentiallyTrustworthyURL(request);\n    // 6. If should request be blocked due to a bad port, should fetching request\n    // be blocked as mixed content, or should request be blocked by Content\n    // Security Policy returns blocked, then set response to a network error.\n    if (requestBadPort(request) === \"blocked\") {\n        response = makeNetworkError(\"bad port\");\n    }\n    // TODO: should fetching request be blocked as mixed content?\n    // TODO: should request be blocked by Content Security Policy?\n    // 7. If requests referrer policy is the empty string, then set requests\n    // referrer policy to requests policy containers referrer policy.\n    if (request.referrerPolicy === \"\") {\n        request.referrerPolicy = request.policyContainer.referrerPolicy;\n    }\n    // 8. If requests referrer is not \"no-referrer\", then set requests\n    // referrer to the result of invoking determine requests referrer.\n    if (request.referrer !== \"no-referrer\") {\n        request.referrer = determineRequestsReferrer(request);\n    }\n    // 9. Set requests current URLs scheme to \"https\" if all of the following\n    // conditions are true:\n    // - requests current URLs scheme is \"http\"\n    // - requests current URLs host is a domain\n    // - Matching requests current URLs host per Known HSTS Host Domain Name\n    //   Matching results in either a superdomain match with an asserted\n    //   includeSubDomains directive or a congruent match (with or without an\n    //   asserted includeSubDomains directive). [HSTS]\n    // TODO\n    // 10. If recursive is false, then run the remaining steps in parallel.\n    // TODO\n    // 11. If response is null, then set response to the result of running\n    // the steps corresponding to the first matching statement:\n    if (response === null) {\n        response = await (async ()=>{\n            const currentURL = requestCurrentURL(request);\n            if (// - requests current URLs origin is same origin with requests origin,\n            //   and requests response tainting is \"basic\"\n            sameOrigin(currentURL, request.url) && request.responseTainting === \"basic\" || // requests current URLs scheme is \"data\"\n            currentURL.protocol === \"data:\" || // - requests mode is \"navigate\" or \"websocket\"\n            request.mode === \"navigate\" || request.mode === \"websocket\") {\n                // 1. Set requests response tainting to \"basic\".\n                request.responseTainting = \"basic\";\n                // 2. Return the result of running scheme fetch given fetchParams.\n                return await schemeFetch(fetchParams);\n            }\n            // requests mode is \"same-origin\"\n            if (request.mode === \"same-origin\") {\n                // 1. Return a network error.\n                return makeNetworkError('request mode cannot be \"same-origin\"');\n            }\n            // requests mode is \"no-cors\"\n            if (request.mode === \"no-cors\") {\n                // 1. If requests redirect mode is not \"follow\", then return a network\n                // error.\n                if (request.redirect !== \"follow\") {\n                    return makeNetworkError('redirect mode cannot be \"follow\" for \"no-cors\" request');\n                }\n                // 2. Set requests response tainting to \"opaque\".\n                request.responseTainting = \"opaque\";\n                // 3. Return the result of running scheme fetch given fetchParams.\n                return await schemeFetch(fetchParams);\n            }\n            // requests current URLs scheme is not an HTTP(S) scheme\n            if (!urlIsHttpHttpsScheme(requestCurrentURL(request))) {\n                // Return a network error.\n                return makeNetworkError(\"URL scheme must be a HTTP(S) scheme\");\n            }\n            // - requests use-CORS-preflight flag is set\n            // - requests unsafe-request flag is set and either requests method is\n            //   not a CORS-safelisted method or CORS-unsafe request-header names with\n            //   requests header list is not empty\n            //    1. Set requests response tainting to \"cors\".\n            //    2. Let corsWithPreflightResponse be the result of running HTTP fetch\n            //    given fetchParams and true.\n            //    3. If corsWithPreflightResponse is a network error, then clear cache\n            //    entries using request.\n            //    4. Return corsWithPreflightResponse.\n            // TODO\n            // Otherwise\n            //    1. Set requests response tainting to \"cors\".\n            request.responseTainting = \"cors\";\n            //    2. Return the result of running HTTP fetch given fetchParams.\n            return await httpFetch(fetchParams);\n        })();\n    }\n    // 12. If recursive is true, then return response.\n    if (recursive) {\n        return response;\n    }\n    // 13. If response is not a network error and response is not a filtered\n    // response, then:\n    if (response.status !== 0 && !response.internalResponse) {\n        // If requests response tainting is \"cors\", then:\n        if (request.responseTainting === \"cors\") {\n        // 1. Let headerNames be the result of extracting header list values\n        // given `Access-Control-Expose-Headers` and responses header list.\n        // TODO\n        // 2. If requests credentials mode is not \"include\" and headerNames\n        // contains `*`, then set responses CORS-exposed header-name list to\n        // all unique header names in responses header list.\n        // TODO\n        // 3. Otherwise, if headerNames is not null or failure, then set\n        // responses CORS-exposed header-name list to headerNames.\n        // TODO\n        }\n        // Set response to the following filtered response with response as its\n        // internal response, depending on requests response tainting:\n        if (request.responseTainting === \"basic\") {\n            response = filterResponse(response, \"basic\");\n        } else if (request.responseTainting === \"cors\") {\n            response = filterResponse(response, \"cors\");\n        } else if (request.responseTainting === \"opaque\") {\n            response = filterResponse(response, \"opaque\");\n        } else {\n            assert(false);\n        }\n    }\n    // 14. Let internalResponse be response, if response is a network error,\n    // and responses internal response otherwise.\n    let internalResponse = response.status === 0 ? response : response.internalResponse;\n    // 15. If internalResponses URL list is empty, then set it to a clone of\n    // requests URL list.\n    if (internalResponse.urlList.length === 0) {\n        internalResponse.urlList.push(...request.urlList);\n    }\n    // 16. If requests timing allow failed flag is unset, then set\n    // internalResponses timing allow passed flag.\n    if (!request.timingAllowFailed) {\n        response.timingAllowPassed = true;\n    }\n    // 17. If response is not a network error and any of the following returns\n    // blocked\n    // - should internalResponse to request be blocked as mixed content\n    // - should internalResponse to request be blocked by Content Security Policy\n    // - should internalResponse to request be blocked due to its MIME type\n    // - should internalResponse to request be blocked due to nosniff\n    // TODO\n    // 18. If responses type is \"opaque\", internalResponses status is 206,\n    // internalResponses range-requested flag is set, and requests header\n    // list does not contain `Range`, then set response and internalResponse\n    // to a network error.\n    if (response.type === \"opaque\" && internalResponse.status === 206 && internalResponse.rangeRequested && !request.headers.contains(\"range\", true)) {\n        response = internalResponse = makeNetworkError();\n    }\n    // 19. If response is not a network error and either requests method is\n    // `HEAD` or `CONNECT`, or internalResponses status is a null body status,\n    // set internalResponses body to null and disregard any enqueuing toward\n    // it (if any).\n    if (response.status !== 0 && (request.method === \"HEAD\" || request.method === \"CONNECT\" || nullBodyStatus.includes(internalResponse.status))) {\n        internalResponse.body = null;\n        fetchParams.controller.dump = true;\n    }\n    // 20. If requests integrity metadata is not the empty string, then:\n    if (request.integrity) {\n        // 1. Let processBodyError be this step: run fetch finale given fetchParams\n        // and a network error.\n        const processBodyError = (reason)=>fetchFinale(fetchParams, makeNetworkError(reason));\n        // 2. If requests response tainting is \"opaque\", or responses body is null,\n        // then run processBodyError and abort these steps.\n        if (request.responseTainting === \"opaque\" || response.body == null) {\n            processBodyError(response.error);\n            return;\n        }\n        // 3. Let processBody given bytes be these steps:\n        const processBody = (bytes)=>{\n            // 1. If bytes do not match requests integrity metadata,\n            // then run processBodyError and abort these steps. [SRI]\n            if (!bytesMatch(bytes, request.integrity)) {\n                processBodyError(\"integrity mismatch\");\n                return;\n            }\n            // 2. Set responses body to bytes as a body.\n            response.body = safelyExtractBody(bytes)[0];\n            // 3. Run fetch finale given fetchParams and response.\n            fetchFinale(fetchParams, response);\n        };\n        // 4. Fully read responses body given processBody and processBodyError.\n        await fullyReadBody(response.body, processBody, processBodyError);\n    } else {\n        // 21. Otherwise, run fetch finale given fetchParams and response.\n        fetchFinale(fetchParams, response);\n    }\n}\n// https://fetch.spec.whatwg.org/#concept-scheme-fetch\n// given a fetch params fetchParams\nfunction schemeFetch(fetchParams) {\n    // Note: since the connection is destroyed on redirect, which sets fetchParams to a\n    // cancelled state, we do not want this condition to trigger *unless* there have been\n    // no redirects. See https://github.com/nodejs/undici/issues/1776\n    // 1. If fetchParams is canceled, then return the appropriate network error for fetchParams.\n    if (isCancelled(fetchParams) && fetchParams.request.redirectCount === 0) {\n        return Promise.resolve(makeAppropriateNetworkError(fetchParams));\n    }\n    // 2. Let request be fetchParamss request.\n    const { request } = fetchParams;\n    const { protocol: scheme } = requestCurrentURL(request);\n    // 3. Switch on requests current URLs scheme and run the associated steps:\n    switch(scheme){\n        case \"about:\":\n            {\n                // If requests current URLs path is the string \"blank\", then return a new response\n                // whose status message is `OK`, header list is  (`Content-Type`, `text/html;charset=utf-8`) ,\n                // and body is the empty byte sequence as a body.\n                // Otherwise, return a network error.\n                return Promise.resolve(makeNetworkError(\"about scheme is not supported\"));\n            }\n        case \"blob:\":\n            {\n                if (!resolveObjectURL) {\n                    resolveObjectURL = (__webpack_require__(/*! node:buffer */ \"node:buffer\").resolveObjectURL);\n                }\n                // 1. Let blobURLEntry be requests current URLs blob URL entry.\n                const blobURLEntry = requestCurrentURL(request);\n                // https://github.com/web-platform-tests/wpt/blob/7b0ebaccc62b566a1965396e5be7bb2bc06f841f/FileAPI/url/resources/fetch-tests.js#L52-L56\n                // Buffer.resolveObjectURL does not ignore URL queries.\n                if (blobURLEntry.search.length !== 0) {\n                    return Promise.resolve(makeNetworkError(\"NetworkError when attempting to fetch resource.\"));\n                }\n                const blob = resolveObjectURL(blobURLEntry.toString());\n                // 2. If requests method is not `GET`, blobURLEntry is null, or blobURLEntrys\n                //    object is not a Blob object, then return a network error.\n                if (request.method !== \"GET\" || !isBlobLike(blob)) {\n                    return Promise.resolve(makeNetworkError(\"invalid method\"));\n                }\n                // 3. Let blob be blobURLEntrys object.\n                // Note: done above\n                // 4. Let response be a new response.\n                const response = makeResponse();\n                // 5. Let fullLength be blobs size.\n                const fullLength = blob.size;\n                // 6. Let serializedFullLength be fullLength, serialized and isomorphic encoded.\n                const serializedFullLength = isomorphicEncode(`${fullLength}`);\n                // 7. Let type be blobs type.\n                const type = blob.type;\n                // 8. If requests header list does not contain `Range`:\n                // 9. Otherwise:\n                if (!request.headersList.contains(\"range\", true)) {\n                    // 1. Let bodyWithType be the result of safely extracting blob.\n                    // Note: in the FileAPI a blob \"object\" is a Blob *or* a MediaSource.\n                    // In node, this can only ever be a Blob. Therefore we can safely\n                    // use extractBody directly.\n                    const bodyWithType = extractBody(blob);\n                    // 2. Set responses status message to `OK`.\n                    response.statusText = \"OK\";\n                    // 3. Set responses body to bodyWithTypes body.\n                    response.body = bodyWithType[0];\n                    // 4. Set responses header list to  (`Content-Length`, serializedFullLength), (`Content-Type`, type) .\n                    response.headersList.set(\"content-length\", serializedFullLength, true);\n                    response.headersList.set(\"content-type\", type, true);\n                } else {\n                    // 1. Set responses range-requested flag.\n                    response.rangeRequested = true;\n                    // 2. Let rangeHeader be the result of getting `Range` from requests header list.\n                    const rangeHeader = request.headersList.get(\"range\", true);\n                    // 3. Let rangeValue be the result of parsing a single range header value given rangeHeader and true.\n                    const rangeValue = simpleRangeHeaderValue(rangeHeader, true);\n                    // 4. If rangeValue is failure, then return a network error.\n                    if (rangeValue === \"failure\") {\n                        return Promise.resolve(makeNetworkError(\"failed to fetch the data URL\"));\n                    }\n                    // 5. Let (rangeStart, rangeEnd) be rangeValue.\n                    let { rangeStartValue: rangeStart, rangeEndValue: rangeEnd } = rangeValue;\n                    // 6. If rangeStart is null:\n                    // 7. Otherwise:\n                    if (rangeStart === null) {\n                        // 1. Set rangeStart to fullLength  rangeEnd.\n                        rangeStart = fullLength - rangeEnd;\n                        // 2. Set rangeEnd to rangeStart + rangeEnd  1.\n                        rangeEnd = rangeStart + rangeEnd - 1;\n                    } else {\n                        // 1. If rangeStart is greater than or equal to fullLength, then return a network error.\n                        if (rangeStart >= fullLength) {\n                            return Promise.resolve(makeNetworkError(\"Range start is greater than the blob's size.\"));\n                        }\n                        // 2. If rangeEnd is null or rangeEnd is greater than or equal to fullLength, then set\n                        //    rangeEnd to fullLength  1.\n                        if (rangeEnd === null || rangeEnd >= fullLength) {\n                            rangeEnd = fullLength - 1;\n                        }\n                    }\n                    // 8. Let slicedBlob be the result of invoking slice blob given blob, rangeStart,\n                    //    rangeEnd + 1, and type.\n                    const slicedBlob = blob.slice(rangeStart, rangeEnd, type);\n                    // 9. Let slicedBodyWithType be the result of safely extracting slicedBlob.\n                    // Note: same reason as mentioned above as to why we use extractBody\n                    const slicedBodyWithType = extractBody(slicedBlob);\n                    // 10. Set responses body to slicedBodyWithTypes body.\n                    response.body = slicedBodyWithType[0];\n                    // 11. Let serializedSlicedLength be slicedBlobs size, serialized and isomorphic encoded.\n                    const serializedSlicedLength = isomorphicEncode(`${slicedBlob.size}`);\n                    // 12. Let contentRange be the result of invoking build a content range given rangeStart,\n                    //     rangeEnd, and fullLength.\n                    const contentRange = buildContentRange(rangeStart, rangeEnd, fullLength);\n                    // 13. Set responses status to 206.\n                    response.status = 206;\n                    // 14. Set responses status message to `Partial Content`.\n                    response.statusText = \"Partial Content\";\n                    // 15. Set responses header list to  (`Content-Length`, serializedSlicedLength),\n                    //     (`Content-Type`, type), (`Content-Range`, contentRange) .\n                    response.headersList.set(\"content-length\", serializedSlicedLength, true);\n                    response.headersList.set(\"content-type\", type, true);\n                    response.headersList.set(\"content-range\", contentRange, true);\n                }\n                // 10. Return response.\n                return Promise.resolve(response);\n            }\n        case \"data:\":\n            {\n                // 1. Let dataURLStruct be the result of running the\n                //    data: URL processor on requests current URL.\n                const currentURL = requestCurrentURL(request);\n                const dataURLStruct = dataURLProcessor(currentURL);\n                // 2. If dataURLStruct is failure, then return a\n                //    network error.\n                if (dataURLStruct === \"failure\") {\n                    return Promise.resolve(makeNetworkError(\"failed to fetch the data URL\"));\n                }\n                // 3. Let mimeType be dataURLStructs MIME type, serialized.\n                const mimeType = serializeAMimeType(dataURLStruct.mimeType);\n                // 4. Return a response whose status message is `OK`,\n                //    header list is  (`Content-Type`, mimeType) ,\n                //    and body is dataURLStructs body as a body.\n                return Promise.resolve(makeResponse({\n                    statusText: \"OK\",\n                    headersList: [\n                        [\n                            \"content-type\",\n                            {\n                                name: \"Content-Type\",\n                                value: mimeType\n                            }\n                        ]\n                    ],\n                    body: safelyExtractBody(dataURLStruct.body)[0]\n                }));\n            }\n        case \"file:\":\n            {\n                // For now, unfortunate as it is, file URLs are left as an exercise for the reader.\n                // When in doubt, return a network error.\n                return Promise.resolve(makeNetworkError(\"not implemented... yet...\"));\n            }\n        case \"http:\":\n        case \"https:\":\n            {\n                // Return the result of running HTTP fetch given fetchParams.\n                return httpFetch(fetchParams).catch((err)=>makeNetworkError(err));\n            }\n        default:\n            {\n                return Promise.resolve(makeNetworkError(\"unknown scheme\"));\n            }\n    }\n}\n// https://fetch.spec.whatwg.org/#finalize-response\nfunction finalizeResponse(fetchParams, response) {\n    // 1. Set fetchParamss requests done flag.\n    fetchParams.request.done = true;\n    // 2, If fetchParamss process response done is not null, then queue a fetch\n    // task to run fetchParamss process response done given response, with\n    // fetchParamss task destination.\n    if (fetchParams.processResponseDone != null) {\n        queueMicrotask(()=>fetchParams.processResponseDone(response));\n    }\n}\n// https://fetch.spec.whatwg.org/#fetch-finale\nfunction fetchFinale(fetchParams, response) {\n    // 1. Let timingInfo be fetchParamss timing info.\n    let timingInfo = fetchParams.timingInfo;\n    // 2. If response is not a network error and fetchParamss requests client is a secure context,\n    //    then set timingInfos server-timing headers to the result of getting, decoding, and splitting\n    //    `Server-Timing` from responses internal responses header list.\n    // TODO\n    // 3. Let processResponseEndOfBody be the following steps:\n    const processResponseEndOfBody = ()=>{\n        // 1. Let unsafeEndTime be the unsafe shared current time.\n        const unsafeEndTime = Date.now(); // ?\n        // 2. If fetchParamss requests destination is \"document\", then set fetchParamss controllers\n        //    full timing info to fetchParamss timing info.\n        if (fetchParams.request.destination === \"document\") {\n            fetchParams.controller.fullTimingInfo = timingInfo;\n        }\n        // 3. Set fetchParamss controllers report timing steps to the following steps given a global object global:\n        fetchParams.controller.reportTimingSteps = ()=>{\n            // 1. If fetchParamss requests URLs scheme is not an HTTP(S) scheme, then return.\n            if (fetchParams.request.url.protocol !== \"https:\") {\n                return;\n            }\n            // 2. Set timingInfos end time to the relative high resolution time given unsafeEndTime and global.\n            timingInfo.endTime = unsafeEndTime;\n            // 3. Let cacheState be responses cache state.\n            let cacheState = response.cacheState;\n            // 4. Let bodyInfo be responses body info.\n            const bodyInfo = response.bodyInfo;\n            // 5. If responses timing allow passed flag is not set, then set timingInfo to the result of creating an\n            //    opaque timing info for timingInfo and set cacheState to the empty string.\n            if (!response.timingAllowPassed) {\n                timingInfo = createOpaqueTimingInfo(timingInfo);\n                cacheState = \"\";\n            }\n            // 6. Let responseStatus be 0.\n            let responseStatus = 0;\n            // 7. If fetchParamss requests mode is not \"navigate\" or responses has-cross-origin-redirects is false:\n            if (fetchParams.request.mode !== \"navigator\" || !response.hasCrossOriginRedirects) {\n                // 1. Set responseStatus to responses status.\n                responseStatus = response.status;\n                // 2. Let mimeType be the result of extracting a MIME type from responses header list.\n                const mimeType = extractMimeType(response.headersList);\n                // 3. If mimeType is not failure, then set bodyInfos content type to the result of minimizing a supported MIME type given mimeType.\n                if (mimeType !== \"failure\") {\n                    bodyInfo.contentType = minimizeSupportedMimeType(mimeType);\n                }\n            }\n            // 8. If fetchParamss requests initiator type is non-null, then mark resource timing given timingInfo,\n            //    fetchParamss requests URL, fetchParamss requests initiator type, global, cacheState, bodyInfo,\n            //    and responseStatus.\n            if (fetchParams.request.initiatorType != null) {\n                // TODO: update markresourcetiming\n                markResourceTiming(timingInfo, fetchParams.request.url.href, fetchParams.request.initiatorType, globalThis, cacheState, bodyInfo, responseStatus);\n            }\n        };\n        // 4. Let processResponseEndOfBodyTask be the following steps:\n        const processResponseEndOfBodyTask = ()=>{\n            // 1. Set fetchParamss requests done flag.\n            fetchParams.request.done = true;\n            // 2. If fetchParamss process response end-of-body is non-null, then run fetchParamss process\n            //    response end-of-body given response.\n            if (fetchParams.processResponseEndOfBody != null) {\n                queueMicrotask(()=>fetchParams.processResponseEndOfBody(response));\n            }\n            // 3. If fetchParamss requests initiator type is non-null and fetchParamss requests clients\n            //    global object is fetchParamss task destination, then run fetchParamss controllers report\n            //    timing steps given fetchParamss requests clients global object.\n            if (fetchParams.request.initiatorType != null) {\n                fetchParams.controller.reportTimingSteps();\n            }\n        };\n        // 5. Queue a fetch task to run processResponseEndOfBodyTask with fetchParamss task destination\n        queueMicrotask(()=>processResponseEndOfBodyTask());\n    };\n    // 4. If fetchParamss process response is non-null, then queue a fetch task to run fetchParamss\n    //    process response given response, with fetchParamss task destination.\n    if (fetchParams.processResponse != null) {\n        queueMicrotask(()=>{\n            fetchParams.processResponse(response);\n            fetchParams.processResponse = null;\n        });\n    }\n    // 5. Let internalResponse be response, if response is a network error; otherwise responses internal response.\n    const internalResponse = response.type === \"error\" ? response : response.internalResponse ?? response;\n    // 6. If internalResponses body is null, then run processResponseEndOfBody.\n    // 7. Otherwise:\n    if (internalResponse.body == null) {\n        processResponseEndOfBody();\n    } else {\n        // mcollina: all the following steps of the specs are skipped.\n        // The internal transform stream is not needed.\n        // See https://github.com/nodejs/undici/pull/3093#issuecomment-2050198541\n        // 1. Let transformStream be a new TransformStream.\n        // 2. Let identityTransformAlgorithm be an algorithm which, given chunk, enqueues chunk in transformStream.\n        // 3. Set up transformStream with transformAlgorithm set to identityTransformAlgorithm and flushAlgorithm\n        //    set to processResponseEndOfBody.\n        // 4. Set internalResponses bodys stream to the result of internalResponses bodys stream piped through transformStream.\n        finished(internalResponse.body.stream, ()=>{\n            processResponseEndOfBody();\n        });\n    }\n}\n// https://fetch.spec.whatwg.org/#http-fetch\nasync function httpFetch(fetchParams) {\n    // 1. Let request be fetchParamss request.\n    const request = fetchParams.request;\n    // 2. Let response be null.\n    let response = null;\n    // 3. Let actualResponse be null.\n    let actualResponse = null;\n    // 4. Let timingInfo be fetchParamss timing info.\n    const timingInfo = fetchParams.timingInfo;\n    // 5. If requests service-workers mode is \"all\", then:\n    if (request.serviceWorkers === \"all\") {\n    // TODO\n    }\n    // 6. If response is null, then:\n    if (response === null) {\n        // 1. If makeCORSPreflight is true and one of these conditions is true:\n        // TODO\n        // 2. If requests redirect mode is \"follow\", then set requests\n        // service-workers mode to \"none\".\n        if (request.redirect === \"follow\") {\n            request.serviceWorkers = \"none\";\n        }\n        // 3. Set response and actualResponse to the result of running\n        // HTTP-network-or-cache fetch given fetchParams.\n        actualResponse = response = await httpNetworkOrCacheFetch(fetchParams);\n        // 4. If requests response tainting is \"cors\" and a CORS check\n        // for request and response returns failure, then return a network error.\n        if (request.responseTainting === \"cors\" && corsCheck(request, response) === \"failure\") {\n            return makeNetworkError(\"cors failure\");\n        }\n        // 5. If the TAO check for request and response returns failure, then set\n        // requests timing allow failed flag.\n        if (TAOCheck(request, response) === \"failure\") {\n            request.timingAllowFailed = true;\n        }\n    }\n    // 7. If either requests response tainting or responses type\n    // is \"opaque\", and the cross-origin resource policy check with\n    // requests origin, requests client, requests destination,\n    // and actualResponse returns blocked, then return a network error.\n    if ((request.responseTainting === \"opaque\" || response.type === \"opaque\") && crossOriginResourcePolicyCheck(request.origin, request.client, request.destination, actualResponse) === \"blocked\") {\n        return makeNetworkError(\"blocked\");\n    }\n    // 8. If actualResponses status is a redirect status, then:\n    if (redirectStatusSet.has(actualResponse.status)) {\n        // 1. If actualResponses status is not 303, requests body is not null,\n        // and the connection uses HTTP/2, then user agents may, and are even\n        // encouraged to, transmit an RST_STREAM frame.\n        // See, https://github.com/whatwg/fetch/issues/1288\n        if (request.redirect !== \"manual\") {\n            fetchParams.controller.connection.destroy(undefined, false);\n        }\n        // 2. Switch on requests redirect mode:\n        if (request.redirect === \"error\") {\n            // Set response to a network error.\n            response = makeNetworkError(\"unexpected redirect\");\n        } else if (request.redirect === \"manual\") {\n            // Set response to an opaque-redirect filtered response whose internal\n            // response is actualResponse.\n            // NOTE(spec): On the web this would return an `opaqueredirect` response,\n            // but that doesn't make sense server side.\n            // See https://github.com/nodejs/undici/issues/1193.\n            response = actualResponse;\n        } else if (request.redirect === \"follow\") {\n            // Set response to the result of running HTTP-redirect fetch given\n            // fetchParams and response.\n            response = await httpRedirectFetch(fetchParams, response);\n        } else {\n            assert(false);\n        }\n    }\n    // 9. Set responses timing info to timingInfo.\n    response.timingInfo = timingInfo;\n    // 10. Return response.\n    return response;\n}\n// https://fetch.spec.whatwg.org/#http-redirect-fetch\nfunction httpRedirectFetch(fetchParams, response) {\n    // 1. Let request be fetchParamss request.\n    const request = fetchParams.request;\n    // 2. Let actualResponse be response, if response is not a filtered response,\n    // and responses internal response otherwise.\n    const actualResponse = response.internalResponse ? response.internalResponse : response;\n    // 3. Let locationURL be actualResponses location URL given requests current\n    // URLs fragment.\n    let locationURL;\n    try {\n        locationURL = responseLocationURL(actualResponse, requestCurrentURL(request).hash);\n        // 4. If locationURL is null, then return response.\n        if (locationURL == null) {\n            return response;\n        }\n    } catch (err) {\n        // 5. If locationURL is failure, then return a network error.\n        return Promise.resolve(makeNetworkError(err));\n    }\n    // 6. If locationURLs scheme is not an HTTP(S) scheme, then return a network\n    // error.\n    if (!urlIsHttpHttpsScheme(locationURL)) {\n        return Promise.resolve(makeNetworkError(\"URL scheme must be a HTTP(S) scheme\"));\n    }\n    // 7. If requests redirect count is 20, then return a network error.\n    if (request.redirectCount === 20) {\n        return Promise.resolve(makeNetworkError(\"redirect count exceeded\"));\n    }\n    // 8. Increase requests redirect count by 1.\n    request.redirectCount += 1;\n    // 9. If requests mode is \"cors\", locationURL includes credentials, and\n    // requests origin is not same origin with locationURLs origin, then return\n    //  a network error.\n    if (request.mode === \"cors\" && (locationURL.username || locationURL.password) && !sameOrigin(request, locationURL)) {\n        return Promise.resolve(makeNetworkError('cross origin not allowed for request mode \"cors\"'));\n    }\n    // 10. If requests response tainting is \"cors\" and locationURL includes\n    // credentials, then return a network error.\n    if (request.responseTainting === \"cors\" && (locationURL.username || locationURL.password)) {\n        return Promise.resolve(makeNetworkError('URL cannot contain credentials for request mode \"cors\"'));\n    }\n    // 11. If actualResponses status is not 303, requests body is non-null,\n    // and requests bodys source is null, then return a network error.\n    if (actualResponse.status !== 303 && request.body != null && request.body.source == null) {\n        return Promise.resolve(makeNetworkError());\n    }\n    // 12. If one of the following is true\n    // - actualResponses status is 301 or 302 and requests method is `POST`\n    // - actualResponses status is 303 and requests method is not `GET` or `HEAD`\n    if ([\n        301,\n        302\n    ].includes(actualResponse.status) && request.method === \"POST\" || actualResponse.status === 303 && !GET_OR_HEAD.includes(request.method)) {\n        // then:\n        // 1. Set requests method to `GET` and requests body to null.\n        request.method = \"GET\";\n        request.body = null;\n        // 2. For each headerName of request-body-header name, delete headerName from\n        // requests header list.\n        for (const headerName of requestBodyHeader){\n            request.headersList.delete(headerName);\n        }\n    }\n    // 13. If requests current URLs origin is not same origin with locationURLs\n    //     origin, then for each headerName of CORS non-wildcard request-header name,\n    //     delete headerName from requests header list.\n    if (!sameOrigin(requestCurrentURL(request), locationURL)) {\n        // https://fetch.spec.whatwg.org/#cors-non-wildcard-request-header-name\n        request.headersList.delete(\"authorization\", true);\n        // https://fetch.spec.whatwg.org/#authentication-entries\n        request.headersList.delete(\"proxy-authorization\", true);\n        // \"Cookie\" and \"Host\" are forbidden request-headers, which undici doesn't implement.\n        request.headersList.delete(\"cookie\", true);\n        request.headersList.delete(\"host\", true);\n    }\n    // 14. If requests body is non-null, then set requests body to the first return\n    // value of safely extracting requests bodys source.\n    if (request.body != null) {\n        assert(request.body.source != null);\n        request.body = safelyExtractBody(request.body.source)[0];\n    }\n    // 15. Let timingInfo be fetchParamss timing info.\n    const timingInfo = fetchParams.timingInfo;\n    // 16. Set timingInfos redirect end time and post-redirect start time to the\n    // coarsened shared current time given fetchParamss cross-origin isolated\n    // capability.\n    timingInfo.redirectEndTime = timingInfo.postRedirectStartTime = coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability);\n    // 17. If timingInfos redirect start time is 0, then set timingInfos\n    //  redirect start time to timingInfos start time.\n    if (timingInfo.redirectStartTime === 0) {\n        timingInfo.redirectStartTime = timingInfo.startTime;\n    }\n    // 18. Append locationURL to requests URL list.\n    request.urlList.push(locationURL);\n    // 19. Invoke set requests referrer policy on redirect on request and\n    // actualResponse.\n    setRequestReferrerPolicyOnRedirect(request, actualResponse);\n    // 20. Return the result of running main fetch given fetchParams and true.\n    return mainFetch(fetchParams, true);\n}\n// https://fetch.spec.whatwg.org/#http-network-or-cache-fetch\nasync function httpNetworkOrCacheFetch(fetchParams, isAuthenticationFetch = false, isNewConnectionFetch = false) {\n    // 1. Let request be fetchParamss request.\n    const request = fetchParams.request;\n    // 2. Let httpFetchParams be null.\n    let httpFetchParams = null;\n    // 3. Let httpRequest be null.\n    let httpRequest = null;\n    // 4. Let response be null.\n    let response = null;\n    // 5. Let storedResponse be null.\n    // TODO: cache\n    // 6. Let httpCache be null.\n    const httpCache = null;\n    // 7. Let the revalidatingFlag be unset.\n    const revalidatingFlag = false;\n    // 8. Run these steps, but abort when the ongoing fetch is terminated:\n    //    1. If requests window is \"no-window\" and requests redirect mode is\n    //    \"error\", then set httpFetchParams to fetchParams and httpRequest to\n    //    request.\n    if (request.window === \"no-window\" && request.redirect === \"error\") {\n        httpFetchParams = fetchParams;\n        httpRequest = request;\n    } else {\n        // Otherwise:\n        // 1. Set httpRequest to a clone of request.\n        httpRequest = cloneRequest(request);\n        // 2. Set httpFetchParams to a copy of fetchParams.\n        httpFetchParams = {\n            ...fetchParams\n        };\n        // 3. Set httpFetchParamss request to httpRequest.\n        httpFetchParams.request = httpRequest;\n    }\n    //    3. Let includeCredentials be true if one of\n    const includeCredentials = request.credentials === \"include\" || request.credentials === \"same-origin\" && request.responseTainting === \"basic\";\n    //    4. Let contentLength be httpRequests bodys length, if httpRequests\n    //    body is non-null; otherwise null.\n    const contentLength = httpRequest.body ? httpRequest.body.length : null;\n    //    5. Let contentLengthHeaderValue be null.\n    let contentLengthHeaderValue = null;\n    //    6. If httpRequests body is null and httpRequests method is `POST` or\n    //    `PUT`, then set contentLengthHeaderValue to `0`.\n    if (httpRequest.body == null && [\n        \"POST\",\n        \"PUT\"\n    ].includes(httpRequest.method)) {\n        contentLengthHeaderValue = \"0\";\n    }\n    //    7. If contentLength is non-null, then set contentLengthHeaderValue to\n    //    contentLength, serialized and isomorphic encoded.\n    if (contentLength != null) {\n        contentLengthHeaderValue = isomorphicEncode(`${contentLength}`);\n    }\n    //    8. If contentLengthHeaderValue is non-null, then append\n    //    `Content-Length`/contentLengthHeaderValue to httpRequests header\n    //    list.\n    if (contentLengthHeaderValue != null) {\n        httpRequest.headersList.append(\"content-length\", contentLengthHeaderValue, true);\n    }\n    //    9. If contentLengthHeaderValue is non-null, then append (`Content-Length`,\n    //    contentLengthHeaderValue) to httpRequests header list.\n    //    10. If contentLength is non-null and httpRequests keepalive is true,\n    //    then:\n    if (contentLength != null && httpRequest.keepalive) {\n    // NOTE: keepalive is a noop outside of browser context.\n    }\n    //    11. If httpRequests referrer is a URL, then append\n    //    `Referer`/httpRequests referrer, serialized and isomorphic encoded,\n    //     to httpRequests header list.\n    if (httpRequest.referrer instanceof URL) {\n        httpRequest.headersList.append(\"referer\", isomorphicEncode(httpRequest.referrer.href), true);\n    }\n    //    12. Append a request `Origin` header for httpRequest.\n    appendRequestOriginHeader(httpRequest);\n    //    13. Append the Fetch metadata headers for httpRequest. [FETCH-METADATA]\n    appendFetchMetadata(httpRequest);\n    //    14. If httpRequests header list does not contain `User-Agent`, then\n    //    user agents should append `User-Agent`/default `User-Agent` value to\n    //    httpRequests header list.\n    if (!httpRequest.headersList.contains(\"user-agent\", true)) {\n        httpRequest.headersList.append(\"user-agent\", defaultUserAgent);\n    }\n    //    15. If httpRequests cache mode is \"default\" and httpRequests header\n    //    list contains `If-Modified-Since`, `If-None-Match`,\n    //    `If-Unmodified-Since`, `If-Match`, or `If-Range`, then set\n    //    httpRequests cache mode to \"no-store\".\n    if (httpRequest.cache === \"default\" && (httpRequest.headersList.contains(\"if-modified-since\", true) || httpRequest.headersList.contains(\"if-none-match\", true) || httpRequest.headersList.contains(\"if-unmodified-since\", true) || httpRequest.headersList.contains(\"if-match\", true) || httpRequest.headersList.contains(\"if-range\", true))) {\n        httpRequest.cache = \"no-store\";\n    }\n    //    16. If httpRequests cache mode is \"no-cache\", httpRequests prevent\n    //    no-cache cache-control header modification flag is unset, and\n    //    httpRequests header list does not contain `Cache-Control`, then append\n    //    `Cache-Control`/`max-age=0` to httpRequests header list.\n    if (httpRequest.cache === \"no-cache\" && !httpRequest.preventNoCacheCacheControlHeaderModification && !httpRequest.headersList.contains(\"cache-control\", true)) {\n        httpRequest.headersList.append(\"cache-control\", \"max-age=0\", true);\n    }\n    //    17. If httpRequests cache mode is \"no-store\" or \"reload\", then:\n    if (httpRequest.cache === \"no-store\" || httpRequest.cache === \"reload\") {\n        // 1. If httpRequests header list does not contain `Pragma`, then append\n        // `Pragma`/`no-cache` to httpRequests header list.\n        if (!httpRequest.headersList.contains(\"pragma\", true)) {\n            httpRequest.headersList.append(\"pragma\", \"no-cache\", true);\n        }\n        // 2. If httpRequests header list does not contain `Cache-Control`,\n        // then append `Cache-Control`/`no-cache` to httpRequests header list.\n        if (!httpRequest.headersList.contains(\"cache-control\", true)) {\n            httpRequest.headersList.append(\"cache-control\", \"no-cache\", true);\n        }\n    }\n    //    18. If httpRequests header list contains `Range`, then append\n    //    `Accept-Encoding`/`identity` to httpRequests header list.\n    if (httpRequest.headersList.contains(\"range\", true)) {\n        httpRequest.headersList.append(\"accept-encoding\", \"identity\", true);\n    }\n    //    19. Modify httpRequests header list per HTTP. Do not append a given\n    //    header if httpRequests header list contains that headers name.\n    //    TODO: https://github.com/whatwg/fetch/issues/1285#issuecomment-896560129\n    if (!httpRequest.headersList.contains(\"accept-encoding\", true)) {\n        if (urlHasHttpsScheme(requestCurrentURL(httpRequest))) {\n            httpRequest.headersList.append(\"accept-encoding\", \"br, gzip, deflate\", true);\n        } else {\n            httpRequest.headersList.append(\"accept-encoding\", \"gzip, deflate\", true);\n        }\n    }\n    httpRequest.headersList.delete(\"host\", true);\n    //    20. If includeCredentials is true, then:\n    if (includeCredentials) {\n    // 1. If the user agent is not configured to block cookies for httpRequest\n    // (see section 7 of [COOKIES]), then:\n    // TODO: credentials\n    // 2. If httpRequests header list does not contain `Authorization`, then:\n    // TODO: credentials\n    }\n    //    21. If theres a proxy-authentication entry, use it as appropriate.\n    //    TODO: proxy-authentication\n    //    22. Set httpCache to the result of determining the HTTP cache\n    //    partition, given httpRequest.\n    //    TODO: cache\n    //    23. If httpCache is null, then set httpRequests cache mode to\n    //    \"no-store\".\n    if (httpCache == null) {\n        httpRequest.cache = \"no-store\";\n    }\n    //    24. If httpRequests cache mode is neither \"no-store\" nor \"reload\",\n    //    then:\n    if (httpRequest.cache !== \"no-store\" && httpRequest.cache !== \"reload\") {\n    // TODO: cache\n    }\n    // 9. If aborted, then return the appropriate network error for fetchParams.\n    // TODO\n    // 10. If response is null, then:\n    if (response == null) {\n        // 1. If httpRequests cache mode is \"only-if-cached\", then return a\n        // network error.\n        if (httpRequest.cache === \"only-if-cached\") {\n            return makeNetworkError(\"only if cached\");\n        }\n        // 2. Let forwardResponse be the result of running HTTP-network fetch\n        // given httpFetchParams, includeCredentials, and isNewConnectionFetch.\n        const forwardResponse = await httpNetworkFetch(httpFetchParams, includeCredentials, isNewConnectionFetch);\n        // 3. If httpRequests method is unsafe and forwardResponses status is\n        // in the range 200 to 399, inclusive, invalidate appropriate stored\n        // responses in httpCache, as per the \"Invalidation\" chapter of HTTP\n        // Caching, and set storedResponse to null. [HTTP-CACHING]\n        if (!safeMethodsSet.has(httpRequest.method) && forwardResponse.status >= 200 && forwardResponse.status <= 399) {\n        // TODO: cache\n        }\n        // 4. If the revalidatingFlag is set and forwardResponses status is 304,\n        // then:\n        if (revalidatingFlag && forwardResponse.status === 304) {\n        // TODO: cache\n        }\n        // 5. If response is null, then:\n        if (response == null) {\n            // 1. Set response to forwardResponse.\n            response = forwardResponse;\n        // 2. Store httpRequest and forwardResponse in httpCache, as per the\n        // \"Storing Responses in Caches\" chapter of HTTP Caching. [HTTP-CACHING]\n        // TODO: cache\n        }\n    }\n    // 11. Set responses URL list to a clone of httpRequests URL list.\n    response.urlList = [\n        ...httpRequest.urlList\n    ];\n    // 12. If httpRequests header list contains `Range`, then set responses\n    // range-requested flag.\n    if (httpRequest.headersList.contains(\"range\", true)) {\n        response.rangeRequested = true;\n    }\n    // 13. Set responses request-includes-credentials to includeCredentials.\n    response.requestIncludesCredentials = includeCredentials;\n    // 14. If responses status is 401, httpRequests response tainting is not\n    // \"cors\", includeCredentials is true, and requests window is an environment\n    // settings object, then:\n    // TODO\n    // 15. If responses status is 407, then:\n    if (response.status === 407) {\n        // 1. If requests window is \"no-window\", then return a network error.\n        if (request.window === \"no-window\") {\n            return makeNetworkError();\n        }\n        // 2. ???\n        // 3. If fetchParams is canceled, then return the appropriate network error for fetchParams.\n        if (isCancelled(fetchParams)) {\n            return makeAppropriateNetworkError(fetchParams);\n        }\n        // 4. Prompt the end user as appropriate in requests window and store\n        // the result as a proxy-authentication entry. [HTTP-AUTH]\n        // TODO: Invoke some kind of callback?\n        // 5. Set response to the result of running HTTP-network-or-cache fetch given\n        // fetchParams.\n        // TODO\n        return makeNetworkError(\"proxy authentication required\");\n    }\n    // 16. If all of the following are true\n    if (// responses status is 421\n    response.status === 421 && // isNewConnectionFetch is false\n    !isNewConnectionFetch && // requests body is null, or requests body is non-null and requests bodys source is non-null\n    (request.body == null || request.body.source != null)) {\n        // then:\n        // 1. If fetchParams is canceled, then return the appropriate network error for fetchParams.\n        if (isCancelled(fetchParams)) {\n            return makeAppropriateNetworkError(fetchParams);\n        }\n        // 2. Set response to the result of running HTTP-network-or-cache\n        // fetch given fetchParams, isAuthenticationFetch, and true.\n        // TODO (spec): The spec doesn't specify this but we need to cancel\n        // the active response before we can start a new one.\n        // https://github.com/whatwg/fetch/issues/1293\n        fetchParams.controller.connection.destroy();\n        response = await httpNetworkOrCacheFetch(fetchParams, isAuthenticationFetch, true);\n    }\n    // 17. If isAuthenticationFetch is true, then create an authentication entry\n    if (isAuthenticationFetch) {\n    // TODO\n    }\n    // 18. Return response.\n    return response;\n}\n// https://fetch.spec.whatwg.org/#http-network-fetch\nasync function httpNetworkFetch(fetchParams, includeCredentials = false, forceNewConnection = false) {\n    assert(!fetchParams.controller.connection || fetchParams.controller.connection.destroyed);\n    fetchParams.controller.connection = {\n        abort: null,\n        destroyed: false,\n        destroy (err, abort = true) {\n            if (!this.destroyed) {\n                this.destroyed = true;\n                if (abort) {\n                    this.abort?.(err ?? new DOMException(\"The operation was aborted.\", \"AbortError\"));\n                }\n            }\n        }\n    };\n    // 1. Let request be fetchParamss request.\n    const request = fetchParams.request;\n    // 2. Let response be null.\n    let response = null;\n    // 3. Let timingInfo be fetchParamss timing info.\n    const timingInfo = fetchParams.timingInfo;\n    // 4. Let httpCache be the result of determining the HTTP cache partition,\n    // given request.\n    // TODO: cache\n    const httpCache = null;\n    // 5. If httpCache is null, then set requests cache mode to \"no-store\".\n    if (httpCache == null) {\n        request.cache = \"no-store\";\n    }\n    // 6. Let networkPartitionKey be the result of determining the network\n    // partition key given request.\n    // TODO\n    // 7. Let newConnection be \"yes\" if forceNewConnection is true; otherwise\n    // \"no\".\n    const newConnection = forceNewConnection ? \"yes\" : \"no\"; // eslint-disable-line no-unused-vars\n    // 8. Switch on requests mode:\n    if (request.mode === \"websocket\") {\n    // Let connection be the result of obtaining a WebSocket connection,\n    // given requests current URL.\n    // TODO\n    } else {\n    // Let connection be the result of obtaining a connection, given\n    // networkPartitionKey, requests current URLs origin,\n    // includeCredentials, and forceNewConnection.\n    // TODO\n    }\n    // 9. Run these steps, but abort when the ongoing fetch is terminated:\n    //    1. If connection is failure, then return a network error.\n    //    2. Set timingInfos final connection timing info to the result of\n    //    calling clamp and coarsen connection timing info with connections\n    //    timing info, timingInfos post-redirect start time, and fetchParamss\n    //    cross-origin isolated capability.\n    //    3. If connection is not an HTTP/2 connection, requests body is non-null,\n    //    and requests bodys source is null, then append (`Transfer-Encoding`,\n    //    `chunked`) to requests header list.\n    //    4. Set timingInfos final network-request start time to the coarsened\n    //    shared current time given fetchParamss cross-origin isolated\n    //    capability.\n    //    5. Set response to the result of making an HTTP request over connection\n    //    using request with the following caveats:\n    //        - Follow the relevant requirements from HTTP. [HTTP] [HTTP-SEMANTICS]\n    //        [HTTP-COND] [HTTP-CACHING] [HTTP-AUTH]\n    //        - If requests body is non-null, and requests bodys source is null,\n    //        then the user agent may have a buffer of up to 64 kibibytes and store\n    //        a part of requests body in that buffer. If the user agent reads from\n    //        requests body beyond that buffers size and the user agent needs to\n    //        resend request, then instead return a network error.\n    //        - Set timingInfos final network-response start time to the coarsened\n    //        shared current time given fetchParamss cross-origin isolated capability,\n    //        immediately after the user agents HTTP parser receives the first byte\n    //        of the response (e.g., frame header bytes for HTTP/2 or response status\n    //        line for HTTP/1.x).\n    //        - Wait until all the headers are transmitted.\n    //        - Any responses whose status is in the range 100 to 199, inclusive,\n    //        and is not 101, are to be ignored, except for the purposes of setting\n    //        timingInfos final network-response start time above.\n    //    - If requests header list contains `Transfer-Encoding`/`chunked` and\n    //    response is transferred via HTTP/1.0 or older, then return a network\n    //    error.\n    //    - If the HTTP request results in a TLS client certificate dialog, then:\n    //        1. If requests window is an environment settings object, make the\n    //        dialog available in requests window.\n    //        2. Otherwise, return a network error.\n    // To transmit requests body body, run these steps:\n    let requestBody = null;\n    // 1. If body is null and fetchParamss process request end-of-body is\n    // non-null, then queue a fetch task given fetchParamss process request\n    // end-of-body and fetchParamss task destination.\n    if (request.body == null && fetchParams.processRequestEndOfBody) {\n        queueMicrotask(()=>fetchParams.processRequestEndOfBody());\n    } else if (request.body != null) {\n        // 2. Otherwise, if body is non-null:\n        //    1. Let processBodyChunk given bytes be these steps:\n        const processBodyChunk = async function*(bytes) {\n            // 1. If the ongoing fetch is terminated, then abort these steps.\n            if (isCancelled(fetchParams)) {\n                return;\n            }\n            // 2. Run this step in parallel: transmit bytes.\n            yield bytes;\n            // 3. If fetchParamss process request body is non-null, then run\n            // fetchParamss process request body given bytess length.\n            fetchParams.processRequestBodyChunkLength?.(bytes.byteLength);\n        };\n        // 2. Let processEndOfBody be these steps:\n        const processEndOfBody = ()=>{\n            // 1. If fetchParams is canceled, then abort these steps.\n            if (isCancelled(fetchParams)) {\n                return;\n            }\n            // 2. If fetchParamss process request end-of-body is non-null,\n            // then run fetchParamss process request end-of-body.\n            if (fetchParams.processRequestEndOfBody) {\n                fetchParams.processRequestEndOfBody();\n            }\n        };\n        // 3. Let processBodyError given e be these steps:\n        const processBodyError = (e)=>{\n            // 1. If fetchParams is canceled, then abort these steps.\n            if (isCancelled(fetchParams)) {\n                return;\n            }\n            // 2. If e is an \"AbortError\" DOMException, then abort fetchParamss controller.\n            if (e.name === \"AbortError\") {\n                fetchParams.controller.abort();\n            } else {\n                fetchParams.controller.terminate(e);\n            }\n        };\n        // 4. Incrementally read requests body given processBodyChunk, processEndOfBody,\n        // processBodyError, and fetchParamss task destination.\n        requestBody = async function*() {\n            try {\n                for await (const bytes of request.body.stream){\n                    yield* processBodyChunk(bytes);\n                }\n                processEndOfBody();\n            } catch (err) {\n                processBodyError(err);\n            }\n        }();\n    }\n    try {\n        // socket is only provided for websockets\n        const { body, status, statusText, headersList, socket } = await dispatch({\n            body: requestBody\n        });\n        if (socket) {\n            response = makeResponse({\n                status,\n                statusText,\n                headersList,\n                socket\n            });\n        } else {\n            const iterator = body[Symbol.asyncIterator]();\n            fetchParams.controller.next = ()=>iterator.next();\n            response = makeResponse({\n                status,\n                statusText,\n                headersList\n            });\n        }\n    } catch (err) {\n        // 10. If aborted, then:\n        if (err.name === \"AbortError\") {\n            // 1. If connection uses HTTP/2, then transmit an RST_STREAM frame.\n            fetchParams.controller.connection.destroy();\n            // 2. Return the appropriate network error for fetchParams.\n            return makeAppropriateNetworkError(fetchParams, err);\n        }\n        return makeNetworkError(err);\n    }\n    // 11. Let pullAlgorithm be an action that resumes the ongoing fetch\n    // if it is suspended.\n    const pullAlgorithm = async ()=>{\n        await fetchParams.controller.resume();\n    };\n    // 12. Let cancelAlgorithm be an algorithm that aborts fetchParamss\n    // controller with reason, given reason.\n    const cancelAlgorithm = (reason)=>{\n        // If the aborted fetch was already terminated, then we do not\n        // need to do anything.\n        if (!isCancelled(fetchParams)) {\n            fetchParams.controller.abort(reason);\n        }\n    };\n    // 13. Let highWaterMark be a non-negative, non-NaN number, chosen by\n    // the user agent.\n    // TODO\n    // 14. Let sizeAlgorithm be an algorithm that accepts a chunk object\n    // and returns a non-negative, non-NaN, non-infinite number, chosen by the user agent.\n    // TODO\n    // 15. Let stream be a new ReadableStream.\n    // 16. Set up stream with byte reading support with pullAlgorithm set to pullAlgorithm,\n    //     cancelAlgorithm set to cancelAlgorithm.\n    const stream = new ReadableStream({\n        async start (controller) {\n            fetchParams.controller.controller = controller;\n        },\n        async pull (controller) {\n            await pullAlgorithm(controller);\n        },\n        async cancel (reason) {\n            await cancelAlgorithm(reason);\n        },\n        type: \"bytes\"\n    });\n    // 17. Run these steps, but abort when the ongoing fetch is terminated:\n    //    1. Set responses body to a new body whose stream is stream.\n    response.body = {\n        stream,\n        source: null,\n        length: null\n    };\n    //    2. If response is not a network error and requests cache mode is\n    //    not \"no-store\", then update response in httpCache for request.\n    //    TODO\n    //    3. If includeCredentials is true and the user agent is not configured\n    //    to block cookies for request (see section 7 of [COOKIES]), then run the\n    //    \"set-cookie-string\" parsing algorithm (see section 5.2 of [COOKIES]) on\n    //    the value of each header whose name is a byte-case-insensitive match for\n    //    `Set-Cookie` in responses header list, if any, and requests current URL.\n    //    TODO\n    // 18. If aborted, then:\n    // TODO\n    // 19. Run these steps in parallel:\n    //    1. Run these steps, but abort when fetchParams is canceled:\n    fetchParams.controller.onAborted = onAborted;\n    fetchParams.controller.on(\"terminated\", onAborted);\n    fetchParams.controller.resume = async ()=>{\n        // 1. While true\n        while(true){\n            // 1-3. See onData...\n            // 4. Set bytes to the result of handling content codings given\n            // codings and bytes.\n            let bytes;\n            let isFailure;\n            try {\n                const { done, value } = await fetchParams.controller.next();\n                if (isAborted(fetchParams)) {\n                    break;\n                }\n                bytes = done ? undefined : value;\n            } catch (err) {\n                if (fetchParams.controller.ended && !timingInfo.encodedBodySize) {\n                    // zlib doesn't like empty streams.\n                    bytes = undefined;\n                } else {\n                    bytes = err;\n                    // err may be propagated from the result of calling readablestream.cancel,\n                    // which might not be an error. https://github.com/nodejs/undici/issues/2009\n                    isFailure = true;\n                }\n            }\n            if (bytes === undefined) {\n                // 2. Otherwise, if the bytes transmission for responses message\n                // body is done normally and stream is readable, then close\n                // stream, finalize response for fetchParams and response, and\n                // abort these in-parallel steps.\n                readableStreamClose(fetchParams.controller.controller);\n                finalizeResponse(fetchParams, response);\n                return;\n            }\n            // 5. Increase timingInfos decoded body size by bytess length.\n            timingInfo.decodedBodySize += bytes?.byteLength ?? 0;\n            // 6. If bytes is failure, then terminate fetchParamss controller.\n            if (isFailure) {\n                fetchParams.controller.terminate(bytes);\n                return;\n            }\n            // 7. Enqueue a Uint8Array wrapping an ArrayBuffer containing bytes\n            // into stream.\n            const buffer = new Uint8Array(bytes);\n            if (buffer.byteLength) {\n                fetchParams.controller.controller.enqueue(buffer);\n            }\n            // 8. If stream is errored, then terminate the ongoing fetch.\n            if (isErrored(stream)) {\n                fetchParams.controller.terminate();\n                return;\n            }\n            // 9. If stream doesnt need more data ask the user agent to suspend\n            // the ongoing fetch.\n            if (fetchParams.controller.controller.desiredSize <= 0) {\n                return;\n            }\n        }\n    };\n    //    2. If aborted, then:\n    function onAborted(reason) {\n        // 2. If fetchParams is aborted, then:\n        if (isAborted(fetchParams)) {\n            // 1. Set responses aborted flag.\n            response.aborted = true;\n            // 2. If stream is readable, then error stream with the result of\n            //    deserialize a serialized abort reason given fetchParamss\n            //    controllers serialized abort reason and an\n            //    implementation-defined realm.\n            if (isReadable(stream)) {\n                fetchParams.controller.controller.error(fetchParams.controller.serializedAbortReason);\n            }\n        } else {\n            // 3. Otherwise, if stream is readable, error stream with a TypeError.\n            if (isReadable(stream)) {\n                fetchParams.controller.controller.error(new TypeError(\"terminated\", {\n                    cause: isErrorLike(reason) ? reason : undefined\n                }));\n            }\n        }\n        // 4. If connection uses HTTP/2, then transmit an RST_STREAM frame.\n        // 5. Otherwise, the user agent should close connection unless it would be bad for performance to do so.\n        fetchParams.controller.connection.destroy();\n    }\n    // 20. Return response.\n    return response;\n    function dispatch({ body }) {\n        const url = requestCurrentURL(request);\n        /** @type {import('../..').Agent} */ const agent = fetchParams.controller.dispatcher;\n        return new Promise((resolve, reject)=>agent.dispatch({\n                path: url.pathname + url.search,\n                origin: url.origin,\n                method: request.method,\n                body: agent.isMockActive ? request.body && (request.body.source || request.body.stream) : body,\n                headers: request.headersList.entries,\n                maxRedirections: 0,\n                upgrade: request.mode === \"websocket\" ? \"websocket\" : undefined\n            }, {\n                body: null,\n                abort: null,\n                onConnect (abort) {\n                    // TODO (fix): Do we need connection here?\n                    const { connection } = fetchParams.controller;\n                    // Set timingInfos final connection timing info to the result of calling clamp and coarsen\n                    // connection timing info with connections timing info, timingInfos post-redirect start\n                    // time, and fetchParamss cross-origin isolated capability.\n                    // TODO: implement connection timing\n                    timingInfo.finalConnectionTimingInfo = clampAndCoarsenConnectionTimingInfo(undefined, timingInfo.postRedirectStartTime, fetchParams.crossOriginIsolatedCapability);\n                    if (connection.destroyed) {\n                        abort(new DOMException(\"The operation was aborted.\", \"AbortError\"));\n                    } else {\n                        fetchParams.controller.on(\"terminated\", abort);\n                        this.abort = connection.abort = abort;\n                    }\n                    // Set timingInfos final network-request start time to the coarsened shared current time given\n                    // fetchParamss cross-origin isolated capability.\n                    timingInfo.finalNetworkRequestStartTime = coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability);\n                },\n                onResponseStarted () {\n                    // Set timingInfos final network-response start time to the coarsened shared current\n                    // time given fetchParamss cross-origin isolated capability, immediately after the\n                    // user agents HTTP parser receives the first byte of the response (e.g., frame header\n                    // bytes for HTTP/2 or response status line for HTTP/1.x).\n                    timingInfo.finalNetworkResponseStartTime = coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability);\n                },\n                onHeaders (status, rawHeaders, resume, statusText) {\n                    if (status < 200) {\n                        return;\n                    }\n                    /** @type {string[]} */ let codings = [];\n                    let location = \"\";\n                    const headersList = new HeadersList();\n                    for(let i = 0; i < rawHeaders.length; i += 2){\n                        headersList.append(bufferToLowerCasedHeaderName(rawHeaders[i]), rawHeaders[i + 1].toString(\"latin1\"), true);\n                    }\n                    const contentEncoding = headersList.get(\"content-encoding\", true);\n                    if (contentEncoding) {\n                        // https://www.rfc-editor.org/rfc/rfc7231#section-3.1.2.1\n                        // \"All content-coding values are case-insensitive...\"\n                        codings = contentEncoding.toLowerCase().split(\",\").map((x)=>x.trim());\n                    }\n                    location = headersList.get(\"location\", true);\n                    this.body = new Readable({\n                        read: resume\n                    });\n                    const decoders = [];\n                    const willFollow = location && request.redirect === \"follow\" && redirectStatusSet.has(status);\n                    // https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Encoding\n                    if (codings.length !== 0 && request.method !== \"HEAD\" && request.method !== \"CONNECT\" && !nullBodyStatus.includes(status) && !willFollow) {\n                        for(let i = 0; i < codings.length; ++i){\n                            const coding = codings[i];\n                            // https://www.rfc-editor.org/rfc/rfc9112.html#section-7.2\n                            if (coding === \"x-gzip\" || coding === \"gzip\") {\n                                decoders.push(zlib.createGunzip({\n                                    // Be less strict when decoding compressed responses, since sometimes\n                                    // servers send slightly invalid responses that are still accepted\n                                    // by common browsers.\n                                    // Always using Z_SYNC_FLUSH is what cURL does.\n                                    flush: zlib.constants.Z_SYNC_FLUSH,\n                                    finishFlush: zlib.constants.Z_SYNC_FLUSH\n                                }));\n                            } else if (coding === \"deflate\") {\n                                decoders.push(createInflate());\n                            } else if (coding === \"br\") {\n                                decoders.push(zlib.createBrotliDecompress());\n                            } else {\n                                decoders.length = 0;\n                                break;\n                            }\n                        }\n                    }\n                    resolve({\n                        status,\n                        statusText,\n                        headersList,\n                        body: decoders.length ? pipeline(this.body, ...decoders, ()=>{}) : this.body.on(\"error\", ()=>{})\n                    });\n                    return true;\n                },\n                onData (chunk) {\n                    if (fetchParams.controller.dump) {\n                        return;\n                    }\n                    // 1. If one or more bytes have been transmitted from responses\n                    // message body, then:\n                    //  1. Let bytes be the transmitted bytes.\n                    const bytes = chunk;\n                    //  2. Let codings be the result of extracting header list values\n                    //  given `Content-Encoding` and responses header list.\n                    //  See pullAlgorithm.\n                    //  3. Increase timingInfos encoded body size by bytess length.\n                    timingInfo.encodedBodySize += bytes.byteLength;\n                    //  4. See pullAlgorithm...\n                    return this.body.push(bytes);\n                },\n                onComplete () {\n                    if (this.abort) {\n                        fetchParams.controller.off(\"terminated\", this.abort);\n                    }\n                    if (fetchParams.controller.onAborted) {\n                        fetchParams.controller.off(\"terminated\", fetchParams.controller.onAborted);\n                    }\n                    fetchParams.controller.ended = true;\n                    this.body.push(null);\n                },\n                onError (error) {\n                    if (this.abort) {\n                        fetchParams.controller.off(\"terminated\", this.abort);\n                    }\n                    this.body?.destroy(error);\n                    fetchParams.controller.terminate(error);\n                    reject(error);\n                },\n                onUpgrade (status, rawHeaders, socket) {\n                    if (status !== 101) {\n                        return;\n                    }\n                    const headersList = new HeadersList();\n                    for(let i = 0; i < rawHeaders.length; i += 2){\n                        headersList.append(bufferToLowerCasedHeaderName(rawHeaders[i]), rawHeaders[i + 1].toString(\"latin1\"), true);\n                    }\n                    resolve({\n                        status,\n                        statusText: STATUS_CODES[status],\n                        headersList,\n                        socket\n                    });\n                    return true;\n                }\n            }));\n    }\n}\nmodule.exports = {\n    fetch,\n    Fetch,\n    fetching,\n    finalizeAndReportTiming\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZmV0Y2gvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQTtBQUVBLE1BQU0sRUFDSkEsZ0JBQWdCLEVBQ2hCQywyQkFBMkIsRUFDM0JDLGNBQWMsRUFDZEMsWUFBWSxFQUNaQyxpQkFBQUEsRUFDRCxHQUFHQyxtQkFBT0EsQ0FBQztBQUNaLE1BQU0sRUFBRUMsV0FBQUEsRUFBYSxHQUFHRCxtQkFBT0EsQ0FBQztBQUNoQyxNQUFNLEVBQUVFLE9BQU8sRUFBRUMsWUFBQUEsRUFBYyxHQUFHSCxtQkFBT0EsQ0FBQztBQUMxQyxNQUFNSSxPQUFPSixtQkFBT0EsQ0FBQztBQUNyQixNQUFNLEVBQ0pLLFVBQVUsRUFDVkMsbUJBQW1CLEVBQ25CQyxvQkFBb0IsRUFDcEJDLGNBQWMsRUFDZEMsUUFBUSxFQUNSQyx5QkFBeUIsRUFDekJDLG1CQUFtQixFQUNuQkMsaUJBQWlCLEVBQ2pCQyxrQ0FBa0MsRUFDbENDLDZDQUE2QyxFQUM3Q0Msc0JBQXNCLEVBQ3RCQyxtQkFBbUIsRUFDbkJDLFNBQVMsRUFDVEMsOEJBQThCLEVBQzlCQyx5QkFBeUIsRUFDekJDLDBCQUEwQixFQUMxQkMscUJBQXFCLEVBQ3JCQyxVQUFVLEVBQ1ZDLFVBQVUsRUFDVkMsV0FBVyxFQUNYQyxTQUFTLEVBQ1RDLFdBQVcsRUFDWEMsYUFBYSxFQUNiQyxtQkFBbUIsRUFDbkJDLGdCQUFnQixFQUNoQkMsVUFBVSxFQUNWQyxvQkFBb0IsRUFDcEJDLGlCQUFpQixFQUNqQkMsbUNBQW1DLEVBQ25DQyxzQkFBc0IsRUFDdEJDLGlCQUFpQixFQUNqQkMsYUFBYSxFQUNiQyxlQUFBQSxFQUNELEdBQUdyQyxtQkFBT0EsQ0FBQztBQUNaLE1BQU0sRUFBRXNDLE1BQU0sRUFBRUMsV0FBQUEsRUFBYSxHQUFHdkMsbUJBQU9BLENBQUM7QUFDeEMsTUFBTXdDLFNBQVN4QyxtQkFBT0EsQ0FBQztBQUN2QixNQUFNLEVBQUV5QyxpQkFBaUIsRUFB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QUFZakksWUFBWSxDQUFDeUcsT0FBTzt3QkFDaENwQjt3QkFDQStHO29CQUNGO29CQUVBLE9BQU87Z0JBQ1Q7WUFDRjtJQUVKO0FBQ0Y7QUFFQTZELE9BQU9DLE9BQU8sR0FBRztJQUNmM087SUFDQWpCO0lBQ0ErQztJQUNBL0I7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL21vY2t1cGZsb3cvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZmV0Y2gvaW5kZXguanM/NTZjOCIsIndlYnBhY2s6Ly9tb2NrdXBmbG93Ly4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvd2ViL2ZldGNoL2luZGV4LmpzPzU2YzgqIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9FdGhhbi1BcnJvd29vZC91bmRpY2ktZmV0Y2hcblxuJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHtcbiAgbWFrZU5ldHdvcmtFcnJvcixcbiAgbWFrZUFwcHJvcHJpYXRlTmV0d29ya0Vycm9yLFxuICBmaWx0ZXJSZXNwb25zZSxcbiAgbWFrZVJlc3BvbnNlLFxuICBmcm9tSW5uZXJSZXNwb25zZVxufSA9IHJlcXVpcmUoJy4vcmVzcG9uc2UnKVxuY29uc3QgeyBIZWFkZXJzTGlzdCB9ID0gcmVxdWlyZSgnLi9oZWFkZXJzJylcbmNvbnN0IHsgUmVxdWVzdCwgY2xvbmVSZXF1ZXN0IH0gPSByZXF1aXJlKCcuL3JlcXVlc3QnKVxuY29uc3QgemxpYiA9IHJlcXVpcmUoJ25vZGU6emxpYicpXG5jb25zdCB7XG4gIGJ5dGVzTWF0Y2gsXG4gIG1ha2VQb2xpY3lDb250YWluZXIsXG4gIGNsb25lUG9saWN5Q29udGFpbmVyLFxuICByZXF1ZXN0QmFkUG9ydCxcbiAgVEFPQ2hlY2ssXG4gIGFwcGVuZFJlcXVlc3RPcmlnaW5IZWFkZXIsXG4gIHJlc3BvbnNlTG9jYXRpb25VUkwsXG4gIHJlcXVlc3RDdXJyZW50VVJMLFxuICBzZXRSZXF1ZXN0UmVmZXJyZXJQb2xpY3lPblJlZGlyZWN0LFxuICB0cnlVcGdyYWRlUmVxdWVzdFRvQVBvdGVudGlhbGx5VHJ1c3R3b3J0aHlVUkwsXG4gIGNyZWF0ZU9wYXF1ZVRpbWluZ0luZm8sXG4gIGFwcGVuZEZldGNoTWV0YWRhdGEsXG4gIGNvcnNDaGVjayxcbiAgY3Jvc3NPcmlnaW5SZXNvdXJjZVBvbGljeUNoZWNrLFxuICBkZXRlcm1pbmVSZXF1ZXN0c1JlZmVycmVyLFxuICBjb2Fyc2VuZWRTaGFyZWRDdXJyZW50VGltZSxcbiAgY3JlYXRlRGVmZXJyZWRQcm9taXNlLFxuICBpc0Jsb2JMaWtlLFxuICBzYW1lT3JpZ2luLFxuICBpc0NhbmNlbGxlZCxcbiAgaXNBYm9ydGVkLFxuICBpc0Vycm9yTGlrZSxcbiAgZnVsbHlSZWFkQm9keSxcbiAgcmVhZGFibGVTdHJlYW1DbG9zZSxcbiAgaXNvbW9ycGhpY0VuY29kZSxcbiAgdXJsSXNMb2NhbCxcbiAgdXJsSXNIdHRwSHR0cHNTY2hlbWUsXG4gIHVybEhhc0h0dHBzU2NoZW1lLFxuICBjbGFtcEFuZENvYXJzZW5Db25uZWN0aW9uVGltaW5nSW5mbyxcbiAgc2ltcGxlUmFuZ2VIZWFkZXJWYWx1ZSxcbiAgYnVpbGRDb250ZW50UmFuZ2UsXG4gIGNyZWF0ZUluZmxhdGUsXG4gIGV4dHJhY3RNaW1lVHlwZVxufSA9IHJlcXVpcmUoJy4vdXRpbCcpXG5jb25zdCB7IGtTdGF0ZSwga0Rpc3BhdGNoZXIgfSA9IHJlcXVpcmUoJy4vc3ltYm9scycpXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdub2RlOmFzc2VydCcpXG5jb25zdCB7IHNhZmVseUV4dHJhY3RCb2R5LCBleHRyYWN0Qm9keSB9ID0gcmVxdWlyZSgnLi9ib2R5JylcbmNvbnN0IHtcbiAgcmVkaXJlY3RTdGF0dXNTZXQsXG4gIG51bGxCb2R5U3RhdHVzLFxuICBzYWZlTWV0aG9kc1NldCxcbiAgcmVxdWVzdEJvZHlIZWFkZXIsXG4gIHN1YnJlc291cmNlU2V0XG59ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKVxuY29uc3QgRUUgPSByZXF1aXJlKCdub2RlOmV2ZW50cycpXG5jb25zdCB7IFJlYWRhYmxlLCBwaXBlbGluZSwgZmluaXNoZWQgfSA9IHJlcXVpcmUoJ25vZGU6c3RyZWFtJylcbmNvbnN0IHsgYWRkQWJvcnRMaXN0ZW5lciwgaXNFcnJvcmVkLCBpc1JlYWRhYmxlLCBidWZmZXJUb0xvd2VyQ2FzZWRIZWFkZXJOYW1lIH0gPSByZXF1aXJlKCcuLi8uLi9jb3JlL3V0aWwnKVxuY29uc3QgeyBkYXRhVVJMUHJvY2Vzc29yLCBzZXJpYWxpemVBTWltZVR5cGUsIG1pbmltaXplU3VwcG9ydGVkTWltZVR5cGUgfSA9IHJlcXVpcmUoJy4vZGF0YS11cmwnKVxuY29uc3QgeyBnZXRHbG9iYWxEaXNwYXRjaGVyIH0gPSByZXF1aXJlKCcuLi8uLi9nbG9iYWwnKVxuY29uc3QgeyB3ZWJpZGwgfSA9IHJlcXVpcmUoJy4vd2ViaWRsJylcbmNvbnN0IHsgU1RBVFVTX0NPREVTIH0gPSByZXF1aXJlKCdub2RlOmh0dHAnKVxuY29uc3QgR0VUX09SX0hFQUQgPSBbJ0dFVCcsICdIRUFEJ11cblxuY29uc3QgZGVmYXVsdFVzZXJBZ2VudCA9IHR5cGVvZiBfX1VORElDSV9JU19OT0RFX18gIT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiBlc2J1aWxkRGV0ZWN0aW9uICE9PSAndW5kZWZpbmVkJ1xuICA/ICdub2RlJ1xuICA6ICd1bmRpY2knXG5cbi8qKiBAdHlwZSB7aW1wb3J0KCdidWZmZXInKS5yZXNvbHZlT2JqZWN0VVJMfSAqL1xubGV0IHJlc29sdmVPYmplY3RVUkxcblxuY2xhc3MgRmV0Y2ggZXh0ZW5kcyBFRSB7XG4gIGNvbnN0cnVjdG9yIChkaXNwYXRjaGVyKSB7XG4gICAgc3VwZXIoKVxuXG4gICAgdGhpcy5kaXNwYXRjaGVyID0gZGlzcGF0Y2hlclxuICAgIHRoaXMuY29ubmVjdGlvbiA9IG51bGxcbiAgICB0aGlzLmR1bXAgPSBmYWxzZVxuICAgIHRoaXMuc3RhdGUgPSAnb25nb2luZydcbiAgfVxuXG4gIHRlcm1pbmF0ZSAocmVhc29uKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUgIT09ICdvbmdvaW5nJykge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpcy5zdGF0ZSA9ICd0ZXJtaW5hdGVkJ1xuICAgIHRoaXMuY29ubmVjdGlvbj8uZGVzdHJveShyZWFzb24pXG4gICAgdGhpcy5lbWl0KCd0ZXJtaW5hdGVkJywgcmVhc29uKVxuICB9XG5cbiAgLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2ZldGNoLWNvbnRyb2xsZXItYWJvcnRcbiAgYWJvcnQgKGVycm9yKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUgIT09ICdvbmdvaW5nJykge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gMS4gU2V0IGNvbnRyb2xsZXLigJlzIHN0YXRlIHRvIFwiYWJvcnRlZFwiLlxuICAgIHRoaXMuc3RhdGUgPSAnYWJvcnRlZCdcblxuICAgIC8vIDIuIExldCBmYWxsYmFja0Vycm9yIGJlIGFuIFwiQWJvcnRFcnJvclwiIERPTUV4Y2VwdGlvbi5cbiAgICAvLyAzLiBTZXQgZXJyb3IgdG8gZmFsbGJhY2tFcnJvciBpZiBpdCBpcyBub3QgZ2l2ZW4uXG4gICAgaWYgKCFlcnJvcikge1xuICAgICAgZXJyb3IgPSBuZXcgRE9NRXhjZXB0aW9uKCdUaGUgb3BlcmF0aW9uIHdhcyBhYm9ydGVkLicsICdBYm9ydEVycm9yJylcbiAgICB9XG5cbiAgICAvLyA0LiBMZXQgc2VyaWFsaXplZEVycm9yIGJlIFN0cnVjdHVyZWRTZXJpYWxpemUoZXJyb3IpLlxuICAgIC8vICAgIElmIHRoYXQgdGhyZXcgYW4gZXhjZXB0aW9uLCBjYXRjaCBpdCwgYW5kIGxldFxuICAgIC8vICAgIHNlcmlhbGl6ZWRFcnJvciBiZSBTdHJ1Y3R1cmVkU2VyaWFsaXplKGZhbGxiYWNrRXJyb3IpLlxuXG4gICAgLy8gNS4gU2V0IGNvbnRyb2xsZXLigJlzIHNlcmlhbGl6ZWQgYWJvcnQgcmVhc29uIHRvIHNlcmlhbGl6ZWRFcnJvci5cbiAgICB0aGlzLnNlcmlhbGl6ZWRBYm9ydFJlYXNvbiA9IGVycm9yXG5cbiAgICB0aGlzLmNvbm5lY3Rpb24/LmRlc3Ryb3koZXJyb3IpXG4gICAgdGhpcy5lbWl0KCd0ZXJtaW5hdGVkJywgZXJyb3IpXG4gIH1cbn1cblxuZnVuY3Rpb24gaGFuZGxlRmV0Y2hEb25lIChyZXNwb25zZSkge1xuICBmaW5hbGl6ZUFuZFJlcG9ydFRpbWluZyhyZXNwb25zZSwgJ2ZldGNoJylcbn1cblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2ZldGNoLW1ldGhvZFxuZnVuY3Rpb24gZmV0Y2ggKGlucHV0LCBpbml0ID0gdW5kZWZpbmVkKSB7XG4gIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMSwgJ2dsb2JhbFRoaXMuZmV0Y2gnKVxuXG4gIC8vIDEuIExldCBwIGJlIGEgbmV3IHByb21pc2UuXG4gIGxldCBwID0gY3JlYXRlRGVmZXJyZWRQcm9taXNlKClcblxuICAvLyAyLiBMZXQgcmVxdWVzdE9iamVjdCBiZSB0aGUgcmVzdWx0IG9mIGludm9raW5nIHRoZSBpbml0aWFsIHZhbHVlIG9mXG4gIC8vIFJlcXVlc3QgYXMgY29uc3RydWN0b3Igd2l0aCBpbnB1dCBhbmQgaW5pdCBhcyBhcmd1bWVudHMuIElmIHRoaXMgdGhyb3dzXG4gIC8vIGFuIGV4Y2VwdGlvbiwgcmVqZWN0IHAgd2l0aCBpdCBhbmQgcmV0dXJuIHAuXG4gIGxldCByZXF1ZXN0T2JqZWN0XG5cbiAgdHJ5IHtcbiAgICByZXF1ZXN0T2JqZWN0ID0gbmV3IFJlcXVlc3QoaW5wdXQsIGluaXQpXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBwLnJlamVjdChlKVxuICAgIHJldHVybiBwLnByb21pc2VcbiAgfVxuXG4gIC8vIDMuIExldCByZXF1ZXN0IGJlIHJlcXVlc3RPYmplY3TigJlzIHJlcXVlc3QuXG4gIGNvbnN0IHJlcXVlc3QgPSByZXF1ZXN0T2JqZWN0W2tTdGF0ZV1cblxuICAvLyA0LiBJZiByZXF1ZXN0T2JqZWN04oCZcyBzaWduYWzigJlzIGFib3J0ZWQgZmxhZyBpcyBzZXQsIHRoZW46XG4gIGlmIChyZXF1ZXN0T2JqZWN0LnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgLy8gMS4gQWJvcnQgdGhlIGZldGNoKCkgY2FsbCB3aXRoIHAsIHJlcXVlc3QsIG51bGwsIGFuZFxuICAgIC8vICAgIHJlcXVlc3RPYmplY3TigJlzIHNpZ25hbOKAmXMgYWJvcnQgcmVhc29uLlxuICAgIGFib3J0RmV0Y2gocCwgcmVxdWVzdCwgbnVsbCwgcmVxdWVzdE9iamVjdC5zaWduYWwucmVhc29uKVxuXG4gICAgLy8gMi4gUmV0dXJuIHAuXG4gICAgcmV0dXJuIHAucHJvbWlzZVxuICB9XG5cbiAgLy8gNS4gTGV0IGdsb2JhbE9iamVjdCBiZSByZXF1ZXN04oCZcyBjbGllbnTigJlzIGdsb2JhbCBvYmplY3QuXG4gIGNvbnN0IGdsb2JhbE9iamVjdCA9IHJlcXVlc3QuY2xpZW50Lmdsb2JhbE9iamVjdFxuXG4gIC8vIDYuIElmIGdsb2JhbE9iamVjdCBpcyBhIFNlcnZpY2VXb3JrZXJHbG9iYWxTY29wZSBvYmplY3QsIHRoZW4gc2V0XG4gIC8vIHJlcXVlc3TigJlzIHNlcnZpY2Utd29ya2VycyBtb2RlIHRvIFwibm9uZVwiLlxuICBpZiAoZ2xvYmFsT2JqZWN0Py5jb25zdHJ1Y3Rvcj8ubmFtZSA9PT0gJ1NlcnZpY2VXb3JrZXJHbG9iYWxTY29wZScpIHtcbiAgICByZXF1ZXN0LnNlcnZpY2VXb3JrZXJzID0gJ25vbmUnXG4gIH1cblxuICAvLyA3LiBMZXQgcmVzcG9uc2VPYmplY3QgYmUgbnVsbC5cbiAgbGV0IHJlc3BvbnNlT2JqZWN0ID0gbnVsbFxuXG4gIC8vIDguIExldCByZWxldmFudFJlYWxtIGJlIHRoaXPigJlzIHJlbGV2YW50IFJlYWxtLlxuXG4gIC8vIDkuIExldCBsb2NhbGx5QWJvcnRlZCBiZSBmYWxzZS5cbiAgbGV0IGxvY2FsbHlBYm9ydGVkID0gZmFsc2VcblxuICAvLyAxMC4gTGV0IGNvbnRyb2xsZXIgYmUgbnVsbC5cbiAgbGV0IGNvbnRyb2xsZXIgPSBudWxsXG5cbiAgLy8gMTEuIEFkZCB0aGUgZm9sbG93aW5nIGFib3J0IHN0ZXBzIHRvIHJlcXVlc3RPYmplY3TigJlzIHNpZ25hbDpcbiAgYWRkQWJvcnRMaXN0ZW5lcihcbiAgICByZXF1ZXN0T2JqZWN0LnNpZ25hbCxcbiAgICAoKSA9PiB7XG4gICAgICAvLyAxLiBTZXQgbG9jYWxseUFib3J0ZWQgdG8gdHJ1ZS5cbiAgICAgIGxvY2FsbHlBYm9ydGVkID0gdHJ1ZVxuXG4gICAgICAvLyAyLiBBc3NlcnQ6IGNvbnRyb2xsZXIgaXMgbm9uLW51bGwuXG4gICAgICBhc3NlcnQoY29udHJvbGxlciAhPSBudWxsKVxuXG4gICAgICAvLyAzLiBBYm9ydCBjb250cm9sbGVyIHdpdGggcmVxdWVzdE9iamVjdOKAmXMgc2lnbmFs4oCZcyBhYm9ydCByZWFzb24uXG4gICAgICBjb250cm9sbGVyLmFib3J0KHJlcXVlc3RPYmplY3Quc2lnbmFsLnJlYXNvbilcblxuICAgICAgY29uc3QgcmVhbFJlc3BvbnNlID0gcmVzcG9uc2VPYmplY3Q/LmRlcmVmKClcblxuICAgICAgLy8gNC4gQWJvcnQgdGhlIGZldGNoKCkgY2FsbCB3aXRoIHAsIHJlcXVlc3QsIHJlc3BvbnNlT2JqZWN0LFxuICAgICAgLy8gICAgYW5kIHJlcXVlc3RPYmplY3TigJlzIHNpZ25hbOKAmXMgYWJvcnQgcmVhc29uLlxuICAgICAgYWJvcnRGZXRjaChwLCByZXF1ZXN0LCByZWFsUmVzcG9uc2UsIHJlcXVlc3RPYmplY3Quc2lnbmFsLnJlYXNvbilcbiAgICB9XG4gIClcblxuICAvLyAxMi4gTGV0IGhhbmRsZUZldGNoRG9uZSBnaXZlbiByZXNwb25zZSByZXNwb25zZSBiZSB0byBmaW5hbGl6ZSBhbmRcbiAgLy8gcmVwb3J0IHRpbWluZyB3aXRoIHJlc3BvbnNlLCBnbG9iYWxPYmplY3QsIGFuZCBcImZldGNoXCIuXG4gIC8vIHNlZSBmdW5jdGlvbiBoYW5kbGVGZXRjaERvbmVcblxuICAvLyAxMy4gU2V0IGNvbnRyb2xsZXIgdG8gdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGZldGNoIGdpdmVuIHJlcXVlc3QsXG4gIC8vIHdpdGggcHJvY2Vzc1Jlc3BvbnNlRW5kT2ZCb2R5IHNldCB0byBoYW5kbGVGZXRjaERvbmUsIGFuZCBwcm9jZXNzUmVzcG9uc2VcbiAgLy8gZ2l2ZW4gcmVzcG9uc2UgYmVpbmcgdGhlc2Ugc3Vic3RlcHM6XG5cbiAgY29uc3QgcHJvY2Vzc1Jlc3BvbnNlID0gKHJlc3BvbnNlKSA9PiB7XG4gICAgLy8gMS4gSWYgbG9jYWxseUFib3J0ZWQgaXMgdHJ1ZSwgdGVybWluYXRlIHRoZXNlIHN1YnN0ZXBzLlxuICAgIGlmIChsb2NhbGx5QWJvcnRlZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gMi4gSWYgcmVzcG9uc2XigJlzIGFib3J0ZWQgZmxhZyBpcyBzZXQsIHRoZW46XG4gICAgaWYgKHJlc3BvbnNlLmFib3J0ZWQpIHtcbiAgICAgIC8vIDEuIExldCBkZXNlcmlhbGl6ZWRFcnJvciBiZSB0aGUgcmVzdWx0IG9mIGRlc2VyaWFsaXplIGEgc2VyaWFsaXplZFxuICAgICAgLy8gICAgYWJvcnQgcmVhc29uIGdpdmVuIGNvbnRyb2xsZXLigJlzIHNlcmlhbGl6ZWQgYWJvcnQgcmVhc29uIGFuZFxuICAgICAgLy8gICAgcmVsZXZhbnRSZWFsbS5cblxuICAgICAgLy8gMi4gQWJvcnQgdGhlIGZldGNoKCkgY2FsbCB3aXRoIHAsIHJlcXVlc3QsIHJlc3BvbnNlT2JqZWN0LCBhbmRcbiAgICAgIC8vICAgIGRlc2VyaWFsaXplZEVycm9yLlxuXG4gICAgICBhYm9ydEZldGNoKHAsIHJlcXVlc3QsIHJlc3BvbnNlT2JqZWN0LCBjb250cm9sbGVyLnNlcmlhbGl6ZWRBYm9ydFJlYXNvbilcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIDMuIElmIHJlc3BvbnNlIGlzIGEgbmV0d29yayBlcnJvciwgdGhlbiByZWplY3QgcCB3aXRoIGEgVHlwZUVycm9yXG4gICAgLy8gYW5kIHRlcm1pbmF0ZSB0aGVzZSBzdWJzdGVwcy5cbiAgICBpZiAocmVzcG9uc2UudHlwZSA9PT0gJ2Vycm9yJykge1xuICAgICAgcC5yZWplY3QobmV3IFR5cGVFcnJvcignZmV0Y2ggZmFpbGVkJywgeyBjYXVzZTogcmVzcG9uc2UuZXJyb3IgfSkpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyA0LiBTZXQgcmVzcG9uc2VPYmplY3QgdG8gdGhlIHJlc3VsdCBvZiBjcmVhdGluZyBhIFJlc3BvbnNlIG9iamVjdCxcbiAgICAvLyBnaXZlbiByZXNwb25zZSwgXCJpbW11dGFibGVcIiwgYW5kIHJlbGV2YW50UmVhbG0uXG4gICAgcmVzcG9uc2VPYmplY3QgPSBuZXcgV2Vha1JlZihmcm9tSW5uZXJSZXNwb25zZShyZXNwb25zZSwgJ2ltbXV0YWJsZScpKVxuXG4gICAgLy8gNS4gUmVzb2x2ZSBwIHdpdGggcmVzcG9uc2VPYmplY3QuXG4gICAgcC5yZXNvbHZlKHJlc3BvbnNlT2JqZWN0LmRlcmVmKCkpXG4gICAgcCA9IG51bGxcbiAgfVxuXG4gIGNvbnRyb2xsZXIgPSBmZXRjaGluZyh7XG4gICAgcmVxdWVzdCxcbiAgICBwcm9jZXNzUmVzcG9uc2VFbmRPZkJvZHk6IGhhbmRsZUZldGNoRG9uZSxcbiAgICBwcm9jZXNzUmVzcG9uc2UsXG4gICAgZGlzcGF0Y2hlcjogcmVxdWVzdE9iamVjdFtrRGlzcGF0Y2hlcl0gLy8gdW5kaWNpXG4gIH0pXG5cbiAgLy8gMTQuIFJldHVybiBwLlxuICByZXR1cm4gcC5wcm9taXNlXG59XG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNmaW5hbGl6ZS1hbmQtcmVwb3J0LXRpbWluZ1xuZnVuY3Rpb24gZmluYWxpemVBbmRSZXBvcnRUaW1pbmcgKHJlc3BvbnNlLCBpbml0aWF0b3JUeXBlID0gJ290aGVyJykge1xuICAvLyAxLiBJZiByZXNwb25zZSBpcyBhbiBhYm9ydGVkIG5ldHdvcmsgZXJyb3IsIHRoZW4gcmV0dXJuLlxuICBpZiAocmVzcG9uc2UudHlwZSA9PT0gJ2Vycm9yJyAmJiByZXNwb25zZS5hYm9ydGVkKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvLyAyLiBJZiByZXNwb25zZeKAmXMgVVJMIGxpc3QgaXMgbnVsbCBvciBlbXB0eSwgdGhlbiByZXR1cm4uXG4gIGlmICghcmVzcG9uc2UudXJsTGlzdD8ubGVuZ3RoKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvLyAzLiBMZXQgb3JpZ2luYWxVUkwgYmUgcmVzcG9uc2XigJlzIFVSTCBsaXN0WzBdLlxuICBjb25zdCBvcmlnaW5hbFVSTCA9IHJlc3BvbnNlLnVybExpc3RbMF1cblxuICAvLyA0LiBMZXQgdGltaW5nSW5mbyBiZSByZXNwb25zZeKAmXMgdGltaW5nIGluZm8uXG4gIGxldCB0aW1pbmdJbmZvID0gcmVzcG9uc2UudGltaW5nSW5mb1xuXG4gIC8vIDUuIExldCBjYWNoZVN0YXRlIGJlIHJlc3BvbnNl4oCZcyBjYWNoZSBzdGF0ZS5cbiAgbGV0IGNhY2hlU3RhdGUgPSByZXNwb25zZS5jYWNoZVN0YXRlXG5cbiAgLy8gNi4gSWYgb3JpZ2luYWxVUkzigJlzIHNjaGVtZSBpcyBub3QgYW4gSFRUUChTKSBzY2hlbWUsIHRoZW4gcmV0dXJuLlxuICBpZiAoIXVybElzSHR0cEh0dHBzU2NoZW1lKG9yaWdpbmFsVVJMKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLy8gNy4gSWYgdGltaW5nSW5mbyBpcyBudWxsLCB0aGVuIHJldHVybi5cbiAgaWYgKHRpbWluZ0luZm8gPT09IG51bGwpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIDguIElmIHJlc3BvbnNl4oCZcyB0aW1pbmcgYWxsb3cgcGFzc2VkIGZsYWcgaXMgbm90IHNldCwgdGhlbjpcbiAgaWYgKCFyZXNwb25zZS50aW1pbmdBbGxvd1Bhc3NlZCkge1xuICAgIC8vICAxLiBTZXQgdGltaW5nSW5mbyB0byBhIHRoZSByZXN1bHQgb2YgY3JlYXRpbmcgYW4gb3BhcXVlIHRpbWluZyBpbmZvIGZvciB0aW1pbmdJbmZvLlxuICAgIHRpbWluZ0luZm8gPSBjcmVhdGVPcGFxdWVUaW1pbmdJbmZvKHtcbiAgICAgIHN0YXJ0VGltZTogdGltaW5nSW5mby5zdGFydFRpbWVcbiAgICB9KVxuXG4gICAgLy8gIDIuIFNldCBjYWNoZVN0YXRlIHRvIHRoZSBlbXB0eSBzdHJpbmcuXG4gICAgY2FjaGVTdGF0ZSA9ICcnXG4gIH1cblxuICAvLyA5LiBTZXQgdGltaW5nSW5mb+KAmXMgZW5kIHRpbWUgdG8gdGhlIGNvYXJzZW5lZCBzaGFyZWQgY3VycmVudCB0aW1lXG4gIC8vIGdpdmVuIGdsb2JhbOKAmXMgcmVsZXZhbnQgc2V0dGluZ3Mgb2JqZWN04oCZcyBjcm9zcy1vcmlnaW4gaXNvbGF0ZWRcbiAgLy8gY2FwYWJpbGl0eS5cbiAgLy8gVE9ETzogZ2l2ZW4gZ2xvYmFs4oCZcyByZWxldmFudCBzZXR0aW5ncyBvYmplY3TigJlzIGNyb3NzLW9yaWdpbiBpc29sYXRlZFxuICAvLyBjYXBhYmlsaXR5P1xuICB0aW1pbmdJbmZvLmVuZFRpbWUgPSBjb2Fyc2VuZWRTaGFyZWRDdXJyZW50VGltZSgpXG5cbiAgLy8gMTAuIFNldCByZXNwb25zZeKAmXMgdGltaW5nIGluZm8gdG8gdGltaW5nSW5mby5cbiAgcmVzcG9uc2UudGltaW5nSW5mbyA9IHRpbWluZ0luZm9cblxuICAvLyAxMS4gTWFyayByZXNvdXJjZSB0aW1pbmcgZm9yIHRpbWluZ0luZm8sIG9yaWdpbmFsVVJMLCBpbml0aWF0b3JUeXBlLFxuICAvLyBnbG9iYWwsIGFuZCBjYWNoZVN0YXRlLlxuICBtYXJrUmVzb3VyY2VUaW1pbmcoXG4gICAgdGltaW5nSW5mbyxcbiAgICBvcmlnaW5hbFVSTC5ocmVmLFxuICAgIGluaXRpYXRvclR5cGUsXG4gICAgZ2xvYmFsVGhpcyxcbiAgICBjYWNoZVN0YXRlXG4gIClcbn1cblxuLy8gaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3Jlc291cmNlLXRpbWluZy8jZGZuLW1hcmstcmVzb3VyY2UtdGltaW5nXG5jb25zdCBtYXJrUmVzb3VyY2VUaW1pbmcgPSBwZXJmb3JtYW5jZS5tYXJrUmVzb3VyY2VUaW1pbmdcblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2Fib3J0LWZldGNoXG5mdW5jdGlvbiBhYm9ydEZldGNoIChwLCByZXF1ZXN0LCByZXNwb25zZU9iamVjdCwgZXJyb3IpIHtcbiAgLy8gMS4gUmVqZWN0IHByb21pc2Ugd2l0aCBlcnJvci5cbiAgaWYgKHApIHtcbiAgICAvLyBXZSBtaWdodCBoYXZlIGFscmVhZHkgcmVzb2x2ZWQgdGhlIHByb21pc2UgYXQgdGhpcyBzdGFnZVxuICAgIHAucmVqZWN0KGVycm9yKVxuICB9XG5cbiAgLy8gMi4gSWYgcmVxdWVzdOKAmXMgYm9keSBpcyBub3QgbnVsbCBhbmQgaXMgcmVhZGFibGUsIHRoZW4gY2FuY2VsIHJlcXVlc3TigJlzXG4gIC8vIGJvZHkgd2l0aCBlcnJvci5cbiAgaWYgKHJlcXVlc3QuYm9keSAhPSBudWxsICYmIGlzUmVhZGFibGUocmVxdWVzdC5ib2R5Py5zdHJlYW0pKSB7XG4gICAgcmVxdWVzdC5ib2R5LnN0cmVhbS5jYW5jZWwoZXJyb3IpLmNhdGNoKChlcnIpID0+IHtcbiAgICAgIGlmIChlcnIuY29kZSA9PT0gJ0VSUl9JTlZBTElEX1NUQVRFJykge1xuICAgICAgICAvLyBOb2RlIGJ1Zz9cbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJcbiAgICB9KVxuICB9XG5cbiAgLy8gMy4gSWYgcmVzcG9uc2VPYmplY3QgaXMgbnVsbCwgdGhlbiByZXR1cm4uXG4gIGlmIChyZXNwb25zZU9iamVjdCA9PSBudWxsKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvLyA0LiBMZXQgcmVzcG9uc2UgYmUgcmVzcG9uc2VPYmplY3TigJlzIHJlc3BvbnNlLlxuICBjb25zdCByZXNwb25zZSA9IHJlc3BvbnNlT2JqZWN0W2tTdGF0ZV1cblxuICAvLyA1LiBJZiByZXNwb25zZeKAmXMgYm9keSBpcyBub3QgbnVsbCBhbmQgaXMgcmVhZGFibGUsIHRoZW4gZXJyb3IgcmVzcG9uc2XigJlzXG4gIC8vIGJvZHkgd2l0aCBlcnJvci5cbiAgaWYgKHJlc3BvbnNlLmJvZHkgIT0gbnVsbCAmJiBpc1JlYWRhYmxlKHJlc3BvbnNlLmJvZHk/LnN0cmVhbSkpIHtcbiAgICByZXNwb25zZS5ib2R5LnN0cmVhbS5jYW5jZWwoZXJyb3IpLmNhdGNoKChlcnIpID0+IHtcbiAgICAgIGlmIChlcnIuY29kZSA9PT0gJ0VSUl9JTlZBTElEX1NUQVRFJykge1xuICAgICAgICAvLyBOb2RlIGJ1Zz9cbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJcbiAgICB9KVxuICB9XG59XG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNmZXRjaGluZ1xuZnVuY3Rpb24gZmV0Y2hpbmcgKHtcbiAgcmVxdWVzdCxcbiAgcHJvY2Vzc1JlcXVlc3RCb2R5Q2h1bmtMZW5ndGgsXG4gIHByb2Nlc3NSZXF1ZXN0RW5kT2ZCb2R5LFxuICBwcm9jZXNzUmVzcG9uc2UsXG4gIHByb2Nlc3NSZXNwb25zZUVuZE9mQm9keSxcbiAgcHJvY2Vzc1Jlc3BvbnNlQ29uc3VtZUJvZHksXG4gIHVzZVBhcmFsbGVsUXVldWUgPSBmYWxzZSxcbiAgZGlzcGF0Y2hlciA9IGdldEdsb2JhbERpc3BhdGNoZXIoKSAvLyB1bmRpY2lcbn0pIHtcbiAgLy8gRW5zdXJlIHRoYXQgdGhlIGRpc3BhdGNoZXIgaXMgc2V0IGFjY29yZGluZ2x5XG4gIGFzc2VydChkaXNwYXRjaGVyKVxuXG4gIC8vIDEuIExldCB0YXNrRGVzdGluYXRpb24gYmUgbnVsbC5cbiAgbGV0IHRhc2tEZXN0aW5hdGlvbiA9IG51bGxcblxuICAvLyAyLiBMZXQgY3Jvc3NPcmlnaW5Jc29sYXRlZENhcGFiaWxpdHkgYmUgZmFsc2UuXG4gIGxldCBjcm9zc09yaWdpbklzb2xhdGVkQ2FwYWJpbGl0eSA9IGZhbHNlXG5cbiAgLy8gMy4gSWYgcmVxdWVzdOKAmXMgY2xpZW50IGlzIG5vbi1udWxsLCB0aGVuOlxuICBpZiAocmVxdWVzdC5jbGllbnQgIT0gbnVsbCkge1xuICAgIC8vIDEuIFNldCB0YXNrRGVzdGluYXRpb24gdG8gcmVxdWVzdOKAmXMgY2xpZW504oCZcyBnbG9iYWwgb2JqZWN0LlxuICAgIHRhc2tEZXN0aW5hdGlvbiA9IHJlcXVlc3QuY2xpZW50Lmdsb2JhbE9iamVjdFxuXG4gICAgLy8gMi4gU2V0IGNyb3NzT3JpZ2luSXNvbGF0ZWRDYXBhYmlsaXR5IHRvIHJlcXVlc3TigJlzIGNsaWVudOKAmXMgY3Jvc3Mtb3JpZ2luXG4gICAgLy8gaXNvbGF0ZWQgY2FwYWJpbGl0eS5cbiAgICBjcm9zc09yaWdpbklzb2xhdGVkQ2FwYWJpbGl0eSA9XG4gICAgICByZXF1ZXN0LmNsaWVudC5jcm9zc09yaWdpbklzb2xhdGVkQ2FwYWJpbGl0eVxuICB9XG5cbiAgLy8gNC4gSWYgdXNlUGFyYWxsZWxRdWV1ZSBpcyB0cnVlLCB0aGVuIHNldCB0YXNrRGVzdGluYXRpb24gdG8gdGhlIHJlc3VsdCBvZlxuICAvLyBzdGFydGluZyBhIG5ldyBwYXJhbGxlbCBxdWV1ZS5cbiAgLy8gVE9ET1xuXG4gIC8vIDUuIExldCB0aW1pbmdJbmZvIGJlIGEgbmV3IGZldGNoIHRpbWluZyBpbmZvIHdob3NlIHN0YXJ0IHRpbWUgYW5kXG4gIC8vIHBvc3QtcmVkaXJlY3Qgc3RhcnQgdGltZSBhcmUgdGhlIGNvYXJzZW5lZCBzaGFyZWQgY3VycmVudCB0aW1lIGdpdmVuXG4gIC8vIGNyb3NzT3JpZ2luSXNvbGF0ZWRDYXBhYmlsaXR5LlxuICBjb25zdCBjdXJyZW50VGltZSA9IGNvYXJzZW5lZFNoYXJlZEN1cnJlbnRUaW1lKGNyb3NzT3JpZ2luSXNvbGF0ZWRDYXBhYmlsaXR5KVxuICBjb25zdCB0aW1pbmdJbmZvID0gY3JlYXRlT3BhcXVlVGltaW5nSW5mbyh7XG4gICAgc3RhcnRUaW1lOiBjdXJyZW50VGltZVxuICB9KVxuXG4gIC8vIDYuIExldCBmZXRjaFBhcmFtcyBiZSBhIG5ldyBmZXRjaCBwYXJhbXMgd2hvc2VcbiAgLy8gcmVxdWVzdCBpcyByZXF1ZXN0LFxuICAvLyB0aW1pbmcgaW5mbyBpcyB0aW1pbmdJbmZvLFxuICAvLyBwcm9jZXNzIHJlcXVlc3QgYm9keSBjaHVuayBsZW5ndGggaXMgcHJvY2Vzc1JlcXVlc3RCb2R5Q2h1bmtMZW5ndGgsXG4gIC8vIHByb2Nlc3MgcmVxdWVzdCBlbmQtb2YtYm9keSBpcyBwcm9jZXNzUmVxdWVzdEVuZE9mQm9keSxcbiAgLy8gcHJvY2VzcyByZXNwb25zZSBpcyBwcm9jZXNzUmVzcG9uc2UsXG4gIC8vIHByb2Nlc3MgcmVzcG9uc2UgY29uc3VtZSBib2R5IGlzIHByb2Nlc3NSZXNwb25zZUNvbnN1bWVCb2R5LFxuICAvLyBwcm9jZXNzIHJlc3BvbnNlIGVuZC1vZi1ib2R5IGlzIHByb2Nlc3NSZXNwb25zZUVuZE9mQm9keSxcbiAgLy8gdGFzayBkZXN0aW5hdGlvbiBpcyB0YXNrRGVzdGluYXRpb24sXG4gIC8vIGFuZCBjcm9zcy1vcmlnaW4gaXNvbGF0ZWQgY2FwYWJpbGl0eSBpcyBjcm9zc09yaWdpbklzb2xhdGVkQ2FwYWJpbGl0eS5cbiAgY29uc3QgZmV0Y2hQYXJhbXMgPSB7XG4gICAgY29udHJvbGxlcjogbmV3IEZldGNoKGRpc3BhdGNoZXIpLFxuICAgIHJlcXVlc3QsXG4gICAgdGltaW5nSW5mbyxcbiAgICBwcm9jZXNzUmVxdWVzdEJvZHlDaHVua0xlbmd0aCxcbiAgICBwcm9jZXNzUmVxdWVzdEVuZE9mQm9keSxcbiAgICBwcm9jZXNzUmVzcG9uc2UsXG4gICAgcHJvY2Vzc1Jlc3BvbnNlQ29uc3VtZUJvZHksXG4gICAgcHJvY2Vzc1Jlc3BvbnNlRW5kT2ZCb2R5LFxuICAgIHRhc2tEZXN0aW5hdGlvbixcbiAgICBjcm9zc09yaWdpbklzb2xhdGVkQ2FwYWJpbGl0eVxuICB9XG5cbiAgLy8gNy4gSWYgcmVxdWVzdOKAmXMgYm9keSBpcyBhIGJ5dGUgc2VxdWVuY2UsIHRoZW4gc2V0IHJlcXVlc3TigJlzIGJvZHkgdG9cbiAgLy8gICAgcmVxdWVzdOKAmXMgYm9keSBhcyBhIGJvZHkuXG4gIC8vIE5PVEU6IFNpbmNlIGZldGNoaW5nIGlzIG9ubHkgY2FsbGVkIGZyb20gZmV0Y2gsIGJvZHkgc2hvdWxkIGFscmVhZHkgYmVcbiAgLy8gZXh0cmFjdGVkLlxuICBhc3NlcnQoIXJlcXVlc3QuYm9keSB8fCByZXF1ZXN0LmJvZHkuc3RyZWFtKVxuXG4gIC8vIDguIElmIHJlcXVlc3TigJlzIHdpbmRvdyBpcyBcImNsaWVudFwiLCB0aGVuIHNldCByZXF1ZXN04oCZcyB3aW5kb3cgdG8gcmVxdWVzdOKAmXNcbiAgLy8gY2xpZW50LCBpZiByZXF1ZXN04oCZcyBjbGllbnTigJlzIGdsb2JhbCBvYmplY3QgaXMgYSBXaW5kb3cgb2JqZWN0OyBvdGhlcndpc2VcbiAgLy8gXCJuby13aW5kb3dcIi5cbiAgaWYgKHJlcXVlc3Qud2luZG93ID09PSAnY2xpZW50Jykge1xuICAgIC8vIFRPRE86IFdoYXQgaWYgcmVxdWVzdC5jbGllbnQgaXMgbnVsbD9cbiAgICByZXF1ZXN0LndpbmRvdyA9XG4gICAgICByZXF1ZXN0LmNsaWVudD8uZ2xvYmFsT2JqZWN0Py5jb25zdHJ1Y3Rvcj8ubmFtZSA9PT0gJ1dpbmRvdydcbiAgICAgICAgPyByZXF1ZXN0LmNsaWVudFxuICAgICAgICA6ICduby13aW5kb3cnXG4gIH1cblxuICAvLyA5LiBJZiByZXF1ZXN04oCZcyBvcmlnaW4gaXMgXCJjbGllbnRcIiwgdGhlbiBzZXQgcmVxdWVzdOKAmXMgb3JpZ2luIHRvIHJlcXVlc3TigJlzXG4gIC8vIGNsaWVudOKAmXMgb3JpZ2luLlxuICBpZiAocmVxdWVzdC5vcmlnaW4gPT09ICdjbGllbnQnKSB7XG4gICAgcmVxdWVzdC5vcmlnaW4gPSByZXF1ZXN0LmNsaWVudC5vcmlnaW5cbiAgfVxuXG4gIC8vIDEwLiBJZiBhbGwgb2YgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSB0cnVlOlxuICAvLyBUT0RPXG5cbiAgLy8gMTEuIElmIHJlcXVlc3TigJlzIHBvbGljeSBjb250YWluZXIgaXMgXCJjbGllbnRcIiwgdGhlbjpcbiAgaWYgKHJlcXVlc3QucG9saWN5Q29udGFpbmVyID09PSAnY2xpZW50Jykge1xuICAgIC8vIDEuIElmIHJlcXVlc3TigJlzIGNsaWVudCBpcyBub24tbnVsbCwgdGhlbiBzZXQgcmVxdWVzdOKAmXMgcG9saWN5XG4gICAgLy8gY29udGFpbmVyIHRvIGEgY2xvbmUgb2YgcmVxdWVzdOKAmXMgY2xpZW504oCZcyBwb2xpY3kgY29udGFpbmVyLiBbSFRNTF1cbiAgICBpZiAocmVxdWVzdC5jbGllbnQgIT0gbnVsbCkge1xuICAgICAgcmVxdWVzdC5wb2xpY3lDb250YWluZXIgPSBjbG9uZVBvbGljeUNvbnRhaW5lcihcbiAgICAgICAgcmVxdWVzdC5jbGllbnQucG9saWN5Q29udGFpbmVyXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIDIuIE90aGVyd2lzZSwgc2V0IHJlcXVlc3TigJlzIHBvbGljeSBjb250YWluZXIgdG8gYSBuZXcgcG9saWN5XG4gICAgICAvLyBjb250YWluZXIuXG4gICAgICByZXF1ZXN0LnBvbGljeUNvbnRhaW5lciA9IG1ha2VQb2xpY3lDb250YWluZXIoKVxuICAgIH1cbiAgfVxuXG4gIC8vIDEyLiBJZiByZXF1ZXN04oCZcyBoZWFkZXIgbGlzdCBkb2VzIG5vdCBjb250YWluIGBBY2NlcHRgLCB0aGVuOlxuICBpZiAoIXJlcXVlc3QuaGVhZGVyc0xpc3QuY29udGFpbnMoJ2FjY2VwdCcsIHRydWUpKSB7XG4gICAgLy8gMS4gTGV0IHZhbHVlIGJlIGAqLypgLlxuICAgIGNvbnN0IHZhbHVlID0gJyovKidcblxuICAgIC8vIDIuIEEgdXNlciBhZ2VudCBzaG91bGQgc2V0IHZhbHVlIHRvIHRoZSBmaXJzdCBtYXRjaGluZyBzdGF0ZW1lbnQsIGlmXG4gICAgLy8gYW55LCBzd2l0Y2hpbmcgb24gcmVxdWVzdOKAmXMgZGVzdGluYXRpb246XG4gICAgLy8gXCJkb2N1bWVudFwiXG4gICAgLy8gXCJmcmFtZVwiXG4gICAgLy8gXCJpZnJhbWVcIlxuICAgIC8vIGB0ZXh0L2h0bWwsYXBwbGljYXRpb24veGh0bWwreG1sLGFwcGxpY2F0aW9uL3htbDtxPTAuOSwqLyo7cT0wLjhgXG4gICAgLy8gXCJpbWFnZVwiXG4gICAgLy8gYGltYWdlL3BuZyxpbWFnZS9zdmcreG1sLGltYWdlLyo7cT0wLjgsKi8qO3E9MC41YFxuICAgIC8vIFwic3R5bGVcIlxuICAgIC8vIGB0ZXh0L2NzcywqLyo7cT0wLjFgXG4gICAgLy8gVE9ET1xuXG4gICAgLy8gMy4gQXBwZW5kIGBBY2NlcHRgL3ZhbHVlIHRvIHJlcXVlc3TigJlzIGhlYWRlciBsaXN0LlxuICAgIHJlcXVlc3QuaGVhZGVyc0xpc3QuYXBwZW5kKCdhY2NlcHQnLCB2YWx1ZSwgdHJ1ZSlcbiAgfVxuXG4gIC8vIDEzLiBJZiByZXF1ZXN04oCZcyBoZWFkZXIgbGlzdCBkb2VzIG5vdCBjb250YWluIGBBY2NlcHQtTGFuZ3VhZ2VgLCB0aGVuXG4gIC8vIHVzZXIgYWdlbnRzIHNob3VsZCBhcHBlbmQgYEFjY2VwdC1MYW5ndWFnZWAvYW4gYXBwcm9wcmlhdGUgdmFsdWUgdG9cbiAgLy8gcmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QuXG4gIGlmICghcmVxdWVzdC5oZWFkZXJzTGlzdC5jb250YWlucygnYWNjZXB0LWxhbmd1YWdlJywgdHJ1ZSkpIHtcbiAgICByZXF1ZXN0LmhlYWRlcnNMaXN0LmFwcGVuZCgnYWNjZXB0LWxhbmd1YWdlJywgJyonLCB0cnVlKVxuICB9XG5cbiAgLy8gMTQuIElmIHJlcXVlc3TigJlzIHByaW9yaXR5IGlzIG51bGwsIHRoZW4gdXNlIHJlcXVlc3TigJlzIGluaXRpYXRvciBhbmRcbiAgLy8gZGVzdGluYXRpb24gYXBwcm9wcmlhdGVseSBpbiBzZXR0aW5nIHJlcXVlc3TigJlzIHByaW9yaXR5IHRvIGFcbiAgLy8gdXNlci1hZ2VudC1kZWZpbmVkIG9iamVjdC5cbiAgaWYgKHJlcXVlc3QucHJpb3JpdHkgPT09IG51bGwpIHtcbiAgICAvLyBUT0RPXG4gIH1cblxuICAvLyAxNS4gSWYgcmVxdWVzdCBpcyBhIHN1YnJlc291cmNlIHJlcXVlc3QsIHRoZW46XG4gIGlmIChzdWJyZXNvdXJjZVNldC5oYXMocmVxdWVzdC5kZXN0aW5hdGlvbikpIHtcbiAgICAvLyBUT0RPXG4gIH1cblxuICAvLyAxNi4gUnVuIG1haW4gZmV0Y2ggZ2l2ZW4gZmV0Y2hQYXJhbXMuXG4gIG1haW5GZXRjaChmZXRjaFBhcmFtcylcbiAgICAuY2F0Y2goZXJyID0+IHtcbiAgICAgIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIudGVybWluYXRlKGVycilcbiAgICB9KVxuXG4gIC8vIDE3LiBSZXR1cm4gZmV0Y2hQYXJhbSdzIGNvbnRyb2xsZXJcbiAgcmV0dXJuIGZldGNoUGFyYW1zLmNvbnRyb2xsZXJcbn1cblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtbWFpbi1mZXRjaFxuYXN5bmMgZnVuY3Rpb24gbWFpbkZldGNoIChmZXRjaFBhcmFtcywgcmVjdXJzaXZlID0gZmFsc2UpIHtcbiAgLy8gMS4gTGV0IHJlcXVlc3QgYmUgZmV0Y2hQYXJhbXPigJlzIHJlcXVlc3QuXG4gIGNvbnN0IHJlcXVlc3QgPSBmZXRjaFBhcmFtcy5yZXF1ZXN0XG5cbiAgLy8gMi4gTGV0IHJlc3BvbnNlIGJlIG51bGwuXG4gIGxldCByZXNwb25zZSA9IG51bGxcblxuICAvLyAzLiBJZiByZXF1ZXN04oCZcyBsb2NhbC1VUkxzLW9ubHkgZmxhZyBpcyBzZXQgYW5kIHJlcXVlc3TigJlzIGN1cnJlbnQgVVJMIGlzXG4gIC8vIG5vdCBsb2NhbCwgdGhlbiBzZXQgcmVzcG9uc2UgdG8gYSBuZXR3b3JrIGVycm9yLlxuICBpZiAocmVxdWVzdC5sb2NhbFVSTHNPbmx5ICYmICF1cmxJc0xvY2FsKHJlcXVlc3RDdXJyZW50VVJMKHJlcXVlc3QpKSkge1xuICAgIHJlc3BvbnNlID0gbWFrZU5ldHdvcmtFcnJvcignbG9jYWwgVVJMcyBvbmx5JylcbiAgfVxuXG4gIC8vIDQuIFJ1biByZXBvcnQgQ29udGVudCBTZWN1cml0eSBQb2xpY3kgdmlvbGF0aW9ucyBmb3IgcmVxdWVzdC5cbiAgLy8gVE9ET1xuXG4gIC8vIDUuIFVwZ3JhZGUgcmVxdWVzdCB0byBhIHBvdGVudGlhbGx5IHRydXN0d29ydGh5IFVSTCwgaWYgYXBwcm9wcmlhdGUuXG4gIHRyeVVwZ3JhZGVSZXF1ZXN0VG9BUG90ZW50aWFsbHlUcnVzdHdvcnRoeVVSTChyZXF1ZXN0KVxuXG4gIC8vIDYuIElmIHNob3VsZCByZXF1ZXN0IGJlIGJsb2NrZWQgZHVlIHRvIGEgYmFkIHBvcnQsIHNob3VsZCBmZXRjaGluZyByZXF1ZXN0XG4gIC8vIGJlIGJsb2NrZWQgYXMgbWl4ZWQgY29udGVudCwgb3Igc2hvdWxkIHJlcXVlc3QgYmUgYmxvY2tlZCBieSBDb250ZW50XG4gIC8vIFNlY3VyaXR5IFBvbGljeSByZXR1cm5zIGJsb2NrZWQsIHRoZW4gc2V0IHJlc3BvbnNlIHRvIGEgbmV0d29yayBlcnJvci5cbiAgaWYgKHJlcXVlc3RCYWRQb3J0KHJlcXVlc3QpID09PSAnYmxvY2tlZCcpIHtcbiAgICByZXNwb25zZSA9IG1ha2VOZXR3b3JrRXJyb3IoJ2JhZCBwb3J0JylcbiAgfVxuICAvLyBUT0RPOiBzaG91bGQgZmV0Y2hpbmcgcmVxdWVzdCBiZSBibG9ja2VkIGFzIG1peGVkIGNvbnRlbnQ/XG4gIC8vIFRPRE86IHNob3VsZCByZXF1ZXN0IGJlIGJsb2NrZWQgYnkgQ29udGVudCBTZWN1cml0eSBQb2xpY3k/XG5cbiAgLy8gNy4gSWYgcmVxdWVzdOKAmXMgcmVmZXJyZXIgcG9saWN5IGlzIHRoZSBlbXB0eSBzdHJpbmcsIHRoZW4gc2V0IHJlcXVlc3TigJlzXG4gIC8vIHJlZmVycmVyIHBvbGljeSB0byByZXF1ZXN04oCZcyBwb2xpY3kgY29udGFpbmVy4oCZcyByZWZlcnJlciBwb2xpY3kuXG4gIGlmIChyZXF1ZXN0LnJlZmVycmVyUG9saWN5ID09PSAnJykge1xuICAgIHJlcXVlc3QucmVmZXJyZXJQb2xpY3kgPSByZXF1ZXN0LnBvbGljeUNvbnRhaW5lci5yZWZlcnJlclBvbGljeVxuICB9XG5cbiAgLy8gOC4gSWYgcmVxdWVzdOKAmXMgcmVmZXJyZXIgaXMgbm90IFwibm8tcmVmZXJyZXJcIiwgdGhlbiBzZXQgcmVxdWVzdOKAmXNcbiAgLy8gcmVmZXJyZXIgdG8gdGhlIHJlc3VsdCBvZiBpbnZva2luZyBkZXRlcm1pbmUgcmVxdWVzdOKAmXMgcmVmZXJyZXIuXG4gIGlmIChyZXF1ZXN0LnJlZmVycmVyICE9PSAnbm8tcmVmZXJyZXInKSB7XG4gICAgcmVxdWVzdC5yZWZlcnJlciA9IGRldGVybWluZVJlcXVlc3RzUmVmZXJyZXIocmVxdWVzdClcbiAgfVxuXG4gIC8vIDkuIFNldCByZXF1ZXN04oCZcyBjdXJyZW50IFVSTOKAmXMgc2NoZW1lIHRvIFwiaHR0cHNcIiBpZiBhbGwgb2YgdGhlIGZvbGxvd2luZ1xuICAvLyBjb25kaXRpb25zIGFyZSB0cnVlOlxuICAvLyAtIHJlcXVlc3TigJlzIGN1cnJlbnQgVVJM4oCZcyBzY2hlbWUgaXMgXCJodHRwXCJcbiAgLy8gLSByZXF1ZXN04oCZcyBjdXJyZW50IFVSTOKAmXMgaG9zdCBpcyBhIGRvbWFpblxuICAvLyAtIE1hdGNoaW5nIHJlcXVlc3TigJlzIGN1cnJlbnQgVVJM4oCZcyBob3N0IHBlciBLbm93biBIU1RTIEhvc3QgRG9tYWluIE5hbWVcbiAgLy8gICBNYXRjaGluZyByZXN1bHRzIGluIGVpdGhlciBhIHN1cGVyZG9tYWluIG1hdGNoIHdpdGggYW4gYXNzZXJ0ZWRcbiAgLy8gICBpbmNsdWRlU3ViRG9tYWlucyBkaXJlY3RpdmUgb3IgYSBjb25ncnVlbnQgbWF0Y2ggKHdpdGggb3Igd2l0aG91dCBhblxuICAvLyAgIGFzc2VydGVkIGluY2x1ZGVTdWJEb21haW5zIGRpcmVjdGl2ZSkuIFtIU1RTXVxuICAvLyBUT0RPXG5cbiAgLy8gMTAuIElmIHJlY3Vyc2l2ZSBpcyBmYWxzZSwgdGhlbiBydW4gdGhlIHJlbWFpbmluZyBzdGVwcyBpbiBwYXJhbGxlbC5cbiAgLy8gVE9ET1xuXG4gIC8vIDExLiBJZiByZXNwb25zZSBpcyBudWxsLCB0aGVuIHNldCByZXNwb25zZSB0byB0aGUgcmVzdWx0IG9mIHJ1bm5pbmdcbiAgLy8gdGhlIHN0ZXBzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGZpcnN0IG1hdGNoaW5nIHN0YXRlbWVudDpcbiAgaWYgKHJlc3BvbnNlID09PSBudWxsKSB7XG4gICAgcmVzcG9uc2UgPSBhd2FpdCAoYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgY3VycmVudFVSTCA9IHJlcXVlc3RDdXJyZW50VVJMKHJlcXVlc3QpXG5cbiAgICAgIGlmIChcbiAgICAgICAgLy8gLSByZXF1ZXN04oCZcyBjdXJyZW50IFVSTOKAmXMgb3JpZ2luIGlzIHNhbWUgb3JpZ2luIHdpdGggcmVxdWVzdOKAmXMgb3JpZ2luLFxuICAgICAgICAvLyAgIGFuZCByZXF1ZXN04oCZcyByZXNwb25zZSB0YWludGluZyBpcyBcImJhc2ljXCJcbiAgICAgICAgKHNhbWVPcmlnaW4oY3VycmVudFVSTCwgcmVxdWVzdC51cmwpICYmIHJlcXVlc3QucmVzcG9uc2VUYWludGluZyA9PT0gJ2Jhc2ljJykgfHxcbiAgICAgICAgLy8gcmVxdWVzdOKAmXMgY3VycmVudCBVUkzigJlzIHNjaGVtZSBpcyBcImRhdGFcIlxuICAgICAgICAoY3VycmVudFVSTC5wcm90b2NvbCA9PT0gJ2RhdGE6JykgfHxcbiAgICAgICAgLy8gLSByZXF1ZXN04oCZcyBtb2RlIGlzIFwibmF2aWdhdGVcIiBvciBcIndlYnNvY2tldFwiXG4gICAgICAgIChyZXF1ZXN0Lm1vZGUgPT09ICduYXZpZ2F0ZScgfHwgcmVxdWVzdC5tb2RlID09PSAnd2Vic29ja2V0JylcbiAgICAgICkge1xuICAgICAgICAvLyAxLiBTZXQgcmVxdWVzdOKAmXMgcmVzcG9uc2UgdGFpbnRpbmcgdG8gXCJiYXNpY1wiLlxuICAgICAgICByZXF1ZXN0LnJlc3BvbnNlVGFpbnRpbmcgPSAnYmFzaWMnXG5cbiAgICAgICAgLy8gMi4gUmV0dXJuIHRoZSByZXN1bHQgb2YgcnVubmluZyBzY2hlbWUgZmV0Y2ggZ2l2ZW4gZmV0Y2hQYXJhbXMuXG4gICAgICAgIHJldHVybiBhd2FpdCBzY2hlbWVGZXRjaChmZXRjaFBhcmFtcylcbiAgICAgIH1cblxuICAgICAgLy8gcmVxdWVzdOKAmXMgbW9kZSBpcyBcInNhbWUtb3JpZ2luXCJcbiAgICAgIGlmIChyZXF1ZXN0Lm1vZGUgPT09ICdzYW1lLW9yaWdpbicpIHtcbiAgICAgICAgLy8gMS4gUmV0dXJuIGEgbmV0d29yayBlcnJvci5cbiAgICAgICAgcmV0dXJuIG1ha2VOZXR3b3JrRXJyb3IoJ3JlcXVlc3QgbW9kZSBjYW5ub3QgYmUgXCJzYW1lLW9yaWdpblwiJylcbiAgICAgIH1cblxuICAgICAgLy8gcmVxdWVzdOKAmXMgbW9kZSBpcyBcIm5vLWNvcnNcIlxuICAgICAgaWYgKHJlcXVlc3QubW9kZSA9PT0gJ25vLWNvcnMnKSB7XG4gICAgICAgIC8vIDEuIElmIHJlcXVlc3TigJlzIHJlZGlyZWN0IG1vZGUgaXMgbm90IFwiZm9sbG93XCIsIHRoZW4gcmV0dXJuIGEgbmV0d29ya1xuICAgICAgICAvLyBlcnJvci5cbiAgICAgICAgaWYgKHJlcXVlc3QucmVkaXJlY3QgIT09ICdmb2xsb3cnKSB7XG4gICAgICAgICAgcmV0dXJuIG1ha2VOZXR3b3JrRXJyb3IoXG4gICAgICAgICAgICAncmVkaXJlY3QgbW9kZSBjYW5ub3QgYmUgXCJmb2xsb3dcIiBmb3IgXCJuby1jb3JzXCIgcmVxdWVzdCdcbiAgICAgICAgICApXG4gICAgICAgIH1cblxuICAgICAgICAvLyAyLiBTZXQgcmVxdWVzdOKAmXMgcmVzcG9uc2UgdGFpbnRpbmcgdG8gXCJvcGFxdWVcIi5cbiAgICAgICAgcmVxdWVzdC5yZXNwb25zZVRhaW50aW5nID0gJ29wYXF1ZSdcblxuICAgICAgICAvLyAzLiBSZXR1cm4gdGhlIHJlc3VsdCBvZiBydW5uaW5nIHNjaGVtZSBmZXRjaCBnaXZlbiBmZXRjaFBhcmFtcy5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHNjaGVtZUZldGNoKGZldGNoUGFyYW1zKVxuICAgICAgfVxuXG4gICAgICAvLyByZXF1ZXN04oCZcyBjdXJyZW50IFVSTOKAmXMgc2NoZW1lIGlzIG5vdCBhbiBIVFRQKFMpIHNjaGVtZVxuICAgICAgaWYgKCF1cmxJc0h0dHBIdHRwc1NjaGVtZShyZXF1ZXN0Q3VycmVudFVSTChyZXF1ZXN0KSkpIHtcbiAgICAgICAgLy8gUmV0dXJuIGEgbmV0d29yayBlcnJvci5cbiAgICAgICAgcmV0dXJuIG1ha2VOZXR3b3JrRXJyb3IoJ1VSTCBzY2hlbWUgbXVzdCBiZSBhIEhUVFAoUykgc2NoZW1lJylcbiAgICAgIH1cblxuICAgICAgLy8gLSByZXF1ZXN04oCZcyB1c2UtQ09SUy1wcmVmbGlnaHQgZmxhZyBpcyBzZXRcbiAgICAgIC8vIC0gcmVxdWVzdOKAmXMgdW5zYWZlLXJlcXVlc3QgZmxhZyBpcyBzZXQgYW5kIGVpdGhlciByZXF1ZXN04oCZcyBtZXRob2QgaXNcbiAgICAgIC8vICAgbm90IGEgQ09SUy1zYWZlbGlzdGVkIG1ldGhvZCBvciBDT1JTLXVuc2FmZSByZXF1ZXN0LWhlYWRlciBuYW1lcyB3aXRoXG4gICAgICAvLyAgIHJlcXVlc3TigJlzIGhlYWRlciBsaXN0IGlzIG5vdCBlbXB0eVxuICAgICAgLy8gICAgMS4gU2V0IHJlcXVlc3TigJlzIHJlc3BvbnNlIHRhaW50aW5nIHRvIFwiY29yc1wiLlxuICAgICAgLy8gICAgMi4gTGV0IGNvcnNXaXRoUHJlZmxpZ2h0UmVzcG9uc2UgYmUgdGhlIHJlc3VsdCBvZiBydW5uaW5nIEhUVFAgZmV0Y2hcbiAgICAgIC8vICAgIGdpdmVuIGZldGNoUGFyYW1zIGFuZCB0cnVlLlxuICAgICAgLy8gICAgMy4gSWYgY29yc1dpdGhQcmVmbGlnaHRSZXNwb25zZSBpcyBhIG5ldHdvcmsgZXJyb3IsIHRoZW4gY2xlYXIgY2FjaGVcbiAgICAgIC8vICAgIGVudHJpZXMgdXNpbmcgcmVxdWVzdC5cbiAgICAgIC8vICAgIDQuIFJldHVybiBjb3JzV2l0aFByZWZsaWdodFJlc3BvbnNlLlxuICAgICAgLy8gVE9ET1xuXG4gICAgICAvLyBPdGhlcndpc2VcbiAgICAgIC8vICAgIDEuIFNldCByZXF1ZXN04oCZcyByZXNwb25zZSB0YWludGluZyB0byBcImNvcnNcIi5cbiAgICAgIHJlcXVlc3QucmVzcG9uc2VUYWludGluZyA9ICdjb3JzJ1xuXG4gICAgICAvLyAgICAyLiBSZXR1cm4gdGhlIHJlc3VsdCBvZiBydW5uaW5nIEhUVFAgZmV0Y2ggZ2l2ZW4gZmV0Y2hQYXJhbXMuXG4gICAgICByZXR1cm4gYXdhaXQgaHR0cEZldGNoKGZldGNoUGFyYW1zKVxuICAgIH0pKClcbiAgfVxuXG4gIC8vIDEyLiBJZiByZWN1cnNpdmUgaXMgdHJ1ZSwgdGhlbiByZXR1cm4gcmVzcG9uc2UuXG4gIGlmIChyZWN1cnNpdmUpIHtcbiAgICByZXR1cm4gcmVzcG9uc2VcbiAgfVxuXG4gIC8vIDEzLiBJZiByZXNwb25zZSBpcyBub3QgYSBuZXR3b3JrIGVycm9yIGFuZCByZXNwb25zZSBpcyBub3QgYSBmaWx0ZXJlZFxuICAvLyByZXNwb25zZSwgdGhlbjpcbiAgaWYgKHJlc3BvbnNlLnN0YXR1cyAhPT0gMCAmJiAhcmVzcG9uc2UuaW50ZXJuYWxSZXNwb25zZSkge1xuICAgIC8vIElmIHJlcXVlc3TigJlzIHJlc3BvbnNlIHRhaW50aW5nIGlzIFwiY29yc1wiLCB0aGVuOlxuICAgIGlmIChyZXF1ZXN0LnJlc3BvbnNlVGFpbnRpbmcgPT09ICdjb3JzJykge1xuICAgICAgLy8gMS4gTGV0IGhlYWRlck5hbWVzIGJlIHRoZSByZXN1bHQgb2YgZXh0cmFjdGluZyBoZWFkZXIgbGlzdCB2YWx1ZXNcbiAgICAgIC8vIGdpdmVuIGBBY2Nlc3MtQ29udHJvbC1FeHBvc2UtSGVhZGVyc2AgYW5kIHJlc3BvbnNl4oCZcyBoZWFkZXIgbGlzdC5cbiAgICAgIC8vIFRPRE9cbiAgICAgIC8vIDIuIElmIHJlcXVlc3TigJlzIGNyZWRlbnRpYWxzIG1vZGUgaXMgbm90IFwiaW5jbHVkZVwiIGFuZCBoZWFkZXJOYW1lc1xuICAgICAgLy8gY29udGFpbnMgYCpgLCB0aGVuIHNldCByZXNwb25zZeKAmXMgQ09SUy1leHBvc2VkIGhlYWRlci1uYW1lIGxpc3QgdG9cbiAgICAgIC8vIGFsbCB1bmlxdWUgaGVhZGVyIG5hbWVzIGluIHJlc3BvbnNl4oCZcyBoZWFkZXIgbGlzdC5cbiAgICAgIC8vIFRPRE9cbiAgICAgIC8vIDMuIE90aGVyd2lzZSwgaWYgaGVhZGVyTmFtZXMgaXMgbm90IG51bGwgb3IgZmFpbHVyZSwgdGhlbiBzZXRcbiAgICAgIC8vIHJlc3BvbnNl4oCZcyBDT1JTLWV4cG9zZWQgaGVhZGVyLW5hbWUgbGlzdCB0byBoZWFkZXJOYW1lcy5cbiAgICAgIC8vIFRPRE9cbiAgICB9XG5cbiAgICAvLyBTZXQgcmVzcG9uc2UgdG8gdGhlIGZvbGxvd2luZyBmaWx0ZXJlZCByZXNwb25zZSB3aXRoIHJlc3BvbnNlIGFzIGl0c1xuICAgIC8vIGludGVybmFsIHJlc3BvbnNlLCBkZXBlbmRpbmcgb24gcmVxdWVzdOKAmXMgcmVzcG9uc2UgdGFpbnRpbmc6XG4gICAgaWYgKHJlcXVlc3QucmVzcG9uc2VUYWludGluZyA9PT0gJ2Jhc2ljJykge1xuICAgICAgcmVzcG9uc2UgPSBmaWx0ZXJSZXNwb25zZShyZXNwb25zZSwgJ2Jhc2ljJylcbiAgICB9IGVsc2UgaWYgKHJlcXVlc3QucmVzcG9uc2VUYWludGluZyA9PT0gJ2NvcnMnKSB7XG4gICAgICByZXNwb25zZSA9IGZpbHRlclJlc3BvbnNlKHJlc3BvbnNlLCAnY29ycycpXG4gICAgfSBlbHNlIGlmIChyZXF1ZXN0LnJlc3BvbnNlVGFpbnRpbmcgPT09ICdvcGFxdWUnKSB7XG4gICAgICByZXNwb25zZSA9IGZpbHRlclJlc3BvbnNlKHJlc3BvbnNlLCAnb3BhcXVlJylcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzZXJ0KGZhbHNlKVxuICAgIH1cbiAgfVxuXG4gIC8vIDE0LiBMZXQgaW50ZXJuYWxSZXNwb25zZSBiZSByZXNwb25zZSwgaWYgcmVzcG9uc2UgaXMgYSBuZXR3b3JrIGVycm9yLFxuICAvLyBhbmQgcmVzcG9uc2XigJlzIGludGVybmFsIHJlc3BvbnNlIG90aGVyd2lzZS5cbiAgbGV0IGludGVybmFsUmVzcG9uc2UgPVxuICAgIHJlc3BvbnNlLnN0YXR1cyA9PT0gMCA/IHJlc3BvbnNlIDogcmVzcG9uc2UuaW50ZXJuYWxSZXNwb25zZVxuXG4gIC8vIDE1LiBJZiBpbnRlcm5hbFJlc3BvbnNl4oCZcyBVUkwgbGlzdCBpcyBlbXB0eSwgdGhlbiBzZXQgaXQgdG8gYSBjbG9uZSBvZlxuICAvLyByZXF1ZXN04oCZcyBVUkwgbGlzdC5cbiAgaWYgKGludGVybmFsUmVzcG9uc2UudXJsTGlzdC5sZW5ndGggPT09IDApIHtcbiAgICBpbnRlcm5hbFJlc3BvbnNlLnVybExpc3QucHVzaCguLi5yZXF1ZXN0LnVybExpc3QpXG4gIH1cblxuICAvLyAxNi4gSWYgcmVxdWVzdOKAmXMgdGltaW5nIGFsbG93IGZhaWxlZCBmbGFnIGlzIHVuc2V0LCB0aGVuIHNldFxuICAvLyBpbnRlcm5hbFJlc3BvbnNl4oCZcyB0aW1pbmcgYWxsb3cgcGFzc2VkIGZsYWcuXG4gIGlmICghcmVxdWVzdC50aW1pbmdBbGxvd0ZhaWxlZCkge1xuICAgIHJlc3BvbnNlLnRpbWluZ0FsbG93UGFzc2VkID0gdHJ1ZVxuICB9XG5cbiAgLy8gMTcuIElmIHJlc3BvbnNlIGlzIG5vdCBhIG5ldHdvcmsgZXJyb3IgYW5kIGFueSBvZiB0aGUgZm9sbG93aW5nIHJldHVybnNcbiAgLy8gYmxvY2tlZFxuICAvLyAtIHNob3VsZCBpbnRlcm5hbFJlc3BvbnNlIHRvIHJlcXVlc3QgYmUgYmxvY2tlZCBhcyBtaXhlZCBjb250ZW50XG4gIC8vIC0gc2hvdWxkIGludGVybmFsUmVzcG9uc2UgdG8gcmVxdWVzdCBiZSBibG9ja2VkIGJ5IENvbnRlbnQgU2VjdXJpdHkgUG9saWN5XG4gIC8vIC0gc2hvdWxkIGludGVybmFsUmVzcG9uc2UgdG8gcmVxdWVzdCBiZSBibG9ja2VkIGR1ZSB0byBpdHMgTUlNRSB0eXBlXG4gIC8vIC0gc2hvdWxkIGludGVybmFsUmVzcG9uc2UgdG8gcmVxdWVzdCBiZSBibG9ja2VkIGR1ZSB0byBub3NuaWZmXG4gIC8vIFRPRE9cblxuICAvLyAxOC4gSWYgcmVzcG9uc2XigJlzIHR5cGUgaXMgXCJvcGFxdWVcIiwgaW50ZXJuYWxSZXNwb25zZeKAmXMgc3RhdHVzIGlzIDIwNixcbiAgLy8gaW50ZXJuYWxSZXNwb25zZeKAmXMgcmFuZ2UtcmVxdWVzdGVkIGZsYWcgaXMgc2V0LCBhbmQgcmVxdWVzdOKAmXMgaGVhZGVyXG4gIC8vIGxpc3QgZG9lcyBub3QgY29udGFpbiBgUmFuZ2VgLCB0aGVuIHNldCByZXNwb25zZSBhbmQgaW50ZXJuYWxSZXNwb25zZVxuICAvLyB0byBhIG5ldHdvcmsgZXJyb3IuXG4gIGlmIChcbiAgICByZXNwb25zZS50eXBlID09PSAnb3BhcXVlJyAmJlxuICAgIGludGVybmFsUmVzcG9uc2Uuc3RhdHVzID09PSAyMDYgJiZcbiAgICBpbnRlcm5hbFJlc3BvbnNlLnJhbmdlUmVxdWVzdGVkICYmXG4gICAgIXJlcXVlc3QuaGVhZGVycy5jb250YWlucygncmFuZ2UnLCB0cnVlKVxuICApIHtcbiAgICByZXNwb25zZSA9IGludGVybmFsUmVzcG9uc2UgPSBtYWtlTmV0d29ya0Vycm9yKClcbiAgfVxuXG4gIC8vIDE5LiBJZiByZXNwb25zZSBpcyBub3QgYSBuZXR3b3JrIGVycm9yIGFuZCBlaXRoZXIgcmVxdWVzdOKAmXMgbWV0aG9kIGlzXG4gIC8vIGBIRUFEYCBvciBgQ09OTkVDVGAsIG9yIGludGVybmFsUmVzcG9uc2XigJlzIHN0YXR1cyBpcyBhIG51bGwgYm9keSBzdGF0dXMsXG4gIC8vIHNldCBpbnRlcm5hbFJlc3BvbnNl4oCZcyBib2R5IHRvIG51bGwgYW5kIGRpc3JlZ2FyZCBhbnkgZW5xdWV1aW5nIHRvd2FyZFxuICAvLyBpdCAoaWYgYW55KS5cbiAgaWYgKFxuICAgIHJlc3BvbnNlLnN0YXR1cyAhPT0gMCAmJlxuICAgIChyZXF1ZXN0Lm1ldGhvZCA9PT0gJ0hFQUQnIHx8XG4gICAgICByZXF1ZXN0Lm1ldGhvZCA9PT0gJ0NPTk5FQ1QnIHx8XG4gICAgICBudWxsQm9keVN0YXR1cy5pbmNsdWRlcyhpbnRlcm5hbFJlc3BvbnNlLnN0YXR1cykpXG4gICkge1xuICAgIGludGVybmFsUmVzcG9uc2UuYm9keSA9IG51bGxcbiAgICBmZXRjaFBhcmFtcy5jb250cm9sbGVyLmR1bXAgPSB0cnVlXG4gIH1cblxuICAvLyAyMC4gSWYgcmVxdWVzdOKAmXMgaW50ZWdyaXR5IG1ldGFkYXRhIGlzIG5vdCB0aGUgZW1wdHkgc3RyaW5nLCB0aGVuOlxuICBpZiAocmVxdWVzdC5pbnRlZ3JpdHkpIHtcbiAgICAvLyAxLiBMZXQgcHJvY2Vzc0JvZHlFcnJvciBiZSB0aGlzIHN0ZXA6IHJ1biBmZXRjaCBmaW5hbGUgZ2l2ZW4gZmV0Y2hQYXJhbXNcbiAgICAvLyBhbmQgYSBuZXR3b3JrIGVycm9yLlxuICAgIGNvbnN0IHByb2Nlc3NCb2R5RXJyb3IgPSAocmVhc29uKSA9PlxuICAgICAgZmV0Y2hGaW5hbGUoZmV0Y2hQYXJhbXMsIG1ha2VOZXR3b3JrRXJyb3IocmVhc29uKSlcblxuICAgIC8vIDIuIElmIHJlcXVlc3TigJlzIHJlc3BvbnNlIHRhaW50aW5nIGlzIFwib3BhcXVlXCIsIG9yIHJlc3BvbnNl4oCZcyBib2R5IGlzIG51bGwsXG4gICAgLy8gdGhlbiBydW4gcHJvY2Vzc0JvZHlFcnJvciBhbmQgYWJvcnQgdGhlc2Ugc3RlcHMuXG4gICAgaWYgKHJlcXVlc3QucmVzcG9uc2VUYWludGluZyA9PT0gJ29wYXF1ZScgfHwgcmVzcG9uc2UuYm9keSA9PSBudWxsKSB7XG4gICAgICBwcm9jZXNzQm9keUVycm9yKHJlc3BvbnNlLmVycm9yKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gMy4gTGV0IHByb2Nlc3NCb2R5IGdpdmVuIGJ5dGVzIGJlIHRoZXNlIHN0ZXBzOlxuICAgIGNvbnN0IHByb2Nlc3NCb2R5ID0gKGJ5dGVzKSA9PiB7XG4gICAgICAvLyAxLiBJZiBieXRlcyBkbyBub3QgbWF0Y2ggcmVxdWVzdOKAmXMgaW50ZWdyaXR5IG1ldGFkYXRhLFxuICAgICAgLy8gdGhlbiBydW4gcHJvY2Vzc0JvZHlFcnJvciBhbmQgYWJvcnQgdGhlc2Ugc3RlcHMuIFtTUkldXG4gICAgICBpZiAoIWJ5dGVzTWF0Y2goYnl0ZXMsIHJlcXVlc3QuaW50ZWdyaXR5KSkge1xuICAgICAgICBwcm9jZXNzQm9keUVycm9yKCdpbnRlZ3JpdHkgbWlzbWF0Y2gnKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgLy8gMi4gU2V0IHJlc3BvbnNl4oCZcyBib2R5IHRvIGJ5dGVzIGFzIGEgYm9keS5cbiAgICAgIHJlc3BvbnNlLmJvZHkgPSBzYWZlbHlFeHRyYWN0Qm9keShieXRlcylbMF1cblxuICAgICAgLy8gMy4gUnVuIGZldGNoIGZpbmFsZSBnaXZlbiBmZXRjaFBhcmFtcyBhbmQgcmVzcG9uc2UuXG4gICAgICBmZXRjaEZpbmFsZShmZXRjaFBhcmFtcywgcmVzcG9uc2UpXG4gICAgfVxuXG4gICAgLy8gNC4gRnVsbHkgcmVhZCByZXNwb25zZeKAmXMgYm9keSBnaXZlbiBwcm9jZXNzQm9keSBhbmQgcHJvY2Vzc0JvZHlFcnJvci5cbiAgICBhd2FpdCBmdWxseVJlYWRCb2R5KHJlc3BvbnNlLmJvZHksIHByb2Nlc3NCb2R5LCBwcm9jZXNzQm9keUVycm9yKVxuICB9IGVsc2Uge1xuICAgIC8vIDIxLiBPdGhlcndpc2UsIHJ1biBmZXRjaCBmaW5hbGUgZ2l2ZW4gZmV0Y2hQYXJhbXMgYW5kIHJlc3BvbnNlLlxuICAgIGZldGNoRmluYWxlKGZldGNoUGFyYW1zLCByZXNwb25zZSlcbiAgfVxufVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1zY2hlbWUtZmV0Y2hcbi8vIGdpdmVuIGEgZmV0Y2ggcGFyYW1zIGZldGNoUGFyYW1zXG5mdW5jdGlvbiBzY2hlbWVGZXRjaCAoZmV0Y2hQYXJhbXMpIHtcbiAgLy8gTm90ZTogc2luY2UgdGhlIGNvbm5lY3Rpb24gaXMgZGVzdHJveWVkIG9uIHJlZGlyZWN0LCB3aGljaCBzZXRzIGZldGNoUGFyYW1zIHRvIGFcbiAgLy8gY2FuY2VsbGVkIHN0YXRlLCB3ZSBkbyBub3Qgd2FudCB0aGlzIGNvbmRpdGlvbiB0byB0cmlnZ2VyICp1bmxlc3MqIHRoZXJlIGhhdmUgYmVlblxuICAvLyBubyByZWRpcmVjdHMuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL3VuZGljaS9pc3N1ZXMvMTc3NlxuICAvLyAxLiBJZiBmZXRjaFBhcmFtcyBpcyBjYW5jZWxlZCwgdGhlbiByZXR1cm4gdGhlIGFwcHJvcHJpYXRlIG5ldHdvcmsgZXJyb3IgZm9yIGZldGNoUGFyYW1zLlxuICBpZiAoaXNDYW5jZWxsZWQoZmV0Y2hQYXJhbXMpICYmIGZldGNoUGFyYW1zLnJlcXVlc3QucmVkaXJlY3RDb3VudCA9PT0gMCkge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobWFrZUFwcHJvcHJpYXRlTmV0d29ya0Vycm9yKGZldGNoUGFyYW1zKSlcbiAgfVxuXG4gIC8vIDIuIExldCByZXF1ZXN0IGJlIGZldGNoUGFyYW1z4oCZcyByZXF1ZXN0LlxuICBjb25zdCB7IHJlcXVlc3QgfSA9IGZldGNoUGFyYW1zXG5cbiAgY29uc3QgeyBwcm90b2NvbDogc2NoZW1lIH0gPSByZXF1ZXN0Q3VycmVudFVSTChyZXF1ZXN0KVxuXG4gIC8vIDMuIFN3aXRjaCBvbiByZXF1ZXN04oCZcyBjdXJyZW50IFVSTOKAmXMgc2NoZW1lIGFuZCBydW4gdGhlIGFzc29jaWF0ZWQgc3RlcHM6XG4gIHN3aXRjaCAoc2NoZW1lKSB7XG4gICAgY2FzZSAnYWJvdXQ6Jzoge1xuICAgICAgLy8gSWYgcmVxdWVzdOKAmXMgY3VycmVudCBVUkzigJlzIHBhdGggaXMgdGhlIHN0cmluZyBcImJsYW5rXCIsIHRoZW4gcmV0dXJuIGEgbmV3IHJlc3BvbnNlXG4gICAgICAvLyB3aG9zZSBzdGF0dXMgbWVzc2FnZSBpcyBgT0tgLCBoZWFkZXIgbGlzdCBpcyDCqyAoYENvbnRlbnQtVHlwZWAsIGB0ZXh0L2h0bWw7Y2hhcnNldD11dGYtOGApIMK7LFxuICAgICAgLy8gYW5kIGJvZHkgaXMgdGhlIGVtcHR5IGJ5dGUgc2VxdWVuY2UgYXMgYSBib2R5LlxuXG4gICAgICAvLyBPdGhlcndpc2UsIHJldHVybiBhIG5ldHdvcmsgZXJyb3IuXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG1ha2VOZXR3b3JrRXJyb3IoJ2Fib3V0IHNjaGVtZSBpcyBub3Qgc3VwcG9ydGVkJykpXG4gICAgfVxuICAgIGNhc2UgJ2Jsb2I6Jzoge1xuICAgICAgaWYgKCFyZXNvbHZlT2JqZWN0VVJMKSB7XG4gICAgICAgIHJlc29sdmVPYmplY3RVUkwgPSByZXF1aXJlKCdub2RlOmJ1ZmZlcicpLnJlc29sdmVPYmplY3RVUkxcbiAgICAgIH1cblxuICAgICAgLy8gMS4gTGV0IGJsb2JVUkxFbnRyeSBiZSByZXF1ZXN04oCZcyBjdXJyZW50IFVSTOKAmXMgYmxvYiBVUkwgZW50cnkuXG4gICAgICBjb25zdCBibG9iVVJMRW50cnkgPSByZXF1ZXN0Q3VycmVudFVSTChyZXF1ZXN0KVxuXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vd2ViLXBsYXRmb3JtLXRlc3RzL3dwdC9ibG9iLzdiMGViYWNjYzYyYjU2NmExOTY1Mzk2ZTViZTdiYjJiYzA2Zjg0MWYvRmlsZUFQSS91cmwvcmVzb3VyY2VzL2ZldGNoLXRlc3RzLmpzI0w1Mi1MNTZcbiAgICAgIC8vIEJ1ZmZlci5yZXNvbHZlT2JqZWN0VVJMIGRvZXMgbm90IGlnbm9yZSBVUkwgcXVlcmllcy5cbiAgICAgIGlmIChibG9iVVJMRW50cnkuc2VhcmNoLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG1ha2VOZXR3b3JrRXJyb3IoJ05ldHdvcmtFcnJvciB3aGVuIGF0dGVtcHRpbmcgdG8gZmV0Y2ggcmVzb3VyY2UuJykpXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGJsb2IgPSByZXNvbHZlT2JqZWN0VVJMKGJsb2JVUkxFbnRyeS50b1N0cmluZygpKVxuXG4gICAgICAvLyAyLiBJZiByZXF1ZXN04oCZcyBtZXRob2QgaXMgbm90IGBHRVRgLCBibG9iVVJMRW50cnkgaXMgbnVsbCwgb3IgYmxvYlVSTEVudHJ54oCZc1xuICAgICAgLy8gICAgb2JqZWN0IGlzIG5vdCBhIEJsb2Igb2JqZWN0LCB0aGVuIHJldHVybiBhIG5ldHdvcmsgZXJyb3IuXG4gICAgICBpZiAocmVxdWVzdC5tZXRob2QgIT09ICdHRVQnIHx8ICFpc0Jsb2JMaWtlKGJsb2IpKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobWFrZU5ldHdvcmtFcnJvcignaW52YWxpZCBtZXRob2QnKSlcbiAgICAgIH1cblxuICAgICAgLy8gMy4gTGV0IGJsb2IgYmUgYmxvYlVSTEVudHJ54oCZcyBvYmplY3QuXG4gICAgICAvLyBOb3RlOiBkb25lIGFib3ZlXG5cbiAgICAgIC8vIDQuIExldCByZXNwb25zZSBiZSBhIG5ldyByZXNwb25zZS5cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gbWFrZVJlc3BvbnNlKClcblxuICAgICAgLy8gNS4gTGV0IGZ1bGxMZW5ndGggYmUgYmxvYuKAmXMgc2l6ZS5cbiAgICAgIGNvbnN0IGZ1bGxMZW5ndGggPSBibG9iLnNpemVcblxuICAgICAgLy8gNi4gTGV0IHNlcmlhbGl6ZWRGdWxsTGVuZ3RoIGJlIGZ1bGxMZW5ndGgsIHNlcmlhbGl6ZWQgYW5kIGlzb21vcnBoaWMgZW5jb2RlZC5cbiAgICAgIGNvbnN0IHNlcmlhbGl6ZWRGdWxsTGVuZ3RoID0gaXNvbW9ycGhpY0VuY29kZShgJHtmdWxsTGVuZ3RofWApXG5cbiAgICAgIC8vIDcuIExldCB0eXBlIGJlIGJsb2LigJlzIHR5cGUuXG4gICAgICBjb25zdCB0eXBlID0gYmxvYi50eXBlXG5cbiAgICAgIC8vIDguIElmIHJlcXVlc3TigJlzIGhlYWRlciBsaXN0IGRvZXMgbm90IGNvbnRhaW4gYFJhbmdlYDpcbiAgICAgIC8vIDkuIE90aGVyd2lzZTpcbiAgICAgIGlmICghcmVxdWVzdC5oZWFkZXJzTGlzdC5jb250YWlucygncmFuZ2UnLCB0cnVlKSkge1xuICAgICAgICAvLyAxLiBMZXQgYm9keVdpdGhUeXBlIGJlIHRoZSByZXN1bHQgb2Ygc2FmZWx5IGV4dHJhY3RpbmcgYmxvYi5cbiAgICAgICAgLy8gTm90ZTogaW4gdGhlIEZpbGVBUEkgYSBibG9iIFwib2JqZWN0XCIgaXMgYSBCbG9iICpvciogYSBNZWRpYVNvdXJjZS5cbiAgICAgICAgLy8gSW4gbm9kZSwgdGhpcyBjYW4gb25seSBldmVyIGJlIGEgQmxvYi4gVGhlcmVmb3JlIHdlIGNhbiBzYWZlbHlcbiAgICAgICAgLy8gdXNlIGV4dHJhY3RCb2R5IGRpcmVjdGx5LlxuICAgICAgICBjb25zdCBib2R5V2l0aFR5cGUgPSBleHRyYWN0Qm9keShibG9iKVxuXG4gICAgICAgIC8vIDIuIFNldCByZXNwb25zZeKAmXMgc3RhdHVzIG1lc3NhZ2UgdG8gYE9LYC5cbiAgICAgICAgcmVzcG9uc2Uuc3RhdHVzVGV4dCA9ICdPSydcblxuICAgICAgICAvLyAzLiBTZXQgcmVzcG9uc2XigJlzIGJvZHkgdG8gYm9keVdpdGhUeXBl4oCZcyBib2R5LlxuICAgICAgICByZXNwb25zZS5ib2R5ID0gYm9keVdpdGhUeXBlWzBdXG5cbiAgICAgICAgLy8gNC4gU2V0IHJlc3BvbnNl4oCZcyBoZWFkZXIgbGlzdCB0byDCqyAoYENvbnRlbnQtTGVuZ3RoYCwgc2VyaWFsaXplZEZ1bGxMZW5ndGgpLCAoYENvbnRlbnQtVHlwZWAsIHR5cGUpIMK7LlxuICAgICAgICByZXNwb25zZS5oZWFkZXJzTGlzdC5zZXQoJ2NvbnRlbnQtbGVuZ3RoJywgc2VyaWFsaXplZEZ1bGxMZW5ndGgsIHRydWUpXG4gICAgICAgIHJlc3BvbnNlLmhlYWRlcnNMaXN0LnNldCgnY29udGVudC10eXBlJywgdHlwZSwgdHJ1ZSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIDEuIFNldCByZXNwb25zZeKAmXMgcmFuZ2UtcmVxdWVzdGVkIGZsYWcuXG4gICAgICAgIHJlc3BvbnNlLnJhbmdlUmVxdWVzdGVkID0gdHJ1ZVxuXG4gICAgICAgIC8vIDIuIExldCByYW5nZUhlYWRlciBiZSB0aGUgcmVzdWx0IG9mIGdldHRpbmcgYFJhbmdlYCBmcm9tIHJlcXVlc3TigJlzIGhlYWRlciBsaXN0LlxuICAgICAgICBjb25zdCByYW5nZUhlYWRlciA9IHJlcXVlc3QuaGVhZGVyc0xpc3QuZ2V0KCdyYW5nZScsIHRydWUpXG5cbiAgICAgICAgLy8gMy4gTGV0IHJhbmdlVmFsdWUgYmUgdGhlIHJlc3VsdCBvZiBwYXJzaW5nIGEgc2luZ2xlIHJhbmdlIGhlYWRlciB2YWx1ZSBnaXZlbiByYW5nZUhlYWRlciBhbmQgdHJ1ZS5cbiAgICAgICAgY29uc3QgcmFuZ2VWYWx1ZSA9IHNpbXBsZVJhbmdlSGVhZGVyVmFsdWUocmFuZ2VIZWFkZXIsIHRydWUpXG5cbiAgICAgICAgLy8gNC4gSWYgcmFuZ2VWYWx1ZSBpcyBmYWlsdXJlLCB0aGVuIHJldHVybiBhIG5ldHdvcmsgZXJyb3IuXG4gICAgICAgIGlmIChyYW5nZVZhbHVlID09PSAnZmFpbHVyZScpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG1ha2VOZXR3b3JrRXJyb3IoJ2ZhaWxlZCB0byBmZXRjaCB0aGUgZGF0YSBVUkwnKSlcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDUuIExldCAocmFuZ2VTdGFydCwgcmFuZ2VFbmQpIGJlIHJhbmdlVmFsdWUuXG4gICAgICAgIGxldCB7IHJhbmdlU3RhcnRWYWx1ZTogcmFuZ2VTdGFydCwgcmFuZ2VFbmRWYWx1ZTogcmFuZ2VFbmQgfSA9IHJhbmdlVmFsdWVcblxuICAgICAgICAvLyA2LiBJZiByYW5nZVN0YXJ0IGlzIG51bGw6XG4gICAgICAgIC8vIDcuIE90aGVyd2lzZTpcbiAgICAgICAgaWYgKHJhbmdlU3RhcnQgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyAxLiBTZXQgcmFuZ2VTdGFydCB0byBmdWxsTGVuZ3RoIOKIkiByYW5nZUVuZC5cbiAgICAgICAgICByYW5nZVN0YXJ0ID0gZnVsbExlbmd0aCAtIHJhbmdlRW5kXG5cbiAgICAgICAgICAvLyAyLiBTZXQgcmFuZ2VFbmQgdG8gcmFuZ2VTdGFydCArIHJhbmdlRW5kIOKIkiAxLlxuICAgICAgICAgIHJhbmdlRW5kID0gcmFuZ2VTdGFydCArIHJhbmdlRW5kIC0gMVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIDEuIElmIHJhbmdlU3RhcnQgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIGZ1bGxMZW5ndGgsIHRoZW4gcmV0dXJuIGEgbmV0d29yayBlcnJvci5cbiAgICAgICAgICBpZiAocmFuZ2VTdGFydCA+PSBmdWxsTGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG1ha2VOZXR3b3JrRXJyb3IoJ1JhbmdlIHN0YXJ0IGlzIGdyZWF0ZXIgdGhhbiB0aGUgYmxvYlxcJ3Mgc2l6ZS4nKSlcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyAyLiBJZiByYW5nZUVuZCBpcyBudWxsIG9yIHJhbmdlRW5kIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byBmdWxsTGVuZ3RoLCB0aGVuIHNldFxuICAgICAgICAgIC8vICAgIHJhbmdlRW5kIHRvIGZ1bGxMZW5ndGgg4oiSIDEuXG4gICAgICAgICAgaWYgKHJhbmdlRW5kID09PSBudWxsIHx8IHJhbmdlRW5kID49IGZ1bGxMZW5ndGgpIHtcbiAgICAgICAgICAgIHJhbmdlRW5kID0gZnVsbExlbmd0aCAtIDFcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyA4LiBMZXQgc2xpY2VkQmxvYiBiZSB0aGUgcmVzdWx0IG9mIGludm9raW5nIHNsaWNlIGJsb2IgZ2l2ZW4gYmxvYiwgcmFuZ2VTdGFydCxcbiAgICAgICAgLy8gICAgcmFuZ2VFbmQgKyAxLCBhbmQgdHlwZS5cbiAgICAgICAgY29uc3Qgc2xpY2VkQmxvYiA9IGJsb2Iuc2xpY2UocmFuZ2VTdGFydCwgcmFuZ2VFbmQsIHR5cGUpXG5cbiAgICAgICAgLy8gOS4gTGV0IHNsaWNlZEJvZHlXaXRoVHlwZSBiZSB0aGUgcmVzdWx0IG9mIHNhZmVseSBleHRyYWN0aW5nIHNsaWNlZEJsb2IuXG4gICAgICAgIC8vIE5vdGU6IHNhbWUgcmVhc29uIGFzIG1lbnRpb25lZCBhYm92ZSBhcyB0byB3aHkgd2UgdXNlIGV4dHJhY3RCb2R5XG4gICAgICAgIGNvbnN0IHNsaWNlZEJvZHlXaXRoVHlwZSA9IGV4dHJhY3RCb2R5KHNsaWNlZEJsb2IpXG5cbiAgICAgICAgLy8gMTAuIFNldCByZXNwb25zZeKAmXMgYm9keSB0byBzbGljZWRCb2R5V2l0aFR5cGXigJlzIGJvZHkuXG4gICAgICAgIHJlc3BvbnNlLmJvZHkgPSBzbGljZWRCb2R5V2l0aFR5cGVbMF1cblxuICAgICAgICAvLyAxMS4gTGV0IHNlcmlhbGl6ZWRTbGljZWRMZW5ndGggYmUgc2xpY2VkQmxvYuKAmXMgc2l6ZSwgc2VyaWFsaXplZCBhbmQgaXNvbW9ycGhpYyBlbmNvZGVkLlxuICAgICAgICBjb25zdCBzZXJpYWxpemVkU2xpY2VkTGVuZ3RoID0gaXNvbW9ycGhpY0VuY29kZShgJHtzbGljZWRCbG9iLnNpemV9YClcblxuICAgICAgICAvLyAxMi4gTGV0IGNvbnRlbnRSYW5nZSBiZSB0aGUgcmVzdWx0IG9mIGludm9raW5nIGJ1aWxkIGEgY29udGVudCByYW5nZSBnaXZlbiByYW5nZVN0YXJ0LFxuICAgICAgICAvLyAgICAgcmFuZ2VFbmQsIGFuZCBmdWxsTGVuZ3RoLlxuICAgICAgICBjb25zdCBjb250ZW50UmFuZ2UgPSBidWlsZENvbnRlbnRSYW5nZShyYW5nZVN0YXJ0LCByYW5nZUVuZCwgZnVsbExlbmd0aClcblxuICAgICAgICAvLyAxMy4gU2V0IHJlc3BvbnNl4oCZcyBzdGF0dXMgdG8gMjA2LlxuICAgICAgICByZXNwb25zZS5zdGF0dXMgPSAyMDZcblxuICAgICAgICAvLyAxNC4gU2V0IHJlc3BvbnNl4oCZcyBzdGF0dXMgbWVzc2FnZSB0byBgUGFydGlhbCBDb250ZW50YC5cbiAgICAgICAgcmVzcG9uc2Uuc3RhdHVzVGV4dCA9ICdQYXJ0aWFsIENvbnRlbnQnXG5cbiAgICAgICAgLy8gMTUuIFNldCByZXNwb25zZeKAmXMgaGVhZGVyIGxpc3QgdG8gwqsgKGBDb250ZW50LUxlbmd0aGAsIHNlcmlhbGl6ZWRTbGljZWRMZW5ndGgpLFxuICAgICAgICAvLyAgICAgKGBDb250ZW50LVR5cGVgLCB0eXBlKSwgKGBDb250ZW50LVJhbmdlYCwgY29udGVudFJhbmdlKSDCuy5cbiAgICAgICAgcmVzcG9uc2UuaGVhZGVyc0xpc3Quc2V0KCdjb250ZW50LWxlbmd0aCcsIHNlcmlhbGl6ZWRTbGljZWRMZW5ndGgsIHRydWUpXG4gICAgICAgIHJlc3BvbnNlLmhlYWRlcnNMaXN0LnNldCgnY29udGVudC10eXBlJywgdHlwZSwgdHJ1ZSlcbiAgICAgICAgcmVzcG9uc2UuaGVhZGVyc0xpc3Quc2V0KCdjb250ZW50LXJhbmdlJywgY29udGVudFJhbmdlLCB0cnVlKVxuICAgICAgfVxuXG4gICAgICAvLyAxMC4gUmV0dXJuIHJlc3BvbnNlLlxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXNwb25zZSlcbiAgICB9XG4gICAgY2FzZSAnZGF0YTonOiB7XG4gICAgICAvLyAxLiBMZXQgZGF0YVVSTFN0cnVjdCBiZSB0aGUgcmVzdWx0IG9mIHJ1bm5pbmcgdGhlXG4gICAgICAvLyAgICBkYXRhOiBVUkwgcHJvY2Vzc29yIG9uIHJlcXVlc3TigJlzIGN1cnJlbnQgVVJMLlxuICAgICAgY29uc3QgY3VycmVudFVSTCA9IHJlcXVlc3RDdXJyZW50VVJMKHJlcXVlc3QpXG4gICAgICBjb25zdCBkYXRhVVJMU3RydWN0ID0gZGF0YVVSTFByb2Nlc3NvcihjdXJyZW50VVJMKVxuXG4gICAgICAvLyAyLiBJZiBkYXRhVVJMU3RydWN0IGlzIGZhaWx1cmUsIHRoZW4gcmV0dXJuIGFcbiAgICAgIC8vICAgIG5ldHdvcmsgZXJyb3IuXG4gICAgICBpZiAoZGF0YVVSTFN0cnVjdCA9PT0gJ2ZhaWx1cmUnKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobWFrZU5ldHdvcmtFcnJvcignZmFpbGVkIHRvIGZldGNoIHRoZSBkYXRhIFVSTCcpKVxuICAgICAgfVxuXG4gICAgICAvLyAzLiBMZXQgbWltZVR5cGUgYmUgZGF0YVVSTFN0cnVjdOKAmXMgTUlNRSB0eXBlLCBzZXJpYWxpemVkLlxuICAgICAgY29uc3QgbWltZVR5cGUgPSBzZXJpYWxpemVBTWltZVR5cGUoZGF0YVVSTFN0cnVjdC5taW1lVHlwZSlcblxuICAgICAgLy8gNC4gUmV0dXJuIGEgcmVzcG9uc2Ugd2hvc2Ugc3RhdHVzIG1lc3NhZ2UgaXMgYE9LYCxcbiAgICAgIC8vICAgIGhlYWRlciBsaXN0IGlzIMKrIChgQ29udGVudC1UeXBlYCwgbWltZVR5cGUpIMK7LFxuICAgICAgLy8gICAgYW5kIGJvZHkgaXMgZGF0YVVSTFN0cnVjdOKAmXMgYm9keSBhcyBhIGJvZHkuXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG1ha2VSZXNwb25zZSh7XG4gICAgICAgIHN0YXR1c1RleHQ6ICdPSycsXG4gICAgICAgIGhlYWRlcnNMaXN0OiBbXG4gICAgICAgICAgWydjb250ZW50LXR5cGUnLCB7IG5hbWU6ICdDb250ZW50LVR5cGUnLCB2YWx1ZTogbWltZVR5cGUgfV1cbiAgICAgICAgXSxcbiAgICAgICAgYm9keTogc2FmZWx5RXh0cmFjdEJvZHkoZGF0YVVSTFN0cnVjdC5ib2R5KVswXVxuICAgICAgfSkpXG4gICAgfVxuICAgIGNhc2UgJ2ZpbGU6Jzoge1xuICAgICAgLy8gRm9yIG5vdywgdW5mb3J0dW5hdGUgYXMgaXQgaXMsIGZpbGUgVVJMcyBhcmUgbGVmdCBhcyBhbiBleGVyY2lzZSBmb3IgdGhlIHJlYWRlci5cbiAgICAgIC8vIFdoZW4gaW4gZG91YnQsIHJldHVybiBhIG5ldHdvcmsgZXJyb3IuXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG1ha2VOZXR3b3JrRXJyb3IoJ25vdCBpbXBsZW1lbnRlZC4uLiB5ZXQuLi4nKSlcbiAgICB9XG4gICAgY2FzZSAnaHR0cDonOlxuICAgIGNhc2UgJ2h0dHBzOic6IHtcbiAgICAgIC8vIFJldHVybiB0aGUgcmVzdWx0IG9mIHJ1bm5pbmcgSFRUUCBmZXRjaCBnaXZlbiBmZXRjaFBhcmFtcy5cblxuICAgICAgcmV0dXJuIGh0dHBGZXRjaChmZXRjaFBhcmFtcylcbiAgICAgICAgLmNhdGNoKChlcnIpID0+IG1ha2VOZXR3b3JrRXJyb3IoZXJyKSlcbiAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShtYWtlTmV0d29ya0Vycm9yKCd1bmtub3duIHNjaGVtZScpKVxuICAgIH1cbiAgfVxufVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jZmluYWxpemUtcmVzcG9uc2VcbmZ1bmN0aW9uIGZpbmFsaXplUmVzcG9uc2UgKGZldGNoUGFyYW1zLCByZXNwb25zZSkge1xuICAvLyAxLiBTZXQgZmV0Y2hQYXJhbXPigJlzIHJlcXVlc3TigJlzIGRvbmUgZmxhZy5cbiAgZmV0Y2hQYXJhbXMucmVxdWVzdC5kb25lID0gdHJ1ZVxuXG4gIC8vIDIsIElmIGZldGNoUGFyYW1z4oCZcyBwcm9jZXNzIHJlc3BvbnNlIGRvbmUgaXMgbm90IG51bGwsIHRoZW4gcXVldWUgYSBmZXRjaFxuICAvLyB0YXNrIHRvIHJ1biBmZXRjaFBhcmFtc+KAmXMgcHJvY2VzcyByZXNwb25zZSBkb25lIGdpdmVuIHJlc3BvbnNlLCB3aXRoXG4gIC8vIGZldGNoUGFyYW1z4oCZcyB0YXNrIGRlc3RpbmF0aW9uLlxuICBpZiAoZmV0Y2hQYXJhbXMucHJvY2Vzc1Jlc3BvbnNlRG9uZSAhPSBudWxsKSB7XG4gICAgcXVldWVNaWNyb3Rhc2soKCkgPT4gZmV0Y2hQYXJhbXMucHJvY2Vzc1Jlc3BvbnNlRG9uZShyZXNwb25zZSkpXG4gIH1cbn1cblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2ZldGNoLWZpbmFsZVxuZnVuY3Rpb24gZmV0Y2hGaW5hbGUgKGZldGNoUGFyYW1zLCByZXNwb25zZSkge1xuICAvLyAxLiBMZXQgdGltaW5nSW5mbyBiZSBmZXRjaFBhcmFtc+KAmXMgdGltaW5nIGluZm8uXG4gIGxldCB0aW1pbmdJbmZvID0gZmV0Y2hQYXJhbXMudGltaW5nSW5mb1xuXG4gIC8vIDIuIElmIHJlc3BvbnNlIGlzIG5vdCBhIG5ldHdvcmsgZXJyb3IgYW5kIGZldGNoUGFyYW1z4oCZcyByZXF1ZXN04oCZcyBjbGllbnQgaXMgYSBzZWN1cmUgY29udGV4dCxcbiAgLy8gICAgdGhlbiBzZXQgdGltaW5nSW5mb+KAmXMgc2VydmVyLXRpbWluZyBoZWFkZXJzIHRvIHRoZSByZXN1bHQgb2YgZ2V0dGluZywgZGVjb2RpbmcsIGFuZCBzcGxpdHRpbmdcbiAgLy8gICAgYFNlcnZlci1UaW1pbmdgIGZyb20gcmVzcG9uc2XigJlzIGludGVybmFsIHJlc3BvbnNl4oCZcyBoZWFkZXIgbGlzdC5cbiAgLy8gVE9ET1xuXG4gIC8vIDMuIExldCBwcm9jZXNzUmVzcG9uc2VFbmRPZkJvZHkgYmUgdGhlIGZvbGxvd2luZyBzdGVwczpcbiAgY29uc3QgcHJvY2Vzc1Jlc3BvbnNlRW5kT2ZCb2R5ID0gKCkgPT4ge1xuICAgIC8vIDEuIExldCB1bnNhZmVFbmRUaW1lIGJlIHRoZSB1bnNhZmUgc2hhcmVkIGN1cnJlbnQgdGltZS5cbiAgICBjb25zdCB1bnNhZmVFbmRUaW1lID0gRGF0ZS5ub3coKSAvLyA/XG5cbiAgICAvLyAyLiBJZiBmZXRjaFBhcmFtc+KAmXMgcmVxdWVzdOKAmXMgZGVzdGluYXRpb24gaXMgXCJkb2N1bWVudFwiLCB0aGVuIHNldCBmZXRjaFBhcmFtc+KAmXMgY29udHJvbGxlcuKAmXNcbiAgICAvLyAgICBmdWxsIHRpbWluZyBpbmZvIHRvIGZldGNoUGFyYW1z4oCZcyB0aW1pbmcgaW5mby5cbiAgICBpZiAoZmV0Y2hQYXJhbXMucmVxdWVzdC5kZXN0aW5hdGlvbiA9PT0gJ2RvY3VtZW50Jykge1xuICAgICAgZmV0Y2hQYXJhbXMuY29udHJvbGxlci5mdWxsVGltaW5nSW5mbyA9IHRpbWluZ0luZm9cbiAgICB9XG5cbiAgICAvLyAzLiBTZXQgZmV0Y2hQYXJhbXPigJlzIGNvbnRyb2xsZXLigJlzIHJlcG9ydCB0aW1pbmcgc3RlcHMgdG8gdGhlIGZvbGxvd2luZyBzdGVwcyBnaXZlbiBhIGdsb2JhbCBvYmplY3QgZ2xvYmFsOlxuICAgIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIucmVwb3J0VGltaW5nU3RlcHMgPSAoKSA9PiB7XG4gICAgICAvLyAxLiBJZiBmZXRjaFBhcmFtc+KAmXMgcmVxdWVzdOKAmXMgVVJM4oCZcyBzY2hlbWUgaXMgbm90IGFuIEhUVFAoUykgc2NoZW1lLCB0aGVuIHJldHVybi5cbiAgICAgIGlmIChmZXRjaFBhcmFtcy5yZXF1ZXN0LnVybC5wcm90b2NvbCAhPT0gJ2h0dHBzOicpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIC8vIDIuIFNldCB0aW1pbmdJbmZv4oCZcyBlbmQgdGltZSB0byB0aGUgcmVsYXRpdmUgaGlnaCByZXNvbHV0aW9uIHRpbWUgZ2l2ZW4gdW5zYWZlRW5kVGltZSBhbmQgZ2xvYmFsLlxuICAgICAgdGltaW5nSW5mby5lbmRUaW1lID0gdW5zYWZlRW5kVGltZVxuXG4gICAgICAvLyAzLiBMZXQgY2FjaGVTdGF0ZSBiZSByZXNwb25zZeKAmXMgY2FjaGUgc3RhdGUuXG4gICAgICBsZXQgY2FjaGVTdGF0ZSA9IHJlc3BvbnNlLmNhY2hlU3RhdGVcblxuICAgICAgLy8gNC4gTGV0IGJvZHlJbmZvIGJlIHJlc3BvbnNl4oCZcyBib2R5IGluZm8uXG4gICAgICBjb25zdCBib2R5SW5mbyA9IHJlc3BvbnNlLmJvZHlJbmZvXG5cbiAgICAgIC8vIDUuIElmIHJlc3BvbnNl4oCZcyB0aW1pbmcgYWxsb3cgcGFzc2VkIGZsYWcgaXMgbm90IHNldCwgdGhlbiBzZXQgdGltaW5nSW5mbyB0byB0aGUgcmVzdWx0IG9mIGNyZWF0aW5nIGFuXG4gICAgICAvLyAgICBvcGFxdWUgdGltaW5nIGluZm8gZm9yIHRpbWluZ0luZm8gYW5kIHNldCBjYWNoZVN0YXRlIHRvIHRoZSBlbXB0eSBzdHJpbmcuXG4gICAgICBpZiAoIXJlc3BvbnNlLnRpbWluZ0FsbG93UGFzc2VkKSB7XG4gICAgICAgIHRpbWluZ0luZm8gPSBjcmVhdGVPcGFxdWVUaW1pbmdJbmZvKHRpbWluZ0luZm8pXG5cbiAgICAgICAgY2FjaGVTdGF0ZSA9ICcnXG4gICAgICB9XG5cbiAgICAgIC8vIDYuIExldCByZXNwb25zZVN0YXR1cyBiZSAwLlxuICAgICAgbGV0IHJlc3BvbnNlU3RhdHVzID0gMFxuXG4gICAgICAvLyA3LiBJZiBmZXRjaFBhcmFtc+KAmXMgcmVxdWVzdOKAmXMgbW9kZSBpcyBub3QgXCJuYXZpZ2F0ZVwiIG9yIHJlc3BvbnNl4oCZcyBoYXMtY3Jvc3Mtb3JpZ2luLXJlZGlyZWN0cyBpcyBmYWxzZTpcbiAgICAgIGlmIChmZXRjaFBhcmFtcy5yZXF1ZXN0Lm1vZGUgIT09ICduYXZpZ2F0b3InIHx8ICFyZXNwb25zZS5oYXNDcm9zc09yaWdpblJlZGlyZWN0cykge1xuICAgICAgICAvLyAxLiBTZXQgcmVzcG9uc2VTdGF0dXMgdG8gcmVzcG9uc2XigJlzIHN0YXR1cy5cbiAgICAgICAgcmVzcG9uc2VTdGF0dXMgPSByZXNwb25zZS5zdGF0dXNcblxuICAgICAgICAvLyAyLiBMZXQgbWltZVR5cGUgYmUgdGhlIHJlc3VsdCBvZiBleHRyYWN0aW5nIGEgTUlNRSB0eXBlIGZyb20gcmVzcG9uc2XigJlzIGhlYWRlciBsaXN0LlxuICAgICAgICBjb25zdCBtaW1lVHlwZSA9IGV4dHJhY3RNaW1lVHlwZShyZXNwb25zZS5oZWFkZXJzTGlzdClcblxuICAgICAgICAvLyAzLiBJZiBtaW1lVHlwZSBpcyBub3QgZmFpbHVyZSwgdGhlbiBzZXQgYm9keUluZm/igJlzIGNvbnRlbnQgdHlwZSB0byB0aGUgcmVzdWx0IG9mIG1pbmltaXppbmcgYSBzdXBwb3J0ZWQgTUlNRSB0eXBlIGdpdmVuIG1pbWVUeXBlLlxuICAgICAgICBpZiAobWltZVR5cGUgIT09ICdmYWlsdXJlJykge1xuICAgICAgICAgIGJvZHlJbmZvLmNvbnRlbnRUeXBlID0gbWluaW1pemVTdXBwb3J0ZWRNaW1lVHlwZShtaW1lVHlwZSlcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyA4LiBJZiBmZXRjaFBhcmFtc+KAmXMgcmVxdWVzdOKAmXMgaW5pdGlhdG9yIHR5cGUgaXMgbm9uLW51bGwsIHRoZW4gbWFyayByZXNvdXJjZSB0aW1pbmcgZ2l2ZW4gdGltaW5nSW5mbyxcbiAgICAgIC8vICAgIGZldGNoUGFyYW1z4oCZcyByZXF1ZXN04oCZcyBVUkwsIGZldGNoUGFyYW1z4oCZcyByZXF1ZXN04oCZcyBpbml0aWF0b3IgdHlwZSwgZ2xvYmFsLCBjYWNoZVN0YXRlLCBib2R5SW5mbyxcbiAgICAgIC8vICAgIGFuZCByZXNwb25zZVN0YXR1cy5cbiAgICAgIGlmIChmZXRjaFBhcmFtcy5yZXF1ZXN0LmluaXRpYXRvclR5cGUgIT0gbnVsbCkge1xuICAgICAgICAvLyBUT0RPOiB1cGRhdGUgbWFya3Jlc291cmNldGltaW5nXG4gICAgICAgIG1hcmtSZXNvdXJjZVRpbWluZyh0aW1pbmdJbmZvLCBmZXRjaFBhcmFtcy5yZXF1ZXN0LnVybC5ocmVmLCBmZXRjaFBhcmFtcy5yZXF1ZXN0LmluaXRpYXRvclR5cGUsIGdsb2JhbFRoaXMsIGNhY2hlU3RhdGUsIGJvZHlJbmZvLCByZXNwb25zZVN0YXR1cylcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyA0LiBMZXQgcHJvY2Vzc1Jlc3BvbnNlRW5kT2ZCb2R5VGFzayBiZSB0aGUgZm9sbG93aW5nIHN0ZXBzOlxuICAgIGNvbnN0IHByb2Nlc3NSZXNwb25zZUVuZE9mQm9keVRhc2sgPSAoKSA9PiB7XG4gICAgICAvLyAxLiBTZXQgZmV0Y2hQYXJhbXPigJlzIHJlcXVlc3TigJlzIGRvbmUgZmxhZy5cbiAgICAgIGZldGNoUGFyYW1zLnJlcXVlc3QuZG9uZSA9IHRydWVcblxuICAgICAgLy8gMi4gSWYgZmV0Y2hQYXJhbXPigJlzIHByb2Nlc3MgcmVzcG9uc2UgZW5kLW9mLWJvZHkgaXMgbm9uLW51bGwsIHRoZW4gcnVuIGZldGNoUGFyYW1z4oCZcyBwcm9jZXNzXG4gICAgICAvLyAgICByZXNwb25zZSBlbmQtb2YtYm9keSBnaXZlbiByZXNwb25zZS5cbiAgICAgIGlmIChmZXRjaFBhcmFtcy5wcm9jZXNzUmVzcG9uc2VFbmRPZkJvZHkgIT0gbnVsbCkge1xuICAgICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiBmZXRjaFBhcmFtcy5wcm9jZXNzUmVzcG9uc2VFbmRPZkJvZHkocmVzcG9uc2UpKVxuICAgICAgfVxuXG4gICAgICAvLyAzLiBJZiBmZXRjaFBhcmFtc+KAmXMgcmVxdWVzdOKAmXMgaW5pdGlhdG9yIHR5cGUgaXMgbm9uLW51bGwgYW5kIGZldGNoUGFyYW1z4oCZcyByZXF1ZXN04oCZcyBjbGllbnTigJlzXG4gICAgICAvLyAgICBnbG9iYWwgb2JqZWN0IGlzIGZldGNoUGFyYW1z4oCZcyB0YXNrIGRlc3RpbmF0aW9uLCB0aGVuIHJ1biBmZXRjaFBhcmFtc+KAmXMgY29udHJvbGxlcuKAmXMgcmVwb3J0XG4gICAgICAvLyAgICB0aW1pbmcgc3RlcHMgZ2l2ZW4gZmV0Y2hQYXJhbXPigJlzIHJlcXVlc3TigJlzIGNsaWVudOKAmXMgZ2xvYmFsIG9iamVjdC5cbiAgICAgIGlmIChmZXRjaFBhcmFtcy5yZXF1ZXN0LmluaXRpYXRvclR5cGUgIT0gbnVsbCkge1xuICAgICAgICBmZXRjaFBhcmFtcy5jb250cm9sbGVyLnJlcG9ydFRpbWluZ1N0ZXBzKClcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyA1LiBRdWV1ZSBhIGZldGNoIHRhc2sgdG8gcnVuIHByb2Nlc3NSZXNwb25zZUVuZE9mQm9keVRhc2sgd2l0aCBmZXRjaFBhcmFtc+KAmXMgdGFzayBkZXN0aW5hdGlvblxuICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHByb2Nlc3NSZXNwb25zZUVuZE9mQm9keVRhc2soKSlcbiAgfVxuXG4gIC8vIDQuIElmIGZldGNoUGFyYW1z4oCZcyBwcm9jZXNzIHJlc3BvbnNlIGlzIG5vbi1udWxsLCB0aGVuIHF1ZXVlIGEgZmV0Y2ggdGFzayB0byBydW4gZmV0Y2hQYXJhbXPigJlzXG4gIC8vICAgIHByb2Nlc3MgcmVzcG9uc2UgZ2l2ZW4gcmVzcG9uc2UsIHdpdGggZmV0Y2hQYXJhbXPigJlzIHRhc2sgZGVzdGluYXRpb24uXG4gIGlmIChmZXRjaFBhcmFtcy5wcm9jZXNzUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgIGZldGNoUGFyYW1zLnByb2Nlc3NSZXNwb25zZShyZXNwb25zZSlcbiAgICAgIGZldGNoUGFyYW1zLnByb2Nlc3NSZXNwb25zZSA9IG51bGxcbiAgICB9KVxuICB9XG5cbiAgLy8gNS4gTGV0IGludGVybmFsUmVzcG9uc2UgYmUgcmVzcG9uc2UsIGlmIHJlc3BvbnNlIGlzIGEgbmV0d29yayBlcnJvcjsgb3RoZXJ3aXNlIHJlc3BvbnNl4oCZcyBpbnRlcm5hbCByZXNwb25zZS5cbiAgY29uc3QgaW50ZXJuYWxSZXNwb25zZSA9IHJlc3BvbnNlLnR5cGUgPT09ICdlcnJvcicgPyByZXNwb25zZSA6IChyZXNwb25zZS5pbnRlcm5hbFJlc3BvbnNlID8/IHJlc3BvbnNlKVxuXG4gIC8vIDYuIElmIGludGVybmFsUmVzcG9uc2XigJlzIGJvZHkgaXMgbnVsbCwgdGhlbiBydW4gcHJvY2Vzc1Jlc3BvbnNlRW5kT2ZCb2R5LlxuICAvLyA3LiBPdGhlcndpc2U6XG4gIGlmIChpbnRlcm5hbFJlc3BvbnNlLmJvZHkgPT0gbnVsbCkge1xuICAgIHByb2Nlc3NSZXNwb25zZUVuZE9mQm9keSgpXG4gIH0gZWxzZSB7XG4gICAgLy8gbWNvbGxpbmE6IGFsbCB0aGUgZm9sbG93aW5nIHN0ZXBzIG9mIHRoZSBzcGVjcyBhcmUgc2tpcHBlZC5cbiAgICAvLyBUaGUgaW50ZXJuYWwgdHJhbnNmb3JtIHN0cmVhbSBpcyBub3QgbmVlZGVkLlxuICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL3VuZGljaS9wdWxsLzMwOTMjaXNzdWVjb21tZW50LTIwNTAxOTg1NDFcblxuICAgIC8vIDEuIExldCB0cmFuc2Zvcm1TdHJlYW0gYmUgYSBuZXcgVHJhbnNmb3JtU3RyZWFtLlxuICAgIC8vIDIuIExldCBpZGVudGl0eVRyYW5zZm9ybUFsZ29yaXRobSBiZSBhbiBhbGdvcml0aG0gd2hpY2gsIGdpdmVuIGNodW5rLCBlbnF1ZXVlcyBjaHVuayBpbiB0cmFuc2Zvcm1TdHJlYW0uXG4gICAgLy8gMy4gU2V0IHVwIHRyYW5zZm9ybVN0cmVhbSB3aXRoIHRyYW5zZm9ybUFsZ29yaXRobSBzZXQgdG8gaWRlbnRpdHlUcmFuc2Zvcm1BbGdvcml0aG0gYW5kIGZsdXNoQWxnb3JpdGhtXG4gICAgLy8gICAgc2V0IHRvIHByb2Nlc3NSZXNwb25zZUVuZE9mQm9keS5cbiAgICAvLyA0LiBTZXQgaW50ZXJuYWxSZXNwb25zZeKAmXMgYm9keeKAmXMgc3RyZWFtIHRvIHRoZSByZXN1bHQgb2YgaW50ZXJuYWxSZXNwb25zZeKAmXMgYm9keeKAmXMgc3RyZWFtIHBpcGVkIHRocm91Z2ggdHJhbnNmb3JtU3RyZWFtLlxuXG4gICAgZmluaXNoZWQoaW50ZXJuYWxSZXNwb25zZS5ib2R5LnN0cmVhbSwgKCkgPT4ge1xuICAgICAgcHJvY2Vzc1Jlc3BvbnNlRW5kT2ZCb2R5KClcbiAgICB9KVxuICB9XG59XG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNodHRwLWZldGNoXG5hc3luYyBmdW5jdGlvbiBodHRwRmV0Y2ggKGZldGNoUGFyYW1zKSB7XG4gIC8vIDEuIExldCByZXF1ZXN0IGJlIGZldGNoUGFyYW1z4oCZcyByZXF1ZXN0LlxuICBjb25zdCByZXF1ZXN0ID0gZmV0Y2hQYXJhbXMucmVxdWVzdFxuXG4gIC8vIDIuIExldCByZXNwb25zZSBiZSBudWxsLlxuICBsZXQgcmVzcG9uc2UgPSBudWxsXG5cbiAgLy8gMy4gTGV0IGFjdHVhbFJlc3BvbnNlIGJlIG51bGwuXG4gIGxldCBhY3R1YWxSZXNwb25zZSA9IG51bGxcblxuICAvLyA0LiBMZXQgdGltaW5nSW5mbyBiZSBmZXRjaFBhcmFtc+KAmXMgdGltaW5nIGluZm8uXG4gIGNvbnN0IHRpbWluZ0luZm8gPSBmZXRjaFBhcmFtcy50aW1pbmdJbmZvXG5cbiAgLy8gNS4gSWYgcmVxdWVzdOKAmXMgc2VydmljZS13b3JrZXJzIG1vZGUgaXMgXCJhbGxcIiwgdGhlbjpcbiAgaWYgKHJlcXVlc3Quc2VydmljZVdvcmtlcnMgPT09ICdhbGwnKSB7XG4gICAgLy8gVE9ET1xuICB9XG5cbiAgLy8gNi4gSWYgcmVzcG9uc2UgaXMgbnVsbCwgdGhlbjpcbiAgaWYgKHJlc3BvbnNlID09PSBudWxsKSB7XG4gICAgLy8gMS4gSWYgbWFrZUNPUlNQcmVmbGlnaHQgaXMgdHJ1ZSBhbmQgb25lIG9mIHRoZXNlIGNvbmRpdGlvbnMgaXMgdHJ1ZTpcbiAgICAvLyBUT0RPXG5cbiAgICAvLyAyLiBJZiByZXF1ZXN04oCZcyByZWRpcmVjdCBtb2RlIGlzIFwiZm9sbG93XCIsIHRoZW4gc2V0IHJlcXVlc3TigJlzXG4gICAgLy8gc2VydmljZS13b3JrZXJzIG1vZGUgdG8gXCJub25lXCIuXG4gICAgaWYgKHJlcXVlc3QucmVkaXJlY3QgPT09ICdmb2xsb3cnKSB7XG4gICAgICByZXF1ZXN0LnNlcnZpY2VXb3JrZXJzID0gJ25vbmUnXG4gICAgfVxuXG4gICAgLy8gMy4gU2V0IHJlc3BvbnNlIGFuZCBhY3R1YWxSZXNwb25zZSB0byB0aGUgcmVzdWx0IG9mIHJ1bm5pbmdcbiAgICAvLyBIVFRQLW5ldHdvcmstb3ItY2FjaGUgZmV0Y2ggZ2l2ZW4gZmV0Y2hQYXJhbXMuXG4gICAgYWN0dWFsUmVzcG9uc2UgPSByZXNwb25zZSA9IGF3YWl0IGh0dHBOZXR3b3JrT3JDYWNoZUZldGNoKGZldGNoUGFyYW1zKVxuXG4gICAgLy8gNC4gSWYgcmVxdWVzdOKAmXMgcmVzcG9uc2UgdGFpbnRpbmcgaXMgXCJjb3JzXCIgYW5kIGEgQ09SUyBjaGVja1xuICAgIC8vIGZvciByZXF1ZXN0IGFuZCByZXNwb25zZSByZXR1cm5zIGZhaWx1cmUsIHRoZW4gcmV0dXJuIGEgbmV0d29yayBlcnJvci5cbiAgICBpZiAoXG4gICAgICByZXF1ZXN0LnJlc3BvbnNlVGFpbnRpbmcgPT09ICdjb3JzJyAmJlxuICAgICAgY29yc0NoZWNrKHJlcXVlc3QsIHJlc3BvbnNlKSA9PT0gJ2ZhaWx1cmUnXG4gICAgKSB7XG4gICAgICByZXR1cm4gbWFrZU5ldHdvcmtFcnJvcignY29ycyBmYWlsdXJlJylcbiAgICB9XG5cbiAgICAvLyA1LiBJZiB0aGUgVEFPIGNoZWNrIGZvciByZXF1ZXN0IGFuZCByZXNwb25zZSByZXR1cm5zIGZhaWx1cmUsIHRoZW4gc2V0XG4gICAgLy8gcmVxdWVzdOKAmXMgdGltaW5nIGFsbG93IGZhaWxlZCBmbGFnLlxuICAgIGlmIChUQU9DaGVjayhyZXF1ZXN0LCByZXNwb25zZSkgPT09ICdmYWlsdXJlJykge1xuICAgICAgcmVxdWVzdC50aW1pbmdBbGxvd0ZhaWxlZCA9IHRydWVcbiAgICB9XG4gIH1cblxuICAvLyA3LiBJZiBlaXRoZXIgcmVxdWVzdOKAmXMgcmVzcG9uc2UgdGFpbnRpbmcgb3IgcmVzcG9uc2XigJlzIHR5cGVcbiAgLy8gaXMgXCJvcGFxdWVcIiwgYW5kIHRoZSBjcm9zcy1vcmlnaW4gcmVzb3VyY2UgcG9saWN5IGNoZWNrIHdpdGhcbiAgLy8gcmVxdWVzdOKAmXMgb3JpZ2luLCByZXF1ZXN04oCZcyBjbGllbnQsIHJlcXVlc3TigJlzIGRlc3RpbmF0aW9uLFxuICAvLyBhbmQgYWN0dWFsUmVzcG9uc2UgcmV0dXJucyBibG9ja2VkLCB0aGVuIHJldHVybiBhIG5ldHdvcmsgZXJyb3IuXG4gIGlmIChcbiAgICAocmVxdWVzdC5yZXNwb25zZVRhaW50aW5nID09PSAnb3BhcXVlJyB8fCByZXNwb25zZS50eXBlID09PSAnb3BhcXVlJykgJiZcbiAgICBjcm9zc09yaWdpblJlc291cmNlUG9saWN5Q2hlY2soXG4gICAgICByZXF1ZXN0Lm9yaWdpbixcbiAgICAgIHJlcXVlc3QuY2xpZW50LFxuICAgICAgcmVxdWVzdC5kZXN0aW5hdGlvbixcbiAgICAgIGFjdHVhbFJlc3BvbnNlXG4gICAgKSA9PT0gJ2Jsb2NrZWQnXG4gICkge1xuICAgIHJldHVybiBtYWtlTmV0d29ya0Vycm9yKCdibG9ja2VkJylcbiAgfVxuXG4gIC8vIDguIElmIGFjdHVhbFJlc3BvbnNl4oCZcyBzdGF0dXMgaXMgYSByZWRpcmVjdCBzdGF0dXMsIHRoZW46XG4gIGlmIChyZWRpcmVjdFN0YXR1c1NldC5oYXMoYWN0dWFsUmVzcG9uc2Uuc3RhdHVzKSkge1xuICAgIC8vIDEuIElmIGFjdHVhbFJlc3BvbnNl4oCZcyBzdGF0dXMgaXMgbm90IDMwMywgcmVxdWVzdOKAmXMgYm9keSBpcyBub3QgbnVsbCxcbiAgICAvLyBhbmQgdGhlIGNvbm5lY3Rpb24gdXNlcyBIVFRQLzIsIHRoZW4gdXNlciBhZ2VudHMgbWF5LCBhbmQgYXJlIGV2ZW5cbiAgICAvLyBlbmNvdXJhZ2VkIHRvLCB0cmFuc21pdCBhbiBSU1RfU1RSRUFNIGZyYW1lLlxuICAgIC8vIFNlZSwgaHR0cHM6Ly9naXRodWIuY29tL3doYXR3Zy9mZXRjaC9pc3N1ZXMvMTI4OFxuICAgIGlmIChyZXF1ZXN0LnJlZGlyZWN0ICE9PSAnbWFudWFsJykge1xuICAgICAgZmV0Y2hQYXJhbXMuY29udHJvbGxlci5jb25uZWN0aW9uLmRlc3Ryb3kodW5kZWZpbmVkLCBmYWxzZSlcbiAgICB9XG5cbiAgICAvLyAyLiBTd2l0Y2ggb24gcmVxdWVzdOKAmXMgcmVkaXJlY3QgbW9kZTpcbiAgICBpZiAocmVxdWVzdC5yZWRpcmVjdCA9PT0gJ2Vycm9yJykge1xuICAgICAgLy8gU2V0IHJlc3BvbnNlIHRvIGEgbmV0d29yayBlcnJvci5cbiAgICAgIHJlc3BvbnNlID0gbWFrZU5ldHdvcmtFcnJvcigndW5leHBlY3RlZCByZWRpcmVjdCcpXG4gICAgfSBlbHNlIGlmIChyZXF1ZXN0LnJlZGlyZWN0ID09PSAnbWFudWFsJykge1xuICAgICAgLy8gU2V0IHJlc3BvbnNlIHRvIGFuIG9wYXF1ZS1yZWRpcmVjdCBmaWx0ZXJlZCByZXNwb25zZSB3aG9zZSBpbnRlcm5hbFxuICAgICAgLy8gcmVzcG9uc2UgaXMgYWN0dWFsUmVzcG9uc2UuXG4gICAgICAvLyBOT1RFKHNwZWMpOiBPbiB0aGUgd2ViIHRoaXMgd291bGQgcmV0dXJuIGFuIGBvcGFxdWVyZWRpcmVjdGAgcmVzcG9uc2UsXG4gICAgICAvLyBidXQgdGhhdCBkb2Vzbid0IG1ha2Ugc2Vuc2Ugc2VydmVyIHNpZGUuXG4gICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy91bmRpY2kvaXNzdWVzLzExOTMuXG4gICAgICByZXNwb25zZSA9IGFjdHVhbFJlc3BvbnNlXG4gICAgfSBlbHNlIGlmIChyZXF1ZXN0LnJlZGlyZWN0ID09PSAnZm9sbG93Jykge1xuICAgICAgLy8gU2V0IHJlc3BvbnNlIHRvIHRoZSByZXN1bHQgb2YgcnVubmluZyBIVFRQLXJlZGlyZWN0IGZldGNoIGdpdmVuXG4gICAgICAvLyBmZXRjaFBhcmFtcyBhbmQgcmVzcG9uc2UuXG4gICAgICByZXNwb25zZSA9IGF3YWl0IGh0dHBSZWRpcmVjdEZldGNoKGZldGNoUGFyYW1zLCByZXNwb25zZSlcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzZXJ0KGZhbHNlKVxuICAgIH1cbiAgfVxuXG4gIC8vIDkuIFNldCByZXNwb25zZeKAmXMgdGltaW5nIGluZm8gdG8gdGltaW5nSW5mby5cbiAgcmVzcG9uc2UudGltaW5nSW5mbyA9IHRpbWluZ0luZm9cblxuICAvLyAxMC4gUmV0dXJuIHJlc3BvbnNlLlxuICByZXR1cm4gcmVzcG9uc2Vcbn1cblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2h0dHAtcmVkaXJlY3QtZmV0Y2hcbmZ1bmN0aW9uIGh0dHBSZWRpcmVjdEZldGNoIChmZXRjaFBhcmFtcywgcmVzcG9uc2UpIHtcbiAgLy8gMS4gTGV0IHJlcXVlc3QgYmUgZmV0Y2hQYXJhbXPigJlzIHJlcXVlc3QuXG4gIGNvbnN0IHJlcXVlc3QgPSBmZXRjaFBhcmFtcy5yZXF1ZXN0XG5cbiAgLy8gMi4gTGV0IGFjdHVhbFJlc3BvbnNlIGJlIHJlc3BvbnNlLCBpZiByZXNwb25zZSBpcyBub3QgYSBmaWx0ZXJlZCByZXNwb25zZSxcbiAgLy8gYW5kIHJlc3BvbnNl4oCZcyBpbnRlcm5hbCByZXNwb25zZSBvdGhlcndpc2UuXG4gIGNvbnN0IGFjdHVhbFJlc3BvbnNlID0gcmVzcG9uc2UuaW50ZXJuYWxSZXNwb25zZVxuICAgID8gcmVzcG9uc2UuaW50ZXJuYWxSZXNwb25zZVxuICAgIDogcmVzcG9uc2VcblxuICAvLyAzLiBMZXQgbG9jYXRpb25VUkwgYmUgYWN0dWFsUmVzcG9uc2XigJlzIGxvY2F0aW9uIFVSTCBnaXZlbiByZXF1ZXN04oCZcyBjdXJyZW50XG4gIC8vIFVSTOKAmXMgZnJhZ21lbnQuXG4gIGxldCBsb2NhdGlvblVSTFxuXG4gIHRyeSB7XG4gICAgbG9jYXRpb25VUkwgPSByZXNwb25zZUxvY2F0aW9uVVJMKFxuICAgICAgYWN0dWFsUmVzcG9uc2UsXG4gICAgICByZXF1ZXN0Q3VycmVudFVSTChyZXF1ZXN0KS5oYXNoXG4gICAgKVxuXG4gICAgLy8gNC4gSWYgbG9jYXRpb25VUkwgaXMgbnVsbCwgdGhlbiByZXR1cm4gcmVzcG9uc2UuXG4gICAgaWYgKGxvY2F0aW9uVVJMID09IG51bGwpIHtcbiAgICAgIHJldHVybiByZXNwb25zZVxuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgLy8gNS4gSWYgbG9jYXRpb25VUkwgaXMgZmFpbHVyZSwgdGhlbiByZXR1cm4gYSBuZXR3b3JrIGVycm9yLlxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobWFrZU5ldHdvcmtFcnJvcihlcnIpKVxuICB9XG5cbiAgLy8gNi4gSWYgbG9jYXRpb25VUkzigJlzIHNjaGVtZSBpcyBub3QgYW4gSFRUUChTKSBzY2hlbWUsIHRoZW4gcmV0dXJuIGEgbmV0d29ya1xuICAvLyBlcnJvci5cbiAgaWYgKCF1cmxJc0h0dHBIdHRwc1NjaGVtZShsb2NhdGlvblVSTCkpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG1ha2VOZXR3b3JrRXJyb3IoJ1VSTCBzY2hlbWUgbXVzdCBiZSBhIEhUVFAoUykgc2NoZW1lJykpXG4gIH1cblxuICAvLyA3LiBJZiByZXF1ZXN04oCZcyByZWRpcmVjdCBjb3VudCBpcyAyMCwgdGhlbiByZXR1cm4gYSBuZXR3b3JrIGVycm9yLlxuICBpZiAocmVxdWVzdC5yZWRpcmVjdENvdW50ID09PSAyMCkge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobWFrZU5ldHdvcmtFcnJvcigncmVkaXJlY3QgY291bnQgZXhjZWVkZWQnKSlcbiAgfVxuXG4gIC8vIDguIEluY3JlYXNlIHJlcXVlc3TigJlzIHJlZGlyZWN0IGNvdW50IGJ5IDEuXG4gIHJlcXVlc3QucmVkaXJlY3RDb3VudCArPSAxXG5cbiAgLy8gOS4gSWYgcmVxdWVzdOKAmXMgbW9kZSBpcyBcImNvcnNcIiwgbG9jYXRpb25VUkwgaW5jbHVkZXMgY3JlZGVudGlhbHMsIGFuZFxuICAvLyByZXF1ZXN04oCZcyBvcmlnaW4gaXMgbm90IHNhbWUgb3JpZ2luIHdpdGggbG9jYXRpb25VUkzigJlzIG9yaWdpbiwgdGhlbiByZXR1cm5cbiAgLy8gIGEgbmV0d29yayBlcnJvci5cbiAgaWYgKFxuICAgIHJlcXVlc3QubW9kZSA9PT0gJ2NvcnMnICYmXG4gICAgKGxvY2F0aW9uVVJMLnVzZXJuYW1lIHx8IGxvY2F0aW9uVVJMLnBhc3N3b3JkKSAmJlxuICAgICFzYW1lT3JpZ2luKHJlcXVlc3QsIGxvY2F0aW9uVVJMKVxuICApIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG1ha2VOZXR3b3JrRXJyb3IoJ2Nyb3NzIG9yaWdpbiBub3QgYWxsb3dlZCBmb3IgcmVxdWVzdCBtb2RlIFwiY29yc1wiJykpXG4gIH1cblxuICAvLyAxMC4gSWYgcmVxdWVzdOKAmXMgcmVzcG9uc2UgdGFpbnRpbmcgaXMgXCJjb3JzXCIgYW5kIGxvY2F0aW9uVVJMIGluY2x1ZGVzXG4gIC8vIGNyZWRlbnRpYWxzLCB0aGVuIHJldHVybiBhIG5ldHdvcmsgZXJyb3IuXG4gIGlmIChcbiAgICByZXF1ZXN0LnJlc3BvbnNlVGFpbnRpbmcgPT09ICdjb3JzJyAmJlxuICAgIChsb2NhdGlvblVSTC51c2VybmFtZSB8fCBsb2NhdGlvblVSTC5wYXNzd29yZClcbiAgKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShtYWtlTmV0d29ya0Vycm9yKFxuICAgICAgJ1VSTCBjYW5ub3QgY29udGFpbiBjcmVkZW50aWFscyBmb3IgcmVxdWVzdCBtb2RlIFwiY29yc1wiJ1xuICAgICkpXG4gIH1cblxuICAvLyAxMS4gSWYgYWN0dWFsUmVzcG9uc2XigJlzIHN0YXR1cyBpcyBub3QgMzAzLCByZXF1ZXN04oCZcyBib2R5IGlzIG5vbi1udWxsLFxuICAvLyBhbmQgcmVxdWVzdOKAmXMgYm9keeKAmXMgc291cmNlIGlzIG51bGwsIHRoZW4gcmV0dXJuIGEgbmV0d29yayBlcnJvci5cbiAgaWYgKFxuICAgIGFjdHVhbFJlc3BvbnNlLnN0YXR1cyAhPT0gMzAzICYmXG4gICAgcmVxdWVzdC5ib2R5ICE9IG51bGwgJiZcbiAgICByZXF1ZXN0LmJvZHkuc291cmNlID09IG51bGxcbiAgKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShtYWtlTmV0d29ya0Vycm9yKCkpXG4gIH1cblxuICAvLyAxMi4gSWYgb25lIG9mIHRoZSBmb2xsb3dpbmcgaXMgdHJ1ZVxuICAvLyAtIGFjdHVhbFJlc3BvbnNl4oCZcyBzdGF0dXMgaXMgMzAxIG9yIDMwMiBhbmQgcmVxdWVzdOKAmXMgbWV0aG9kIGlzIGBQT1NUYFxuICAvLyAtIGFjdHVhbFJlc3BvbnNl4oCZcyBzdGF0dXMgaXMgMzAzIGFuZCByZXF1ZXN04oCZcyBtZXRob2QgaXMgbm90IGBHRVRgIG9yIGBIRUFEYFxuICBpZiAoXG4gICAgKFszMDEsIDMwMl0uaW5jbHVkZXMoYWN0dWFsUmVzcG9uc2Uuc3RhdHVzKSAmJiByZXF1ZXN0Lm1ldGhvZCA9PT0gJ1BPU1QnKSB8fFxuICAgIChhY3R1YWxSZXNwb25zZS5zdGF0dXMgPT09IDMwMyAmJlxuICAgICAgIUdFVF9PUl9IRUFELmluY2x1ZGVzKHJlcXVlc3QubWV0aG9kKSlcbiAgKSB7XG4gICAgLy8gdGhlbjpcbiAgICAvLyAxLiBTZXQgcmVxdWVzdOKAmXMgbWV0aG9kIHRvIGBHRVRgIGFuZCByZXF1ZXN04oCZcyBib2R5IHRvIG51bGwuXG4gICAgcmVxdWVzdC5tZXRob2QgPSAnR0VUJ1xuICAgIHJlcXVlc3QuYm9keSA9IG51bGxcblxuICAgIC8vIDIuIEZvciBlYWNoIGhlYWRlck5hbWUgb2YgcmVxdWVzdC1ib2R5LWhlYWRlciBuYW1lLCBkZWxldGUgaGVhZGVyTmFtZSBmcm9tXG4gICAgLy8gcmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QuXG4gICAgZm9yIChjb25zdCBoZWFkZXJOYW1lIG9mIHJlcXVlc3RCb2R5SGVhZGVyKSB7XG4gICAgICByZXF1ZXN0LmhlYWRlcnNMaXN0LmRlbGV0ZShoZWFkZXJOYW1lKVxuICAgIH1cbiAgfVxuXG4gIC8vIDEzLiBJZiByZXF1ZXN04oCZcyBjdXJyZW50IFVSTOKAmXMgb3JpZ2luIGlzIG5vdCBzYW1lIG9yaWdpbiB3aXRoIGxvY2F0aW9uVVJM4oCZc1xuICAvLyAgICAgb3JpZ2luLCB0aGVuIGZvciBlYWNoIGhlYWRlck5hbWUgb2YgQ09SUyBub24td2lsZGNhcmQgcmVxdWVzdC1oZWFkZXIgbmFtZSxcbiAgLy8gICAgIGRlbGV0ZSBoZWFkZXJOYW1lIGZyb20gcmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QuXG4gIGlmICghc2FtZU9yaWdpbihyZXF1ZXN0Q3VycmVudFVSTChyZXF1ZXN0KSwgbG9jYXRpb25VUkwpKSB7XG4gICAgLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvcnMtbm9uLXdpbGRjYXJkLXJlcXVlc3QtaGVhZGVyLW5hbWVcbiAgICByZXF1ZXN0LmhlYWRlcnNMaXN0LmRlbGV0ZSgnYXV0aG9yaXphdGlvbicsIHRydWUpXG5cbiAgICAvLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jYXV0aGVudGljYXRpb24tZW50cmllc1xuICAgIHJlcXVlc3QuaGVhZGVyc0xpc3QuZGVsZXRlKCdwcm94eS1hdXRob3JpemF0aW9uJywgdHJ1ZSlcblxuICAgIC8vIFwiQ29va2llXCIgYW5kIFwiSG9zdFwiIGFyZSBmb3JiaWRkZW4gcmVxdWVzdC1oZWFkZXJzLCB3aGljaCB1bmRpY2kgZG9lc24ndCBpbXBsZW1lbnQuXG4gICAgcmVxdWVzdC5oZWFkZXJzTGlzdC5kZWxldGUoJ2Nvb2tpZScsIHRydWUpXG4gICAgcmVxdWVzdC5oZWFkZXJzTGlzdC5kZWxldGUoJ2hvc3QnLCB0cnVlKVxuICB9XG5cbiAgLy8gMTQuIElmIHJlcXVlc3TigJlzIGJvZHkgaXMgbm9uLW51bGwsIHRoZW4gc2V0IHJlcXVlc3TigJlzIGJvZHkgdG8gdGhlIGZpcnN0IHJldHVyblxuICAvLyB2YWx1ZSBvZiBzYWZlbHkgZXh0cmFjdGluZyByZXF1ZXN04oCZcyBib2R54oCZcyBzb3VyY2UuXG4gIGlmIChyZXF1ZXN0LmJvZHkgIT0gbnVsbCkge1xuICAgIGFzc2VydChyZXF1ZXN0LmJvZHkuc291cmNlICE9IG51bGwpXG4gICAgcmVxdWVzdC5ib2R5ID0gc2FmZWx5RXh0cmFjdEJvZHkocmVxdWVzdC5ib2R5LnNvdXJjZSlbMF1cbiAgfVxuXG4gIC8vIDE1LiBMZXQgdGltaW5nSW5mbyBiZSBmZXRjaFBhcmFtc+KAmXMgdGltaW5nIGluZm8uXG4gIGNvbnN0IHRpbWluZ0luZm8gPSBmZXRjaFBhcmFtcy50aW1pbmdJbmZvXG5cbiAgLy8gMTYuIFNldCB0aW1pbmdJbmZv4oCZcyByZWRpcmVjdCBlbmQgdGltZSBhbmQgcG9zdC1yZWRpcmVjdCBzdGFydCB0aW1lIHRvIHRoZVxuICAvLyBjb2Fyc2VuZWQgc2hhcmVkIGN1cnJlbnQgdGltZSBnaXZlbiBmZXRjaFBhcmFtc+KAmXMgY3Jvc3Mtb3JpZ2luIGlzb2xhdGVkXG4gIC8vIGNhcGFiaWxpdHkuXG4gIHRpbWluZ0luZm8ucmVkaXJlY3RFbmRUaW1lID0gdGltaW5nSW5mby5wb3N0UmVkaXJlY3RTdGFydFRpbWUgPVxuICAgIGNvYXJzZW5lZFNoYXJlZEN1cnJlbnRUaW1lKGZldGNoUGFyYW1zLmNyb3NzT3JpZ2luSXNvbGF0ZWRDYXBhYmlsaXR5KVxuXG4gIC8vIDE3LiBJZiB0aW1pbmdJbmZv4oCZcyByZWRpcmVjdCBzdGFydCB0aW1lIGlzIDAsIHRoZW4gc2V0IHRpbWluZ0luZm/igJlzXG4gIC8vICByZWRpcmVjdCBzdGFydCB0aW1lIHRvIHRpbWluZ0luZm/igJlzIHN0YXJ0IHRpbWUuXG4gIGlmICh0aW1pbmdJbmZvLnJlZGlyZWN0U3RhcnRUaW1lID09PSAwKSB7XG4gICAgdGltaW5nSW5mby5yZWRpcmVjdFN0YXJ0VGltZSA9IHRpbWluZ0luZm8uc3RhcnRUaW1lXG4gIH1cblxuICAvLyAxOC4gQXBwZW5kIGxvY2F0aW9uVVJMIHRvIHJlcXVlc3TigJlzIFVSTCBsaXN0LlxuICByZXF1ZXN0LnVybExpc3QucHVzaChsb2NhdGlvblVSTClcblxuICAvLyAxOS4gSW52b2tlIHNldCByZXF1ZXN04oCZcyByZWZlcnJlciBwb2xpY3kgb24gcmVkaXJlY3Qgb24gcmVxdWVzdCBhbmRcbiAgLy8gYWN0dWFsUmVzcG9uc2UuXG4gIHNldFJlcXVlc3RSZWZlcnJlclBvbGljeU9uUmVkaXJlY3QocmVxdWVzdCwgYWN0dWFsUmVzcG9uc2UpXG5cbiAgLy8gMjAuIFJldHVybiB0aGUgcmVzdWx0IG9mIHJ1bm5pbmcgbWFpbiBmZXRjaCBnaXZlbiBmZXRjaFBhcmFtcyBhbmQgdHJ1ZS5cbiAgcmV0dXJuIG1haW5GZXRjaChmZXRjaFBhcmFtcywgdHJ1ZSlcbn1cblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2h0dHAtbmV0d29yay1vci1jYWNoZS1mZXRjaFxuYXN5bmMgZnVuY3Rpb24gaHR0cE5ldHdvcmtPckNhY2hlRmV0Y2ggKFxuICBmZXRjaFBhcmFtcyxcbiAgaXNBdXRoZW50aWNhdGlvbkZldGNoID0gZmFsc2UsXG4gIGlzTmV3Q29ubmVjdGlvbkZldGNoID0gZmFsc2Vcbikge1xuICAvLyAxLiBMZXQgcmVxdWVzdCBiZSBmZXRjaFBhcmFtc+KAmXMgcmVxdWVzdC5cbiAgY29uc3QgcmVxdWVzdCA9IGZldGNoUGFyYW1zLnJlcXVlc3RcblxuICAvLyAyLiBMZXQgaHR0cEZldGNoUGFyYW1zIGJlIG51bGwuXG4gIGxldCBodHRwRmV0Y2hQYXJhbXMgPSBudWxsXG5cbiAgLy8gMy4gTGV0IGh0dHBSZXF1ZXN0IGJlIG51bGwuXG4gIGxldCBodHRwUmVxdWVzdCA9IG51bGxcblxuICAvLyA0LiBMZXQgcmVzcG9uc2UgYmUgbnVsbC5cbiAgbGV0IHJlc3BvbnNlID0gbnVsbFxuXG4gIC8vIDUuIExldCBzdG9yZWRSZXNwb25zZSBiZSBudWxsLlxuICAvLyBUT0RPOiBjYWNoZVxuXG4gIC8vIDYuIExldCBodHRwQ2FjaGUgYmUgbnVsbC5cbiAgY29uc3QgaHR0cENhY2hlID0gbnVsbFxuXG4gIC8vIDcuIExldCB0aGUgcmV2YWxpZGF0aW5nRmxhZyBiZSB1bnNldC5cbiAgY29uc3QgcmV2YWxpZGF0aW5nRmxhZyA9IGZhbHNlXG5cbiAgLy8gOC4gUnVuIHRoZXNlIHN0ZXBzLCBidXQgYWJvcnQgd2hlbiB0aGUgb25nb2luZyBmZXRjaCBpcyB0ZXJtaW5hdGVkOlxuXG4gIC8vICAgIDEuIElmIHJlcXVlc3TigJlzIHdpbmRvdyBpcyBcIm5vLXdpbmRvd1wiIGFuZCByZXF1ZXN04oCZcyByZWRpcmVjdCBtb2RlIGlzXG4gIC8vICAgIFwiZXJyb3JcIiwgdGhlbiBzZXQgaHR0cEZldGNoUGFyYW1zIHRvIGZldGNoUGFyYW1zIGFuZCBodHRwUmVxdWVzdCB0b1xuICAvLyAgICByZXF1ZXN0LlxuICBpZiAocmVxdWVzdC53aW5kb3cgPT09ICduby13aW5kb3cnICYmIHJlcXVlc3QucmVkaXJlY3QgPT09ICdlcnJvcicpIHtcbiAgICBodHRwRmV0Y2hQYXJhbXMgPSBmZXRjaFBhcmFtc1xuICAgIGh0dHBSZXF1ZXN0ID0gcmVxdWVzdFxuICB9IGVsc2Uge1xuICAgIC8vIE90aGVyd2lzZTpcblxuICAgIC8vIDEuIFNldCBodHRwUmVxdWVzdCB0byBhIGNsb25lIG9mIHJlcXVlc3QuXG4gICAgaHR0cFJlcXVlc3QgPSBjbG9uZVJlcXVlc3QocmVxdWVzdClcblxuICAgIC8vIDIuIFNldCBodHRwRmV0Y2hQYXJhbXMgdG8gYSBjb3B5IG9mIGZldGNoUGFyYW1zLlxuICAgIGh0dHBGZXRjaFBhcmFtcyA9IHsgLi4uZmV0Y2hQYXJhbXMgfVxuXG4gICAgLy8gMy4gU2V0IGh0dHBGZXRjaFBhcmFtc+KAmXMgcmVxdWVzdCB0byBodHRwUmVxdWVzdC5cbiAgICBodHRwRmV0Y2hQYXJhbXMucmVxdWVzdCA9IGh0dHBSZXF1ZXN0XG4gIH1cblxuICAvLyAgICAzLiBMZXQgaW5jbHVkZUNyZWRlbnRpYWxzIGJlIHRydWUgaWYgb25lIG9mXG4gIGNvbnN0IGluY2x1ZGVDcmVkZW50aWFscyA9XG4gICAgcmVxdWVzdC5jcmVkZW50aWFscyA9PT0gJ2luY2x1ZGUnIHx8XG4gICAgKHJlcXVlc3QuY3JlZGVudGlhbHMgPT09ICdzYW1lLW9yaWdpbicgJiZcbiAgICAgIHJlcXVlc3QucmVzcG9uc2VUYWludGluZyA9PT0gJ2Jhc2ljJylcblxuICAvLyAgICA0LiBMZXQgY29udGVudExlbmd0aCBiZSBodHRwUmVxdWVzdOKAmXMgYm9keeKAmXMgbGVuZ3RoLCBpZiBodHRwUmVxdWVzdOKAmXNcbiAgLy8gICAgYm9keSBpcyBub24tbnVsbDsgb3RoZXJ3aXNlIG51bGwuXG4gIGNvbnN0IGNvbnRlbnRMZW5ndGggPSBodHRwUmVxdWVzdC5ib2R5ID8gaHR0cFJlcXVlc3QuYm9keS5sZW5ndGggOiBudWxsXG5cbiAgLy8gICAgNS4gTGV0IGNvbnRlbnRMZW5ndGhIZWFkZXJWYWx1ZSBiZSBudWxsLlxuICBsZXQgY29udGVudExlbmd0aEhlYWRlclZhbHVlID0gbnVsbFxuXG4gIC8vICAgIDYuIElmIGh0dHBSZXF1ZXN04oCZcyBib2R5IGlzIG51bGwgYW5kIGh0dHBSZXF1ZXN04oCZcyBtZXRob2QgaXMgYFBPU1RgIG9yXG4gIC8vICAgIGBQVVRgLCB0aGVuIHNldCBjb250ZW50TGVuZ3RoSGVhZGVyVmFsdWUgdG8gYDBgLlxuICBpZiAoXG4gICAgaHR0cFJlcXVlc3QuYm9keSA9PSBudWxsICYmXG4gICAgWydQT1NUJywgJ1BVVCddLmluY2x1ZGVzKGh0dHBSZXF1ZXN0Lm1ldGhvZClcbiAgKSB7XG4gICAgY29udGVudExlbmd0aEhlYWRlclZhbHVlID0gJzAnXG4gIH1cblxuICAvLyAgICA3LiBJZiBjb250ZW50TGVuZ3RoIGlzIG5vbi1udWxsLCB0aGVuIHNldCBjb250ZW50TGVuZ3RoSGVhZGVyVmFsdWUgdG9cbiAgLy8gICAgY29udGVudExlbmd0aCwgc2VyaWFsaXplZCBhbmQgaXNvbW9ycGhpYyBlbmNvZGVkLlxuICBpZiAoY29udGVudExlbmd0aCAhPSBudWxsKSB7XG4gICAgY29udGVudExlbmd0aEhlYWRlclZhbHVlID0gaXNvbW9ycGhpY0VuY29kZShgJHtjb250ZW50TGVuZ3RofWApXG4gIH1cblxuICAvLyAgICA4LiBJZiBjb250ZW50TGVuZ3RoSGVhZGVyVmFsdWUgaXMgbm9uLW51bGwsIHRoZW4gYXBwZW5kXG4gIC8vICAgIGBDb250ZW50LUxlbmd0aGAvY29udGVudExlbmd0aEhlYWRlclZhbHVlIHRvIGh0dHBSZXF1ZXN04oCZcyBoZWFkZXJcbiAgLy8gICAgbGlzdC5cbiAgaWYgKGNvbnRlbnRMZW5ndGhIZWFkZXJWYWx1ZSAhPSBudWxsKSB7XG4gICAgaHR0cFJlcXVlc3QuaGVhZGVyc0xpc3QuYXBwZW5kKCdjb250ZW50LWxlbmd0aCcsIGNvbnRlbnRMZW5ndGhIZWFkZXJWYWx1ZSwgdHJ1ZSlcbiAgfVxuXG4gIC8vICAgIDkuIElmIGNvbnRlbnRMZW5ndGhIZWFkZXJWYWx1ZSBpcyBub24tbnVsbCwgdGhlbiBhcHBlbmQgKGBDb250ZW50LUxlbmd0aGAsXG4gIC8vICAgIGNvbnRlbnRMZW5ndGhIZWFkZXJWYWx1ZSkgdG8gaHR0cFJlcXVlc3TigJlzIGhlYWRlciBsaXN0LlxuXG4gIC8vICAgIDEwLiBJZiBjb250ZW50TGVuZ3RoIGlzIG5vbi1udWxsIGFuZCBodHRwUmVxdWVzdOKAmXMga2VlcGFsaXZlIGlzIHRydWUsXG4gIC8vICAgIHRoZW46XG4gIGlmIChjb250ZW50TGVuZ3RoICE9IG51bGwgJiYgaHR0cFJlcXVlc3Qua2VlcGFsaXZlKSB7XG4gICAgLy8gTk9URToga2VlcGFsaXZlIGlzIGEgbm9vcCBvdXRzaWRlIG9mIGJyb3dzZXIgY29udGV4dC5cbiAgfVxuXG4gIC8vICAgIDExLiBJZiBodHRwUmVxdWVzdOKAmXMgcmVmZXJyZXIgaXMgYSBVUkwsIHRoZW4gYXBwZW5kXG4gIC8vICAgIGBSZWZlcmVyYC9odHRwUmVxdWVzdOKAmXMgcmVmZXJyZXIsIHNlcmlhbGl6ZWQgYW5kIGlzb21vcnBoaWMgZW5jb2RlZCxcbiAgLy8gICAgIHRvIGh0dHBSZXF1ZXN04oCZcyBoZWFkZXIgbGlzdC5cbiAgaWYgKGh0dHBSZXF1ZXN0LnJlZmVycmVyIGluc3RhbmNlb2YgVVJMKSB7XG4gICAgaHR0cFJlcXVlc3QuaGVhZGVyc0xpc3QuYXBwZW5kKCdyZWZlcmVyJywgaXNvbW9ycGhpY0VuY29kZShodHRwUmVxdWVzdC5yZWZlcnJlci5ocmVmKSwgdHJ1ZSlcbiAgfVxuXG4gIC8vICAgIDEyLiBBcHBlbmQgYSByZXF1ZXN0IGBPcmlnaW5gIGhlYWRlciBmb3IgaHR0cFJlcXVlc3QuXG4gIGFwcGVuZFJlcXVlc3RPcmlnaW5IZWFkZXIoaHR0cFJlcXVlc3QpXG5cbiAgLy8gICAgMTMuIEFwcGVuZCB0aGUgRmV0Y2ggbWV0YWRhdGEgaGVhZGVycyBmb3IgaHR0cFJlcXVlc3QuIFtGRVRDSC1NRVRBREFUQV1cbiAgYXBwZW5kRmV0Y2hNZXRhZGF0YShodHRwUmVxdWVzdClcblxuICAvLyAgICAxNC4gSWYgaHR0cFJlcXVlc3TigJlzIGhlYWRlciBsaXN0IGRvZXMgbm90IGNvbnRhaW4gYFVzZXItQWdlbnRgLCB0aGVuXG4gIC8vICAgIHVzZXIgYWdlbnRzIHNob3VsZCBhcHBlbmQgYFVzZXItQWdlbnRgL2RlZmF1bHQgYFVzZXItQWdlbnRgIHZhbHVlIHRvXG4gIC8vICAgIGh0dHBSZXF1ZXN04oCZcyBoZWFkZXIgbGlzdC5cbiAgaWYgKCFodHRwUmVxdWVzdC5oZWFkZXJzTGlzdC5jb250YWlucygndXNlci1hZ2VudCcsIHRydWUpKSB7XG4gICAgaHR0cFJlcXVlc3QuaGVhZGVyc0xpc3QuYXBwZW5kKCd1c2VyLWFnZW50JywgZGVmYXVsdFVzZXJBZ2VudClcbiAgfVxuXG4gIC8vICAgIDE1LiBJZiBodHRwUmVxdWVzdOKAmXMgY2FjaGUgbW9kZSBpcyBcImRlZmF1bHRcIiBhbmQgaHR0cFJlcXVlc3TigJlzIGhlYWRlclxuICAvLyAgICBsaXN0IGNvbnRhaW5zIGBJZi1Nb2RpZmllZC1TaW5jZWAsIGBJZi1Ob25lLU1hdGNoYCxcbiAgLy8gICAgYElmLVVubW9kaWZpZWQtU2luY2VgLCBgSWYtTWF0Y2hgLCBvciBgSWYtUmFuZ2VgLCB0aGVuIHNldFxuICAvLyAgICBodHRwUmVxdWVzdOKAmXMgY2FjaGUgbW9kZSB0byBcIm5vLXN0b3JlXCIuXG4gIGlmIChcbiAgICBodHRwUmVxdWVzdC5jYWNoZSA9PT0gJ2RlZmF1bHQnICYmXG4gICAgKGh0dHBSZXF1ZXN0LmhlYWRlcnNMaXN0LmNvbnRhaW5zKCdpZi1tb2RpZmllZC1zaW5jZScsIHRydWUpIHx8XG4gICAgICBodHRwUmVxdWVzdC5oZWFkZXJzTGlzdC5jb250YWlucygnaWYtbm9uZS1tYXRjaCcsIHRydWUpIHx8XG4gICAgICBodHRwUmVxdWVzdC5oZWFkZXJzTGlzdC5jb250YWlucygnaWYtdW5tb2RpZmllZC1zaW5jZScsIHRydWUpIHx8XG4gICAgICBodHRwUmVxdWVzdC5oZWFkZXJzTGlzdC5jb250YWlucygnaWYtbWF0Y2gnLCB0cnVlKSB8fFxuICAgICAgaHR0cFJlcXVlc3QuaGVhZGVyc0xpc3QuY29udGFpbnMoJ2lmLXJhbmdlJywgdHJ1ZSkpXG4gICkge1xuICAgIGh0dHBSZXF1ZXN0LmNhY2hlID0gJ25vLXN0b3JlJ1xuICB9XG5cbiAgLy8gICAgMTYuIElmIGh0dHBSZXF1ZXN04oCZcyBjYWNoZSBtb2RlIGlzIFwibm8tY2FjaGVcIiwgaHR0cFJlcXVlc3TigJlzIHByZXZlbnRcbiAgLy8gICAgbm8tY2FjaGUgY2FjaGUtY29udHJvbCBoZWFkZXIgbW9kaWZpY2F0aW9uIGZsYWcgaXMgdW5zZXQsIGFuZFxuICAvLyAgICBodHRwUmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QgZG9lcyBub3QgY29udGFpbiBgQ2FjaGUtQ29udHJvbGAsIHRoZW4gYXBwZW5kXG4gIC8vICAgIGBDYWNoZS1Db250cm9sYC9gbWF4LWFnZT0wYCB0byBodHRwUmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QuXG4gIGlmIChcbiAgICBodHRwUmVxdWVzdC5jYWNoZSA9PT0gJ25vLWNhY2hlJyAmJlxuICAgICFodHRwUmVxdWVzdC5wcmV2ZW50Tm9DYWNoZUNhY2hlQ29udHJvbEhlYWRlck1vZGlmaWNhdGlvbiAmJlxuICAgICFodHRwUmVxdWVzdC5oZWFkZXJzTGlzdC5jb250YWlucygnY2FjaGUtY29udHJvbCcsIHRydWUpXG4gICkge1xuICAgIGh0dHBSZXF1ZXN0LmhlYWRlcnNMaXN0LmFwcGVuZCgnY2FjaGUtY29udHJvbCcsICdtYXgtYWdlPTAnLCB0cnVlKVxuICB9XG5cbiAgLy8gICAgMTcuIElmIGh0dHBSZXF1ZXN04oCZcyBjYWNoZSBtb2RlIGlzIFwibm8tc3RvcmVcIiBvciBcInJlbG9hZFwiLCB0aGVuOlxuICBpZiAoaHR0cFJlcXVlc3QuY2FjaGUgPT09ICduby1zdG9yZScgfHwgaHR0cFJlcXVlc3QuY2FjaGUgPT09ICdyZWxvYWQnKSB7XG4gICAgLy8gMS4gSWYgaHR0cFJlcXVlc3TigJlzIGhlYWRlciBsaXN0IGRvZXMgbm90IGNvbnRhaW4gYFByYWdtYWAsIHRoZW4gYXBwZW5kXG4gICAgLy8gYFByYWdtYWAvYG5vLWNhY2hlYCB0byBodHRwUmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QuXG4gICAgaWYgKCFodHRwUmVxdWVzdC5oZWFkZXJzTGlzdC5jb250YWlucygncHJhZ21hJywgdHJ1ZSkpIHtcbiAgICAgIGh0dHBSZXF1ZXN0LmhlYWRlcnNMaXN0LmFwcGVuZCgncHJhZ21hJywgJ25vLWNhY2hlJywgdHJ1ZSlcbiAgICB9XG5cbiAgICAvLyAyLiBJZiBodHRwUmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QgZG9lcyBub3QgY29udGFpbiBgQ2FjaGUtQ29udHJvbGAsXG4gICAgLy8gdGhlbiBhcHBlbmQgYENhY2hlLUNvbnRyb2xgL2Buby1jYWNoZWAgdG8gaHR0cFJlcXVlc3TigJlzIGhlYWRlciBsaXN0LlxuICAgIGlmICghaHR0cFJlcXVlc3QuaGVhZGVyc0xpc3QuY29udGFpbnMoJ2NhY2hlLWNvbnRyb2wnLCB0cnVlKSkge1xuICAgICAgaHR0cFJlcXVlc3QuaGVhZGVyc0xpc3QuYXBwZW5kKCdjYWNoZS1jb250cm9sJywgJ25vLWNhY2hlJywgdHJ1ZSlcbiAgICB9XG4gIH1cblxuICAvLyAgICAxOC4gSWYgaHR0cFJlcXVlc3TigJlzIGhlYWRlciBsaXN0IGNvbnRhaW5zIGBSYW5nZWAsIHRoZW4gYXBwZW5kXG4gIC8vICAgIGBBY2NlcHQtRW5jb2RpbmdgL2BpZGVudGl0eWAgdG8gaHR0cFJlcXVlc3TigJlzIGhlYWRlciBsaXN0LlxuICBpZiAoaHR0cFJlcXVlc3QuaGVhZGVyc0xpc3QuY29udGFpbnMoJ3JhbmdlJywgdHJ1ZSkpIHtcbiAgICBodHRwUmVxdWVzdC5oZWFkZXJzTGlzdC5hcHBlbmQoJ2FjY2VwdC1lbmNvZGluZycsICdpZGVudGl0eScsIHRydWUpXG4gIH1cblxuICAvLyAgICAxOS4gTW9kaWZ5IGh0dHBSZXF1ZXN04oCZcyBoZWFkZXIgbGlzdCBwZXIgSFRUUC4gRG8gbm90IGFwcGVuZCBhIGdpdmVuXG4gIC8vICAgIGhlYWRlciBpZiBodHRwUmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QgY29udGFpbnMgdGhhdCBoZWFkZXLigJlzIG5hbWUuXG4gIC8vICAgIFRPRE86IGh0dHBzOi8vZ2l0aHViLmNvbS93aGF0d2cvZmV0Y2gvaXNzdWVzLzEyODUjaXNzdWVjb21tZW50LTg5NjU2MDEyOVxuICBpZiAoIWh0dHBSZXF1ZXN0LmhlYWRlcnNMaXN0LmNvbnRhaW5zKCdhY2NlcHQtZW5jb2RpbmcnLCB0cnVlKSkge1xuICAgIGlmICh1cmxIYXNIdHRwc1NjaGVtZShyZXF1ZXN0Q3VycmVudFVSTChodHRwUmVxdWVzdCkpKSB7XG4gICAgICBodHRwUmVxdWVzdC5oZWFkZXJzTGlzdC5hcHBlbmQoJ2FjY2VwdC1lbmNvZGluZycsICdiciwgZ3ppcCwgZGVmbGF0ZScsIHRydWUpXG4gICAgfSBlbHNlIHtcbiAgICAgIGh0dHBSZXF1ZXN0LmhlYWRlcnNMaXN0LmFwcGVuZCgnYWNjZXB0LWVuY29kaW5nJywgJ2d6aXAsIGRlZmxhdGUnLCB0cnVlKVxuICAgIH1cbiAgfVxuXG4gIGh0dHBSZXF1ZXN0LmhlYWRlcnNMaXN0LmRlbGV0ZSgnaG9zdCcsIHRydWUpXG5cbiAgLy8gICAgMjAuIElmIGluY2x1ZGVDcmVkZW50aWFscyBpcyB0cnVlLCB0aGVuOlxuICBpZiAoaW5jbHVkZUNyZWRlbnRpYWxzKSB7XG4gICAgLy8gMS4gSWYgdGhlIHVzZXIgYWdlbnQgaXMgbm90IGNvbmZpZ3VyZWQgdG8gYmxvY2sgY29va2llcyBmb3IgaHR0cFJlcXVlc3RcbiAgICAvLyAoc2VlIHNlY3Rpb24gNyBvZiBbQ09PS0lFU10pLCB0aGVuOlxuICAgIC8vIFRPRE86IGNyZWRlbnRpYWxzXG4gICAgLy8gMi4gSWYgaHR0cFJlcXVlc3TigJlzIGhlYWRlciBsaXN0IGRvZXMgbm90IGNvbnRhaW4gYEF1dGhvcml6YXRpb25gLCB0aGVuOlxuICAgIC8vIFRPRE86IGNyZWRlbnRpYWxzXG4gIH1cblxuICAvLyAgICAyMS4gSWYgdGhlcmXigJlzIGEgcHJveHktYXV0aGVudGljYXRpb24gZW50cnksIHVzZSBpdCBhcyBhcHByb3ByaWF0ZS5cbiAgLy8gICAgVE9ETzogcHJveHktYXV0aGVudGljYXRpb25cblxuICAvLyAgICAyMi4gU2V0IGh0dHBDYWNoZSB0byB0aGUgcmVzdWx0IG9mIGRldGVybWluaW5nIHRoZSBIVFRQIGNhY2hlXG4gIC8vICAgIHBhcnRpdGlvbiwgZ2l2ZW4gaHR0cFJlcXVlc3QuXG4gIC8vICAgIFRPRE86IGNhY2hlXG5cbiAgLy8gICAgMjMuIElmIGh0dHBDYWNoZSBpcyBudWxsLCB0aGVuIHNldCBodHRwUmVxdWVzdOKAmXMgY2FjaGUgbW9kZSB0b1xuICAvLyAgICBcIm5vLXN0b3JlXCIuXG4gIGlmIChodHRwQ2FjaGUgPT0gbnVsbCkge1xuICAgIGh0dHBSZXF1ZXN0LmNhY2hlID0gJ25vLXN0b3JlJ1xuICB9XG5cbiAgLy8gICAgMjQuIElmIGh0dHBSZXF1ZXN04oCZcyBjYWNoZSBtb2RlIGlzIG5laXRoZXIgXCJuby1zdG9yZVwiIG5vciBcInJlbG9hZFwiLFxuICAvLyAgICB0aGVuOlxuICBpZiAoaHR0cFJlcXVlc3QuY2FjaGUgIT09ICduby1zdG9yZScgJiYgaHR0cFJlcXVlc3QuY2FjaGUgIT09ICdyZWxvYWQnKSB7XG4gICAgLy8gVE9ETzogY2FjaGVcbiAgfVxuXG4gIC8vIDkuIElmIGFib3J0ZWQsIHRoZW4gcmV0dXJuIHRoZSBhcHByb3ByaWF0ZSBuZXR3b3JrIGVycm9yIGZvciBmZXRjaFBhcmFtcy5cbiAgLy8gVE9ET1xuXG4gIC8vIDEwLiBJZiByZXNwb25zZSBpcyBudWxsLCB0aGVuOlxuICBpZiAocmVzcG9uc2UgPT0gbnVsbCkge1xuICAgIC8vIDEuIElmIGh0dHBSZXF1ZXN04oCZcyBjYWNoZSBtb2RlIGlzIFwib25seS1pZi1jYWNoZWRcIiwgdGhlbiByZXR1cm4gYVxuICAgIC8vIG5ldHdvcmsgZXJyb3IuXG4gICAgaWYgKGh0dHBSZXF1ZXN0LmNhY2hlID09PSAnb25seS1pZi1jYWNoZWQnKSB7XG4gICAgICByZXR1cm4gbWFrZU5ldHdvcmtFcnJvcignb25seSBpZiBjYWNoZWQnKVxuICAgIH1cblxuICAgIC8vIDIuIExldCBmb3J3YXJkUmVzcG9uc2UgYmUgdGhlIHJlc3VsdCBvZiBydW5uaW5nIEhUVFAtbmV0d29yayBmZXRjaFxuICAgIC8vIGdpdmVuIGh0dHBGZXRjaFBhcmFtcywgaW5jbHVkZUNyZWRlbnRpYWxzLCBhbmQgaXNOZXdDb25uZWN0aW9uRmV0Y2guXG4gICAgY29uc3QgZm9yd2FyZFJlc3BvbnNlID0gYXdhaXQgaHR0cE5ldHdvcmtGZXRjaChcbiAgICAgIGh0dHBGZXRjaFBhcmFtcyxcbiAgICAgIGluY2x1ZGVDcmVkZW50aWFscyxcbiAgICAgIGlzTmV3Q29ubmVjdGlvbkZldGNoXG4gICAgKVxuXG4gICAgLy8gMy4gSWYgaHR0cFJlcXVlc3TigJlzIG1ldGhvZCBpcyB1bnNhZmUgYW5kIGZvcndhcmRSZXNwb25zZeKAmXMgc3RhdHVzIGlzXG4gICAgLy8gaW4gdGhlIHJhbmdlIDIwMCB0byAzOTksIGluY2x1c2l2ZSwgaW52YWxpZGF0ZSBhcHByb3ByaWF0ZSBzdG9yZWRcbiAgICAvLyByZXNwb25zZXMgaW4gaHR0cENhY2hlLCBhcyBwZXIgdGhlIFwiSW52YWxpZGF0aW9uXCIgY2hhcHRlciBvZiBIVFRQXG4gICAgLy8gQ2FjaGluZywgYW5kIHNldCBzdG9yZWRSZXNwb25zZSB0byBudWxsLiBbSFRUUC1DQUNISU5HXVxuICAgIGlmIChcbiAgICAgICFzYWZlTWV0aG9kc1NldC5oYXMoaHR0cFJlcXVlc3QubWV0aG9kKSAmJlxuICAgICAgZm9yd2FyZFJlc3BvbnNlLnN0YXR1cyA+PSAyMDAgJiZcbiAgICAgIGZvcndhcmRSZXNwb25zZS5zdGF0dXMgPD0gMzk5XG4gICAgKSB7XG4gICAgICAvLyBUT0RPOiBjYWNoZVxuICAgIH1cblxuICAgIC8vIDQuIElmIHRoZSByZXZhbGlkYXRpbmdGbGFnIGlzIHNldCBhbmQgZm9yd2FyZFJlc3BvbnNl4oCZcyBzdGF0dXMgaXMgMzA0LFxuICAgIC8vIHRoZW46XG4gICAgaWYgKHJldmFsaWRhdGluZ0ZsYWcgJiYgZm9yd2FyZFJlc3BvbnNlLnN0YXR1cyA9PT0gMzA0KSB7XG4gICAgICAvLyBUT0RPOiBjYWNoZVxuICAgIH1cblxuICAgIC8vIDUuIElmIHJlc3BvbnNlIGlzIG51bGwsIHRoZW46XG4gICAgaWYgKHJlc3BvbnNlID09IG51bGwpIHtcbiAgICAgIC8vIDEuIFNldCByZXNwb25zZSB0byBmb3J3YXJkUmVzcG9uc2UuXG4gICAgICByZXNwb25zZSA9IGZvcndhcmRSZXNwb25zZVxuXG4gICAgICAvLyAyLiBTdG9yZSBodHRwUmVxdWVzdCBhbmQgZm9yd2FyZFJlc3BvbnNlIGluIGh0dHBDYWNoZSwgYXMgcGVyIHRoZVxuICAgICAgLy8gXCJTdG9yaW5nIFJlc3BvbnNlcyBpbiBDYWNoZXNcIiBjaGFwdGVyIG9mIEhUVFAgQ2FjaGluZy4gW0hUVFAtQ0FDSElOR11cbiAgICAgIC8vIFRPRE86IGNhY2hlXG4gICAgfVxuICB9XG5cbiAgLy8gMTEuIFNldCByZXNwb25zZeKAmXMgVVJMIGxpc3QgdG8gYSBjbG9uZSBvZiBodHRwUmVxdWVzdOKAmXMgVVJMIGxpc3QuXG4gIHJlc3BvbnNlLnVybExpc3QgPSBbLi4uaHR0cFJlcXVlc3QudXJsTGlzdF1cblxuICAvLyAxMi4gSWYgaHR0cFJlcXVlc3TigJlzIGhlYWRlciBsaXN0IGNvbnRhaW5zIGBSYW5nZWAsIHRoZW4gc2V0IHJlc3BvbnNl4oCZc1xuICAvLyByYW5nZS1yZXF1ZXN0ZWQgZmxhZy5cbiAgaWYgKGh0dHBSZXF1ZXN0LmhlYWRlcnNMaXN0LmNvbnRhaW5zKCdyYW5nZScsIHRydWUpKSB7XG4gICAgcmVzcG9uc2UucmFuZ2VSZXF1ZXN0ZWQgPSB0cnVlXG4gIH1cblxuICAvLyAxMy4gU2V0IHJlc3BvbnNl4oCZcyByZXF1ZXN0LWluY2x1ZGVzLWNyZWRlbnRpYWxzIHRvIGluY2x1ZGVDcmVkZW50aWFscy5cbiAgcmVzcG9uc2UucmVxdWVzdEluY2x1ZGVzQ3JlZGVudGlhbHMgPSBpbmNsdWRlQ3JlZGVudGlhbHNcblxuICAvLyAxNC4gSWYgcmVzcG9uc2XigJlzIHN0YXR1cyBpcyA0MDEsIGh0dHBSZXF1ZXN04oCZcyByZXNwb25zZSB0YWludGluZyBpcyBub3RcbiAgLy8gXCJjb3JzXCIsIGluY2x1ZGVDcmVkZW50aWFscyBpcyB0cnVlLCBhbmQgcmVxdWVzdOKAmXMgd2luZG93IGlzIGFuIGVudmlyb25tZW50XG4gIC8vIHNldHRpbmdzIG9iamVjdCwgdGhlbjpcbiAgLy8gVE9ET1xuXG4gIC8vIDE1LiBJZiByZXNwb25zZeKAmXMgc3RhdHVzIGlzIDQwNywgdGhlbjpcbiAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDA3KSB7XG4gICAgLy8gMS4gSWYgcmVxdWVzdOKAmXMgd2luZG93IGlzIFwibm8td2luZG93XCIsIHRoZW4gcmV0dXJuIGEgbmV0d29yayBlcnJvci5cbiAgICBpZiAocmVxdWVzdC53aW5kb3cgPT09ICduby13aW5kb3cnKSB7XG4gICAgICByZXR1cm4gbWFrZU5ldHdvcmtFcnJvcigpXG4gICAgfVxuXG4gICAgLy8gMi4gPz8/XG5cbiAgICAvLyAzLiBJZiBmZXRjaFBhcmFtcyBpcyBjYW5jZWxlZCwgdGhlbiByZXR1cm4gdGhlIGFwcHJvcHJpYXRlIG5ldHdvcmsgZXJyb3IgZm9yIGZldGNoUGFyYW1zLlxuICAgIGlmIChpc0NhbmNlbGxlZChmZXRjaFBhcmFtcykpIHtcbiAgICAgIHJldHVybiBtYWtlQXBwcm9wcmlhdGVOZXR3b3JrRXJyb3IoZmV0Y2hQYXJhbXMpXG4gICAgfVxuXG4gICAgLy8gNC4gUHJvbXB0IHRoZSBlbmQgdXNlciBhcyBhcHByb3ByaWF0ZSBpbiByZXF1ZXN04oCZcyB3aW5kb3cgYW5kIHN0b3JlXG4gICAgLy8gdGhlIHJlc3VsdCBhcyBhIHByb3h5LWF1dGhlbnRpY2F0aW9uIGVudHJ5LiBbSFRUUC1BVVRIXVxuICAgIC8vIFRPRE86IEludm9rZSBzb21lIGtpbmQgb2YgY2FsbGJhY2s/XG5cbiAgICAvLyA1LiBTZXQgcmVzcG9uc2UgdG8gdGhlIHJlc3VsdCBvZiBydW5uaW5nIEhUVFAtbmV0d29yay1vci1jYWNoZSBmZXRjaCBnaXZlblxuICAgIC8vIGZldGNoUGFyYW1zLlxuICAgIC8vIFRPRE9cbiAgICByZXR1cm4gbWFrZU5ldHdvcmtFcnJvcigncHJveHkgYXV0aGVudGljYXRpb24gcmVxdWlyZWQnKVxuICB9XG5cbiAgLy8gMTYuIElmIGFsbCBvZiB0aGUgZm9sbG93aW5nIGFyZSB0cnVlXG4gIGlmIChcbiAgICAvLyByZXNwb25zZeKAmXMgc3RhdHVzIGlzIDQyMVxuICAgIHJlc3BvbnNlLnN0YXR1cyA9PT0gNDIxICYmXG4gICAgLy8gaXNOZXdDb25uZWN0aW9uRmV0Y2ggaXMgZmFsc2VcbiAgICAhaXNOZXdDb25uZWN0aW9uRmV0Y2ggJiZcbiAgICAvLyByZXF1ZXN04oCZcyBib2R5IGlzIG51bGwsIG9yIHJlcXVlc3TigJlzIGJvZHkgaXMgbm9uLW51bGwgYW5kIHJlcXVlc3TigJlzIGJvZHnigJlzIHNvdXJjZSBpcyBub24tbnVsbFxuICAgIChyZXF1ZXN0LmJvZHkgPT0gbnVsbCB8fCByZXF1ZXN0LmJvZHkuc291cmNlICE9IG51bGwpXG4gICkge1xuICAgIC8vIHRoZW46XG5cbiAgICAvLyAxLiBJZiBmZXRjaFBhcmFtcyBpcyBjYW5jZWxlZCwgdGhlbiByZXR1cm4gdGhlIGFwcHJvcHJpYXRlIG5ldHdvcmsgZXJyb3IgZm9yIGZldGNoUGFyYW1zLlxuICAgIGlmIChpc0NhbmNlbGxlZChmZXRjaFBhcmFtcykpIHtcbiAgICAgIHJldHVybiBtYWtlQXBwcm9wcmlhdGVOZXR3b3JrRXJyb3IoZmV0Y2hQYXJhbXMpXG4gICAgfVxuXG4gICAgLy8gMi4gU2V0IHJlc3BvbnNlIHRvIHRoZSByZXN1bHQgb2YgcnVubmluZyBIVFRQLW5ldHdvcmstb3ItY2FjaGVcbiAgICAvLyBmZXRjaCBnaXZlbiBmZXRjaFBhcmFtcywgaXNBdXRoZW50aWNhdGlvbkZldGNoLCBhbmQgdHJ1ZS5cblxuICAgIC8vIFRPRE8gKHNwZWMpOiBUaGUgc3BlYyBkb2Vzbid0IHNwZWNpZnkgdGhpcyBidXQgd2UgbmVlZCB0byBjYW5jZWxcbiAgICAvLyB0aGUgYWN0aXZlIHJlc3BvbnNlIGJlZm9yZSB3ZSBjYW4gc3RhcnQgYSBuZXcgb25lLlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS93aGF0d2cvZmV0Y2gvaXNzdWVzLzEyOTNcbiAgICBmZXRjaFBhcmFtcy5jb250cm9sbGVyLmNvbm5lY3Rpb24uZGVzdHJveSgpXG5cbiAgICByZXNwb25zZSA9IGF3YWl0IGh0dHBOZXR3b3JrT3JDYWNoZUZldGNoKFxuICAgICAgZmV0Y2hQYXJhbXMsXG4gICAgICBpc0F1dGhlbnRpY2F0aW9uRmV0Y2gsXG4gICAgICB0cnVlXG4gICAgKVxuICB9XG5cbiAgLy8gMTcuIElmIGlzQXV0aGVudGljYXRpb25GZXRjaCBpcyB0cnVlLCB0aGVuIGNyZWF0ZSBhbiBhdXRoZW50aWNhdGlvbiBlbnRyeVxuICBpZiAoaXNBdXRoZW50aWNhdGlvbkZldGNoKSB7XG4gICAgLy8gVE9ET1xuICB9XG5cbiAgLy8gMTguIFJldHVybiByZXNwb25zZS5cbiAgcmV0dXJuIHJlc3BvbnNlXG59XG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNodHRwLW5ldHdvcmstZmV0Y2hcbmFzeW5jIGZ1bmN0aW9uIGh0dHBOZXR3b3JrRmV0Y2ggKFxuICBmZXRjaFBhcmFtcyxcbiAgaW5jbHVkZUNyZWRlbnRpYWxzID0gZmFsc2UsXG4gIGZvcmNlTmV3Q29ubmVjdGlvbiA9IGZhbHNlXG4pIHtcbiAgYXNzZXJ0KCFmZXRjaFBhcmFtcy5jb250cm9sbGVyLmNvbm5lY3Rpb24gfHwgZmV0Y2hQYXJhbXMuY29udHJvbGxlci5jb25uZWN0aW9uLmRlc3Ryb3llZClcblxuICBmZXRjaFBhcmFtcy5jb250cm9sbGVyLmNvbm5lY3Rpb24gPSB7XG4gICAgYWJvcnQ6IG51bGwsXG4gICAgZGVzdHJveWVkOiBmYWxzZSxcbiAgICBkZXN0cm95IChlcnIsIGFib3J0ID0gdHJ1ZSkge1xuICAgICAgaWYgKCF0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWVcbiAgICAgICAgaWYgKGFib3J0KSB7XG4gICAgICAgICAgdGhpcy5hYm9ydD8uKGVyciA/PyBuZXcgRE9NRXhjZXB0aW9uKCdUaGUgb3BlcmF0aW9uIHdhcyBhYm9ydGVkLicsICdBYm9ydEVycm9yJykpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyAxLiBMZXQgcmVxdWVzdCBiZSBmZXRjaFBhcmFtc+KAmXMgcmVxdWVzdC5cbiAgY29uc3QgcmVxdWVzdCA9IGZldGNoUGFyYW1zLnJlcXVlc3RcblxuICAvLyAyLiBMZXQgcmVzcG9uc2UgYmUgbnVsbC5cbiAgbGV0IHJlc3BvbnNlID0gbnVsbFxuXG4gIC8vIDMuIExldCB0aW1pbmdJbmZvIGJlIGZldGNoUGFyYW1z4oCZcyB0aW1pbmcgaW5mby5cbiAgY29uc3QgdGltaW5nSW5mbyA9IGZldGNoUGFyYW1zLnRpbWluZ0luZm9cblxuICAvLyA0LiBMZXQgaHR0cENhY2hlIGJlIHRoZSByZXN1bHQgb2YgZGV0ZXJtaW5pbmcgdGhlIEhUVFAgY2FjaGUgcGFydGl0aW9uLFxuICAvLyBnaXZlbiByZXF1ZXN0LlxuICAvLyBUT0RPOiBjYWNoZVxuICBjb25zdCBodHRwQ2FjaGUgPSBudWxsXG5cbiAgLy8gNS4gSWYgaHR0cENhY2hlIGlzIG51bGwsIHRoZW4gc2V0IHJlcXVlc3TigJlzIGNhY2hlIG1vZGUgdG8gXCJuby1zdG9yZVwiLlxuICBpZiAoaHR0cENhY2hlID09IG51bGwpIHtcbiAgICByZXF1ZXN0LmNhY2hlID0gJ25vLXN0b3JlJ1xuICB9XG5cbiAgLy8gNi4gTGV0IG5ldHdvcmtQYXJ0aXRpb25LZXkgYmUgdGhlIHJlc3VsdCBvZiBkZXRlcm1pbmluZyB0aGUgbmV0d29ya1xuICAvLyBwYXJ0aXRpb24ga2V5IGdpdmVuIHJlcXVlc3QuXG4gIC8vIFRPRE9cblxuICAvLyA3LiBMZXQgbmV3Q29ubmVjdGlvbiBiZSBcInllc1wiIGlmIGZvcmNlTmV3Q29ubmVjdGlvbiBpcyB0cnVlOyBvdGhlcndpc2VcbiAgLy8gXCJub1wiLlxuICBjb25zdCBuZXdDb25uZWN0aW9uID0gZm9yY2VOZXdDb25uZWN0aW9uID8gJ3llcycgOiAnbm8nIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcblxuICAvLyA4LiBTd2l0Y2ggb24gcmVxdWVzdOKAmXMgbW9kZTpcbiAgaWYgKHJlcXVlc3QubW9kZSA9PT0gJ3dlYnNvY2tldCcpIHtcbiAgICAvLyBMZXQgY29ubmVjdGlvbiBiZSB0aGUgcmVzdWx0IG9mIG9idGFpbmluZyBhIFdlYlNvY2tldCBjb25uZWN0aW9uLFxuICAgIC8vIGdpdmVuIHJlcXVlc3TigJlzIGN1cnJlbnQgVVJMLlxuICAgIC8vIFRPRE9cbiAgfSBlbHNlIHtcbiAgICAvLyBMZXQgY29ubmVjdGlvbiBiZSB0aGUgcmVzdWx0IG9mIG9idGFpbmluZyBhIGNvbm5lY3Rpb24sIGdpdmVuXG4gICAgLy8gbmV0d29ya1BhcnRpdGlvbktleSwgcmVxdWVzdOKAmXMgY3VycmVudCBVUkzigJlzIG9yaWdpbixcbiAgICAvLyBpbmNsdWRlQ3JlZGVudGlhbHMsIGFuZCBmb3JjZU5ld0Nvbm5lY3Rpb24uXG4gICAgLy8gVE9ET1xuICB9XG5cbiAgLy8gOS4gUnVuIHRoZXNlIHN0ZXBzLCBidXQgYWJvcnQgd2hlbiB0aGUgb25nb2luZyBmZXRjaCBpcyB0ZXJtaW5hdGVkOlxuXG4gIC8vICAgIDEuIElmIGNvbm5lY3Rpb24gaXMgZmFpbHVyZSwgdGhlbiByZXR1cm4gYSBuZXR3b3JrIGVycm9yLlxuXG4gIC8vICAgIDIuIFNldCB0aW1pbmdJbmZv4oCZcyBmaW5hbCBjb25uZWN0aW9uIHRpbWluZyBpbmZvIHRvIHRoZSByZXN1bHQgb2ZcbiAgLy8gICAgY2FsbGluZyBjbGFtcCBhbmQgY29hcnNlbiBjb25uZWN0aW9uIHRpbWluZyBpbmZvIHdpdGggY29ubmVjdGlvbuKAmXNcbiAgLy8gICAgdGltaW5nIGluZm8sIHRpbWluZ0luZm/igJlzIHBvc3QtcmVkaXJlY3Qgc3RhcnQgdGltZSwgYW5kIGZldGNoUGFyYW1z4oCZc1xuICAvLyAgICBjcm9zcy1vcmlnaW4gaXNvbGF0ZWQgY2FwYWJpbGl0eS5cblxuICAvLyAgICAzLiBJZiBjb25uZWN0aW9uIGlzIG5vdCBhbiBIVFRQLzIgY29ubmVjdGlvbiwgcmVxdWVzdOKAmXMgYm9keSBpcyBub24tbnVsbCxcbiAgLy8gICAgYW5kIHJlcXVlc3TigJlzIGJvZHnigJlzIHNvdXJjZSBpcyBudWxsLCB0aGVuIGFwcGVuZCAoYFRyYW5zZmVyLUVuY29kaW5nYCxcbiAgLy8gICAgYGNodW5rZWRgKSB0byByZXF1ZXN04oCZcyBoZWFkZXIgbGlzdC5cblxuICAvLyAgICA0LiBTZXQgdGltaW5nSW5mb+KAmXMgZmluYWwgbmV0d29yay1yZXF1ZXN0IHN0YXJ0IHRpbWUgdG8gdGhlIGNvYXJzZW5lZFxuICAvLyAgICBzaGFyZWQgY3VycmVudCB0aW1lIGdpdmVuIGZldGNoUGFyYW1z4oCZcyBjcm9zcy1vcmlnaW4gaXNvbGF0ZWRcbiAgLy8gICAgY2FwYWJpbGl0eS5cblxuICAvLyAgICA1LiBTZXQgcmVzcG9uc2UgdG8gdGhlIHJlc3VsdCBvZiBtYWtpbmcgYW4gSFRUUCByZXF1ZXN0IG92ZXIgY29ubmVjdGlvblxuICAvLyAgICB1c2luZyByZXF1ZXN0IHdpdGggdGhlIGZvbGxvd2luZyBjYXZlYXRzOlxuXG4gIC8vICAgICAgICAtIEZvbGxvdyB0aGUgcmVsZXZhbnQgcmVxdWlyZW1lbnRzIGZyb20gSFRUUC4gW0hUVFBdIFtIVFRQLVNFTUFOVElDU11cbiAgLy8gICAgICAgIFtIVFRQLUNPTkRdIFtIVFRQLUNBQ0hJTkddIFtIVFRQLUFVVEhdXG5cbiAgLy8gICAgICAgIC0gSWYgcmVxdWVzdOKAmXMgYm9keSBpcyBub24tbnVsbCwgYW5kIHJlcXVlc3TigJlzIGJvZHnigJlzIHNvdXJjZSBpcyBudWxsLFxuICAvLyAgICAgICAgdGhlbiB0aGUgdXNlciBhZ2VudCBtYXkgaGF2ZSBhIGJ1ZmZlciBvZiB1cCB0byA2NCBraWJpYnl0ZXMgYW5kIHN0b3JlXG4gIC8vICAgICAgICBhIHBhcnQgb2YgcmVxdWVzdOKAmXMgYm9keSBpbiB0aGF0IGJ1ZmZlci4gSWYgdGhlIHVzZXIgYWdlbnQgcmVhZHMgZnJvbVxuICAvLyAgICAgICAgcmVxdWVzdOKAmXMgYm9keSBiZXlvbmQgdGhhdCBidWZmZXLigJlzIHNpemUgYW5kIHRoZSB1c2VyIGFnZW50IG5lZWRzIHRvXG4gIC8vICAgICAgICByZXNlbmQgcmVxdWVzdCwgdGhlbiBpbnN0ZWFkIHJldHVybiBhIG5ldHdvcmsgZXJyb3IuXG5cbiAgLy8gICAgICAgIC0gU2V0IHRpbWluZ0luZm/igJlzIGZpbmFsIG5ldHdvcmstcmVzcG9uc2Ugc3RhcnQgdGltZSB0byB0aGUgY29hcnNlbmVkXG4gIC8vICAgICAgICBzaGFyZWQgY3VycmVudCB0aW1lIGdpdmVuIGZldGNoUGFyYW1z4oCZcyBjcm9zcy1vcmlnaW4gaXNvbGF0ZWQgY2FwYWJpbGl0eSxcbiAgLy8gICAgICAgIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSB1c2VyIGFnZW504oCZcyBIVFRQIHBhcnNlciByZWNlaXZlcyB0aGUgZmlyc3QgYnl0ZVxuICAvLyAgICAgICAgb2YgdGhlIHJlc3BvbnNlIChlLmcuLCBmcmFtZSBoZWFkZXIgYnl0ZXMgZm9yIEhUVFAvMiBvciByZXNwb25zZSBzdGF0dXNcbiAgLy8gICAgICAgIGxpbmUgZm9yIEhUVFAvMS54KS5cblxuICAvLyAgICAgICAgLSBXYWl0IHVudGlsIGFsbCB0aGUgaGVhZGVycyBhcmUgdHJhbnNtaXR0ZWQuXG5cbiAgLy8gICAgICAgIC0gQW55IHJlc3BvbnNlcyB3aG9zZSBzdGF0dXMgaXMgaW4gdGhlIHJhbmdlIDEwMCB0byAxOTksIGluY2x1c2l2ZSxcbiAgLy8gICAgICAgIGFuZCBpcyBub3QgMTAxLCBhcmUgdG8gYmUgaWdub3JlZCwgZXhjZXB0IGZvciB0aGUgcHVycG9zZXMgb2Ygc2V0dGluZ1xuICAvLyAgICAgICAgdGltaW5nSW5mb+KAmXMgZmluYWwgbmV0d29yay1yZXNwb25zZSBzdGFydCB0aW1lIGFib3ZlLlxuXG4gIC8vICAgIC0gSWYgcmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QgY29udGFpbnMgYFRyYW5zZmVyLUVuY29kaW5nYC9gY2h1bmtlZGAgYW5kXG4gIC8vICAgIHJlc3BvbnNlIGlzIHRyYW5zZmVycmVkIHZpYSBIVFRQLzEuMCBvciBvbGRlciwgdGhlbiByZXR1cm4gYSBuZXR3b3JrXG4gIC8vICAgIGVycm9yLlxuXG4gIC8vICAgIC0gSWYgdGhlIEhUVFAgcmVxdWVzdCByZXN1bHRzIGluIGEgVExTIGNsaWVudCBjZXJ0aWZpY2F0ZSBkaWFsb2csIHRoZW46XG5cbiAgLy8gICAgICAgIDEuIElmIHJlcXVlc3TigJlzIHdpbmRvdyBpcyBhbiBlbnZpcm9ubWVudCBzZXR0aW5ncyBvYmplY3QsIG1ha2UgdGhlXG4gIC8vICAgICAgICBkaWFsb2cgYXZhaWxhYmxlIGluIHJlcXVlc3TigJlzIHdpbmRvdy5cblxuICAvLyAgICAgICAgMi4gT3RoZXJ3aXNlLCByZXR1cm4gYSBuZXR3b3JrIGVycm9yLlxuXG4gIC8vIFRvIHRyYW5zbWl0IHJlcXVlc3TigJlzIGJvZHkgYm9keSwgcnVuIHRoZXNlIHN0ZXBzOlxuICBsZXQgcmVxdWVzdEJvZHkgPSBudWxsXG4gIC8vIDEuIElmIGJvZHkgaXMgbnVsbCBhbmQgZmV0Y2hQYXJhbXPigJlzIHByb2Nlc3MgcmVxdWVzdCBlbmQtb2YtYm9keSBpc1xuICAvLyBub24tbnVsbCwgdGhlbiBxdWV1ZSBhIGZldGNoIHRhc2sgZ2l2ZW4gZmV0Y2hQYXJhbXPigJlzIHByb2Nlc3MgcmVxdWVzdFxuICAvLyBlbmQtb2YtYm9keSBhbmQgZmV0Y2hQYXJhbXPigJlzIHRhc2sgZGVzdGluYXRpb24uXG4gIGlmIChyZXF1ZXN0LmJvZHkgPT0gbnVsbCAmJiBmZXRjaFBhcmFtcy5wcm9jZXNzUmVxdWVzdEVuZE9mQm9keSkge1xuICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IGZldGNoUGFyYW1zLnByb2Nlc3NSZXF1ZXN0RW5kT2ZCb2R5KCkpXG4gIH0gZWxzZSBpZiAocmVxdWVzdC5ib2R5ICE9IG51bGwpIHtcbiAgICAvLyAyLiBPdGhlcndpc2UsIGlmIGJvZHkgaXMgbm9uLW51bGw6XG5cbiAgICAvLyAgICAxLiBMZXQgcHJvY2Vzc0JvZHlDaHVuayBnaXZlbiBieXRlcyBiZSB0aGVzZSBzdGVwczpcbiAgICBjb25zdCBwcm9jZXNzQm9keUNodW5rID0gYXN5bmMgZnVuY3Rpb24gKiAoYnl0ZXMpIHtcbiAgICAgIC8vIDEuIElmIHRoZSBvbmdvaW5nIGZldGNoIGlzIHRlcm1pbmF0ZWQsIHRoZW4gYWJvcnQgdGhlc2Ugc3RlcHMuXG4gICAgICBpZiAoaXNDYW5jZWxsZWQoZmV0Y2hQYXJhbXMpKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICAvLyAyLiBSdW4gdGhpcyBzdGVwIGluIHBhcmFsbGVsOiB0cmFuc21pdCBieXRlcy5cbiAgICAgIHlpZWxkIGJ5dGVzXG5cbiAgICAgIC8vIDMuIElmIGZldGNoUGFyYW1z4oCZcyBwcm9jZXNzIHJlcXVlc3QgYm9keSBpcyBub24tbnVsbCwgdGhlbiBydW5cbiAgICAgIC8vIGZldGNoUGFyYW1z4oCZcyBwcm9jZXNzIHJlcXVlc3QgYm9keSBnaXZlbiBieXRlc+KAmXMgbGVuZ3RoLlxuICAgICAgZmV0Y2hQYXJhbXMucHJvY2Vzc1JlcXVlc3RCb2R5Q2h1bmtMZW5ndGg/LihieXRlcy5ieXRlTGVuZ3RoKVxuICAgIH1cblxuICAgIC8vIDIuIExldCBwcm9jZXNzRW5kT2ZCb2R5IGJlIHRoZXNlIHN0ZXBzOlxuICAgIGNvbnN0IHByb2Nlc3NFbmRPZkJvZHkgPSAoKSA9PiB7XG4gICAgICAvLyAxLiBJZiBmZXRjaFBhcmFtcyBpcyBjYW5jZWxlZCwgdGhlbiBhYm9ydCB0aGVzZSBzdGVwcy5cbiAgICAgIGlmIChpc0NhbmNlbGxlZChmZXRjaFBhcmFtcykpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIC8vIDIuIElmIGZldGNoUGFyYW1z4oCZcyBwcm9jZXNzIHJlcXVlc3QgZW5kLW9mLWJvZHkgaXMgbm9uLW51bGwsXG4gICAgICAvLyB0aGVuIHJ1biBmZXRjaFBhcmFtc+KAmXMgcHJvY2VzcyByZXF1ZXN0IGVuZC1vZi1ib2R5LlxuICAgICAgaWYgKGZldGNoUGFyYW1zLnByb2Nlc3NSZXF1ZXN0RW5kT2ZCb2R5KSB7XG4gICAgICAgIGZldGNoUGFyYW1zLnByb2Nlc3NSZXF1ZXN0RW5kT2ZCb2R5KClcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyAzLiBMZXQgcHJvY2Vzc0JvZHlFcnJvciBnaXZlbiBlIGJlIHRoZXNlIHN0ZXBzOlxuICAgIGNvbnN0IHByb2Nlc3NCb2R5RXJyb3IgPSAoZSkgPT4ge1xuICAgICAgLy8gMS4gSWYgZmV0Y2hQYXJhbXMgaXMgY2FuY2VsZWQsIHRoZW4gYWJvcnQgdGhlc2Ugc3RlcHMuXG4gICAgICBpZiAoaXNDYW5jZWxsZWQoZmV0Y2hQYXJhbXMpKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICAvLyAyLiBJZiBlIGlzIGFuIFwiQWJvcnRFcnJvclwiIERPTUV4Y2VwdGlvbiwgdGhlbiBhYm9ydCBmZXRjaFBhcmFtc+KAmXMgY29udHJvbGxlci5cbiAgICAgIGlmIChlLm5hbWUgPT09ICdBYm9ydEVycm9yJykge1xuICAgICAgICBmZXRjaFBhcmFtcy5jb250cm9sbGVyLmFib3J0KClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIudGVybWluYXRlKGUpXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gNC4gSW5jcmVtZW50YWxseSByZWFkIHJlcXVlc3TigJlzIGJvZHkgZ2l2ZW4gcHJvY2Vzc0JvZHlDaHVuaywgcHJvY2Vzc0VuZE9mQm9keSxcbiAgICAvLyBwcm9jZXNzQm9keUVycm9yLCBhbmQgZmV0Y2hQYXJhbXPigJlzIHRhc2sgZGVzdGluYXRpb24uXG4gICAgcmVxdWVzdEJvZHkgPSAoYXN5bmMgZnVuY3Rpb24gKiAoKSB7XG4gICAgICB0cnkge1xuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGJ5dGVzIG9mIHJlcXVlc3QuYm9keS5zdHJlYW0pIHtcbiAgICAgICAgICB5aWVsZCAqIHByb2Nlc3NCb2R5Q2h1bmsoYnl0ZXMpXG4gICAgICAgIH1cbiAgICAgICAgcHJvY2Vzc0VuZE9mQm9keSgpXG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgcHJvY2Vzc0JvZHlFcnJvcihlcnIpXG4gICAgICB9XG4gICAgfSkoKVxuICB9XG5cbiAgdHJ5IHtcbiAgICAvLyBzb2NrZXQgaXMgb25seSBwcm92aWRlZCBmb3Igd2Vic29ja2V0c1xuICAgIGNvbnN0IHsgYm9keSwgc3RhdHVzLCBzdGF0dXNUZXh0LCBoZWFkZXJzTGlzdCwgc29ja2V0IH0gPSBhd2FpdCBkaXNwYXRjaCh7IGJvZHk6IHJlcXVlc3RCb2R5IH0pXG5cbiAgICBpZiAoc29ja2V0KSB7XG4gICAgICByZXNwb25zZSA9IG1ha2VSZXNwb25zZSh7IHN0YXR1cywgc3RhdHVzVGV4dCwgaGVhZGVyc0xpc3QsIHNvY2tldCB9KVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBpdGVyYXRvciA9IGJvZHlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKClcbiAgICAgIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIubmV4dCA9ICgpID0+IGl0ZXJhdG9yLm5leHQoKVxuXG4gICAgICByZXNwb25zZSA9IG1ha2VSZXNwb25zZSh7IHN0YXR1cywgc3RhdHVzVGV4dCwgaGVhZGVyc0xpc3QgfSlcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIDEwLiBJZiBhYm9ydGVkLCB0aGVuOlxuICAgIGlmIChlcnIubmFtZSA9PT0gJ0Fib3J0RXJyb3InKSB7XG4gICAgICAvLyAxLiBJZiBjb25uZWN0aW9uIHVzZXMgSFRUUC8yLCB0aGVuIHRyYW5zbWl0IGFuIFJTVF9TVFJFQU0gZnJhbWUuXG4gICAgICBmZXRjaFBhcmFtcy5jb250cm9sbGVyLmNvbm5lY3Rpb24uZGVzdHJveSgpXG5cbiAgICAgIC8vIDIuIFJldHVybiB0aGUgYXBwcm9wcmlhdGUgbmV0d29yayBlcnJvciBmb3IgZmV0Y2hQYXJhbXMuXG4gICAgICByZXR1cm4gbWFrZUFwcHJvcHJpYXRlTmV0d29ya0Vycm9yKGZldGNoUGFyYW1zLCBlcnIpXG4gICAgfVxuXG4gICAgcmV0dXJuIG1ha2VOZXR3b3JrRXJyb3IoZXJyKVxuICB9XG5cbiAgLy8gMTEuIExldCBwdWxsQWxnb3JpdGhtIGJlIGFuIGFjdGlvbiB0aGF0IHJlc3VtZXMgdGhlIG9uZ29pbmcgZmV0Y2hcbiAgLy8gaWYgaXQgaXMgc3VzcGVuZGVkLlxuICBjb25zdCBwdWxsQWxnb3JpdGhtID0gYXN5bmMgKCkgPT4ge1xuICAgIGF3YWl0IGZldGNoUGFyYW1zLmNvbnRyb2xsZXIucmVzdW1lKClcbiAgfVxuXG4gIC8vIDEyLiBMZXQgY2FuY2VsQWxnb3JpdGhtIGJlIGFuIGFsZ29yaXRobSB0aGF0IGFib3J0cyBmZXRjaFBhcmFtc+KAmXNcbiAgLy8gY29udHJvbGxlciB3aXRoIHJlYXNvbiwgZ2l2ZW4gcmVhc29uLlxuICBjb25zdCBjYW5jZWxBbGdvcml0aG0gPSAocmVhc29uKSA9PiB7XG4gICAgLy8gSWYgdGhlIGFib3J0ZWQgZmV0Y2ggd2FzIGFscmVhZHkgdGVybWluYXRlZCwgdGhlbiB3ZSBkbyBub3RcbiAgICAvLyBuZWVkIHRvIGRvIGFueXRoaW5nLlxuICAgIGlmICghaXNDYW5jZWxsZWQoZmV0Y2hQYXJhbXMpKSB7XG4gICAgICBmZXRjaFBhcmFtcy5jb250cm9sbGVyLmFib3J0KHJlYXNvbilcbiAgICB9XG4gIH1cblxuICAvLyAxMy4gTGV0IGhpZ2hXYXRlck1hcmsgYmUgYSBub24tbmVnYXRpdmUsIG5vbi1OYU4gbnVtYmVyLCBjaG9zZW4gYnlcbiAgLy8gdGhlIHVzZXIgYWdlbnQuXG4gIC8vIFRPRE9cblxuICAvLyAxNC4gTGV0IHNpemVBbGdvcml0aG0gYmUgYW4gYWxnb3JpdGhtIHRoYXQgYWNjZXB0cyBhIGNodW5rIG9iamVjdFxuICAvLyBhbmQgcmV0dXJucyBhIG5vbi1uZWdhdGl2ZSwgbm9uLU5hTiwgbm9uLWluZmluaXRlIG51bWJlciwgY2hvc2VuIGJ5IHRoZSB1c2VyIGFnZW50LlxuICAvLyBUT0RPXG5cbiAgLy8gMTUuIExldCBzdHJlYW0gYmUgYSBuZXcgUmVhZGFibGVTdHJlYW0uXG4gIC8vIDE2LiBTZXQgdXAgc3RyZWFtIHdpdGggYnl0ZSByZWFkaW5nIHN1cHBvcnQgd2l0aCBwdWxsQWxnb3JpdGhtIHNldCB0byBwdWxsQWxnb3JpdGhtLFxuICAvLyAgICAgY2FuY2VsQWxnb3JpdGhtIHNldCB0byBjYW5jZWxBbGdvcml0aG0uXG4gIGNvbnN0IHN0cmVhbSA9IG5ldyBSZWFkYWJsZVN0cmVhbShcbiAgICB7XG4gICAgICBhc3luYyBzdGFydCAoY29udHJvbGxlcikge1xuICAgICAgICBmZXRjaFBhcmFtcy5jb250cm9sbGVyLmNvbnRyb2xsZXIgPSBjb250cm9sbGVyXG4gICAgICB9LFxuICAgICAgYXN5bmMgcHVsbCAoY29udHJvbGxlcikge1xuICAgICAgICBhd2FpdCBwdWxsQWxnb3JpdGhtKGNvbnRyb2xsZXIpXG4gICAgICB9LFxuICAgICAgYXN5bmMgY2FuY2VsIChyZWFzb24pIHtcbiAgICAgICAgYXdhaXQgY2FuY2VsQWxnb3JpdGhtKHJlYXNvbilcbiAgICAgIH0sXG4gICAgICB0eXBlOiAnYnl0ZXMnXG4gICAgfVxuICApXG5cbiAgLy8gMTcuIFJ1biB0aGVzZSBzdGVwcywgYnV0IGFib3J0IHdoZW4gdGhlIG9uZ29pbmcgZmV0Y2ggaXMgdGVybWluYXRlZDpcblxuICAvLyAgICAxLiBTZXQgcmVzcG9uc2XigJlzIGJvZHkgdG8gYSBuZXcgYm9keSB3aG9zZSBzdHJlYW0gaXMgc3RyZWFtLlxuICByZXNwb25zZS5ib2R5ID0geyBzdHJlYW0sIHNvdXJjZTogbnVsbCwgbGVuZ3RoOiBudWxsIH1cblxuICAvLyAgICAyLiBJZiByZXNwb25zZSBpcyBub3QgYSBuZXR3b3JrIGVycm9yIGFuZCByZXF1ZXN04oCZcyBjYWNoZSBtb2RlIGlzXG4gIC8vICAgIG5vdCBcIm5vLXN0b3JlXCIsIHRoZW4gdXBkYXRlIHJlc3BvbnNlIGluIGh0dHBDYWNoZSBmb3IgcmVxdWVzdC5cbiAgLy8gICAgVE9ET1xuXG4gIC8vICAgIDMuIElmIGluY2x1ZGVDcmVkZW50aWFscyBpcyB0cnVlIGFuZCB0aGUgdXNlciBhZ2VudCBpcyBub3QgY29uZmlndXJlZFxuICAvLyAgICB0byBibG9jayBjb29raWVzIGZvciByZXF1ZXN0IChzZWUgc2VjdGlvbiA3IG9mIFtDT09LSUVTXSksIHRoZW4gcnVuIHRoZVxuICAvLyAgICBcInNldC1jb29raWUtc3RyaW5nXCIgcGFyc2luZyBhbGdvcml0aG0gKHNlZSBzZWN0aW9uIDUuMiBvZiBbQ09PS0lFU10pIG9uXG4gIC8vICAgIHRoZSB2YWx1ZSBvZiBlYWNoIGhlYWRlciB3aG9zZSBuYW1lIGlzIGEgYnl0ZS1jYXNlLWluc2Vuc2l0aXZlIG1hdGNoIGZvclxuICAvLyAgICBgU2V0LUNvb2tpZWAgaW4gcmVzcG9uc2XigJlzIGhlYWRlciBsaXN0LCBpZiBhbnksIGFuZCByZXF1ZXN04oCZcyBjdXJyZW50IFVSTC5cbiAgLy8gICAgVE9ET1xuXG4gIC8vIDE4LiBJZiBhYm9ydGVkLCB0aGVuOlxuICAvLyBUT0RPXG5cbiAgLy8gMTkuIFJ1biB0aGVzZSBzdGVwcyBpbiBwYXJhbGxlbDpcblxuICAvLyAgICAxLiBSdW4gdGhlc2Ugc3RlcHMsIGJ1dCBhYm9ydCB3aGVuIGZldGNoUGFyYW1zIGlzIGNhbmNlbGVkOlxuICBmZXRjaFBhcmFtcy5jb250cm9sbGVyLm9uQWJvcnRlZCA9IG9uQWJvcnRlZFxuICBmZXRjaFBhcmFtcy5jb250cm9sbGVyLm9uKCd0ZXJtaW5hdGVkJywgb25BYm9ydGVkKVxuICBmZXRjaFBhcmFtcy5jb250cm9sbGVyLnJlc3VtZSA9IGFzeW5jICgpID0+IHtcbiAgICAvLyAxLiBXaGlsZSB0cnVlXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIC8vIDEtMy4gU2VlIG9uRGF0YS4uLlxuXG4gICAgICAvLyA0LiBTZXQgYnl0ZXMgdG8gdGhlIHJlc3VsdCBvZiBoYW5kbGluZyBjb250ZW50IGNvZGluZ3MgZ2l2ZW5cbiAgICAgIC8vIGNvZGluZ3MgYW5kIGJ5dGVzLlxuICAgICAgbGV0IGJ5dGVzXG4gICAgICBsZXQgaXNGYWlsdXJlXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCBmZXRjaFBhcmFtcy5jb250cm9sbGVyLm5leHQoKVxuXG4gICAgICAgIGlmIChpc0Fib3J0ZWQoZmV0Y2hQYXJhbXMpKSB7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuXG4gICAgICAgIGJ5dGVzID0gZG9uZSA/IHVuZGVmaW5lZCA6IHZhbHVlXG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgaWYgKGZldGNoUGFyYW1zLmNvbnRyb2xsZXIuZW5kZWQgJiYgIXRpbWluZ0luZm8uZW5jb2RlZEJvZHlTaXplKSB7XG4gICAgICAgICAgLy8gemxpYiBkb2Vzbid0IGxpa2UgZW1wdHkgc3RyZWFtcy5cbiAgICAgICAgICBieXRlcyA9IHVuZGVmaW5lZFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJ5dGVzID0gZXJyXG5cbiAgICAgICAgICAvLyBlcnIgbWF5IGJlIHByb3BhZ2F0ZWQgZnJvbSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgcmVhZGFibGVzdHJlYW0uY2FuY2VsLFxuICAgICAgICAgIC8vIHdoaWNoIG1pZ2h0IG5vdCBiZSBhbiBlcnJvci4gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy91bmRpY2kvaXNzdWVzLzIwMDlcbiAgICAgICAgICBpc0ZhaWx1cmUgPSB0cnVlXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGJ5dGVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gMi4gT3RoZXJ3aXNlLCBpZiB0aGUgYnl0ZXMgdHJhbnNtaXNzaW9uIGZvciByZXNwb25zZeKAmXMgbWVzc2FnZVxuICAgICAgICAvLyBib2R5IGlzIGRvbmUgbm9ybWFsbHkgYW5kIHN0cmVhbSBpcyByZWFkYWJsZSwgdGhlbiBjbG9zZVxuICAgICAgICAvLyBzdHJlYW0sIGZpbmFsaXplIHJlc3BvbnNlIGZvciBmZXRjaFBhcmFtcyBhbmQgcmVzcG9uc2UsIGFuZFxuICAgICAgICAvLyBhYm9ydCB0aGVzZSBpbi1wYXJhbGxlbCBzdGVwcy5cbiAgICAgICAgcmVhZGFibGVTdHJlYW1DbG9zZShmZXRjaFBhcmFtcy5jb250cm9sbGVyLmNvbnRyb2xsZXIpXG5cbiAgICAgICAgZmluYWxpemVSZXNwb25zZShmZXRjaFBhcmFtcywgcmVzcG9uc2UpXG5cbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIC8vIDUuIEluY3JlYXNlIHRpbWluZ0luZm/igJlzIGRlY29kZWQgYm9keSBzaXplIGJ5IGJ5dGVz4oCZcyBsZW5ndGguXG4gICAgICB0aW1pbmdJbmZvLmRlY29kZWRCb2R5U2l6ZSArPSBieXRlcz8uYnl0ZUxlbmd0aCA/PyAwXG5cbiAgICAgIC8vIDYuIElmIGJ5dGVzIGlzIGZhaWx1cmUsIHRoZW4gdGVybWluYXRlIGZldGNoUGFyYW1z4oCZcyBjb250cm9sbGVyLlxuICAgICAgaWYgKGlzRmFpbHVyZSkge1xuICAgICAgICBmZXRjaFBhcmFtcy5jb250cm9sbGVyLnRlcm1pbmF0ZShieXRlcylcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIC8vIDcuIEVucXVldWUgYSBVaW50OEFycmF5IHdyYXBwaW5nIGFuIEFycmF5QnVmZmVyIGNvbnRhaW5pbmcgYnl0ZXNcbiAgICAgIC8vIGludG8gc3RyZWFtLlxuICAgICAgY29uc3QgYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoYnl0ZXMpXG4gICAgICBpZiAoYnVmZmVyLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgZmV0Y2hQYXJhbXMuY29udHJvbGxlci5jb250cm9sbGVyLmVucXVldWUoYnVmZmVyKVxuICAgICAgfVxuXG4gICAgICAvLyA4LiBJZiBzdHJlYW0gaXMgZXJyb3JlZCwgdGhlbiB0ZXJtaW5hdGUgdGhlIG9uZ29pbmcgZmV0Y2guXG4gICAgICBpZiAoaXNFcnJvcmVkKHN0cmVhbSkpIHtcbiAgICAgICAgZmV0Y2hQYXJhbXMuY29udHJvbGxlci50ZXJtaW5hdGUoKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgLy8gOS4gSWYgc3RyZWFtIGRvZXNu4oCZdCBuZWVkIG1vcmUgZGF0YSBhc2sgdGhlIHVzZXIgYWdlbnQgdG8gc3VzcGVuZFxuICAgICAgLy8gdGhlIG9uZ29pbmcgZmV0Y2guXG4gICAgICBpZiAoZmV0Y2hQYXJhbXMuY29udHJvbGxlci5jb250cm9sbGVyLmRlc2lyZWRTaXplIDw9IDApIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gICAgMi4gSWYgYWJvcnRlZCwgdGhlbjpcbiAgZnVuY3Rpb24gb25BYm9ydGVkIChyZWFzb24pIHtcbiAgICAvLyAyLiBJZiBmZXRjaFBhcmFtcyBpcyBhYm9ydGVkLCB0aGVuOlxuICAgIGlmIChpc0Fib3J0ZWQoZmV0Y2hQYXJhbXMpKSB7XG4gICAgICAvLyAxLiBTZXQgcmVzcG9uc2XigJlzIGFib3J0ZWQgZmxhZy5cbiAgICAgIHJlc3BvbnNlLmFib3J0ZWQgPSB0cnVlXG5cbiAgICAgIC8vIDIuIElmIHN0cmVhbSBpcyByZWFkYWJsZSwgdGhlbiBlcnJvciBzdHJlYW0gd2l0aCB0aGUgcmVzdWx0IG9mXG4gICAgICAvLyAgICBkZXNlcmlhbGl6ZSBhIHNlcmlhbGl6ZWQgYWJvcnQgcmVhc29uIGdpdmVuIGZldGNoUGFyYW1z4oCZc1xuICAgICAgLy8gICAgY29udHJvbGxlcuKAmXMgc2VyaWFsaXplZCBhYm9ydCByZWFzb24gYW5kIGFuXG4gICAgICAvLyAgICBpbXBsZW1lbnRhdGlvbi1kZWZpbmVkIHJlYWxtLlxuICAgICAgaWYgKGlzUmVhZGFibGUoc3RyZWFtKSkge1xuICAgICAgICBmZXRjaFBhcmFtcy5jb250cm9sbGVyLmNvbnRyb2xsZXIuZXJyb3IoXG4gICAgICAgICAgZmV0Y2hQYXJhbXMuY29udHJvbGxlci5zZXJpYWxpemVkQWJvcnRSZWFzb25cbiAgICAgICAgKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyAzLiBPdGhlcndpc2UsIGlmIHN0cmVhbSBpcyByZWFkYWJsZSwgZXJyb3Igc3RyZWFtIHdpdGggYSBUeXBlRXJyb3IuXG4gICAgICBpZiAoaXNSZWFkYWJsZShzdHJlYW0pKSB7XG4gICAgICAgIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIuY29udHJvbGxlci5lcnJvcihuZXcgVHlwZUVycm9yKCd0ZXJtaW5hdGVkJywge1xuICAgICAgICAgIGNhdXNlOiBpc0Vycm9yTGlrZShyZWFzb24pID8gcmVhc29uIDogdW5kZWZpbmVkXG4gICAgICAgIH0pKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIDQuIElmIGNvbm5lY3Rpb24gdXNlcyBIVFRQLzIsIHRoZW4gdHJhbnNtaXQgYW4gUlNUX1NUUkVBTSBmcmFtZS5cbiAgICAvLyA1LiBPdGhlcndpc2UsIHRoZSB1c2VyIGFnZW50IHNob3VsZCBjbG9zZSBjb25uZWN0aW9uIHVubGVzcyBpdCB3b3VsZCBiZSBiYWQgZm9yIHBlcmZvcm1hbmNlIHRvIGRvIHNvLlxuICAgIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIuY29ubmVjdGlvbi5kZXN0cm95KClcbiAgfVxuXG4gIC8vIDIwLiBSZXR1cm4gcmVzcG9uc2UuXG4gIHJldHVybiByZXNwb25zZVxuXG4gIGZ1bmN0aW9uIGRpc3BhdGNoICh7IGJvZHkgfSkge1xuICAgIGNvbnN0IHVybCA9IHJlcXVlc3RDdXJyZW50VVJMKHJlcXVlc3QpXG4gICAgLyoqIEB0eXBlIHtpbXBvcnQoJy4uLy4uJykuQWdlbnR9ICovXG4gICAgY29uc3QgYWdlbnQgPSBmZXRjaFBhcmFtcy5jb250cm9sbGVyLmRpc3BhdGNoZXJcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiBhZ2VudC5kaXNwYXRjaChcbiAgICAgIHtcbiAgICAgICAgcGF0aDogdXJsLnBhdGhuYW1lICsgdXJsLnNlYXJjaCxcbiAgICAgICAgb3JpZ2luOiB1cmwub3JpZ2luLFxuICAgICAgICBtZXRob2Q6IHJlcXVlc3QubWV0aG9kLFxuICAgICAgICBib2R5OiBhZ2VudC5pc01vY2tBY3RpdmUgPyByZXF1ZXN0LmJvZHkgJiYgKHJlcXVlc3QuYm9keS5zb3VyY2UgfHwgcmVxdWVzdC5ib2R5LnN0cmVhbSkgOiBib2R5LFxuICAgICAgICBoZWFkZXJzOiByZXF1ZXN0LmhlYWRlcnNMaXN0LmVudHJpZXMsXG4gICAgICAgIG1heFJlZGlyZWN0aW9uczogMCxcbiAgICAgICAgdXBncmFkZTogcmVxdWVzdC5tb2RlID09PSAnd2Vic29ja2V0JyA/ICd3ZWJzb2NrZXQnIDogdW5kZWZpbmVkXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBib2R5OiBudWxsLFxuICAgICAgICBhYm9ydDogbnVsbCxcblxuICAgICAgICBvbkNvbm5lY3QgKGFib3J0KSB7XG4gICAgICAgICAgLy8gVE9ETyAoZml4KTogRG8gd2UgbmVlZCBjb25uZWN0aW9uIGhlcmU/XG4gICAgICAgICAgY29uc3QgeyBjb25uZWN0aW9uIH0gPSBmZXRjaFBhcmFtcy5jb250cm9sbGVyXG5cbiAgICAgICAgICAvLyBTZXQgdGltaW5nSW5mb+KAmXMgZmluYWwgY29ubmVjdGlvbiB0aW1pbmcgaW5mbyB0byB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgY2xhbXAgYW5kIGNvYXJzZW5cbiAgICAgICAgICAvLyBjb25uZWN0aW9uIHRpbWluZyBpbmZvIHdpdGggY29ubmVjdGlvbuKAmXMgdGltaW5nIGluZm8sIHRpbWluZ0luZm/igJlzIHBvc3QtcmVkaXJlY3Qgc3RhcnRcbiAgICAgICAgICAvLyB0aW1lLCBhbmQgZmV0Y2hQYXJhbXPigJlzIGNyb3NzLW9yaWdpbiBpc29sYXRlZCBjYXBhYmlsaXR5LlxuICAgICAgICAgIC8vIFRPRE86IGltcGxlbWVudCBjb25uZWN0aW9uIHRpbWluZ1xuICAgICAgICAgIHRpbWluZ0luZm8uZmluYWxDb25uZWN0aW9uVGltaW5nSW5mbyA9IGNsYW1wQW5kQ29hcnNlbkNvbm5lY3Rpb25UaW1pbmdJbmZvKHVuZGVmaW5lZCwgdGltaW5nSW5mby5wb3N0UmVkaXJlY3RTdGFydFRpbWUsIGZldGNoUGFyYW1zLmNyb3NzT3JpZ2luSXNvbGF0ZWRDYXBhYmlsaXR5KVxuXG4gICAgICAgICAgaWYgKGNvbm5lY3Rpb24uZGVzdHJveWVkKSB7XG4gICAgICAgICAgICBhYm9ydChuZXcgRE9NRXhjZXB0aW9uKCdUaGUgb3BlcmF0aW9uIHdhcyBhYm9ydGVkLicsICdBYm9ydEVycm9yJykpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIub24oJ3Rlcm1pbmF0ZWQnLCBhYm9ydClcbiAgICAgICAgICAgIHRoaXMuYWJvcnQgPSBjb25uZWN0aW9uLmFib3J0ID0gYWJvcnRcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBTZXQgdGltaW5nSW5mb+KAmXMgZmluYWwgbmV0d29yay1yZXF1ZXN0IHN0YXJ0IHRpbWUgdG8gdGhlIGNvYXJzZW5lZCBzaGFyZWQgY3VycmVudCB0aW1lIGdpdmVuXG4gICAgICAgICAgLy8gZmV0Y2hQYXJhbXPigJlzIGNyb3NzLW9yaWdpbiBpc29sYXRlZCBjYXBhYmlsaXR5LlxuICAgICAgICAgIHRpbWluZ0luZm8uZmluYWxOZXR3b3JrUmVxdWVzdFN0YXJ0VGltZSA9IGNvYXJzZW5lZFNoYXJlZEN1cnJlbnRUaW1lKGZldGNoUGFyYW1zLmNyb3NzT3JpZ2luSXNvbGF0ZWRDYXBhYmlsaXR5KVxuICAgICAgICB9LFxuXG4gICAgICAgIG9uUmVzcG9uc2VTdGFydGVkICgpIHtcbiAgICAgICAgICAvLyBTZXQgdGltaW5nSW5mb+KAmXMgZmluYWwgbmV0d29yay1yZXNwb25zZSBzdGFydCB0aW1lIHRvIHRoZSBjb2Fyc2VuZWQgc2hhcmVkIGN1cnJlbnRcbiAgICAgICAgICAvLyB0aW1lIGdpdmVuIGZldGNoUGFyYW1z4oCZcyBjcm9zcy1vcmlnaW4gaXNvbGF0ZWQgY2FwYWJpbGl0eSwgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlXG4gICAgICAgICAgLy8gdXNlciBhZ2VudOKAmXMgSFRUUCBwYXJzZXIgcmVjZWl2ZXMgdGhlIGZpcnN0IGJ5dGUgb2YgdGhlIHJlc3BvbnNlIChlLmcuLCBmcmFtZSBoZWFkZXJcbiAgICAgICAgICAvLyBieXRlcyBmb3IgSFRUUC8yIG9yIHJlc3BvbnNlIHN0YXR1cyBsaW5lIGZvciBIVFRQLzEueCkuXG4gICAgICAgICAgdGltaW5nSW5mby5maW5hbE5ldHdvcmtSZXNwb25zZVN0YXJ0VGltZSA9IGNvYXJzZW5lZFNoYXJlZEN1cnJlbnRUaW1lKGZldGNoUGFyYW1zLmNyb3NzT3JpZ2luSXNvbGF0ZWRDYXBhYmlsaXR5KVxuICAgICAgICB9LFxuXG4gICAgICAgIG9uSGVhZGVycyAoc3RhdHVzLCByYXdIZWFkZXJzLCByZXN1bWUsIHN0YXR1c1RleHQpIHtcbiAgICAgICAgICBpZiAoc3RhdHVzIDwgMjAwKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvKiogQHR5cGUge3N0cmluZ1tdfSAqL1xuICAgICAgICAgIGxldCBjb2RpbmdzID0gW11cbiAgICAgICAgICBsZXQgbG9jYXRpb24gPSAnJ1xuXG4gICAgICAgICAgY29uc3QgaGVhZGVyc0xpc3QgPSBuZXcgSGVhZGVyc0xpc3QoKVxuXG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYXdIZWFkZXJzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICBoZWFkZXJzTGlzdC5hcHBlbmQoYnVmZmVyVG9Mb3dlckNhc2VkSGVhZGVyTmFtZShyYXdIZWFkZXJzW2ldKSwgcmF3SGVhZGVyc1tpICsgMV0udG9TdHJpbmcoJ2xhdGluMScpLCB0cnVlKVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBjb250ZW50RW5jb2RpbmcgPSBoZWFkZXJzTGlzdC5nZXQoJ2NvbnRlbnQtZW5jb2RpbmcnLCB0cnVlKVxuICAgICAgICAgIGlmIChjb250ZW50RW5jb2RpbmcpIHtcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM3MjMxI3NlY3Rpb24tMy4xLjIuMVxuICAgICAgICAgICAgLy8gXCJBbGwgY29udGVudC1jb2RpbmcgdmFsdWVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlLi4uXCJcbiAgICAgICAgICAgIGNvZGluZ3MgPSBjb250ZW50RW5jb2RpbmcudG9Mb3dlckNhc2UoKS5zcGxpdCgnLCcpLm1hcCgoeCkgPT4geC50cmltKCkpXG4gICAgICAgICAgfVxuICAgICAgICAgIGxvY2F0aW9uID0gaGVhZGVyc0xpc3QuZ2V0KCdsb2NhdGlvbicsIHRydWUpXG5cbiAgICAgICAgICB0aGlzLmJvZHkgPSBuZXcgUmVhZGFibGUoeyByZWFkOiByZXN1bWUgfSlcblxuICAgICAgICAgIGNvbnN0IGRlY29kZXJzID0gW11cblxuICAgICAgICAgIGNvbnN0IHdpbGxGb2xsb3cgPSBsb2NhdGlvbiAmJiByZXF1ZXN0LnJlZGlyZWN0ID09PSAnZm9sbG93JyAmJlxuICAgICAgICAgICAgcmVkaXJlY3RTdGF0dXNTZXQuaGFzKHN0YXR1cylcblxuICAgICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvSGVhZGVycy9Db250ZW50LUVuY29kaW5nXG4gICAgICAgICAgaWYgKGNvZGluZ3MubGVuZ3RoICE9PSAwICYmIHJlcXVlc3QubWV0aG9kICE9PSAnSEVBRCcgJiYgcmVxdWVzdC5tZXRob2QgIT09ICdDT05ORUNUJyAmJiAhbnVsbEJvZHlTdGF0dXMuaW5jbHVkZXMoc3RhdHVzKSAmJiAhd2lsbEZvbGxvdykge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2RpbmdzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGNvZGluZyA9IGNvZGluZ3NbaV1cbiAgICAgICAgICAgICAgLy8gaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkxMTIuaHRtbCNzZWN0aW9uLTcuMlxuICAgICAgICAgICAgICBpZiAoY29kaW5nID09PSAneC1nemlwJyB8fCBjb2RpbmcgPT09ICdnemlwJykge1xuICAgICAgICAgICAgICAgIGRlY29kZXJzLnB1c2goemxpYi5jcmVhdGVHdW56aXAoe1xuICAgICAgICAgICAgICAgICAgLy8gQmUgbGVzcyBzdHJpY3Qgd2hlbiBkZWNvZGluZyBjb21wcmVzc2VkIHJlc3BvbnNlcywgc2luY2Ugc29tZXRpbWVzXG4gICAgICAgICAgICAgICAgICAvLyBzZXJ2ZXJzIHNlbmQgc2xpZ2h0bHkgaW52YWxpZCByZXNwb25zZXMgdGhhdCBhcmUgc3RpbGwgYWNjZXB0ZWRcbiAgICAgICAgICAgICAgICAgIC8vIGJ5IGNvbW1vbiBicm93c2Vycy5cbiAgICAgICAgICAgICAgICAgIC8vIEFsd2F5cyB1c2luZyBaX1NZTkNfRkxVU0ggaXMgd2hhdCBjVVJMIGRvZXMuXG4gICAgICAgICAgICAgICAgICBmbHVzaDogemxpYi5jb25zdGFudHMuWl9TWU5DX0ZMVVNILFxuICAgICAgICAgICAgICAgICAgZmluaXNoRmx1c2g6IHpsaWIuY29uc3RhbnRzLlpfU1lOQ19GTFVTSFxuICAgICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvZGluZyA9PT0gJ2RlZmxhdGUnKSB7XG4gICAgICAgICAgICAgICAgZGVjb2RlcnMucHVzaChjcmVhdGVJbmZsYXRlKCkpXG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29kaW5nID09PSAnYnInKSB7XG4gICAgICAgICAgICAgICAgZGVjb2RlcnMucHVzaCh6bGliLmNyZWF0ZUJyb3RsaURlY29tcHJlc3MoKSlcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZWNvZGVycy5sZW5ndGggPSAwXG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgICAgc3RhdHVzLFxuICAgICAgICAgICAgc3RhdHVzVGV4dCxcbiAgICAgICAgICAgIGhlYWRlcnNMaXN0LFxuICAgICAgICAgICAgYm9keTogZGVjb2RlcnMubGVuZ3RoXG4gICAgICAgICAgICAgID8gcGlwZWxpbmUodGhpcy5ib2R5LCAuLi5kZWNvZGVycywgKCkgPT4geyB9KVxuICAgICAgICAgICAgICA6IHRoaXMuYm9keS5vbignZXJyb3InLCAoKSA9PiB7IH0pXG4gICAgICAgICAgfSlcblxuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH0sXG5cbiAgICAgICAgb25EYXRhIChjaHVuaykge1xuICAgICAgICAgIGlmIChmZXRjaFBhcmFtcy5jb250cm9sbGVyLmR1bXApIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIDEuIElmIG9uZSBvciBtb3JlIGJ5dGVzIGhhdmUgYmVlbiB0cmFuc21pdHRlZCBmcm9tIHJlc3BvbnNl4oCZc1xuICAgICAgICAgIC8vIG1lc3NhZ2UgYm9keSwgdGhlbjpcblxuICAgICAgICAgIC8vICAxLiBMZXQgYnl0ZXMgYmUgdGhlIHRyYW5zbWl0dGVkIGJ5dGVzLlxuICAgICAgICAgIGNvbnN0IGJ5dGVzID0gY2h1bmtcblxuICAgICAgICAgIC8vICAyLiBMZXQgY29kaW5ncyBiZSB0aGUgcmVzdWx0IG9mIGV4dHJhY3RpbmcgaGVhZGVyIGxpc3QgdmFsdWVzXG4gICAgICAgICAgLy8gIGdpdmVuIGBDb250ZW50LUVuY29kaW5nYCBhbmQgcmVzcG9uc2XigJlzIGhlYWRlciBsaXN0LlxuICAgICAgICAgIC8vICBTZWUgcHVsbEFsZ29yaXRobS5cblxuICAgICAgICAgIC8vICAzLiBJbmNyZWFzZSB0aW1pbmdJbmZv4oCZcyBlbmNvZGVkIGJvZHkgc2l6ZSBieSBieXRlc+KAmXMgbGVuZ3RoLlxuICAgICAgICAgIHRpbWluZ0luZm8uZW5jb2RlZEJvZHlTaXplICs9IGJ5dGVzLmJ5dGVMZW5ndGhcblxuICAgICAgICAgIC8vICA0LiBTZWUgcHVsbEFsZ29yaXRobS4uLlxuXG4gICAgICAgICAgcmV0dXJuIHRoaXMuYm9keS5wdXNoKGJ5dGVzKVxuICAgICAgICB9LFxuXG4gICAgICAgIG9uQ29tcGxldGUgKCkge1xuICAgICAgICAgIGlmICh0aGlzLmFib3J0KSB7XG4gICAgICAgICAgICBmZXRjaFBhcmFtcy5jb250cm9sbGVyLm9mZigndGVybWluYXRlZCcsIHRoaXMuYWJvcnQpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGZldGNoUGFyYW1zLmNvbnRyb2xsZXIub25BYm9ydGVkKSB7XG4gICAgICAgICAgICBmZXRjaFBhcmFtcy5jb250cm9sbGVyLm9mZigndGVybWluYXRlZCcsIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIub25BYm9ydGVkKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIuZW5kZWQgPSB0cnVlXG5cbiAgICAgICAgICB0aGlzLmJvZHkucHVzaChudWxsKVxuICAgICAgICB9LFxuXG4gICAgICAgIG9uRXJyb3IgKGVycm9yKSB7XG4gICAgICAgICAgaWYgKHRoaXMuYWJvcnQpIHtcbiAgICAgICAgICAgIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIub2ZmKCd0ZXJtaW5hdGVkJywgdGhpcy5hYm9ydClcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmJvZHk/LmRlc3Ryb3koZXJyb3IpXG5cbiAgICAgICAgICBmZXRjaFBhcmFtcy5jb250cm9sbGVyLnRlcm1pbmF0ZShlcnJvcilcblxuICAgICAgICAgIHJlamVjdChlcnJvcilcbiAgICAgICAgfSxcblxuICAgICAgICBvblVwZ3JhZGUgKHN0YXR1cywgcmF3SGVhZGVycywgc29ja2V0KSB7XG4gICAgICAgICAgaWYgKHN0YXR1cyAhPT0gMTAxKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBoZWFkZXJzTGlzdCA9IG5ldyBIZWFkZXJzTGlzdCgpXG5cbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJhd0hlYWRlcnMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgIGhlYWRlcnNMaXN0LmFwcGVuZChidWZmZXJUb0xvd2VyQ2FzZWRIZWFkZXJOYW1lKHJhd0hlYWRlcnNbaV0pLCByYXdIZWFkZXJzW2kgKyAxXS50b1N0cmluZygnbGF0aW4xJyksIHRydWUpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgICBzdGF0dXMsXG4gICAgICAgICAgICBzdGF0dXNUZXh0OiBTVEFUVVNfQ09ERVNbc3RhdHVzXSxcbiAgICAgICAgICAgIGhlYWRlcnNMaXN0LFxuICAgICAgICAgICAgc29ja2V0XG4gICAgICAgICAgfSlcblxuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICApKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBmZXRjaCxcbiAgRmV0Y2gsXG4gIGZldGNoaW5nLFxuICBmaW5hbGl6ZUFuZFJlcG9ydFRpbWluZ1xufVxuIl0sIm5hbWVzIjpbIm1ha2VOZXR3b3JrRXJyb3IiLCJtYWtlQXBwcm9wcmlhdGVOZXR3b3JrRXJyb3IiLCJmaWx0ZXJSZXNwb25zZSIsIm1ha2VSZXNwb25zZSIsImZyb21Jbm5lclJlc3BvbnNlIiwicmVxdWlyZSIsIkhlYWRlcnNMaXN0IiwiUmVxdWVzdCIsImNsb25lUmVxdWVzdCIsInpsaWIiLCJieXRlc01hdGNoIiwibWFrZVBvbGljeUNvbnRhaW5lciIsImNsb25lUG9saWN5Q29udGFpbmVyIiwicmVxdWVzdEJhZFBvcnQiLCJUQU9DaGVjayIsImFwcGVuZFJlcXVlc3RPcmlnaW5IZWFkZXIiLCJyZXNwb25zZUxvY2F0aW9uVVJMIiwicmVxdWVzdEN1cnJlbnRVUkwiLCJzZXRSZXF1ZXN0UmVmZXJyZXJQb2xpY3lPblJlZGlyZWN0IiwidHJ5VXBncmFkZVJlcXVlc3RUb0FQb3RlbnRpYWxseVRydXN0d29ydGh5VVJMIiwiY3JlYXRlT3BhcXVlVGltaW5nSW5mbyIsImFwcGVuZEZldGNoTWV0YWRhdGEiLCJjb3JzQ2hlY2siLCJjcm9zc09yaWdpblJlc291cmNlUG9saWN5Q2hlY2siLCJkZXRlcm1pbmVSZXF1ZXN0c1JlZmVycmVyIiwiY29hcnNlbmVkU2hhcmVkQ3VycmVudFRpbWUiLCJjcmVhdGVEZWZlcnJlZFByb21pc2UiLCJpc0Jsb2JMaWtlIiwic2FtZU9yaWdpbiIsImlzQ2FuY2VsbGVkIiwiaXNBYm9ydGVkIiwiaXNFcnJvckxpa2UiLCJmdWxseVJlYWRCb2R5IiwicmVhZGFibGVTdHJlYW1DbG9zZSIsImlzb21vcnBoaWNFbmNvZGUiLCJ1cmxJc0xvY2FsIiwidXJsSXNIdHRwSHR0cHNTY2hlbWUiLCJ1cmxIYXNIdHRwc1NjaGVtZSIsImNsYW1wQW5kQ29hcnNlbkNvbm5lY3Rpb25UaW1pbmdJbmZvIiwic2ltcGxlUmFuZ2VIZWFkZXJWYWx1ZSIsImJ1aWxkQ29udGVudFJhbmdlIiwiY3JlYXRlSW5mbGF0ZSIsImV4dHJhY3RNaW1lVHlwZSIsImtTdGF0ZSIsImtEaXNwYXRjaGVyIiwiYXNzZXJ0Iiwic2FmZWx5RXh0cmFjdEJvZHkiLCJleHRyYWN0Qm9keSIsInJlZGlyZWN0U3RhdHVzU2V0IiwibnVsbEJvZHlTdGF0dXMiLCJzYWZlTWV0aG9kc1NldCIsInJlcXVlc3RCb2R5SGVhZGVyIiwic3VicmVzb3VyY2VTZXQiLCJFRSIsIlJlYWRhYmxlIiwicGlwZWxpbmUiLCJmaW5pc2hlZCIsImFkZEFib3J0TGlzdGVuZXIiLCJpc0Vycm9yZWQiLCJpc1JlYWRhYmxlIiwiYnVmZmVyVG9Mb3dlckNhc2VkSGVhZGVyTmFtZSIsImRhdGFVUkxQcm9jZXNzb3IiLCJzZXJpYWxpemVBTWltZVR5cGUiLCJtaW5pbWl6ZVN1cHBvcnRlZE1pbWVUeXBlIiwiZ2V0R2xvYmFsRGlzcGF0Y2hlciIsIndlYmlkbCIsIlNUQVRVU19DT0RFUyIsIkdFVF9PUl9IRUFEIiwiZGVmYXVsdFVzZXJBZ2VudCIsIl9fVU5ESUNJX0lTX05PREVfXyIsImVzYnVpbGREZXRlY3Rpb24iLCJyZXNvbHZlT2JqZWN0VVJMIiwiRmV0Y2giLCJjb25zdHJ1Y3RvciIsImRpc3BhdGNoZXIiLCJjb25uZWN0aW9uIiwiZHVtcCIsInN0YXRlIiwidGVybWluYXRlIiwicmVhc29uIiwiZGVzdHJveSIsImVtaXQiLCJhYm9ydCIsImVycm9yIiwiRE9NRXhjZXB0aW9uIiwic2VyaWFsaXplZEFib3J0UmVhc29uIiwiaGFuZGxlRmV0Y2hEb25lIiwicmVzcG9uc2UiLCJmaW5hbGl6ZUFuZFJlcG9ydFRpbWluZyIsImZldGNoIiwiaW5wdXQiLCJpbml0IiwidW5kZWZpbmVkIiwiYXJndW1lbnRMZW5ndGhDaGVjayIsImFyZ3VtZW50cyIsInAiLCJyZXF1ZXN0T2JqZWN0IiwiZSIsInJlamVjdCIsInByb21pc2UiLCJyZXF1ZXN0Iiwic2lnbmFsIiwiYWJvcnRlZCIsImFib3J0RmV0Y2giLCJnbG9iYWxPYmplY3QiLCJjbGllbnQiLCJuYW1lIiwic2VydmljZVdvcmtlcnMiLCJyZXNwb25zZU9iamVjdCIsImxvY2FsbHlBYm9ydGVkIiwiY29udHJvbGxlciIsInJlYWxSZXNwb25zZSIsImRlcmVmIiwicHJvY2Vzc1Jlc3BvbnNlIiwidHlwZSIsIlR5cGVFcnJvciIsImNhdXNlIiwiV2Vha1JlZiIsInJlc29sdmUiLCJmZXRjaGluZyIsInByb2Nlc3NSZXNwb25zZUVuZE9mQm9keSIsImluaXRpYXRvclR5cGUiLCJ1cmxMaXN0IiwibGVuZ3RoIiwib3JpZ2luYWxVUkwiLCJ0aW1pbmdJbmZvIiwiY2FjaGVTdGF0ZSIsInRpbWluZ0FsbG93UGFzc2VkIiwic3RhcnRUaW1lIiwiZW5kVGltZSIsIm1hcmtSZXNvdXJjZVRpbWluZyIsImhyZWYiLCJnbG9iYWxUaGlzIiwicGVyZm9ybWFuY2UiLCJib2R5Iiwic3RyZWFtIiwiY2FuY2VsIiwiY2F0Y2giLCJlcnIiLCJjb2RlIiwicHJvY2Vzc1JlcXVlc3RCb2R5Q2h1bmtMZW5ndGgiLCJwcm9jZXNzUmVxdWVzdEVuZE9mQm9keSIsInByb2Nlc3NSZXNwb25zZUNvbnN1bWVCb2R5IiwidXNlUGFyYWxsZWxRdWV1ZSIsInRhc2tEZXN0aW5hdGlvbiIsImNyb3NzT3JpZ2luSXNvbGF0ZWRDYXBhYmlsaXR5IiwiY3VycmVudFRpbWUiLCJmZXRjaFBhcmFtcyIsIndpbmRvdyIsIm9yaWdpbiIsInBvbGljeUNvbnRhaW5lciIsImhlYWRlcnNMaXN0IiwiY29udGFpbnMiLCJ2YWx1ZSIsImFwcGVuZCIsInByaW9yaXR5IiwiaGFzIiwiZGVzdGluYXRpb24iLCJtYWluRmV0Y2giLCJyZWN1cnNpdmUiLCJsb2NhbFVSTHNPbmx5IiwicmVmZXJyZXJQb2xpY3kiLCJyZWZlcnJlciIsImN1cnJlbnRVUkwiLCJ1cmwiLCJyZXNwb25zZVRhaW50aW5nIiwicHJvdG9jb2wiLCJtb2RlIiwic2NoZW1lRmV0Y2giLCJyZWRpcmVjdCIsImh0dHBGZXRjaCIsInN0YXR1cyIsImludGVybmFsUmVzcG9uc2UiLCJwdXNoIiwidGltaW5nQWxsb3dGYWlsZWQiLCJyYW5nZVJlcXVlc3RlZCIsImhlYWRlcnMiLCJtZXRob2QiLCJpbmNsdWRlcyIsImludGVncml0eSIsInByb2Nlc3NCb2R5RXJyb3IiLCJmZXRjaEZpbmFsZSIsInByb2Nlc3NCb2R5IiwiYnl0ZXMiLCJyZWRpcmVjdENvdW50IiwiUHJvbWlzZSIsInNjaGVtZSIsImJsb2JVUkxFbnRyeSIsInNlYXJjaCIsImJsb2IiLCJ0b1N0cmluZyIsImZ1bGxMZW5ndGgiLCJzaXplIiwic2VyaWFsaXplZEZ1bGxMZW5ndGgiLCJib2R5V2l0aFR5cGUiLCJzdGF0dXNUZXh0Iiwic2V0IiwicmFuZ2VIZWFkZXIiLCJnZXQiLCJyYW5nZVZhbHVlIiwicmFuZ2VTdGFydFZhbHVlIiwicmFuZ2VTdGFydCIsInJhbmdlRW5kVmFsdWUiLCJyYW5nZUVuZCIsInNsaWNlZEJsb2IiLCJzbGljZSIsInNsaWNlZEJvZHlXaXRoVHlwZSIsInNlcmlhbGl6ZWRTbGljZWRMZW5ndGgiLCJjb250ZW50UmFuZ2UiLCJkYXRhVVJMU3RydWN0IiwibWltZVR5cGUiLCJmaW5hbGl6ZVJlc3BvbnNlIiwiZG9uZSIsInByb2Nlc3NSZXNwb25zZURvbmUiLCJxdWV1ZU1pY3JvdGFzayIsInVuc2FmZUVuZFRpbWUiLCJEYXRlIiwibm93IiwiZnVsbFRpbWluZ0luZm8iLCJyZXBvcnRUaW1pbmdTdGVwcyIsImJvZHlJbmZvIiwicmVzcG9uc2VTdGF0dXMiLCJoYXNDcm9zc09yaWdpblJlZGlyZWN0cyIsImNvbnRlbnRUeXBlIiwicHJvY2Vzc1Jlc3BvbnNlRW5kT2ZCb2R5VGFzayIsImFjdHVhbFJlc3BvbnNlIiwiaHR0cE5ldHdvcmtPckNhY2hlRmV0Y2giLCJodHRwUmVkaXJlY3RGZXRjaCIsImxvY2F0aW9uVVJMIiwiaGFzaCIsInVzZXJuYW1lIiwicGFzc3dvcmQiLCJzb3VyY2UiLCJoZWFkZXJOYW1lIiwiZGVsZXRlIiwicmVkaXJlY3RFbmRUaW1lIiwicG9zdFJlZGlyZWN0U3RhcnRUaW1lIiwicmVkaXJlY3RTdGFydFRpbWUiLCJpc0F1dGhlbnRpY2F0aW9uRmV0Y2giLCJpc05ld0Nvbm5lY3Rpb25GZXRjaCIsImh0dHBGZXRjaFBhcmFtcyIsImh0dHBSZXF1ZXN0IiwiaHR0cENhY2hlIiwicmV2YWxpZGF0aW5nRmxhZyIsImluY2x1ZGVDcmVkZW50aWFscyIsImNyZWRlbnRpYWxzIiwiY29udGVudExlbmd0aCIsImNvbnRlbnRMZW5ndGhIZWFkZXJWYWx1ZSIsImtlZXBhbGl2ZSIsIlVSTCIsImNhY2hlIiwicHJldmVudE5vQ2FjaGVDYWNoZUNvbnRyb2xIZWFkZXJNb2RpZmljYXRpb24iLCJmb3J3YXJkUmVzcG9uc2UiLCJodHRwTmV0d29ya0ZldGNoIiwicmVxdWVzdEluY2x1ZGVzQ3JlZGVudGlhbHMiLCJmb3JjZU5ld0Nvbm5lY3Rpb24iLCJkZXN0cm95ZWQiLCJuZXdDb25uZWN0aW9uIiwicmVxdWVzdEJvZHkiLCJwcm9jZXNzQm9keUNodW5rIiwiYnl0ZUxlbmd0aCIsInByb2Nlc3NFbmRPZkJvZHkiLCJzb2NrZXQiLCJkaXNwYXRjaCIsIml0ZXJhdG9yIiwiU3ltYm9sIiwiYXN5bmNJdGVyYXRvciIsIm5leHQiLCJwdWxsQWxnb3JpdGhtIiwicmVzdW1lIiwiY2FuY2VsQWxnb3JpdGhtIiwiUmVhZGFibGVTdHJlYW0iLCJzdGFydCIsInB1bGwiLCJvbkFib3J0ZWQiLCJvbiIsImlzRmFpbHVyZSIsImVuZGVkIiwiZW5jb2RlZEJvZHlTaXplIiwiZGVjb2RlZEJvZHlTaXplIiwiYnVmZmVyIiwiVWludDhBcnJheSIsImVucXVldWUiLCJkZXNpcmVkU2l6ZSIsImFnZW50IiwicGF0aCIsInBhdGhuYW1lIiwiaXNNb2NrQWN0aXZlIiwiZW50cmllcyIsIm1heFJlZGlyZWN0aW9ucyIsInVwZ3JhZGUiLCJvbkNvbm5lY3QiLCJmaW5hbENvbm5lY3Rpb25UaW1pbmdJbmZvIiwiZmluYWxOZXR3b3JrUmVxdWVzdFN0YXJ0VGltZSIsIm9uUmVzcG9uc2VTdGFydGVkIiwiZmluYWxOZXR3b3JrUmVzcG9uc2VTdGFydFRpbWUiLCJvbkhlYWRlcnMiLCJyYXdIZWFkZXJzIiwiY29kaW5ncyIsImxvY2F0aW9uIiwiaSIsImNvbnRlbnRFbmNvZGluZyIsInRvTG93ZXJDYXNlIiwic3BsaXQiLCJtYXAiLCJ4IiwidHJpbSIsInJlYWQiLCJkZWNvZGVycyIsIndpbGxGb2xsb3ciLCJjb2RpbmciLCJjcmVhdGVHdW56aXAiLCJmbHVzaCIsImNvbnN0YW50cyIsIlpfU1lOQ19GTFVTSCIsImZpbmlzaEZsdXNoIiwiY3JlYXRlQnJvdGxpRGVjb21wcmVzcyIsIm9uRGF0YSIsImNodW5rIiwib25Db21wbGV0ZSIsIm9mZiIsIm9uRXJyb3IiLCJvblVwZ3JhZGUiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/fetch/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/fetch/request.js":
/*!******************************************************!*\
  !*** ./node_modules/undici/lib/web/fetch/request.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* globals AbortController */ \nconst { extractBody, mixinBody, cloneBody } = __webpack_require__(/*! ./body */ \"(ssr)/./node_modules/undici/lib/web/fetch/body.js\");\nconst { Headers, fill: fillHeaders, HeadersList, setHeadersGuard, getHeadersGuard, setHeadersList, getHeadersList } = __webpack_require__(/*! ./headers */ \"(ssr)/./node_modules/undici/lib/web/fetch/headers.js\");\nconst { FinalizationRegistry } = __webpack_require__(/*! ./dispatcher-weakref */ \"(ssr)/./node_modules/undici/lib/web/fetch/dispatcher-weakref.js\")();\nconst util = __webpack_require__(/*! ../../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\");\nconst nodeUtil = __webpack_require__(/*! node:util */ \"node:util\");\nconst { isValidHTTPToken, sameOrigin, environmentSettingsObject } = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/undici/lib/web/fetch/util.js\");\nconst { forbiddenMethodsSet, corsSafeListedMethodsSet, referrerPolicy, requestRedirect, requestMode, requestCredentials, requestCache, requestDuplex } = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/undici/lib/web/fetch/constants.js\");\nconst { kEnumerableProperty, normalizedMethodRecordsBase, normalizedMethodRecords } = util;\nconst { kHeaders, kSignal, kState, kDispatcher } = __webpack_require__(/*! ./symbols */ \"(ssr)/./node_modules/undici/lib/web/fetch/symbols.js\");\nconst { webidl } = __webpack_require__(/*! ./webidl */ \"(ssr)/./node_modules/undici/lib/web/fetch/webidl.js\");\nconst { URLSerializer } = __webpack_require__(/*! ./data-url */ \"(ssr)/./node_modules/undici/lib/web/fetch/data-url.js\");\nconst { kConstruct } = __webpack_require__(/*! ../../core/symbols */ \"(ssr)/./node_modules/undici/lib/core/symbols.js\");\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\");\nconst { getMaxListeners, setMaxListeners, getEventListeners, defaultMaxListeners } = __webpack_require__(/*! node:events */ \"node:events\");\nconst kAbortController = Symbol(\"abortController\");\nconst requestFinalizer = new FinalizationRegistry(({ signal, abort })=>{\n    signal.removeEventListener(\"abort\", abort);\n});\nconst dependentControllerMap = new WeakMap();\nfunction buildAbort(acRef) {\n    return abort;\n    function abort() {\n        const ac = acRef.deref();\n        if (ac !== undefined) {\n            // Currently, there is a problem with FinalizationRegistry.\n            // https://github.com/nodejs/node/issues/49344\n            // https://github.com/nodejs/node/issues/47748\n            // In the case of abort, the first step is to unregister from it.\n            // If the controller can refer to it, it is still registered.\n            // It will be removed in the future.\n            requestFinalizer.unregister(abort);\n            // Unsubscribe a listener.\n            // FinalizationRegistry will no longer be called, so this must be done.\n            this.removeEventListener(\"abort\", abort);\n            ac.abort(this.reason);\n            const controllerList = dependentControllerMap.get(ac.signal);\n            if (controllerList !== undefined) {\n                if (controllerList.size !== 0) {\n                    for (const ref of controllerList){\n                        const ctrl = ref.deref();\n                        if (ctrl !== undefined) {\n                            ctrl.abort(this.reason);\n                        }\n                    }\n                    controllerList.clear();\n                }\n                dependentControllerMap.delete(ac.signal);\n            }\n        }\n    }\n}\nlet patchMethodWarning = false;\n// https://fetch.spec.whatwg.org/#request-class\nclass Request {\n    // https://fetch.spec.whatwg.org/#dom-request\n    constructor(input, init = {}){\n        if (input === kConstruct) {\n            return;\n        }\n        const prefix = \"Request constructor\";\n        webidl.argumentLengthCheck(arguments, 1, prefix);\n        input = webidl.converters.RequestInfo(input, prefix, \"input\");\n        init = webidl.converters.RequestInit(init, prefix, \"init\");\n        // 1. Let request be null.\n        let request = null;\n        // 2. Let fallbackMode be null.\n        let fallbackMode = null;\n        // 3. Let baseURL be thiss relevant settings objects API base URL.\n        const baseUrl = environmentSettingsObject.settingsObject.baseUrl;\n        // 4. Let signal be null.\n        let signal = null;\n        // 5. If input is a string, then:\n        if (typeof input === \"string\") {\n            this[kDispatcher] = init.dispatcher;\n            // 1. Let parsedURL be the result of parsing input with baseURL.\n            // 2. If parsedURL is failure, then throw a TypeError.\n            let parsedURL;\n            try {\n                parsedURL = new URL(input, baseUrl);\n            } catch (err) {\n                throw new TypeError(\"Failed to parse URL from \" + input, {\n                    cause: err\n                });\n            }\n            // 3. If parsedURL includes credentials, then throw a TypeError.\n            if (parsedURL.username || parsedURL.password) {\n                throw new TypeError(\"Request cannot be constructed from a URL that includes credentials: \" + input);\n            }\n            // 4. Set request to a new request whose URL is parsedURL.\n            request = makeRequest({\n                urlList: [\n                    parsedURL\n                ]\n            });\n            // 5. Set fallbackMode to \"cors\".\n            fallbackMode = \"cors\";\n        } else {\n            this[kDispatcher] = init.dispatcher || input[kDispatcher];\n            // 6. Otherwise:\n            // 7. Assert: input is a Request object.\n            assert(input instanceof Request);\n            // 8. Set request to inputs request.\n            request = input[kState];\n            // 9. Set signal to inputs signal.\n            signal = input[kSignal];\n        }\n        // 7. Let origin be thiss relevant settings objects origin.\n        const origin = environmentSettingsObject.settingsObject.origin;\n        // 8. Let window be \"client\".\n        let window = \"client\";\n        // 9. If requests window is an environment settings object and its origin\n        // is same origin with origin, then set window to requests window.\n        if (request.window?.constructor?.name === \"EnvironmentSettingsObject\" && sameOrigin(request.window, origin)) {\n            window = request.window;\n        }\n        // 10. If init[\"window\"] exists and is non-null, then throw a TypeError.\n        if (init.window != null) {\n            throw new TypeError(`'window' option '${window}' must be null`);\n        }\n        // 11. If init[\"window\"] exists, then set window to \"no-window\".\n        if (\"window\" in init) {\n            window = \"no-window\";\n        }\n        // 12. Set request to a new request with the following properties:\n        request = makeRequest({\n            // URL requests URL.\n            // undici implementation note: this is set as the first item in request's urlList in makeRequest\n            // method requests method.\n            method: request.method,\n            // header list A copy of requests header list.\n            // undici implementation note: headersList is cloned in makeRequest\n            headersList: request.headersList,\n            // unsafe-request flag Set.\n            unsafeRequest: request.unsafeRequest,\n            // client Thiss relevant settings object.\n            client: environmentSettingsObject.settingsObject,\n            // window window.\n            window,\n            // priority requests priority.\n            priority: request.priority,\n            // origin requests origin. The propagation of the origin is only significant for navigation requests\n            // being handled by a service worker. In this scenario a request can have an origin that is different\n            // from the current client.\n            origin: request.origin,\n            // referrer requests referrer.\n            referrer: request.referrer,\n            // referrer policy requests referrer policy.\n            referrerPolicy: request.referrerPolicy,\n            // mode requests mode.\n            mode: request.mode,\n            // credentials mode requests credentials mode.\n            credentials: request.credentials,\n            // cache mode requests cache mode.\n            cache: request.cache,\n            // redirect mode requests redirect mode.\n            redirect: request.redirect,\n            // integrity metadata requests integrity metadata.\n            integrity: request.integrity,\n            // keepalive requests keepalive.\n            keepalive: request.keepalive,\n            // reload-navigation flag requests reload-navigation flag.\n            reloadNavigation: request.reloadNavigation,\n            // history-navigation flag requests history-navigation flag.\n            historyNavigation: request.historyNavigation,\n            // URL list A clone of requests URL list.\n            urlList: [\n                ...request.urlList\n            ]\n        });\n        const initHasKey = Object.keys(init).length !== 0;\n        // 13. If init is not empty, then:\n        if (initHasKey) {\n            // 1. If requests mode is \"navigate\", then set it to \"same-origin\".\n            if (request.mode === \"navigate\") {\n                request.mode = \"same-origin\";\n            }\n            // 2. Unset requests reload-navigation flag.\n            request.reloadNavigation = false;\n            // 3. Unset requests history-navigation flag.\n            request.historyNavigation = false;\n            // 4. Set requests origin to \"client\".\n            request.origin = \"client\";\n            // 5. Set requests referrer to \"client\"\n            request.referrer = \"client\";\n            // 6. Set requests referrer policy to the empty string.\n            request.referrerPolicy = \"\";\n            // 7. Set requests URL to requests current URL.\n            request.url = request.urlList[request.urlList.length - 1];\n            // 8. Set requests URL list to  requests URL .\n            request.urlList = [\n                request.url\n            ];\n        }\n        // 14. If init[\"referrer\"] exists, then:\n        if (init.referrer !== undefined) {\n            // 1. Let referrer be init[\"referrer\"].\n            const referrer = init.referrer;\n            // 2. If referrer is the empty string, then set requests referrer to \"no-referrer\".\n            if (referrer === \"\") {\n                request.referrer = \"no-referrer\";\n            } else {\n                // 1. Let parsedReferrer be the result of parsing referrer with\n                // baseURL.\n                // 2. If parsedReferrer is failure, then throw a TypeError.\n                let parsedReferrer;\n                try {\n                    parsedReferrer = new URL(referrer, baseUrl);\n                } catch (err) {\n                    throw new TypeError(`Referrer \"${referrer}\" is not a valid URL.`, {\n                        cause: err\n                    });\n                }\n                // 3. If one of the following is true\n                // - parsedReferrers scheme is \"about\" and path is the string \"client\"\n                // - parsedReferrers origin is not same origin with origin\n                // then set requests referrer to \"client\".\n                if (parsedReferrer.protocol === \"about:\" && parsedReferrer.hostname === \"client\" || origin && !sameOrigin(parsedReferrer, environmentSettingsObject.settingsObject.baseUrl)) {\n                    request.referrer = \"client\";\n                } else {\n                    // 4. Otherwise, set requests referrer to parsedReferrer.\n                    request.referrer = parsedReferrer;\n                }\n            }\n        }\n        // 15. If init[\"referrerPolicy\"] exists, then set requests referrer policy\n        // to it.\n        if (init.referrerPolicy !== undefined) {\n            request.referrerPolicy = init.referrerPolicy;\n        }\n        // 16. Let mode be init[\"mode\"] if it exists, and fallbackMode otherwise.\n        let mode;\n        if (init.mode !== undefined) {\n            mode = init.mode;\n        } else {\n            mode = fallbackMode;\n        }\n        // 17. If mode is \"navigate\", then throw a TypeError.\n        if (mode === \"navigate\") {\n            throw webidl.errors.exception({\n                header: \"Request constructor\",\n                message: \"invalid request mode navigate.\"\n            });\n        }\n        // 18. If mode is non-null, set requests mode to mode.\n        if (mode != null) {\n            request.mode = mode;\n        }\n        // 19. If init[\"credentials\"] exists, then set requests credentials mode\n        // to it.\n        if (init.credentials !== undefined) {\n            request.credentials = init.credentials;\n        }\n        // 18. If init[\"cache\"] exists, then set requests cache mode to it.\n        if (init.cache !== undefined) {\n            request.cache = init.cache;\n        }\n        // 21. If requests cache mode is \"only-if-cached\" and requests mode is\n        // not \"same-origin\", then throw a TypeError.\n        if (request.cache === \"only-if-cached\" && request.mode !== \"same-origin\") {\n            throw new TypeError(\"'only-if-cached' can be set only with 'same-origin' mode\");\n        }\n        // 22. If init[\"redirect\"] exists, then set requests redirect mode to it.\n        if (init.redirect !== undefined) {\n            request.redirect = init.redirect;\n        }\n        // 23. If init[\"integrity\"] exists, then set requests integrity metadata to it.\n        if (init.integrity != null) {\n            request.integrity = String(init.integrity);\n        }\n        // 24. If init[\"keepalive\"] exists, then set requests keepalive to it.\n        if (init.keepalive !== undefined) {\n            request.keepalive = Boolean(init.keepalive);\n        }\n        // 25. If init[\"method\"] exists, then:\n        if (init.method !== undefined) {\n            // 1. Let method be init[\"method\"].\n            let method = init.method;\n            const mayBeNormalized = normalizedMethodRecords[method];\n            if (mayBeNormalized !== undefined) {\n                // Note: Bypass validation DELETE, GET, HEAD, OPTIONS, POST, PUT, PATCH and these lowercase ones\n                request.method = mayBeNormalized;\n            } else {\n                // 2. If method is not a method or method is a forbidden method, then\n                // throw a TypeError.\n                if (!isValidHTTPToken(method)) {\n                    throw new TypeError(`'${method}' is not a valid HTTP method.`);\n                }\n                const upperCase = method.toUpperCase();\n                if (forbiddenMethodsSet.has(upperCase)) {\n                    throw new TypeError(`'${method}' HTTP method is unsupported.`);\n                }\n                // 3. Normalize method.\n                // https://fetch.spec.whatwg.org/#concept-method-normalize\n                // Note: must be in uppercase\n                method = normalizedMethodRecordsBase[upperCase] ?? method;\n                // 4. Set requests method to method.\n                request.method = method;\n            }\n            if (!patchMethodWarning && request.method === \"patch\") {\n                process.emitWarning(\"Using `patch` is highly likely to result in a `405 Method Not Allowed`. `PATCH` is much more likely to succeed.\", {\n                    code: \"UNDICI-FETCH-patch\"\n                });\n                patchMethodWarning = true;\n            }\n        }\n        // 26. If init[\"signal\"] exists, then set signal to it.\n        if (init.signal !== undefined) {\n            signal = init.signal;\n        }\n        // 27. Set thiss request to request.\n        this[kState] = request;\n        // 28. Set thiss signal to a new AbortSignal object with thiss relevant\n        // Realm.\n        // TODO: could this be simplified with AbortSignal.any\n        // (https://dom.spec.whatwg.org/#dom-abortsignal-any)\n        const ac = new AbortController();\n        this[kSignal] = ac.signal;\n        // 29. If signal is not null, then make thiss signal follow signal.\n        if (signal != null) {\n            if (!signal || typeof signal.aborted !== \"boolean\" || typeof signal.addEventListener !== \"function\") {\n                throw new TypeError(\"Failed to construct 'Request': member signal is not of type AbortSignal.\");\n            }\n            if (signal.aborted) {\n                ac.abort(signal.reason);\n            } else {\n                // Keep a strong ref to ac while request object\n                // is alive. This is needed to prevent AbortController\n                // from being prematurely garbage collected.\n                // See, https://github.com/nodejs/undici/issues/1926.\n                this[kAbortController] = ac;\n                const acRef = new WeakRef(ac);\n                const abort = buildAbort(acRef);\n                // Third-party AbortControllers may not work with these.\n                // See, https://github.com/nodejs/undici/pull/1910#issuecomment-1464495619.\n                try {\n                    // If the max amount of listeners is equal to the default, increase it\n                    // This is only available in node >= v19.9.0\n                    if (typeof getMaxListeners === \"function\" && getMaxListeners(signal) === defaultMaxListeners) {\n                        setMaxListeners(1500, signal);\n                    } else if (getEventListeners(signal, \"abort\").length >= defaultMaxListeners) {\n                        setMaxListeners(1500, signal);\n                    }\n                } catch  {}\n                util.addAbortListener(signal, abort);\n                // The third argument must be a registry key to be unregistered.\n                // Without it, you cannot unregister.\n                // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/FinalizationRegistry\n                // abort is used as the unregister key. (because it is unique)\n                requestFinalizer.register(ac, {\n                    signal,\n                    abort\n                }, abort);\n            }\n        }\n        // 30. Set thiss headers to a new Headers object with thiss relevant\n        // Realm, whose header list is requests header list and guard is\n        // \"request\".\n        this[kHeaders] = new Headers(kConstruct);\n        setHeadersList(this[kHeaders], request.headersList);\n        setHeadersGuard(this[kHeaders], \"request\");\n        // 31. If thiss requests mode is \"no-cors\", then:\n        if (mode === \"no-cors\") {\n            // 1. If thiss requests method is not a CORS-safelisted method,\n            // then throw a TypeError.\n            if (!corsSafeListedMethodsSet.has(request.method)) {\n                throw new TypeError(`'${request.method} is unsupported in no-cors mode.`);\n            }\n            // 2. Set thiss headerss guard to \"request-no-cors\".\n            setHeadersGuard(this[kHeaders], \"request-no-cors\");\n        }\n        // 32. If init is not empty, then:\n        if (initHasKey) {\n            /** @type {HeadersList} */ const headersList = getHeadersList(this[kHeaders]);\n            // 1. Let headers be a copy of thiss headers and its associated header\n            // list.\n            // 2. If init[\"headers\"] exists, then set headers to init[\"headers\"].\n            const headers = init.headers !== undefined ? init.headers : new HeadersList(headersList);\n            // 3. Empty thiss headerss header list.\n            headersList.clear();\n            // 4. If headers is a Headers object, then for each header in its header\n            // list, append headers name/headers value to thiss headers.\n            if (headers instanceof HeadersList) {\n                for (const { name, value } of headers.rawValues()){\n                    headersList.append(name, value, false);\n                }\n                // Note: Copy the `set-cookie` meta-data.\n                headersList.cookies = headers.cookies;\n            } else {\n                // 5. Otherwise, fill thiss headers with headers.\n                fillHeaders(this[kHeaders], headers);\n            }\n        }\n        // 33. Let inputBody be inputs requests body if input is a Request\n        // object; otherwise null.\n        const inputBody = input instanceof Request ? input[kState].body : null;\n        // 34. If either init[\"body\"] exists and is non-null or inputBody is\n        // non-null, and requests method is `GET` or `HEAD`, then throw a\n        // TypeError.\n        if ((init.body != null || inputBody != null) && (request.method === \"GET\" || request.method === \"HEAD\")) {\n            throw new TypeError(\"Request with GET/HEAD method cannot have body.\");\n        }\n        // 35. Let initBody be null.\n        let initBody = null;\n        // 36. If init[\"body\"] exists and is non-null, then:\n        if (init.body != null) {\n            // 1. Let Content-Type be null.\n            // 2. Set initBody and Content-Type to the result of extracting\n            // init[\"body\"], with keepalive set to requests keepalive.\n            const [extractedBody, contentType] = extractBody(init.body, request.keepalive);\n            initBody = extractedBody;\n            // 3, If Content-Type is non-null and thiss headerss header list does\n            // not contain `Content-Type`, then append `Content-Type`/Content-Type to\n            // thiss headers.\n            if (contentType && !getHeadersList(this[kHeaders]).contains(\"content-type\", true)) {\n                this[kHeaders].append(\"content-type\", contentType);\n            }\n        }\n        // 37. Let inputOrInitBody be initBody if it is non-null; otherwise\n        // inputBody.\n        const inputOrInitBody = initBody ?? inputBody;\n        // 38. If inputOrInitBody is non-null and inputOrInitBodys source is\n        // null, then:\n        if (inputOrInitBody != null && inputOrInitBody.source == null) {\n            // 1. If initBody is non-null and init[\"duplex\"] does not exist,\n            //    then throw a TypeError.\n            if (initBody != null && init.duplex == null) {\n                throw new TypeError(\"RequestInit: duplex option is required when sending a body.\");\n            }\n            // 2. If thiss requests mode is neither \"same-origin\" nor \"cors\",\n            // then throw a TypeError.\n            if (request.mode !== \"same-origin\" && request.mode !== \"cors\") {\n                throw new TypeError('If request is made from ReadableStream, mode should be \"same-origin\" or \"cors\"');\n            }\n            // 3. Set thiss requests use-CORS-preflight flag.\n            request.useCORSPreflightFlag = true;\n        }\n        // 39. Let finalBody be inputOrInitBody.\n        let finalBody = inputOrInitBody;\n        // 40. If initBody is null and inputBody is non-null, then:\n        if (initBody == null && inputBody != null) {\n            // 1. If input is unusable, then throw a TypeError.\n            if (util.isDisturbed(inputBody.stream) || inputBody.stream.locked) {\n                throw new TypeError(\"Cannot construct a Request with a Request object that has already been used.\");\n            }\n            // 2. Set finalBody to the result of creating a proxy for inputBody.\n            // https://streams.spec.whatwg.org/#readablestream-create-a-proxy\n            const identityTransform = new TransformStream();\n            inputBody.stream.pipeThrough(identityTransform);\n            finalBody = {\n                source: inputBody.source,\n                length: inputBody.length,\n                stream: identityTransform.readable\n            };\n        }\n        // 41. Set thiss requests body to finalBody.\n        this[kState].body = finalBody;\n    }\n    // Returns requests HTTP method, which is \"GET\" by default.\n    get method() {\n        webidl.brandCheck(this, Request);\n        // The method getter steps are to return thiss requests method.\n        return this[kState].method;\n    }\n    // Returns the URL of request as a string.\n    get url() {\n        webidl.brandCheck(this, Request);\n        // The url getter steps are to return thiss requests URL, serialized.\n        return URLSerializer(this[kState].url);\n    }\n    // Returns a Headers object consisting of the headers associated with request.\n    // Note that headers added in the network layer by the user agent will not\n    // be accounted for in this object, e.g., the \"Host\" header.\n    get headers() {\n        webidl.brandCheck(this, Request);\n        // The headers getter steps are to return thiss headers.\n        return this[kHeaders];\n    }\n    // Returns the kind of resource requested by request, e.g., \"document\"\n    // or \"script\".\n    get destination() {\n        webidl.brandCheck(this, Request);\n        // The destination getter are to return thiss requests destination.\n        return this[kState].destination;\n    }\n    // Returns the referrer of request. Its value can be a same-origin URL if\n    // explicitly set in init, the empty string to indicate no referrer, and\n    // \"about:client\" when defaulting to the globals default. This is used\n    // during fetching to determine the value of the `Referer` header of the\n    // request being made.\n    get referrer() {\n        webidl.brandCheck(this, Request);\n        // 1. If thiss requests referrer is \"no-referrer\", then return the\n        // empty string.\n        if (this[kState].referrer === \"no-referrer\") {\n            return \"\";\n        }\n        // 2. If thiss requests referrer is \"client\", then return\n        // \"about:client\".\n        if (this[kState].referrer === \"client\") {\n            return \"about:client\";\n        }\n        // Return thiss requests referrer, serialized.\n        return this[kState].referrer.toString();\n    }\n    // Returns the referrer policy associated with request.\n    // This is used during fetching to compute the value of the requests\n    // referrer.\n    get referrerPolicy() {\n        webidl.brandCheck(this, Request);\n        // The referrerPolicy getter steps are to return thiss requests referrer policy.\n        return this[kState].referrerPolicy;\n    }\n    // Returns the mode associated with request, which is a string indicating\n    // whether the request will use CORS, or will be restricted to same-origin\n    // URLs.\n    get mode() {\n        webidl.brandCheck(this, Request);\n        // The mode getter steps are to return thiss requests mode.\n        return this[kState].mode;\n    }\n    // Returns the credentials mode associated with request,\n    // which is a string indicating whether credentials will be sent with the\n    // request always, never, or only when sent to a same-origin URL.\n    get credentials() {\n        // The credentials getter steps are to return thiss requests credentials mode.\n        return this[kState].credentials;\n    }\n    // Returns the cache mode associated with request,\n    // which is a string indicating how the request will\n    // interact with the browsers cache when fetching.\n    get cache() {\n        webidl.brandCheck(this, Request);\n        // The cache getter steps are to return thiss requests cache mode.\n        return this[kState].cache;\n    }\n    // Returns the redirect mode associated with request,\n    // which is a string indicating how redirects for the\n    // request will be handled during fetching. A request\n    // will follow redirects by default.\n    get redirect() {\n        webidl.brandCheck(this, Request);\n        // The redirect getter steps are to return thiss requests redirect mode.\n        return this[kState].redirect;\n    }\n    // Returns requests subresource integrity metadata, which is a\n    // cryptographic hash of the resource being fetched. Its value\n    // consists of multiple hashes separated by whitespace. [SRI]\n    get integrity() {\n        webidl.brandCheck(this, Request);\n        // The integrity getter steps are to return thiss requests integrity\n        // metadata.\n        return this[kState].integrity;\n    }\n    // Returns a boolean indicating whether or not request can outlive the\n    // global in which it was created.\n    get keepalive() {\n        webidl.brandCheck(this, Request);\n        // The keepalive getter steps are to return thiss requests keepalive.\n        return this[kState].keepalive;\n    }\n    // Returns a boolean indicating whether or not request is for a reload\n    // navigation.\n    get isReloadNavigation() {\n        webidl.brandCheck(this, Request);\n        // The isReloadNavigation getter steps are to return true if thiss\n        // requests reload-navigation flag is set; otherwise false.\n        return this[kState].reloadNavigation;\n    }\n    // Returns a boolean indicating whether or not request is for a history\n    // navigation (a.k.a. back-forward navigation).\n    get isHistoryNavigation() {\n        webidl.brandCheck(this, Request);\n        // The isHistoryNavigation getter steps are to return true if thiss requests\n        // history-navigation flag is set; otherwise false.\n        return this[kState].historyNavigation;\n    }\n    // Returns the signal associated with request, which is an AbortSignal\n    // object indicating whether or not request has been aborted, and its\n    // abort event handler.\n    get signal() {\n        webidl.brandCheck(this, Request);\n        // The signal getter steps are to return thiss signal.\n        return this[kSignal];\n    }\n    get body() {\n        webidl.brandCheck(this, Request);\n        return this[kState].body ? this[kState].body.stream : null;\n    }\n    get bodyUsed() {\n        webidl.brandCheck(this, Request);\n        return !!this[kState].body && util.isDisturbed(this[kState].body.stream);\n    }\n    get duplex() {\n        webidl.brandCheck(this, Request);\n        return \"half\";\n    }\n    // Returns a clone of request.\n    clone() {\n        webidl.brandCheck(this, Request);\n        // 1. If this is unusable, then throw a TypeError.\n        if (this.bodyUsed || this.body?.locked) {\n            throw new TypeError(\"unusable\");\n        }\n        // 2. Let clonedRequest be the result of cloning thiss request.\n        const clonedRequest = cloneRequest(this[kState]);\n        // 3. Let clonedRequestObject be the result of creating a Request object,\n        // given clonedRequest, thiss headerss guard, and thiss relevant Realm.\n        // 4. Make clonedRequestObjects signal follow thiss signal.\n        const ac = new AbortController();\n        if (this.signal.aborted) {\n            ac.abort(this.signal.reason);\n        } else {\n            let list = dependentControllerMap.get(this.signal);\n            if (list === undefined) {\n                list = new Set();\n                dependentControllerMap.set(this.signal, list);\n            }\n            const acRef = new WeakRef(ac);\n            list.add(acRef);\n            util.addAbortListener(ac.signal, buildAbort(acRef));\n        }\n        // 4. Return clonedRequestObject.\n        return fromInnerRequest(clonedRequest, ac.signal, getHeadersGuard(this[kHeaders]));\n    }\n    [nodeUtil.inspect.custom](depth, options) {\n        if (options.depth === null) {\n            options.depth = 2;\n        }\n        options.colors ??= true;\n        const properties = {\n            method: this.method,\n            url: this.url,\n            headers: this.headers,\n            destination: this.destination,\n            referrer: this.referrer,\n            referrerPolicy: this.referrerPolicy,\n            mode: this.mode,\n            credentials: this.credentials,\n            cache: this.cache,\n            redirect: this.redirect,\n            integrity: this.integrity,\n            keepalive: this.keepalive,\n            isReloadNavigation: this.isReloadNavigation,\n            isHistoryNavigation: this.isHistoryNavigation,\n            signal: this.signal\n        };\n        return `Request ${nodeUtil.formatWithOptions(options, properties)}`;\n    }\n}\nmixinBody(Request);\n// https://fetch.spec.whatwg.org/#requests\nfunction makeRequest(init) {\n    return {\n        method: init.method ?? \"GET\",\n        localURLsOnly: init.localURLsOnly ?? false,\n        unsafeRequest: init.unsafeRequest ?? false,\n        body: init.body ?? null,\n        client: init.client ?? null,\n        reservedClient: init.reservedClient ?? null,\n        replacesClientId: init.replacesClientId ?? \"\",\n        window: init.window ?? \"client\",\n        keepalive: init.keepalive ?? false,\n        serviceWorkers: init.serviceWorkers ?? \"all\",\n        initiator: init.initiator ?? \"\",\n        destination: init.destination ?? \"\",\n        priority: init.priority ?? null,\n        origin: init.origin ?? \"client\",\n        policyContainer: init.policyContainer ?? \"client\",\n        referrer: init.referrer ?? \"client\",\n        referrerPolicy: init.referrerPolicy ?? \"\",\n        mode: init.mode ?? \"no-cors\",\n        useCORSPreflightFlag: init.useCORSPreflightFlag ?? false,\n        credentials: init.credentials ?? \"same-origin\",\n        useCredentials: init.useCredentials ?? false,\n        cache: init.cache ?? \"default\",\n        redirect: init.redirect ?? \"follow\",\n        integrity: init.integrity ?? \"\",\n        cryptoGraphicsNonceMetadata: init.cryptoGraphicsNonceMetadata ?? \"\",\n        parserMetadata: init.parserMetadata ?? \"\",\n        reloadNavigation: init.reloadNavigation ?? false,\n        historyNavigation: init.historyNavigation ?? false,\n        userActivation: init.userActivation ?? false,\n        taintedOrigin: init.taintedOrigin ?? false,\n        redirectCount: init.redirectCount ?? 0,\n        responseTainting: init.responseTainting ?? \"basic\",\n        preventNoCacheCacheControlHeaderModification: init.preventNoCacheCacheControlHeaderModification ?? false,\n        done: init.done ?? false,\n        timingAllowFailed: init.timingAllowFailed ?? false,\n        urlList: init.urlList,\n        url: init.urlList[0],\n        headersList: init.headersList ? new HeadersList(init.headersList) : new HeadersList()\n    };\n}\n// https://fetch.spec.whatwg.org/#concept-request-clone\nfunction cloneRequest(request) {\n    // To clone a request request, run these steps:\n    // 1. Let newRequest be a copy of request, except for its body.\n    const newRequest = makeRequest({\n        ...request,\n        body: null\n    });\n    // 2. If requests body is non-null, set newRequests body to the\n    // result of cloning requests body.\n    if (request.body != null) {\n        newRequest.body = cloneBody(request.body);\n    }\n    // 3. Return newRequest.\n    return newRequest;\n}\n/**\n * @see https://fetch.spec.whatwg.org/#request-create\n * @param {any} innerRequest\n * @param {AbortSignal} signal\n * @param {'request' | 'immutable' | 'request-no-cors' | 'response' | 'none'} guard\n * @returns {Request}\n */ function fromInnerRequest(innerRequest, signal, guard) {\n    const request = new Request(kConstruct);\n    request[kState] = innerRequest;\n    request[kSignal] = signal;\n    request[kHeaders] = new Headers(kConstruct);\n    setHeadersList(request[kHeaders], innerRequest.headersList);\n    setHeadersGuard(request[kHeaders], guard);\n    return request;\n}\nObject.defineProperties(Request.prototype, {\n    method: kEnumerableProperty,\n    url: kEnumerableProperty,\n    headers: kEnumerableProperty,\n    redirect: kEnumerableProperty,\n    clone: kEnumerableProperty,\n    signal: kEnumerableProperty,\n    duplex: kEnumerableProperty,\n    destination: kEnumerableProperty,\n    body: kEnumerableProperty,\n    bodyUsed: kEnumerableProperty,\n    isHistoryNavigation: kEnumerableProperty,\n    isReloadNavigation: kEnumerableProperty,\n    keepalive: kEnumerableProperty,\n    integrity: kEnumerableProperty,\n    cache: kEnumerableProperty,\n    credentials: kEnumerableProperty,\n    attribute: kEnumerableProperty,\n    referrerPolicy: kEnumerableProperty,\n    referrer: kEnumerableProperty,\n    mode: kEnumerableProperty,\n    [Symbol.toStringTag]: {\n        value: \"Request\",\n        configurable: true\n    }\n});\nwebidl.converters.Request = webidl.interfaceConverter(Request);\n// https://fetch.spec.whatwg.org/#requestinfo\nwebidl.converters.RequestInfo = function(V, prefix, argument) {\n    if (typeof V === \"string\") {\n        return webidl.converters.USVString(V, prefix, argument);\n    }\n    if (V instanceof Request) {\n        return webidl.converters.Request(V, prefix, argument);\n    }\n    return webidl.converters.USVString(V, prefix, argument);\n};\nwebidl.converters.AbortSignal = webidl.interfaceConverter(AbortSignal);\n// https://fetch.spec.whatwg.org/#requestinit\nwebidl.converters.RequestInit = webidl.dictionaryConverter([\n    {\n        key: \"method\",\n        converter: webidl.converters.ByteString\n    },\n    {\n        key: \"headers\",\n        converter: webidl.converters.HeadersInit\n    },\n    {\n        key: \"body\",\n        converter: webidl.nullableConverter(webidl.converters.BodyInit)\n    },\n    {\n        key: \"referrer\",\n        converter: webidl.converters.USVString\n    },\n    {\n        key: \"referrerPolicy\",\n        converter: webidl.converters.DOMString,\n        // https://w3c.github.io/webappsec-referrer-policy/#referrer-policy\n        allowedValues: referrerPolicy\n    },\n    {\n        key: \"mode\",\n        converter: webidl.converters.DOMString,\n        // https://fetch.spec.whatwg.org/#concept-request-mode\n        allowedValues: requestMode\n    },\n    {\n        key: \"credentials\",\n        converter: webidl.converters.DOMString,\n        // https://fetch.spec.whatwg.org/#requestcredentials\n        allowedValues: requestCredentials\n    },\n    {\n        key: \"cache\",\n        converter: webidl.converters.DOMString,\n        // https://fetch.spec.whatwg.org/#requestcache\n        allowedValues: requestCache\n    },\n    {\n        key: \"redirect\",\n        converter: webidl.converters.DOMString,\n        // https://fetch.spec.whatwg.org/#requestredirect\n        allowedValues: requestRedirect\n    },\n    {\n        key: \"integrity\",\n        converter: webidl.converters.DOMString\n    },\n    {\n        key: \"keepalive\",\n        converter: webidl.converters.boolean\n    },\n    {\n        key: \"signal\",\n        converter: webidl.nullableConverter((signal)=>webidl.converters.AbortSignal(signal, \"RequestInit\", \"signal\", {\n                strict: false\n            }))\n    },\n    {\n        key: \"window\",\n        converter: webidl.converters.any\n    },\n    {\n        key: \"duplex\",\n        converter: webidl.converters.DOMString,\n        allowedValues: requestDuplex\n    },\n    {\n        key: \"dispatcher\",\n        // undici specific option\n        converter: webidl.converters.any\n    }\n]);\nmodule.exports = {\n    Request,\n    makeRequest,\n    fromInnerRequest,\n    cloneRequest\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZmV0Y2gvcmVxdWVzdC5qcyIsIm1hcHBpbmdzIjoiQUFBQSw4QkFFQTtBQUVBLE1BQU0sRUFBRUEsV0FBVyxFQUFFQyxTQUFTLEVBQUVDLFNBQUFBLEVBQVcsR0FBR0MsbUJBQU9BLENBQUM7QUFDdEQsTUFBTSxFQUFFQyxPQUFPLEVBQUVDLE1BQU1DLFdBQVcsRUFBRUMsV0FBVyxFQUFFQyxlQUFlLEVBQUVDLGVBQWUsRUFBRUMsY0FBYyxFQUFFQyxjQUFBQSxFQUFnQixHQUFHUixtQkFBT0EsQ0FBQztBQUM5SCxNQUFNLEVBQUVTLG9CQUFBQSxFQUFzQixHQUFHVCxtQkFBT0EsQ0FBQztBQUN6QyxNQUFNVSxPQUFPVixtQkFBT0EsQ0FBQztBQUNyQixNQUFNVyxXQUFXWCxtQkFBT0EsQ0FBQztBQUN6QixNQUFNLEVBQ0pZLGdCQUFnQixFQUNoQkMsVUFBVSxFQUNWQyx5QkFBQUEsRUFDRCxHQUFHZCxtQkFBT0EsQ0FBQztBQUNaLE1BQU0sRUFDSmUsbUJBQW1CLEVBQ25CQyx3QkFBd0IsRUFDeEJDLGNBQWMsRUFDZEMsZUFBZSxFQUNmQyxXQUFXLEVBQ1hDLGtCQUFrQixFQUNsQkMsWUFBWSxFQUNaQyxhQUFBQSxFQUNELEdBQUd0QixtQkFBT0EsQ0FBQztBQUNaLE1BQU0sRUFBRXVCLG1CQUFtQixFQUFFQywyQkFBMkIsRUFBRUMsdUJBQUFBLEVBQXlCLEdBQUdmO0FBQ3RGLE1BQU0sRUFBRWdCLFFBQVEsRUFBRUMsT0FBTyxFQUFFQyxNQUFNLEVBQUVDLFdBQUFBLEVBQWEsR0FBRzdCLG1CQUFPQSxDQUFDO0FBQzNELE1BQU0sRUFBRThCLE1BQUFBLEVBQVEsR0FBRzlCLG1CQUFPQSxDQUFDO0FBQzNCLE1BQU0sRUFBRStCLGFBQUFBLEVBQWUsR0FBRy9CLG1CQUFPQSxDQUFDO0FBQ2xDLE1BQU0sRUFBRWdDLFVBQUFBLEVBQVksR0FBR2hDLG1CQUFPQSxDQUFDO0FBQy9CLE1BQU1pQyxTQUFT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V0FBVzlLLE9BQU9pTCxpQkFBaUIsQ0FDaEN0SyxDQUFBQSxTQUFXWCxPQUFPc0MsVUFBVSxDQUFDcUksV0FBVyxDQUN2Q2hLLFFBQ0EsZUFDQSxVQUNBO2dCQUFFMkssUUFBUTtZQUFNO0lBR3RCO0lBQ0E7UUFDRVQsS0FBSztRQUNMQyxXQUFXOUssT0FBT3NDLFVBQVUsQ0FBQ2lKLEdBQUFBO0lBQy9CO0lBQ0E7UUFDRVYsS0FBSztRQUNMQyxXQUFXOUssT0FBT3NDLFVBQVUsQ0FBQzZJLFNBQVM7UUFDdENDLGVBQWU1TDtJQUNqQjtJQUNBO1FBQ0VxTCxLQUFLO1FBQWM7UUFDbkJDLFdBQVc5SyxPQUFPc0MsVUFBVSxDQUFDaUosR0FBQUE7SUFDL0I7Q0FDRDtBQUVEQyxPQUFPQyxPQUFPLEdBQUc7SUFBRTFKO0lBQVNzQjtJQUFha0Y7SUFBa0JMO0FBQWEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tb2NrdXBmbG93Ly4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvd2ViL2ZldGNoL3JlcXVlc3QuanM/YzkwOSIsIndlYnBhY2s6Ly9tb2NrdXBmbG93Ly4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvd2ViL2ZldGNoL3JlcXVlc3QuanM/YzkwOSoiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZ2xvYmFscyBBYm9ydENvbnRyb2xsZXIgKi9cblxuJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgZXh0cmFjdEJvZHksIG1peGluQm9keSwgY2xvbmVCb2R5IH0gPSByZXF1aXJlKCcuL2JvZHknKVxuY29uc3QgeyBIZWFkZXJzLCBmaWxsOiBmaWxsSGVhZGVycywgSGVhZGVyc0xpc3QsIHNldEhlYWRlcnNHdWFyZCwgZ2V0SGVhZGVyc0d1YXJkLCBzZXRIZWFkZXJzTGlzdCwgZ2V0SGVhZGVyc0xpc3QgfSA9IHJlcXVpcmUoJy4vaGVhZGVycycpXG5jb25zdCB7IEZpbmFsaXphdGlvblJlZ2lzdHJ5IH0gPSByZXF1aXJlKCcuL2Rpc3BhdGNoZXItd2Vha3JlZicpKClcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCcuLi8uLi9jb3JlL3V0aWwnKVxuY29uc3Qgbm9kZVV0aWwgPSByZXF1aXJlKCdub2RlOnV0aWwnKVxuY29uc3Qge1xuICBpc1ZhbGlkSFRUUFRva2VuLFxuICBzYW1lT3JpZ2luLFxuICBlbnZpcm9ubWVudFNldHRpbmdzT2JqZWN0XG59ID0gcmVxdWlyZSgnLi91dGlsJylcbmNvbnN0IHtcbiAgZm9yYmlkZGVuTWV0aG9kc1NldCxcbiAgY29yc1NhZmVMaXN0ZWRNZXRob2RzU2V0LFxuICByZWZlcnJlclBvbGljeSxcbiAgcmVxdWVzdFJlZGlyZWN0LFxuICByZXF1ZXN0TW9kZSxcbiAgcmVxdWVzdENyZWRlbnRpYWxzLFxuICByZXF1ZXN0Q2FjaGUsXG4gIHJlcXVlc3REdXBsZXhcbn0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpXG5jb25zdCB7IGtFbnVtZXJhYmxlUHJvcGVydHksIG5vcm1hbGl6ZWRNZXRob2RSZWNvcmRzQmFzZSwgbm9ybWFsaXplZE1ldGhvZFJlY29yZHMgfSA9IHV0aWxcbmNvbnN0IHsga0hlYWRlcnMsIGtTaWduYWwsIGtTdGF0ZSwga0Rpc3BhdGNoZXIgfSA9IHJlcXVpcmUoJy4vc3ltYm9scycpXG5jb25zdCB7IHdlYmlkbCB9ID0gcmVxdWlyZSgnLi93ZWJpZGwnKVxuY29uc3QgeyBVUkxTZXJpYWxpemVyIH0gPSByZXF1aXJlKCcuL2RhdGEtdXJsJylcbmNvbnN0IHsga0NvbnN0cnVjdCB9ID0gcmVxdWlyZSgnLi4vLi4vY29yZS9zeW1ib2xzJylcbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ25vZGU6YXNzZXJ0JylcbmNvbnN0IHsgZ2V0TWF4TGlzdGVuZXJzLCBzZXRNYXhMaXN0ZW5lcnMsIGdldEV2ZW50TGlzdGVuZXJzLCBkZWZhdWx0TWF4TGlzdGVuZXJzIH0gPSByZXF1aXJlKCdub2RlOmV2ZW50cycpXG5cbmNvbnN0IGtBYm9ydENvbnRyb2xsZXIgPSBTeW1ib2woJ2Fib3J0Q29udHJvbGxlcicpXG5cbmNvbnN0IHJlcXVlc3RGaW5hbGl6ZXIgPSBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkoKHsgc2lnbmFsLCBhYm9ydCB9KSA9PiB7XG4gIHNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKCdhYm9ydCcsIGFib3J0KVxufSlcblxuY29uc3QgZGVwZW5kZW50Q29udHJvbGxlck1hcCA9IG5ldyBXZWFrTWFwKClcblxuZnVuY3Rpb24gYnVpbGRBYm9ydCAoYWNSZWYpIHtcbiAgcmV0dXJuIGFib3J0XG5cbiAgZnVuY3Rpb24gYWJvcnQgKCkge1xuICAgIGNvbnN0IGFjID0gYWNSZWYuZGVyZWYoKVxuICAgIGlmIChhYyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBDdXJyZW50bHksIHRoZXJlIGlzIGEgcHJvYmxlbSB3aXRoIEZpbmFsaXphdGlvblJlZ2lzdHJ5LlxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2lzc3Vlcy80OTM0NFxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2lzc3Vlcy80Nzc0OFxuICAgICAgLy8gSW4gdGhlIGNhc2Ugb2YgYWJvcnQsIHRoZSBmaXJzdCBzdGVwIGlzIHRvIHVucmVnaXN0ZXIgZnJvbSBpdC5cbiAgICAgIC8vIElmIHRoZSBjb250cm9sbGVyIGNhbiByZWZlciB0byBpdCwgaXQgaXMgc3RpbGwgcmVnaXN0ZXJlZC5cbiAgICAgIC8vIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgZnV0dXJlLlxuICAgICAgcmVxdWVzdEZpbmFsaXplci51bnJlZ2lzdGVyKGFib3J0KVxuXG4gICAgICAvLyBVbnN1YnNjcmliZSBhIGxpc3RlbmVyLlxuICAgICAgLy8gRmluYWxpemF0aW9uUmVnaXN0cnkgd2lsbCBubyBsb25nZXIgYmUgY2FsbGVkLCBzbyB0aGlzIG11c3QgYmUgZG9uZS5cbiAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBhYm9ydClcblxuICAgICAgYWMuYWJvcnQodGhpcy5yZWFzb24pXG5cbiAgICAgIGNvbnN0IGNvbnRyb2xsZXJMaXN0ID0gZGVwZW5kZW50Q29udHJvbGxlck1hcC5nZXQoYWMuc2lnbmFsKVxuXG4gICAgICBpZiAoY29udHJvbGxlckxpc3QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoY29udHJvbGxlckxpc3Quc2l6ZSAhPT0gMCkge1xuICAgICAgICAgIGZvciAoY29uc3QgcmVmIG9mIGNvbnRyb2xsZXJMaXN0KSB7XG4gICAgICAgICAgICBjb25zdCBjdHJsID0gcmVmLmRlcmVmKClcbiAgICAgICAgICAgIGlmIChjdHJsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgY3RybC5hYm9ydCh0aGlzLnJlYXNvbilcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgY29udHJvbGxlckxpc3QuY2xlYXIoKVxuICAgICAgICB9XG4gICAgICAgIGRlcGVuZGVudENvbnRyb2xsZXJNYXAuZGVsZXRlKGFjLnNpZ25hbClcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxubGV0IHBhdGNoTWV0aG9kV2FybmluZyA9IGZhbHNlXG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNyZXF1ZXN0LWNsYXNzXG5jbGFzcyBSZXF1ZXN0IHtcbiAgLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2RvbS1yZXF1ZXN0XG4gIGNvbnN0cnVjdG9yIChpbnB1dCwgaW5pdCA9IHt9KSB7XG4gICAgaWYgKGlucHV0ID09PSBrQ29uc3RydWN0KSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCBwcmVmaXggPSAnUmVxdWVzdCBjb25zdHJ1Y3RvcidcbiAgICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDEsIHByZWZpeClcblxuICAgIGlucHV0ID0gd2ViaWRsLmNvbnZlcnRlcnMuUmVxdWVzdEluZm8oaW5wdXQsIHByZWZpeCwgJ2lucHV0JylcbiAgICBpbml0ID0gd2ViaWRsLmNvbnZlcnRlcnMuUmVxdWVzdEluaXQoaW5pdCwgcHJlZml4LCAnaW5pdCcpXG5cbiAgICAvLyAxLiBMZXQgcmVxdWVzdCBiZSBudWxsLlxuICAgIGxldCByZXF1ZXN0ID0gbnVsbFxuXG4gICAgLy8gMi4gTGV0IGZhbGxiYWNrTW9kZSBiZSBudWxsLlxuICAgIGxldCBmYWxsYmFja01vZGUgPSBudWxsXG5cbiAgICAvLyAzLiBMZXQgYmFzZVVSTCBiZSB0aGlz4oCZcyByZWxldmFudCBzZXR0aW5ncyBvYmplY3TigJlzIEFQSSBiYXNlIFVSTC5cbiAgICBjb25zdCBiYXNlVXJsID0gZW52aXJvbm1lbnRTZXR0aW5nc09iamVjdC5zZXR0aW5nc09iamVjdC5iYXNlVXJsXG5cbiAgICAvLyA0LiBMZXQgc2lnbmFsIGJlIG51bGwuXG4gICAgbGV0IHNpZ25hbCA9IG51bGxcblxuICAgIC8vIDUuIElmIGlucHV0IGlzIGEgc3RyaW5nLCB0aGVuOlxuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aGlzW2tEaXNwYXRjaGVyXSA9IGluaXQuZGlzcGF0Y2hlclxuXG4gICAgICAvLyAxLiBMZXQgcGFyc2VkVVJMIGJlIHRoZSByZXN1bHQgb2YgcGFyc2luZyBpbnB1dCB3aXRoIGJhc2VVUkwuXG4gICAgICAvLyAyLiBJZiBwYXJzZWRVUkwgaXMgZmFpbHVyZSwgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgICAgIGxldCBwYXJzZWRVUkxcbiAgICAgIHRyeSB7XG4gICAgICAgIHBhcnNlZFVSTCA9IG5ldyBVUkwoaW5wdXQsIGJhc2VVcmwpXG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRmFpbGVkIHRvIHBhcnNlIFVSTCBmcm9tICcgKyBpbnB1dCwgeyBjYXVzZTogZXJyIH0pXG4gICAgICB9XG5cbiAgICAgIC8vIDMuIElmIHBhcnNlZFVSTCBpbmNsdWRlcyBjcmVkZW50aWFscywgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgICAgIGlmIChwYXJzZWRVUkwudXNlcm5hbWUgfHwgcGFyc2VkVVJMLnBhc3N3b3JkKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgJ1JlcXVlc3QgY2Fubm90IGJlIGNvbnN0cnVjdGVkIGZyb20gYSBVUkwgdGhhdCBpbmNsdWRlcyBjcmVkZW50aWFsczogJyArXG4gICAgICAgICAgICBpbnB1dFxuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIC8vIDQuIFNldCByZXF1ZXN0IHRvIGEgbmV3IHJlcXVlc3Qgd2hvc2UgVVJMIGlzIHBhcnNlZFVSTC5cbiAgICAgIHJlcXVlc3QgPSBtYWtlUmVxdWVzdCh7IHVybExpc3Q6IFtwYXJzZWRVUkxdIH0pXG5cbiAgICAgIC8vIDUuIFNldCBmYWxsYmFja01vZGUgdG8gXCJjb3JzXCIuXG4gICAgICBmYWxsYmFja01vZGUgPSAnY29ycydcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpc1trRGlzcGF0Y2hlcl0gPSBpbml0LmRpc3BhdGNoZXIgfHwgaW5wdXRba0Rpc3BhdGNoZXJdXG5cbiAgICAgIC8vIDYuIE90aGVyd2lzZTpcblxuICAgICAgLy8gNy4gQXNzZXJ0OiBpbnB1dCBpcyBhIFJlcXVlc3Qgb2JqZWN0LlxuICAgICAgYXNzZXJ0KGlucHV0IGluc3RhbmNlb2YgUmVxdWVzdClcblxuICAgICAgLy8gOC4gU2V0IHJlcXVlc3QgdG8gaW5wdXTigJlzIHJlcXVlc3QuXG4gICAgICByZXF1ZXN0ID0gaW5wdXRba1N0YXRlXVxuXG4gICAgICAvLyA5LiBTZXQgc2lnbmFsIHRvIGlucHV04oCZcyBzaWduYWwuXG4gICAgICBzaWduYWwgPSBpbnB1dFtrU2lnbmFsXVxuICAgIH1cblxuICAgIC8vIDcuIExldCBvcmlnaW4gYmUgdGhpc+KAmXMgcmVsZXZhbnQgc2V0dGluZ3Mgb2JqZWN04oCZcyBvcmlnaW4uXG4gICAgY29uc3Qgb3JpZ2luID0gZW52aXJvbm1lbnRTZXR0aW5nc09iamVjdC5zZXR0aW5nc09iamVjdC5vcmlnaW5cblxuICAgIC8vIDguIExldCB3aW5kb3cgYmUgXCJjbGllbnRcIi5cbiAgICBsZXQgd2luZG93ID0gJ2NsaWVudCdcblxuICAgIC8vIDkuIElmIHJlcXVlc3TigJlzIHdpbmRvdyBpcyBhbiBlbnZpcm9ubWVudCBzZXR0aW5ncyBvYmplY3QgYW5kIGl0cyBvcmlnaW5cbiAgICAvLyBpcyBzYW1lIG9yaWdpbiB3aXRoIG9yaWdpbiwgdGhlbiBzZXQgd2luZG93IHRvIHJlcXVlc3TigJlzIHdpbmRvdy5cbiAgICBpZiAoXG4gICAgICByZXF1ZXN0LndpbmRvdz8uY29uc3RydWN0b3I/Lm5hbWUgPT09ICdFbnZpcm9ubWVudFNldHRpbmdzT2JqZWN0JyAmJlxuICAgICAgc2FtZU9yaWdpbihyZXF1ZXN0LndpbmRvdywgb3JpZ2luKVxuICAgICkge1xuICAgICAgd2luZG93ID0gcmVxdWVzdC53aW5kb3dcbiAgICB9XG5cbiAgICAvLyAxMC4gSWYgaW5pdFtcIndpbmRvd1wiXSBleGlzdHMgYW5kIGlzIG5vbi1udWxsLCB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICAgIGlmIChpbml0LndpbmRvdyAhPSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGAnd2luZG93JyBvcHRpb24gJyR7d2luZG93fScgbXVzdCBiZSBudWxsYClcbiAgICB9XG5cbiAgICAvLyAxMS4gSWYgaW5pdFtcIndpbmRvd1wiXSBleGlzdHMsIHRoZW4gc2V0IHdpbmRvdyB0byBcIm5vLXdpbmRvd1wiLlxuICAgIGlmICgnd2luZG93JyBpbiBpbml0KSB7XG4gICAgICB3aW5kb3cgPSAnbm8td2luZG93J1xuICAgIH1cblxuICAgIC8vIDEyLiBTZXQgcmVxdWVzdCB0byBhIG5ldyByZXF1ZXN0IHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgIHJlcXVlc3QgPSBtYWtlUmVxdWVzdCh7XG4gICAgICAvLyBVUkwgcmVxdWVzdOKAmXMgVVJMLlxuICAgICAgLy8gdW5kaWNpIGltcGxlbWVudGF0aW9uIG5vdGU6IHRoaXMgaXMgc2V0IGFzIHRoZSBmaXJzdCBpdGVtIGluIHJlcXVlc3QncyB1cmxMaXN0IGluIG1ha2VSZXF1ZXN0XG4gICAgICAvLyBtZXRob2QgcmVxdWVzdOKAmXMgbWV0aG9kLlxuICAgICAgbWV0aG9kOiByZXF1ZXN0Lm1ldGhvZCxcbiAgICAgIC8vIGhlYWRlciBsaXN0IEEgY29weSBvZiByZXF1ZXN04oCZcyBoZWFkZXIgbGlzdC5cbiAgICAgIC8vIHVuZGljaSBpbXBsZW1lbnRhdGlvbiBub3RlOiBoZWFkZXJzTGlzdCBpcyBjbG9uZWQgaW4gbWFrZVJlcXVlc3RcbiAgICAgIGhlYWRlcnNMaXN0OiByZXF1ZXN0LmhlYWRlcnNMaXN0LFxuICAgICAgLy8gdW5zYWZlLXJlcXVlc3QgZmxhZyBTZXQuXG4gICAgICB1bnNhZmVSZXF1ZXN0OiByZXF1ZXN0LnVuc2FmZVJlcXVlc3QsXG4gICAgICAvLyBjbGllbnQgVGhpc+KAmXMgcmVsZXZhbnQgc2V0dGluZ3Mgb2JqZWN0LlxuICAgICAgY2xpZW50OiBlbnZpcm9ubWVudFNldHRpbmdzT2JqZWN0LnNldHRpbmdzT2JqZWN0LFxuICAgICAgLy8gd2luZG93IHdpbmRvdy5cbiAgICAgIHdpbmRvdyxcbiAgICAgIC8vIHByaW9yaXR5IHJlcXVlc3TigJlzIHByaW9yaXR5LlxuICAgICAgcHJpb3JpdHk6IHJlcXVlc3QucHJpb3JpdHksXG4gICAgICAvLyBvcmlnaW4gcmVxdWVzdOKAmXMgb3JpZ2luLiBUaGUgcHJvcGFnYXRpb24gb2YgdGhlIG9yaWdpbiBpcyBvbmx5IHNpZ25pZmljYW50IGZvciBuYXZpZ2F0aW9uIHJlcXVlc3RzXG4gICAgICAvLyBiZWluZyBoYW5kbGVkIGJ5IGEgc2VydmljZSB3b3JrZXIuIEluIHRoaXMgc2NlbmFyaW8gYSByZXF1ZXN0IGNhbiBoYXZlIGFuIG9yaWdpbiB0aGF0IGlzIGRpZmZlcmVudFxuICAgICAgLy8gZnJvbSB0aGUgY3VycmVudCBjbGllbnQuXG4gICAgICBvcmlnaW46IHJlcXVlc3Qub3JpZ2luLFxuICAgICAgLy8gcmVmZXJyZXIgcmVxdWVzdOKAmXMgcmVmZXJyZXIuXG4gICAgICByZWZlcnJlcjogcmVxdWVzdC5yZWZlcnJlcixcbiAgICAgIC8vIHJlZmVycmVyIHBvbGljeSByZXF1ZXN04oCZcyByZWZlcnJlciBwb2xpY3kuXG4gICAgICByZWZlcnJlclBvbGljeTogcmVxdWVzdC5yZWZlcnJlclBvbGljeSxcbiAgICAgIC8vIG1vZGUgcmVxdWVzdOKAmXMgbW9kZS5cbiAgICAgIG1vZGU6IHJlcXVlc3QubW9kZSxcbiAgICAgIC8vIGNyZWRlbnRpYWxzIG1vZGUgcmVxdWVzdOKAmXMgY3JlZGVudGlhbHMgbW9kZS5cbiAgICAgIGNyZWRlbnRpYWxzOiByZXF1ZXN0LmNyZWRlbnRpYWxzLFxuICAgICAgLy8gY2FjaGUgbW9kZSByZXF1ZXN04oCZcyBjYWNoZSBtb2RlLlxuICAgICAgY2FjaGU6IHJlcXVlc3QuY2FjaGUsXG4gICAgICAvLyByZWRpcmVjdCBtb2RlIHJlcXVlc3TigJlzIHJlZGlyZWN0IG1vZGUuXG4gICAgICByZWRpcmVjdDogcmVxdWVzdC5yZWRpcmVjdCxcbiAgICAgIC8vIGludGVncml0eSBtZXRhZGF0YSByZXF1ZXN04oCZcyBpbnRlZ3JpdHkgbWV0YWRhdGEuXG4gICAgICBpbnRlZ3JpdHk6IHJlcXVlc3QuaW50ZWdyaXR5LFxuICAgICAgLy8ga2VlcGFsaXZlIHJlcXVlc3TigJlzIGtlZXBhbGl2ZS5cbiAgICAgIGtlZXBhbGl2ZTogcmVxdWVzdC5rZWVwYWxpdmUsXG4gICAgICAvLyByZWxvYWQtbmF2aWdhdGlvbiBmbGFnIHJlcXVlc3TigJlzIHJlbG9hZC1uYXZpZ2F0aW9uIGZsYWcuXG4gICAgICByZWxvYWROYXZpZ2F0aW9uOiByZXF1ZXN0LnJlbG9hZE5hdmlnYXRpb24sXG4gICAgICAvLyBoaXN0b3J5LW5hdmlnYXRpb24gZmxhZyByZXF1ZXN04oCZcyBoaXN0b3J5LW5hdmlnYXRpb24gZmxhZy5cbiAgICAgIGhpc3RvcnlOYXZpZ2F0aW9uOiByZXF1ZXN0Lmhpc3RvcnlOYXZpZ2F0aW9uLFxuICAgICAgLy8gVVJMIGxpc3QgQSBjbG9uZSBvZiByZXF1ZXN04oCZcyBVUkwgbGlzdC5cbiAgICAgIHVybExpc3Q6IFsuLi5yZXF1ZXN0LnVybExpc3RdXG4gICAgfSlcblxuICAgIGNvbnN0IGluaXRIYXNLZXkgPSBPYmplY3Qua2V5cyhpbml0KS5sZW5ndGggIT09IDBcblxuICAgIC8vIDEzLiBJZiBpbml0IGlzIG5vdCBlbXB0eSwgdGhlbjpcbiAgICBpZiAoaW5pdEhhc0tleSkge1xuICAgICAgLy8gMS4gSWYgcmVxdWVzdOKAmXMgbW9kZSBpcyBcIm5hdmlnYXRlXCIsIHRoZW4gc2V0IGl0IHRvIFwic2FtZS1vcmlnaW5cIi5cbiAgICAgIGlmIChyZXF1ZXN0Lm1vZGUgPT09ICduYXZpZ2F0ZScpIHtcbiAgICAgICAgcmVxdWVzdC5tb2RlID0gJ3NhbWUtb3JpZ2luJ1xuICAgICAgfVxuXG4gICAgICAvLyAyLiBVbnNldCByZXF1ZXN04oCZcyByZWxvYWQtbmF2aWdhdGlvbiBmbGFnLlxuICAgICAgcmVxdWVzdC5yZWxvYWROYXZpZ2F0aW9uID0gZmFsc2VcblxuICAgICAgLy8gMy4gVW5zZXQgcmVxdWVzdOKAmXMgaGlzdG9yeS1uYXZpZ2F0aW9uIGZsYWcuXG4gICAgICByZXF1ZXN0Lmhpc3RvcnlOYXZpZ2F0aW9uID0gZmFsc2VcblxuICAgICAgLy8gNC4gU2V0IHJlcXVlc3TigJlzIG9yaWdpbiB0byBcImNsaWVudFwiLlxuICAgICAgcmVxdWVzdC5vcmlnaW4gPSAnY2xpZW50J1xuXG4gICAgICAvLyA1LiBTZXQgcmVxdWVzdOKAmXMgcmVmZXJyZXIgdG8gXCJjbGllbnRcIlxuICAgICAgcmVxdWVzdC5yZWZlcnJlciA9ICdjbGllbnQnXG5cbiAgICAgIC8vIDYuIFNldCByZXF1ZXN04oCZcyByZWZlcnJlciBwb2xpY3kgdG8gdGhlIGVtcHR5IHN0cmluZy5cbiAgICAgIHJlcXVlc3QucmVmZXJyZXJQb2xpY3kgPSAnJ1xuXG4gICAgICAvLyA3LiBTZXQgcmVxdWVzdOKAmXMgVVJMIHRvIHJlcXVlc3TigJlzIGN1cnJlbnQgVVJMLlxuICAgICAgcmVxdWVzdC51cmwgPSByZXF1ZXN0LnVybExpc3RbcmVxdWVzdC51cmxMaXN0Lmxlbmd0aCAtIDFdXG5cbiAgICAgIC8vIDguIFNldCByZXF1ZXN04oCZcyBVUkwgbGlzdCB0byDCqyByZXF1ZXN04oCZcyBVUkwgwrsuXG4gICAgICByZXF1ZXN0LnVybExpc3QgPSBbcmVxdWVzdC51cmxdXG4gICAgfVxuXG4gICAgLy8gMTQuIElmIGluaXRbXCJyZWZlcnJlclwiXSBleGlzdHMsIHRoZW46XG4gICAgaWYgKGluaXQucmVmZXJyZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gMS4gTGV0IHJlZmVycmVyIGJlIGluaXRbXCJyZWZlcnJlclwiXS5cbiAgICAgIGNvbnN0IHJlZmVycmVyID0gaW5pdC5yZWZlcnJlclxuXG4gICAgICAvLyAyLiBJZiByZWZlcnJlciBpcyB0aGUgZW1wdHkgc3RyaW5nLCB0aGVuIHNldCByZXF1ZXN04oCZcyByZWZlcnJlciB0byBcIm5vLXJlZmVycmVyXCIuXG4gICAgICBpZiAocmVmZXJyZXIgPT09ICcnKSB7XG4gICAgICAgIHJlcXVlc3QucmVmZXJyZXIgPSAnbm8tcmVmZXJyZXInXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyAxLiBMZXQgcGFyc2VkUmVmZXJyZXIgYmUgdGhlIHJlc3VsdCBvZiBwYXJzaW5nIHJlZmVycmVyIHdpdGhcbiAgICAgICAgLy8gYmFzZVVSTC5cbiAgICAgICAgLy8gMi4gSWYgcGFyc2VkUmVmZXJyZXIgaXMgZmFpbHVyZSwgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgICAgICAgbGV0IHBhcnNlZFJlZmVycmVyXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcGFyc2VkUmVmZXJyZXIgPSBuZXcgVVJMKHJlZmVycmVyLCBiYXNlVXJsKVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBSZWZlcnJlciBcIiR7cmVmZXJyZXJ9XCIgaXMgbm90IGEgdmFsaWQgVVJMLmAsIHsgY2F1c2U6IGVyciB9KVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gMy4gSWYgb25lIG9mIHRoZSBmb2xsb3dpbmcgaXMgdHJ1ZVxuICAgICAgICAvLyAtIHBhcnNlZFJlZmVycmVy4oCZcyBzY2hlbWUgaXMgXCJhYm91dFwiIGFuZCBwYXRoIGlzIHRoZSBzdHJpbmcgXCJjbGllbnRcIlxuICAgICAgICAvLyAtIHBhcnNlZFJlZmVycmVy4oCZcyBvcmlnaW4gaXMgbm90IHNhbWUgb3JpZ2luIHdpdGggb3JpZ2luXG4gICAgICAgIC8vIHRoZW4gc2V0IHJlcXVlc3TigJlzIHJlZmVycmVyIHRvIFwiY2xpZW50XCIuXG4gICAgICAgIGlmIChcbiAgICAgICAgICAocGFyc2VkUmVmZXJyZXIucHJvdG9jb2wgPT09ICdhYm91dDonICYmIHBhcnNlZFJlZmVycmVyLmhvc3RuYW1lID09PSAnY2xpZW50JykgfHxcbiAgICAgICAgICAob3JpZ2luICYmICFzYW1lT3JpZ2luKHBhcnNlZFJlZmVycmVyLCBlbnZpcm9ubWVudFNldHRpbmdzT2JqZWN0LnNldHRpbmdzT2JqZWN0LmJhc2VVcmwpKVxuICAgICAgICApIHtcbiAgICAgICAgICByZXF1ZXN0LnJlZmVycmVyID0gJ2NsaWVudCdcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyA0LiBPdGhlcndpc2UsIHNldCByZXF1ZXN04oCZcyByZWZlcnJlciB0byBwYXJzZWRSZWZlcnJlci5cbiAgICAgICAgICByZXF1ZXN0LnJlZmVycmVyID0gcGFyc2VkUmVmZXJyZXJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIDE1LiBJZiBpbml0W1wicmVmZXJyZXJQb2xpY3lcIl0gZXhpc3RzLCB0aGVuIHNldCByZXF1ZXN04oCZcyByZWZlcnJlciBwb2xpY3lcbiAgICAvLyB0byBpdC5cbiAgICBpZiAoaW5pdC5yZWZlcnJlclBvbGljeSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXF1ZXN0LnJlZmVycmVyUG9saWN5ID0gaW5pdC5yZWZlcnJlclBvbGljeVxuICAgIH1cblxuICAgIC8vIDE2LiBMZXQgbW9kZSBiZSBpbml0W1wibW9kZVwiXSBpZiBpdCBleGlzdHMsIGFuZCBmYWxsYmFja01vZGUgb3RoZXJ3aXNlLlxuICAgIGxldCBtb2RlXG4gICAgaWYgKGluaXQubW9kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBtb2RlID0gaW5pdC5tb2RlXG4gICAgfSBlbHNlIHtcbiAgICAgIG1vZGUgPSBmYWxsYmFja01vZGVcbiAgICB9XG5cbiAgICAvLyAxNy4gSWYgbW9kZSBpcyBcIm5hdmlnYXRlXCIsIHRoZW4gdGhyb3cgYSBUeXBlRXJyb3IuXG4gICAgaWYgKG1vZGUgPT09ICduYXZpZ2F0ZScpIHtcbiAgICAgIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgICAgaGVhZGVyOiAnUmVxdWVzdCBjb25zdHJ1Y3RvcicsXG4gICAgICAgIG1lc3NhZ2U6ICdpbnZhbGlkIHJlcXVlc3QgbW9kZSBuYXZpZ2F0ZS4nXG4gICAgICB9KVxuICAgIH1cblxuICAgIC8vIDE4LiBJZiBtb2RlIGlzIG5vbi1udWxsLCBzZXQgcmVxdWVzdOKAmXMgbW9kZSB0byBtb2RlLlxuICAgIGlmIChtb2RlICE9IG51bGwpIHtcbiAgICAgIHJlcXVlc3QubW9kZSA9IG1vZGVcbiAgICB9XG5cbiAgICAvLyAxOS4gSWYgaW5pdFtcImNyZWRlbnRpYWxzXCJdIGV4aXN0cywgdGhlbiBzZXQgcmVxdWVzdOKAmXMgY3JlZGVudGlhbHMgbW9kZVxuICAgIC8vIHRvIGl0LlxuICAgIGlmIChpbml0LmNyZWRlbnRpYWxzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJlcXVlc3QuY3JlZGVudGlhbHMgPSBpbml0LmNyZWRlbnRpYWxzXG4gICAgfVxuXG4gICAgLy8gMTguIElmIGluaXRbXCJjYWNoZVwiXSBleGlzdHMsIHRoZW4gc2V0IHJlcXVlc3TigJlzIGNhY2hlIG1vZGUgdG8gaXQuXG4gICAgaWYgKGluaXQuY2FjaGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmVxdWVzdC5jYWNoZSA9IGluaXQuY2FjaGVcbiAgICB9XG5cbiAgICAvLyAyMS4gSWYgcmVxdWVzdOKAmXMgY2FjaGUgbW9kZSBpcyBcIm9ubHktaWYtY2FjaGVkXCIgYW5kIHJlcXVlc3TigJlzIG1vZGUgaXNcbiAgICAvLyBub3QgXCJzYW1lLW9yaWdpblwiLCB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICAgIGlmIChyZXF1ZXN0LmNhY2hlID09PSAnb25seS1pZi1jYWNoZWQnICYmIHJlcXVlc3QubW9kZSAhPT0gJ3NhbWUtb3JpZ2luJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgXCInb25seS1pZi1jYWNoZWQnIGNhbiBiZSBzZXQgb25seSB3aXRoICdzYW1lLW9yaWdpbicgbW9kZVwiXG4gICAgICApXG4gICAgfVxuXG4gICAgLy8gMjIuIElmIGluaXRbXCJyZWRpcmVjdFwiXSBleGlzdHMsIHRoZW4gc2V0IHJlcXVlc3TigJlzIHJlZGlyZWN0IG1vZGUgdG8gaXQuXG4gICAgaWYgKGluaXQucmVkaXJlY3QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmVxdWVzdC5yZWRpcmVjdCA9IGluaXQucmVkaXJlY3RcbiAgICB9XG5cbiAgICAvLyAyMy4gSWYgaW5pdFtcImludGVncml0eVwiXSBleGlzdHMsIHRoZW4gc2V0IHJlcXVlc3TigJlzIGludGVncml0eSBtZXRhZGF0YSB0byBpdC5cbiAgICBpZiAoaW5pdC5pbnRlZ3JpdHkgIT0gbnVsbCkge1xuICAgICAgcmVxdWVzdC5pbnRlZ3JpdHkgPSBTdHJpbmcoaW5pdC5pbnRlZ3JpdHkpXG4gICAgfVxuXG4gICAgLy8gMjQuIElmIGluaXRbXCJrZWVwYWxpdmVcIl0gZXhpc3RzLCB0aGVuIHNldCByZXF1ZXN04oCZcyBrZWVwYWxpdmUgdG8gaXQuXG4gICAgaWYgKGluaXQua2VlcGFsaXZlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJlcXVlc3Qua2VlcGFsaXZlID0gQm9vbGVhbihpbml0LmtlZXBhbGl2ZSlcbiAgICB9XG5cbiAgICAvLyAyNS4gSWYgaW5pdFtcIm1ldGhvZFwiXSBleGlzdHMsIHRoZW46XG4gICAgaWYgKGluaXQubWV0aG9kICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIDEuIExldCBtZXRob2QgYmUgaW5pdFtcIm1ldGhvZFwiXS5cbiAgICAgIGxldCBtZXRob2QgPSBpbml0Lm1ldGhvZFxuXG4gICAgICBjb25zdCBtYXlCZU5vcm1hbGl6ZWQgPSBub3JtYWxpemVkTWV0aG9kUmVjb3Jkc1ttZXRob2RdXG5cbiAgICAgIGlmIChtYXlCZU5vcm1hbGl6ZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBOb3RlOiBCeXBhc3MgdmFsaWRhdGlvbiBERUxFVEUsIEdFVCwgSEVBRCwgT1BUSU9OUywgUE9TVCwgUFVULCBQQVRDSCBhbmQgdGhlc2UgbG93ZXJjYXNlIG9uZXNcbiAgICAgICAgcmVxdWVzdC5tZXRob2QgPSBtYXlCZU5vcm1hbGl6ZWRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIDIuIElmIG1ldGhvZCBpcyBub3QgYSBtZXRob2Qgb3IgbWV0aG9kIGlzIGEgZm9yYmlkZGVuIG1ldGhvZCwgdGhlblxuICAgICAgICAvLyB0aHJvdyBhIFR5cGVFcnJvci5cbiAgICAgICAgaWYgKCFpc1ZhbGlkSFRUUFRva2VuKG1ldGhvZCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGAnJHttZXRob2R9JyBpcyBub3QgYSB2YWxpZCBIVFRQIG1ldGhvZC5gKVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdXBwZXJDYXNlID0gbWV0aG9kLnRvVXBwZXJDYXNlKClcblxuICAgICAgICBpZiAoZm9yYmlkZGVuTWV0aG9kc1NldC5oYXModXBwZXJDYXNlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCcke21ldGhvZH0nIEhUVFAgbWV0aG9kIGlzIHVuc3VwcG9ydGVkLmApXG4gICAgICAgIH1cblxuICAgICAgICAvLyAzLiBOb3JtYWxpemUgbWV0aG9kLlxuICAgICAgICAvLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1tZXRob2Qtbm9ybWFsaXplXG4gICAgICAgIC8vIE5vdGU6IG11c3QgYmUgaW4gdXBwZXJjYXNlXG4gICAgICAgIG1ldGhvZCA9IG5vcm1hbGl6ZWRNZXRob2RSZWNvcmRzQmFzZVt1cHBlckNhc2VdID8/IG1ldGhvZFxuXG4gICAgICAgIC8vIDQuIFNldCByZXF1ZXN04oCZcyBtZXRob2QgdG8gbWV0aG9kLlxuICAgICAgICByZXF1ZXN0Lm1ldGhvZCA9IG1ldGhvZFxuICAgICAgfVxuXG4gICAgICBpZiAoIXBhdGNoTWV0aG9kV2FybmluZyAmJiByZXF1ZXN0Lm1ldGhvZCA9PT0gJ3BhdGNoJykge1xuICAgICAgICBwcm9jZXNzLmVtaXRXYXJuaW5nKCdVc2luZyBgcGF0Y2hgIGlzIGhpZ2hseSBsaWtlbHkgdG8gcmVzdWx0IGluIGEgYDQwNSBNZXRob2QgTm90IEFsbG93ZWRgLiBgUEFUQ0hgIGlzIG11Y2ggbW9yZSBsaWtlbHkgdG8gc3VjY2VlZC4nLCB7XG4gICAgICAgICAgY29kZTogJ1VORElDSS1GRVRDSC1wYXRjaCdcbiAgICAgICAgfSlcblxuICAgICAgICBwYXRjaE1ldGhvZFdhcm5pbmcgPSB0cnVlXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gMjYuIElmIGluaXRbXCJzaWduYWxcIl0gZXhpc3RzLCB0aGVuIHNldCBzaWduYWwgdG8gaXQuXG4gICAgaWYgKGluaXQuc2lnbmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHNpZ25hbCA9IGluaXQuc2lnbmFsXG4gICAgfVxuXG4gICAgLy8gMjcuIFNldCB0aGlz4oCZcyByZXF1ZXN0IHRvIHJlcXVlc3QuXG4gICAgdGhpc1trU3RhdGVdID0gcmVxdWVzdFxuXG4gICAgLy8gMjguIFNldCB0aGlz4oCZcyBzaWduYWwgdG8gYSBuZXcgQWJvcnRTaWduYWwgb2JqZWN0IHdpdGggdGhpc+KAmXMgcmVsZXZhbnRcbiAgICAvLyBSZWFsbS5cbiAgICAvLyBUT0RPOiBjb3VsZCB0aGlzIGJlIHNpbXBsaWZpZWQgd2l0aCBBYm9ydFNpZ25hbC5hbnlcbiAgICAvLyAoaHR0cHM6Ly9kb20uc3BlYy53aGF0d2cub3JnLyNkb20tYWJvcnRzaWduYWwtYW55KVxuICAgIGNvbnN0IGFjID0gbmV3IEFib3J0Q29udHJvbGxlcigpXG4gICAgdGhpc1trU2lnbmFsXSA9IGFjLnNpZ25hbFxuXG4gICAgLy8gMjkuIElmIHNpZ25hbCBpcyBub3QgbnVsbCwgdGhlbiBtYWtlIHRoaXPigJlzIHNpZ25hbCBmb2xsb3cgc2lnbmFsLlxuICAgIGlmIChzaWduYWwgIT0gbnVsbCkge1xuICAgICAgaWYgKFxuICAgICAgICAhc2lnbmFsIHx8XG4gICAgICAgIHR5cGVvZiBzaWduYWwuYWJvcnRlZCAhPT0gJ2Jvb2xlYW4nIHx8XG4gICAgICAgIHR5cGVvZiBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJ1xuICAgICAgKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgXCJGYWlsZWQgdG8gY29uc3RydWN0ICdSZXF1ZXN0JzogbWVtYmVyIHNpZ25hbCBpcyBub3Qgb2YgdHlwZSBBYm9ydFNpZ25hbC5cIlxuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIGlmIChzaWduYWwuYWJvcnRlZCkge1xuICAgICAgICBhYy5hYm9ydChzaWduYWwucmVhc29uKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gS2VlcCBhIHN0cm9uZyByZWYgdG8gYWMgd2hpbGUgcmVxdWVzdCBvYmplY3RcbiAgICAgICAgLy8gaXMgYWxpdmUuIFRoaXMgaXMgbmVlZGVkIHRvIHByZXZlbnQgQWJvcnRDb250cm9sbGVyXG4gICAgICAgIC8vIGZyb20gYmVpbmcgcHJlbWF0dXJlbHkgZ2FyYmFnZSBjb2xsZWN0ZWQuXG4gICAgICAgIC8vIFNlZSwgaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy91bmRpY2kvaXNzdWVzLzE5MjYuXG4gICAgICAgIHRoaXNba0Fib3J0Q29udHJvbGxlcl0gPSBhY1xuXG4gICAgICAgIGNvbnN0IGFjUmVmID0gbmV3IFdlYWtSZWYoYWMpXG4gICAgICAgIGNvbnN0IGFib3J0ID0gYnVpbGRBYm9ydChhY1JlZilcblxuICAgICAgICAvLyBUaGlyZC1wYXJ0eSBBYm9ydENvbnRyb2xsZXJzIG1heSBub3Qgd29yayB3aXRoIHRoZXNlLlxuICAgICAgICAvLyBTZWUsIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvdW5kaWNpL3B1bGwvMTkxMCNpc3N1ZWNvbW1lbnQtMTQ2NDQ5NTYxOS5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBJZiB0aGUgbWF4IGFtb3VudCBvZiBsaXN0ZW5lcnMgaXMgZXF1YWwgdG8gdGhlIGRlZmF1bHQsIGluY3JlYXNlIGl0XG4gICAgICAgICAgLy8gVGhpcyBpcyBvbmx5IGF2YWlsYWJsZSBpbiBub2RlID49IHYxOS45LjBcbiAgICAgICAgICBpZiAodHlwZW9mIGdldE1heExpc3RlbmVycyA9PT0gJ2Z1bmN0aW9uJyAmJiBnZXRNYXhMaXN0ZW5lcnMoc2lnbmFsKSA9PT0gZGVmYXVsdE1heExpc3RlbmVycykge1xuICAgICAgICAgICAgc2V0TWF4TGlzdGVuZXJzKDE1MDAsIHNpZ25hbClcbiAgICAgICAgICB9IGVsc2UgaWYgKGdldEV2ZW50TGlzdGVuZXJzKHNpZ25hbCwgJ2Fib3J0JykubGVuZ3RoID49IGRlZmF1bHRNYXhMaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgIHNldE1heExpc3RlbmVycygxNTAwLCBzaWduYWwpXG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIHt9XG5cbiAgICAgICAgdXRpbC5hZGRBYm9ydExpc3RlbmVyKHNpZ25hbCwgYWJvcnQpXG4gICAgICAgIC8vIFRoZSB0aGlyZCBhcmd1bWVudCBtdXN0IGJlIGEgcmVnaXN0cnkga2V5IHRvIGJlIHVucmVnaXN0ZXJlZC5cbiAgICAgICAgLy8gV2l0aG91dCBpdCwgeW91IGNhbm5vdCB1bnJlZ2lzdGVyLlxuICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9GaW5hbGl6YXRpb25SZWdpc3RyeVxuICAgICAgICAvLyBhYm9ydCBpcyB1c2VkIGFzIHRoZSB1bnJlZ2lzdGVyIGtleS4gKGJlY2F1c2UgaXQgaXMgdW5pcXVlKVxuICAgICAgICByZXF1ZXN0RmluYWxpemVyLnJlZ2lzdGVyKGFjLCB7IHNpZ25hbCwgYWJvcnQgfSwgYWJvcnQpXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gMzAuIFNldCB0aGlz4oCZcyBoZWFkZXJzIHRvIGEgbmV3IEhlYWRlcnMgb2JqZWN0IHdpdGggdGhpc+KAmXMgcmVsZXZhbnRcbiAgICAvLyBSZWFsbSwgd2hvc2UgaGVhZGVyIGxpc3QgaXMgcmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QgYW5kIGd1YXJkIGlzXG4gICAgLy8gXCJyZXF1ZXN0XCIuXG4gICAgdGhpc1trSGVhZGVyc10gPSBuZXcgSGVhZGVycyhrQ29uc3RydWN0KVxuICAgIHNldEhlYWRlcnNMaXN0KHRoaXNba0hlYWRlcnNdLCByZXF1ZXN0LmhlYWRlcnNMaXN0KVxuICAgIHNldEhlYWRlcnNHdWFyZCh0aGlzW2tIZWFkZXJzXSwgJ3JlcXVlc3QnKVxuXG4gICAgLy8gMzEuIElmIHRoaXPigJlzIHJlcXVlc3TigJlzIG1vZGUgaXMgXCJuby1jb3JzXCIsIHRoZW46XG4gICAgaWYgKG1vZGUgPT09ICduby1jb3JzJykge1xuICAgICAgLy8gMS4gSWYgdGhpc+KAmXMgcmVxdWVzdOKAmXMgbWV0aG9kIGlzIG5vdCBhIENPUlMtc2FmZWxpc3RlZCBtZXRob2QsXG4gICAgICAvLyB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICAgICAgaWYgKCFjb3JzU2FmZUxpc3RlZE1ldGhvZHNTZXQuaGFzKHJlcXVlc3QubWV0aG9kKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgIGAnJHtyZXF1ZXN0Lm1ldGhvZH0gaXMgdW5zdXBwb3J0ZWQgaW4gbm8tY29ycyBtb2RlLmBcbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICAvLyAyLiBTZXQgdGhpc+KAmXMgaGVhZGVyc+KAmXMgZ3VhcmQgdG8gXCJyZXF1ZXN0LW5vLWNvcnNcIi5cbiAgICAgIHNldEhlYWRlcnNHdWFyZCh0aGlzW2tIZWFkZXJzXSwgJ3JlcXVlc3Qtbm8tY29ycycpXG4gICAgfVxuXG4gICAgLy8gMzIuIElmIGluaXQgaXMgbm90IGVtcHR5LCB0aGVuOlxuICAgIGlmIChpbml0SGFzS2V5KSB7XG4gICAgICAvKiogQHR5cGUge0hlYWRlcnNMaXN0fSAqL1xuICAgICAgY29uc3QgaGVhZGVyc0xpc3QgPSBnZXRIZWFkZXJzTGlzdCh0aGlzW2tIZWFkZXJzXSlcbiAgICAgIC8vIDEuIExldCBoZWFkZXJzIGJlIGEgY29weSBvZiB0aGlz4oCZcyBoZWFkZXJzIGFuZCBpdHMgYXNzb2NpYXRlZCBoZWFkZXJcbiAgICAgIC8vIGxpc3QuXG4gICAgICAvLyAyLiBJZiBpbml0W1wiaGVhZGVyc1wiXSBleGlzdHMsIHRoZW4gc2V0IGhlYWRlcnMgdG8gaW5pdFtcImhlYWRlcnNcIl0uXG4gICAgICBjb25zdCBoZWFkZXJzID0gaW5pdC5oZWFkZXJzICE9PSB1bmRlZmluZWQgPyBpbml0LmhlYWRlcnMgOiBuZXcgSGVhZGVyc0xpc3QoaGVhZGVyc0xpc3QpXG5cbiAgICAgIC8vIDMuIEVtcHR5IHRoaXPigJlzIGhlYWRlcnPigJlzIGhlYWRlciBsaXN0LlxuICAgICAgaGVhZGVyc0xpc3QuY2xlYXIoKVxuXG4gICAgICAvLyA0LiBJZiBoZWFkZXJzIGlzIGEgSGVhZGVycyBvYmplY3QsIHRoZW4gZm9yIGVhY2ggaGVhZGVyIGluIGl0cyBoZWFkZXJcbiAgICAgIC8vIGxpc3QsIGFwcGVuZCBoZWFkZXLigJlzIG5hbWUvaGVhZGVy4oCZcyB2YWx1ZSB0byB0aGlz4oCZcyBoZWFkZXJzLlxuICAgICAgaWYgKGhlYWRlcnMgaW5zdGFuY2VvZiBIZWFkZXJzTGlzdCkge1xuICAgICAgICBmb3IgKGNvbnN0IHsgbmFtZSwgdmFsdWUgfSBvZiBoZWFkZXJzLnJhd1ZhbHVlcygpKSB7XG4gICAgICAgICAgaGVhZGVyc0xpc3QuYXBwZW5kKG5hbWUsIHZhbHVlLCBmYWxzZSlcbiAgICAgICAgfVxuICAgICAgICAvLyBOb3RlOiBDb3B5IHRoZSBgc2V0LWNvb2tpZWAgbWV0YS1kYXRhLlxuICAgICAgICBoZWFkZXJzTGlzdC5jb29raWVzID0gaGVhZGVycy5jb29raWVzXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyA1LiBPdGhlcndpc2UsIGZpbGwgdGhpc+KAmXMgaGVhZGVycyB3aXRoIGhlYWRlcnMuXG4gICAgICAgIGZpbGxIZWFkZXJzKHRoaXNba0hlYWRlcnNdLCBoZWFkZXJzKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIDMzLiBMZXQgaW5wdXRCb2R5IGJlIGlucHV04oCZcyByZXF1ZXN04oCZcyBib2R5IGlmIGlucHV0IGlzIGEgUmVxdWVzdFxuICAgIC8vIG9iamVjdDsgb3RoZXJ3aXNlIG51bGwuXG4gICAgY29uc3QgaW5wdXRCb2R5ID0gaW5wdXQgaW5zdGFuY2VvZiBSZXF1ZXN0ID8gaW5wdXRba1N0YXRlXS5ib2R5IDogbnVsbFxuXG4gICAgLy8gMzQuIElmIGVpdGhlciBpbml0W1wiYm9keVwiXSBleGlzdHMgYW5kIGlzIG5vbi1udWxsIG9yIGlucHV0Qm9keSBpc1xuICAgIC8vIG5vbi1udWxsLCBhbmQgcmVxdWVzdOKAmXMgbWV0aG9kIGlzIGBHRVRgIG9yIGBIRUFEYCwgdGhlbiB0aHJvdyBhXG4gICAgLy8gVHlwZUVycm9yLlxuICAgIGlmIChcbiAgICAgIChpbml0LmJvZHkgIT0gbnVsbCB8fCBpbnB1dEJvZHkgIT0gbnVsbCkgJiZcbiAgICAgIChyZXF1ZXN0Lm1ldGhvZCA9PT0gJ0dFVCcgfHwgcmVxdWVzdC5tZXRob2QgPT09ICdIRUFEJylcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1JlcXVlc3Qgd2l0aCBHRVQvSEVBRCBtZXRob2QgY2Fubm90IGhhdmUgYm9keS4nKVxuICAgIH1cblxuICAgIC8vIDM1LiBMZXQgaW5pdEJvZHkgYmUgbnVsbC5cbiAgICBsZXQgaW5pdEJvZHkgPSBudWxsXG5cbiAgICAvLyAzNi4gSWYgaW5pdFtcImJvZHlcIl0gZXhpc3RzIGFuZCBpcyBub24tbnVsbCwgdGhlbjpcbiAgICBpZiAoaW5pdC5ib2R5ICE9IG51bGwpIHtcbiAgICAgIC8vIDEuIExldCBDb250ZW50LVR5cGUgYmUgbnVsbC5cbiAgICAgIC8vIDIuIFNldCBpbml0Qm9keSBhbmQgQ29udGVudC1UeXBlIHRvIHRoZSByZXN1bHQgb2YgZXh0cmFjdGluZ1xuICAgICAgLy8gaW5pdFtcImJvZHlcIl0sIHdpdGgga2VlcGFsaXZlIHNldCB0byByZXF1ZXN04oCZcyBrZWVwYWxpdmUuXG4gICAgICBjb25zdCBbZXh0cmFjdGVkQm9keSwgY29udGVudFR5cGVdID0gZXh0cmFjdEJvZHkoXG4gICAgICAgIGluaXQuYm9keSxcbiAgICAgICAgcmVxdWVzdC5rZWVwYWxpdmVcbiAgICAgIClcbiAgICAgIGluaXRCb2R5ID0gZXh0cmFjdGVkQm9keVxuXG4gICAgICAvLyAzLCBJZiBDb250ZW50LVR5cGUgaXMgbm9uLW51bGwgYW5kIHRoaXPigJlzIGhlYWRlcnPigJlzIGhlYWRlciBsaXN0IGRvZXNcbiAgICAgIC8vIG5vdCBjb250YWluIGBDb250ZW50LVR5cGVgLCB0aGVuIGFwcGVuZCBgQ29udGVudC1UeXBlYC9Db250ZW50LVR5cGUgdG9cbiAgICAgIC8vIHRoaXPigJlzIGhlYWRlcnMuXG4gICAgICBpZiAoY29udGVudFR5cGUgJiYgIWdldEhlYWRlcnNMaXN0KHRoaXNba0hlYWRlcnNdKS5jb250YWlucygnY29udGVudC10eXBlJywgdHJ1ZSkpIHtcbiAgICAgICAgdGhpc1trSGVhZGVyc10uYXBwZW5kKCdjb250ZW50LXR5cGUnLCBjb250ZW50VHlwZSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyAzNy4gTGV0IGlucHV0T3JJbml0Qm9keSBiZSBpbml0Qm9keSBpZiBpdCBpcyBub24tbnVsbDsgb3RoZXJ3aXNlXG4gICAgLy8gaW5wdXRCb2R5LlxuICAgIGNvbnN0IGlucHV0T3JJbml0Qm9keSA9IGluaXRCb2R5ID8/IGlucHV0Qm9keVxuXG4gICAgLy8gMzguIElmIGlucHV0T3JJbml0Qm9keSBpcyBub24tbnVsbCBhbmQgaW5wdXRPckluaXRCb2R54oCZcyBzb3VyY2UgaXNcbiAgICAvLyBudWxsLCB0aGVuOlxuICAgIGlmIChpbnB1dE9ySW5pdEJvZHkgIT0gbnVsbCAmJiBpbnB1dE9ySW5pdEJvZHkuc291cmNlID09IG51bGwpIHtcbiAgICAgIC8vIDEuIElmIGluaXRCb2R5IGlzIG5vbi1udWxsIGFuZCBpbml0W1wiZHVwbGV4XCJdIGRvZXMgbm90IGV4aXN0LFxuICAgICAgLy8gICAgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgICAgIGlmIChpbml0Qm9keSAhPSBudWxsICYmIGluaXQuZHVwbGV4ID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUmVxdWVzdEluaXQ6IGR1cGxleCBvcHRpb24gaXMgcmVxdWlyZWQgd2hlbiBzZW5kaW5nIGEgYm9keS4nKVxuICAgICAgfVxuXG4gICAgICAvLyAyLiBJZiB0aGlz4oCZcyByZXF1ZXN04oCZcyBtb2RlIGlzIG5laXRoZXIgXCJzYW1lLW9yaWdpblwiIG5vciBcImNvcnNcIixcbiAgICAgIC8vIHRoZW4gdGhyb3cgYSBUeXBlRXJyb3IuXG4gICAgICBpZiAocmVxdWVzdC5tb2RlICE9PSAnc2FtZS1vcmlnaW4nICYmIHJlcXVlc3QubW9kZSAhPT0gJ2NvcnMnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgJ0lmIHJlcXVlc3QgaXMgbWFkZSBmcm9tIFJlYWRhYmxlU3RyZWFtLCBtb2RlIHNob3VsZCBiZSBcInNhbWUtb3JpZ2luXCIgb3IgXCJjb3JzXCInXG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgLy8gMy4gU2V0IHRoaXPigJlzIHJlcXVlc3TigJlzIHVzZS1DT1JTLXByZWZsaWdodCBmbGFnLlxuICAgICAgcmVxdWVzdC51c2VDT1JTUHJlZmxpZ2h0RmxhZyA9IHRydWVcbiAgICB9XG5cbiAgICAvLyAzOS4gTGV0IGZpbmFsQm9keSBiZSBpbnB1dE9ySW5pdEJvZHkuXG4gICAgbGV0IGZpbmFsQm9keSA9IGlucHV0T3JJbml0Qm9keVxuXG4gICAgLy8gNDAuIElmIGluaXRCb2R5IGlzIG51bGwgYW5kIGlucHV0Qm9keSBpcyBub24tbnVsbCwgdGhlbjpcbiAgICBpZiAoaW5pdEJvZHkgPT0gbnVsbCAmJiBpbnB1dEJvZHkgIT0gbnVsbCkge1xuICAgICAgLy8gMS4gSWYgaW5wdXQgaXMgdW51c2FibGUsIHRoZW4gdGhyb3cgYSBUeXBlRXJyb3IuXG4gICAgICBpZiAodXRpbC5pc0Rpc3R1cmJlZChpbnB1dEJvZHkuc3RyZWFtKSB8fCBpbnB1dEJvZHkuc3RyZWFtLmxvY2tlZCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICdDYW5ub3QgY29uc3RydWN0IGEgUmVxdWVzdCB3aXRoIGEgUmVxdWVzdCBvYmplY3QgdGhhdCBoYXMgYWxyZWFkeSBiZWVuIHVzZWQuJ1xuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIC8vIDIuIFNldCBmaW5hbEJvZHkgdG8gdGhlIHJlc3VsdCBvZiBjcmVhdGluZyBhIHByb3h5IGZvciBpbnB1dEJvZHkuXG4gICAgICAvLyBodHRwczovL3N0cmVhbXMuc3BlYy53aGF0d2cub3JnLyNyZWFkYWJsZXN0cmVhbS1jcmVhdGUtYS1wcm94eVxuICAgICAgY29uc3QgaWRlbnRpdHlUcmFuc2Zvcm0gPSBuZXcgVHJhbnNmb3JtU3RyZWFtKClcbiAgICAgIGlucHV0Qm9keS5zdHJlYW0ucGlwZVRocm91Z2goaWRlbnRpdHlUcmFuc2Zvcm0pXG4gICAgICBmaW5hbEJvZHkgPSB7XG4gICAgICAgIHNvdXJjZTogaW5wdXRCb2R5LnNvdXJjZSxcbiAgICAgICAgbGVuZ3RoOiBpbnB1dEJvZHkubGVuZ3RoLFxuICAgICAgICBzdHJlYW06IGlkZW50aXR5VHJhbnNmb3JtLnJlYWRhYmxlXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gNDEuIFNldCB0aGlz4oCZcyByZXF1ZXN04oCZcyBib2R5IHRvIGZpbmFsQm9keS5cbiAgICB0aGlzW2tTdGF0ZV0uYm9keSA9IGZpbmFsQm9keVxuICB9XG5cbiAgLy8gUmV0dXJucyByZXF1ZXN04oCZcyBIVFRQIG1ldGhvZCwgd2hpY2ggaXMgXCJHRVRcIiBieSBkZWZhdWx0LlxuICBnZXQgbWV0aG9kICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBSZXF1ZXN0KVxuXG4gICAgLy8gVGhlIG1ldGhvZCBnZXR0ZXIgc3RlcHMgYXJlIHRvIHJldHVybiB0aGlz4oCZcyByZXF1ZXN04oCZcyBtZXRob2QuXG4gICAgcmV0dXJuIHRoaXNba1N0YXRlXS5tZXRob2RcbiAgfVxuXG4gIC8vIFJldHVybnMgdGhlIFVSTCBvZiByZXF1ZXN0IGFzIGEgc3RyaW5nLlxuICBnZXQgdXJsICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBSZXF1ZXN0KVxuXG4gICAgLy8gVGhlIHVybCBnZXR0ZXIgc3RlcHMgYXJlIHRvIHJldHVybiB0aGlz4oCZcyByZXF1ZXN04oCZcyBVUkwsIHNlcmlhbGl6ZWQuXG4gICAgcmV0dXJuIFVSTFNlcmlhbGl6ZXIodGhpc1trU3RhdGVdLnVybClcbiAgfVxuXG4gIC8vIFJldHVybnMgYSBIZWFkZXJzIG9iamVjdCBjb25zaXN0aW5nIG9mIHRoZSBoZWFkZXJzIGFzc29jaWF0ZWQgd2l0aCByZXF1ZXN0LlxuICAvLyBOb3RlIHRoYXQgaGVhZGVycyBhZGRlZCBpbiB0aGUgbmV0d29yayBsYXllciBieSB0aGUgdXNlciBhZ2VudCB3aWxsIG5vdFxuICAvLyBiZSBhY2NvdW50ZWQgZm9yIGluIHRoaXMgb2JqZWN0LCBlLmcuLCB0aGUgXCJIb3N0XCIgaGVhZGVyLlxuICBnZXQgaGVhZGVycyAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgUmVxdWVzdClcblxuICAgIC8vIFRoZSBoZWFkZXJzIGdldHRlciBzdGVwcyBhcmUgdG8gcmV0dXJuIHRoaXPigJlzIGhlYWRlcnMuXG4gICAgcmV0dXJuIHRoaXNba0hlYWRlcnNdXG4gIH1cblxuICAvLyBSZXR1cm5zIHRoZSBraW5kIG9mIHJlc291cmNlIHJlcXVlc3RlZCBieSByZXF1ZXN0LCBlLmcuLCBcImRvY3VtZW50XCJcbiAgLy8gb3IgXCJzY3JpcHRcIi5cbiAgZ2V0IGRlc3RpbmF0aW9uICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBSZXF1ZXN0KVxuXG4gICAgLy8gVGhlIGRlc3RpbmF0aW9uIGdldHRlciBhcmUgdG8gcmV0dXJuIHRoaXPigJlzIHJlcXVlc3TigJlzIGRlc3RpbmF0aW9uLlxuICAgIHJldHVybiB0aGlzW2tTdGF0ZV0uZGVzdGluYXRpb25cbiAgfVxuXG4gIC8vIFJldHVybnMgdGhlIHJlZmVycmVyIG9mIHJlcXVlc3QuIEl0cyB2YWx1ZSBjYW4gYmUgYSBzYW1lLW9yaWdpbiBVUkwgaWZcbiAgLy8gZXhwbGljaXRseSBzZXQgaW4gaW5pdCwgdGhlIGVtcHR5IHN0cmluZyB0byBpbmRpY2F0ZSBubyByZWZlcnJlciwgYW5kXG4gIC8vIFwiYWJvdXQ6Y2xpZW50XCIgd2hlbiBkZWZhdWx0aW5nIHRvIHRoZSBnbG9iYWzigJlzIGRlZmF1bHQuIFRoaXMgaXMgdXNlZFxuICAvLyBkdXJpbmcgZmV0Y2hpbmcgdG8gZGV0ZXJtaW5lIHRoZSB2YWx1ZSBvZiB0aGUgYFJlZmVyZXJgIGhlYWRlciBvZiB0aGVcbiAgLy8gcmVxdWVzdCBiZWluZyBtYWRlLlxuICBnZXQgcmVmZXJyZXIgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFJlcXVlc3QpXG5cbiAgICAvLyAxLiBJZiB0aGlz4oCZcyByZXF1ZXN04oCZcyByZWZlcnJlciBpcyBcIm5vLXJlZmVycmVyXCIsIHRoZW4gcmV0dXJuIHRoZVxuICAgIC8vIGVtcHR5IHN0cmluZy5cbiAgICBpZiAodGhpc1trU3RhdGVdLnJlZmVycmVyID09PSAnbm8tcmVmZXJyZXInKSB7XG4gICAgICByZXR1cm4gJydcbiAgICB9XG5cbiAgICAvLyAyLiBJZiB0aGlz4oCZcyByZXF1ZXN04oCZcyByZWZlcnJlciBpcyBcImNsaWVudFwiLCB0aGVuIHJldHVyblxuICAgIC8vIFwiYWJvdXQ6Y2xpZW50XCIuXG4gICAgaWYgKHRoaXNba1N0YXRlXS5yZWZlcnJlciA9PT0gJ2NsaWVudCcpIHtcbiAgICAgIHJldHVybiAnYWJvdXQ6Y2xpZW50J1xuICAgIH1cblxuICAgIC8vIFJldHVybiB0aGlz4oCZcyByZXF1ZXN04oCZcyByZWZlcnJlciwgc2VyaWFsaXplZC5cbiAgICByZXR1cm4gdGhpc1trU3RhdGVdLnJlZmVycmVyLnRvU3RyaW5nKClcbiAgfVxuXG4gIC8vIFJldHVybnMgdGhlIHJlZmVycmVyIHBvbGljeSBhc3NvY2lhdGVkIHdpdGggcmVxdWVzdC5cbiAgLy8gVGhpcyBpcyB1c2VkIGR1cmluZyBmZXRjaGluZyB0byBjb21wdXRlIHRoZSB2YWx1ZSBvZiB0aGUgcmVxdWVzdOKAmXNcbiAgLy8gcmVmZXJyZXIuXG4gIGdldCByZWZlcnJlclBvbGljeSAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgUmVxdWVzdClcblxuICAgIC8vIFRoZSByZWZlcnJlclBvbGljeSBnZXR0ZXIgc3RlcHMgYXJlIHRvIHJldHVybiB0aGlz4oCZcyByZXF1ZXN04oCZcyByZWZlcnJlciBwb2xpY3kuXG4gICAgcmV0dXJuIHRoaXNba1N0YXRlXS5yZWZlcnJlclBvbGljeVxuICB9XG5cbiAgLy8gUmV0dXJucyB0aGUgbW9kZSBhc3NvY2lhdGVkIHdpdGggcmVxdWVzdCwgd2hpY2ggaXMgYSBzdHJpbmcgaW5kaWNhdGluZ1xuICAvLyB3aGV0aGVyIHRoZSByZXF1ZXN0IHdpbGwgdXNlIENPUlMsIG9yIHdpbGwgYmUgcmVzdHJpY3RlZCB0byBzYW1lLW9yaWdpblxuICAvLyBVUkxzLlxuICBnZXQgbW9kZSAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgUmVxdWVzdClcblxuICAgIC8vIFRoZSBtb2RlIGdldHRlciBzdGVwcyBhcmUgdG8gcmV0dXJuIHRoaXPigJlzIHJlcXVlc3TigJlzIG1vZGUuXG4gICAgcmV0dXJuIHRoaXNba1N0YXRlXS5tb2RlXG4gIH1cblxuICAvLyBSZXR1cm5zIHRoZSBjcmVkZW50aWFscyBtb2RlIGFzc29jaWF0ZWQgd2l0aCByZXF1ZXN0LFxuICAvLyB3aGljaCBpcyBhIHN0cmluZyBpbmRpY2F0aW5nIHdoZXRoZXIgY3JlZGVudGlhbHMgd2lsbCBiZSBzZW50IHdpdGggdGhlXG4gIC8vIHJlcXVlc3QgYWx3YXlzLCBuZXZlciwgb3Igb25seSB3aGVuIHNlbnQgdG8gYSBzYW1lLW9yaWdpbiBVUkwuXG4gIGdldCBjcmVkZW50aWFscyAoKSB7XG4gICAgLy8gVGhlIGNyZWRlbnRpYWxzIGdldHRlciBzdGVwcyBhcmUgdG8gcmV0dXJuIHRoaXPigJlzIHJlcXVlc3TigJlzIGNyZWRlbnRpYWxzIG1vZGUuXG4gICAgcmV0dXJuIHRoaXNba1N0YXRlXS5jcmVkZW50aWFsc1xuICB9XG5cbiAgLy8gUmV0dXJucyB0aGUgY2FjaGUgbW9kZSBhc3NvY2lhdGVkIHdpdGggcmVxdWVzdCxcbiAgLy8gd2hpY2ggaXMgYSBzdHJpbmcgaW5kaWNhdGluZyBob3cgdGhlIHJlcXVlc3Qgd2lsbFxuICAvLyBpbnRlcmFjdCB3aXRoIHRoZSBicm93c2Vy4oCZcyBjYWNoZSB3aGVuIGZldGNoaW5nLlxuICBnZXQgY2FjaGUgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFJlcXVlc3QpXG5cbiAgICAvLyBUaGUgY2FjaGUgZ2V0dGVyIHN0ZXBzIGFyZSB0byByZXR1cm4gdGhpc+KAmXMgcmVxdWVzdOKAmXMgY2FjaGUgbW9kZS5cbiAgICByZXR1cm4gdGhpc1trU3RhdGVdLmNhY2hlXG4gIH1cblxuICAvLyBSZXR1cm5zIHRoZSByZWRpcmVjdCBtb2RlIGFzc29jaWF0ZWQgd2l0aCByZXF1ZXN0LFxuICAvLyB3aGljaCBpcyBhIHN0cmluZyBpbmRpY2F0aW5nIGhvdyByZWRpcmVjdHMgZm9yIHRoZVxuICAvLyByZXF1ZXN0IHdpbGwgYmUgaGFuZGxlZCBkdXJpbmcgZmV0Y2hpbmcuIEEgcmVxdWVzdFxuICAvLyB3aWxsIGZvbGxvdyByZWRpcmVjdHMgYnkgZGVmYXVsdC5cbiAgZ2V0IHJlZGlyZWN0ICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBSZXF1ZXN0KVxuXG4gICAgLy8gVGhlIHJlZGlyZWN0IGdldHRlciBzdGVwcyBhcmUgdG8gcmV0dXJuIHRoaXPigJlzIHJlcXVlc3TigJlzIHJlZGlyZWN0IG1vZGUuXG4gICAgcmV0dXJuIHRoaXNba1N0YXRlXS5yZWRpcmVjdFxuICB9XG5cbiAgLy8gUmV0dXJucyByZXF1ZXN04oCZcyBzdWJyZXNvdXJjZSBpbnRlZ3JpdHkgbWV0YWRhdGEsIHdoaWNoIGlzIGFcbiAgLy8gY3J5cHRvZ3JhcGhpYyBoYXNoIG9mIHRoZSByZXNvdXJjZSBiZWluZyBmZXRjaGVkLiBJdHMgdmFsdWVcbiAgLy8gY29uc2lzdHMgb2YgbXVsdGlwbGUgaGFzaGVzIHNlcGFyYXRlZCBieSB3aGl0ZXNwYWNlLiBbU1JJXVxuICBnZXQgaW50ZWdyaXR5ICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBSZXF1ZXN0KVxuXG4gICAgLy8gVGhlIGludGVncml0eSBnZXR0ZXIgc3RlcHMgYXJlIHRvIHJldHVybiB0aGlz4oCZcyByZXF1ZXN04oCZcyBpbnRlZ3JpdHlcbiAgICAvLyBtZXRhZGF0YS5cbiAgICByZXR1cm4gdGhpc1trU3RhdGVdLmludGVncml0eVxuICB9XG5cbiAgLy8gUmV0dXJucyBhIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIG9yIG5vdCByZXF1ZXN0IGNhbiBvdXRsaXZlIHRoZVxuICAvLyBnbG9iYWwgaW4gd2hpY2ggaXQgd2FzIGNyZWF0ZWQuXG4gIGdldCBrZWVwYWxpdmUgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFJlcXVlc3QpXG5cbiAgICAvLyBUaGUga2VlcGFsaXZlIGdldHRlciBzdGVwcyBhcmUgdG8gcmV0dXJuIHRoaXPigJlzIHJlcXVlc3TigJlzIGtlZXBhbGl2ZS5cbiAgICByZXR1cm4gdGhpc1trU3RhdGVdLmtlZXBhbGl2ZVxuICB9XG5cbiAgLy8gUmV0dXJucyBhIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIG9yIG5vdCByZXF1ZXN0IGlzIGZvciBhIHJlbG9hZFxuICAvLyBuYXZpZ2F0aW9uLlxuICBnZXQgaXNSZWxvYWROYXZpZ2F0aW9uICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBSZXF1ZXN0KVxuXG4gICAgLy8gVGhlIGlzUmVsb2FkTmF2aWdhdGlvbiBnZXR0ZXIgc3RlcHMgYXJlIHRvIHJldHVybiB0cnVlIGlmIHRoaXPigJlzXG4gICAgLy8gcmVxdWVzdOKAmXMgcmVsb2FkLW5hdmlnYXRpb24gZmxhZyBpcyBzZXQ7IG90aGVyd2lzZSBmYWxzZS5cbiAgICByZXR1cm4gdGhpc1trU3RhdGVdLnJlbG9hZE5hdmlnYXRpb25cbiAgfVxuXG4gIC8vIFJldHVybnMgYSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciBvciBub3QgcmVxdWVzdCBpcyBmb3IgYSBoaXN0b3J5XG4gIC8vIG5hdmlnYXRpb24gKGEuay5hLiBiYWNrLWZvcndhcmQgbmF2aWdhdGlvbikuXG4gIGdldCBpc0hpc3RvcnlOYXZpZ2F0aW9uICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBSZXF1ZXN0KVxuXG4gICAgLy8gVGhlIGlzSGlzdG9yeU5hdmlnYXRpb24gZ2V0dGVyIHN0ZXBzIGFyZSB0byByZXR1cm4gdHJ1ZSBpZiB0aGlz4oCZcyByZXF1ZXN04oCZc1xuICAgIC8vIGhpc3RvcnktbmF2aWdhdGlvbiBmbGFnIGlzIHNldDsgb3RoZXJ3aXNlIGZhbHNlLlxuICAgIHJldHVybiB0aGlzW2tTdGF0ZV0uaGlzdG9yeU5hdmlnYXRpb25cbiAgfVxuXG4gIC8vIFJldHVybnMgdGhlIHNpZ25hbCBhc3NvY2lhdGVkIHdpdGggcmVxdWVzdCwgd2hpY2ggaXMgYW4gQWJvcnRTaWduYWxcbiAgLy8gb2JqZWN0IGluZGljYXRpbmcgd2hldGhlciBvciBub3QgcmVxdWVzdCBoYXMgYmVlbiBhYm9ydGVkLCBhbmQgaXRzXG4gIC8vIGFib3J0IGV2ZW50IGhhbmRsZXIuXG4gIGdldCBzaWduYWwgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFJlcXVlc3QpXG5cbiAgICAvLyBUaGUgc2lnbmFsIGdldHRlciBzdGVwcyBhcmUgdG8gcmV0dXJuIHRoaXPigJlzIHNpZ25hbC5cbiAgICByZXR1cm4gdGhpc1trU2lnbmFsXVxuICB9XG5cbiAgZ2V0IGJvZHkgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFJlcXVlc3QpXG5cbiAgICByZXR1cm4gdGhpc1trU3RhdGVdLmJvZHkgPyB0aGlzW2tTdGF0ZV0uYm9keS5zdHJlYW0gOiBudWxsXG4gIH1cblxuICBnZXQgYm9keVVzZWQgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFJlcXVlc3QpXG5cbiAgICByZXR1cm4gISF0aGlzW2tTdGF0ZV0uYm9keSAmJiB1dGlsLmlzRGlzdHVyYmVkKHRoaXNba1N0YXRlXS5ib2R5LnN0cmVhbSlcbiAgfVxuXG4gIGdldCBkdXBsZXggKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFJlcXVlc3QpXG5cbiAgICByZXR1cm4gJ2hhbGYnXG4gIH1cblxuICAvLyBSZXR1cm5zIGEgY2xvbmUgb2YgcmVxdWVzdC5cbiAgY2xvbmUgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFJlcXVlc3QpXG5cbiAgICAvLyAxLiBJZiB0aGlzIGlzIHVudXNhYmxlLCB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICAgIGlmICh0aGlzLmJvZHlVc2VkIHx8IHRoaXMuYm9keT8ubG9ja2VkKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd1bnVzYWJsZScpXG4gICAgfVxuXG4gICAgLy8gMi4gTGV0IGNsb25lZFJlcXVlc3QgYmUgdGhlIHJlc3VsdCBvZiBjbG9uaW5nIHRoaXPigJlzIHJlcXVlc3QuXG4gICAgY29uc3QgY2xvbmVkUmVxdWVzdCA9IGNsb25lUmVxdWVzdCh0aGlzW2tTdGF0ZV0pXG5cbiAgICAvLyAzLiBMZXQgY2xvbmVkUmVxdWVzdE9iamVjdCBiZSB0aGUgcmVzdWx0IG9mIGNyZWF0aW5nIGEgUmVxdWVzdCBvYmplY3QsXG4gICAgLy8gZ2l2ZW4gY2xvbmVkUmVxdWVzdCwgdGhpc+KAmXMgaGVhZGVyc+KAmXMgZ3VhcmQsIGFuZCB0aGlz4oCZcyByZWxldmFudCBSZWFsbS5cbiAgICAvLyA0LiBNYWtlIGNsb25lZFJlcXVlc3RPYmplY3TigJlzIHNpZ25hbCBmb2xsb3cgdGhpc+KAmXMgc2lnbmFsLlxuICAgIGNvbnN0IGFjID0gbmV3IEFib3J0Q29udHJvbGxlcigpXG4gICAgaWYgKHRoaXMuc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgIGFjLmFib3J0KHRoaXMuc2lnbmFsLnJlYXNvbilcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGxpc3QgPSBkZXBlbmRlbnRDb250cm9sbGVyTWFwLmdldCh0aGlzLnNpZ25hbClcbiAgICAgIGlmIChsaXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGlzdCA9IG5ldyBTZXQoKVxuICAgICAgICBkZXBlbmRlbnRDb250cm9sbGVyTWFwLnNldCh0aGlzLnNpZ25hbCwgbGlzdClcbiAgICAgIH1cbiAgICAgIGNvbnN0IGFjUmVmID0gbmV3IFdlYWtSZWYoYWMpXG4gICAgICBsaXN0LmFkZChhY1JlZilcbiAgICAgIHV0aWwuYWRkQWJvcnRMaXN0ZW5lcihcbiAgICAgICAgYWMuc2lnbmFsLFxuICAgICAgICBidWlsZEFib3J0KGFjUmVmKVxuICAgICAgKVxuICAgIH1cblxuICAgIC8vIDQuIFJldHVybiBjbG9uZWRSZXF1ZXN0T2JqZWN0LlxuICAgIHJldHVybiBmcm9tSW5uZXJSZXF1ZXN0KGNsb25lZFJlcXVlc3QsIGFjLnNpZ25hbCwgZ2V0SGVhZGVyc0d1YXJkKHRoaXNba0hlYWRlcnNdKSlcbiAgfVxuXG4gIFtub2RlVXRpbC5pbnNwZWN0LmN1c3RvbV0gKGRlcHRoLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMuZGVwdGggPT09IG51bGwpIHtcbiAgICAgIG9wdGlvbnMuZGVwdGggPSAyXG4gICAgfVxuXG4gICAgb3B0aW9ucy5jb2xvcnMgPz89IHRydWVcblxuICAgIGNvbnN0IHByb3BlcnRpZXMgPSB7XG4gICAgICBtZXRob2Q6IHRoaXMubWV0aG9kLFxuICAgICAgdXJsOiB0aGlzLnVybCxcbiAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgIGRlc3RpbmF0aW9uOiB0aGlzLmRlc3RpbmF0aW9uLFxuICAgICAgcmVmZXJyZXI6IHRoaXMucmVmZXJyZXIsXG4gICAgICByZWZlcnJlclBvbGljeTogdGhpcy5yZWZlcnJlclBvbGljeSxcbiAgICAgIG1vZGU6IHRoaXMubW9kZSxcbiAgICAgIGNyZWRlbnRpYWxzOiB0aGlzLmNyZWRlbnRpYWxzLFxuICAgICAgY2FjaGU6IHRoaXMuY2FjaGUsXG4gICAgICByZWRpcmVjdDogdGhpcy5yZWRpcmVjdCxcbiAgICAgIGludGVncml0eTogdGhpcy5pbnRlZ3JpdHksXG4gICAgICBrZWVwYWxpdmU6IHRoaXMua2VlcGFsaXZlLFxuICAgICAgaXNSZWxvYWROYXZpZ2F0aW9uOiB0aGlzLmlzUmVsb2FkTmF2aWdhdGlvbixcbiAgICAgIGlzSGlzdG9yeU5hdmlnYXRpb246IHRoaXMuaXNIaXN0b3J5TmF2aWdhdGlvbixcbiAgICAgIHNpZ25hbDogdGhpcy5zaWduYWxcbiAgICB9XG5cbiAgICByZXR1cm4gYFJlcXVlc3QgJHtub2RlVXRpbC5mb3JtYXRXaXRoT3B0aW9ucyhvcHRpb25zLCBwcm9wZXJ0aWVzKX1gXG4gIH1cbn1cblxubWl4aW5Cb2R5KFJlcXVlc3QpXG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNyZXF1ZXN0c1xuZnVuY3Rpb24gbWFrZVJlcXVlc3QgKGluaXQpIHtcbiAgcmV0dXJuIHtcbiAgICBtZXRob2Q6IGluaXQubWV0aG9kID8/ICdHRVQnLFxuICAgIGxvY2FsVVJMc09ubHk6IGluaXQubG9jYWxVUkxzT25seSA/PyBmYWxzZSxcbiAgICB1bnNhZmVSZXF1ZXN0OiBpbml0LnVuc2FmZVJlcXVlc3QgPz8gZmFsc2UsXG4gICAgYm9keTogaW5pdC5ib2R5ID8/IG51bGwsXG4gICAgY2xpZW50OiBpbml0LmNsaWVudCA/PyBudWxsLFxuICAgIHJlc2VydmVkQ2xpZW50OiBpbml0LnJlc2VydmVkQ2xpZW50ID8/IG51bGwsXG4gICAgcmVwbGFjZXNDbGllbnRJZDogaW5pdC5yZXBsYWNlc0NsaWVudElkID8/ICcnLFxuICAgIHdpbmRvdzogaW5pdC53aW5kb3cgPz8gJ2NsaWVudCcsXG4gICAga2VlcGFsaXZlOiBpbml0LmtlZXBhbGl2ZSA/PyBmYWxzZSxcbiAgICBzZXJ2aWNlV29ya2VyczogaW5pdC5zZXJ2aWNlV29ya2VycyA/PyAnYWxsJyxcbiAgICBpbml0aWF0b3I6IGluaXQuaW5pdGlhdG9yID8/ICcnLFxuICAgIGRlc3RpbmF0aW9uOiBpbml0LmRlc3RpbmF0aW9uID8/ICcnLFxuICAgIHByaW9yaXR5OiBpbml0LnByaW9yaXR5ID8/IG51bGwsXG4gICAgb3JpZ2luOiBpbml0Lm9yaWdpbiA/PyAnY2xpZW50JyxcbiAgICBwb2xpY3lDb250YWluZXI6IGluaXQucG9saWN5Q29udGFpbmVyID8/ICdjbGllbnQnLFxuICAgIHJlZmVycmVyOiBpbml0LnJlZmVycmVyID8/ICdjbGllbnQnLFxuICAgIHJlZmVycmVyUG9saWN5OiBpbml0LnJlZmVycmVyUG9saWN5ID8/ICcnLFxuICAgIG1vZGU6IGluaXQubW9kZSA/PyAnbm8tY29ycycsXG4gICAgdXNlQ09SU1ByZWZsaWdodEZsYWc6IGluaXQudXNlQ09SU1ByZWZsaWdodEZsYWcgPz8gZmFsc2UsXG4gICAgY3JlZGVudGlhbHM6IGluaXQuY3JlZGVudGlhbHMgPz8gJ3NhbWUtb3JpZ2luJyxcbiAgICB1c2VDcmVkZW50aWFsczogaW5pdC51c2VDcmVkZW50aWFscyA/PyBmYWxzZSxcbiAgICBjYWNoZTogaW5pdC5jYWNoZSA/PyAnZGVmYXVsdCcsXG4gICAgcmVkaXJlY3Q6IGluaXQucmVkaXJlY3QgPz8gJ2ZvbGxvdycsXG4gICAgaW50ZWdyaXR5OiBpbml0LmludGVncml0eSA/PyAnJyxcbiAgICBjcnlwdG9HcmFwaGljc05vbmNlTWV0YWRhdGE6IGluaXQuY3J5cHRvR3JhcGhpY3NOb25jZU1ldGFkYXRhID8/ICcnLFxuICAgIHBhcnNlck1ldGFkYXRhOiBpbml0LnBhcnNlck1ldGFkYXRhID8/ICcnLFxuICAgIHJlbG9hZE5hdmlnYXRpb246IGluaXQucmVsb2FkTmF2aWdhdGlvbiA/PyBmYWxzZSxcbiAgICBoaXN0b3J5TmF2aWdhdGlvbjogaW5pdC5oaXN0b3J5TmF2aWdhdGlvbiA/PyBmYWxzZSxcbiAgICB1c2VyQWN0aXZhdGlvbjogaW5pdC51c2VyQWN0aXZhdGlvbiA/PyBmYWxzZSxcbiAgICB0YWludGVkT3JpZ2luOiBpbml0LnRhaW50ZWRPcmlnaW4gPz8gZmFsc2UsXG4gICAgcmVkaXJlY3RDb3VudDogaW5pdC5yZWRpcmVjdENvdW50ID8/IDAsXG4gICAgcmVzcG9uc2VUYWludGluZzogaW5pdC5yZXNwb25zZVRhaW50aW5nID8/ICdiYXNpYycsXG4gICAgcHJldmVudE5vQ2FjaGVDYWNoZUNvbnRyb2xIZWFkZXJNb2RpZmljYXRpb246IGluaXQucHJldmVudE5vQ2FjaGVDYWNoZUNvbnRyb2xIZWFkZXJNb2RpZmljYXRpb24gPz8gZmFsc2UsXG4gICAgZG9uZTogaW5pdC5kb25lID8/IGZhbHNlLFxuICAgIHRpbWluZ0FsbG93RmFpbGVkOiBpbml0LnRpbWluZ0FsbG93RmFpbGVkID8/IGZhbHNlLFxuICAgIHVybExpc3Q6IGluaXQudXJsTGlzdCxcbiAgICB1cmw6IGluaXQudXJsTGlzdFswXSxcbiAgICBoZWFkZXJzTGlzdDogaW5pdC5oZWFkZXJzTGlzdFxuICAgICAgPyBuZXcgSGVhZGVyc0xpc3QoaW5pdC5oZWFkZXJzTGlzdClcbiAgICAgIDogbmV3IEhlYWRlcnNMaXN0KClcbiAgfVxufVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1yZXF1ZXN0LWNsb25lXG5mdW5jdGlvbiBjbG9uZVJlcXVlc3QgKHJlcXVlc3QpIHtcbiAgLy8gVG8gY2xvbmUgYSByZXF1ZXN0IHJlcXVlc3QsIHJ1biB0aGVzZSBzdGVwczpcblxuICAvLyAxLiBMZXQgbmV3UmVxdWVzdCBiZSBhIGNvcHkgb2YgcmVxdWVzdCwgZXhjZXB0IGZvciBpdHMgYm9keS5cbiAgY29uc3QgbmV3UmVxdWVzdCA9IG1ha2VSZXF1ZXN0KHsgLi4ucmVxdWVzdCwgYm9keTogbnVsbCB9KVxuXG4gIC8vIDIuIElmIHJlcXVlc3TigJlzIGJvZHkgaXMgbm9uLW51bGwsIHNldCBuZXdSZXF1ZXN04oCZcyBib2R5IHRvIHRoZVxuICAvLyByZXN1bHQgb2YgY2xvbmluZyByZXF1ZXN04oCZcyBib2R5LlxuICBpZiAocmVxdWVzdC5ib2R5ICE9IG51bGwpIHtcbiAgICBuZXdSZXF1ZXN0LmJvZHkgPSBjbG9uZUJvZHkocmVxdWVzdC5ib2R5KVxuICB9XG5cbiAgLy8gMy4gUmV0dXJuIG5ld1JlcXVlc3QuXG4gIHJldHVybiBuZXdSZXF1ZXN0XG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jcmVxdWVzdC1jcmVhdGVcbiAqIEBwYXJhbSB7YW55fSBpbm5lclJlcXVlc3RcbiAqIEBwYXJhbSB7QWJvcnRTaWduYWx9IHNpZ25hbFxuICogQHBhcmFtIHsncmVxdWVzdCcgfCAnaW1tdXRhYmxlJyB8ICdyZXF1ZXN0LW5vLWNvcnMnIHwgJ3Jlc3BvbnNlJyB8ICdub25lJ30gZ3VhcmRcbiAqIEByZXR1cm5zIHtSZXF1ZXN0fVxuICovXG5mdW5jdGlvbiBmcm9tSW5uZXJSZXF1ZXN0IChpbm5lclJlcXVlc3QsIHNpZ25hbCwgZ3VhcmQpIHtcbiAgY29uc3QgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KGtDb25zdHJ1Y3QpXG4gIHJlcXVlc3Rba1N0YXRlXSA9IGlubmVyUmVxdWVzdFxuICByZXF1ZXN0W2tTaWduYWxdID0gc2lnbmFsXG4gIHJlcXVlc3Rba0hlYWRlcnNdID0gbmV3IEhlYWRlcnMoa0NvbnN0cnVjdClcbiAgc2V0SGVhZGVyc0xpc3QocmVxdWVzdFtrSGVhZGVyc10sIGlubmVyUmVxdWVzdC5oZWFkZXJzTGlzdClcbiAgc2V0SGVhZGVyc0d1YXJkKHJlcXVlc3Rba0hlYWRlcnNdLCBndWFyZClcbiAgcmV0dXJuIHJlcXVlc3Rcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoUmVxdWVzdC5wcm90b3R5cGUsIHtcbiAgbWV0aG9kOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICB1cmw6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGhlYWRlcnM6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIHJlZGlyZWN0OiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBjbG9uZToga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgc2lnbmFsOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBkdXBsZXg6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGRlc3RpbmF0aW9uOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBib2R5OiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBib2R5VXNlZDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgaXNIaXN0b3J5TmF2aWdhdGlvbjoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgaXNSZWxvYWROYXZpZ2F0aW9uOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBrZWVwYWxpdmU6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGludGVncml0eToga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgY2FjaGU6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGNyZWRlbnRpYWxzOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBhdHRyaWJ1dGU6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIHJlZmVycmVyUG9saWN5OiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICByZWZlcnJlcjoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgbW9kZToga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgW1N5bWJvbC50b1N0cmluZ1RhZ106IHtcbiAgICB2YWx1ZTogJ1JlcXVlc3QnLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9XG59KVxuXG53ZWJpZGwuY29udmVydGVycy5SZXF1ZXN0ID0gd2ViaWRsLmludGVyZmFjZUNvbnZlcnRlcihcbiAgUmVxdWVzdFxuKVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jcmVxdWVzdGluZm9cbndlYmlkbC5jb252ZXJ0ZXJzLlJlcXVlc3RJbmZvID0gZnVuY3Rpb24gKFYsIHByZWZpeCwgYXJndW1lbnQpIHtcbiAgaWYgKHR5cGVvZiBWID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB3ZWJpZGwuY29udmVydGVycy5VU1ZTdHJpbmcoViwgcHJlZml4LCBhcmd1bWVudClcbiAgfVxuXG4gIGlmIChWIGluc3RhbmNlb2YgUmVxdWVzdCkge1xuICAgIHJldHVybiB3ZWJpZGwuY29udmVydGVycy5SZXF1ZXN0KFYsIHByZWZpeCwgYXJndW1lbnQpXG4gIH1cblxuICByZXR1cm4gd2ViaWRsLmNvbnZlcnRlcnMuVVNWU3RyaW5nKFYsIHByZWZpeCwgYXJndW1lbnQpXG59XG5cbndlYmlkbC5jb252ZXJ0ZXJzLkFib3J0U2lnbmFsID0gd2ViaWRsLmludGVyZmFjZUNvbnZlcnRlcihcbiAgQWJvcnRTaWduYWxcbilcblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI3JlcXVlc3Rpbml0XG53ZWJpZGwuY29udmVydGVycy5SZXF1ZXN0SW5pdCA9IHdlYmlkbC5kaWN0aW9uYXJ5Q29udmVydGVyKFtcbiAge1xuICAgIGtleTogJ21ldGhvZCcsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5CeXRlU3RyaW5nXG4gIH0sXG4gIHtcbiAgICBrZXk6ICdoZWFkZXJzJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLkhlYWRlcnNJbml0XG4gIH0sXG4gIHtcbiAgICBrZXk6ICdib2R5JyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5udWxsYWJsZUNvbnZlcnRlcihcbiAgICAgIHdlYmlkbC5jb252ZXJ0ZXJzLkJvZHlJbml0XG4gICAgKVxuICB9LFxuICB7XG4gICAga2V5OiAncmVmZXJyZXInLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuVVNWU3RyaW5nXG4gIH0sXG4gIHtcbiAgICBrZXk6ICdyZWZlcnJlclBvbGljeScsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5ET01TdHJpbmcsXG4gICAgLy8gaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmFwcHNlYy1yZWZlcnJlci1wb2xpY3kvI3JlZmVycmVyLXBvbGljeVxuICAgIGFsbG93ZWRWYWx1ZXM6IHJlZmVycmVyUG9saWN5XG4gIH0sXG4gIHtcbiAgICBrZXk6ICdtb2RlJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLkRPTVN0cmluZyxcbiAgICAvLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1yZXF1ZXN0LW1vZGVcbiAgICBhbGxvd2VkVmFsdWVzOiByZXF1ZXN0TW9kZVxuICB9LFxuICB7XG4gICAga2V5OiAnY3JlZGVudGlhbHMnLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuRE9NU3RyaW5nLFxuICAgIC8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNyZXF1ZXN0Y3JlZGVudGlhbHNcbiAgICBhbGxvd2VkVmFsdWVzOiByZXF1ZXN0Q3JlZGVudGlhbHNcbiAgfSxcbiAge1xuICAgIGtleTogJ2NhY2hlJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLkRPTVN0cmluZyxcbiAgICAvLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jcmVxdWVzdGNhY2hlXG4gICAgYWxsb3dlZFZhbHVlczogcmVxdWVzdENhY2hlXG4gIH0sXG4gIHtcbiAgICBrZXk6ICdyZWRpcmVjdCcsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5ET01TdHJpbmcsXG4gICAgLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI3JlcXVlc3RyZWRpcmVjdFxuICAgIGFsbG93ZWRWYWx1ZXM6IHJlcXVlc3RSZWRpcmVjdFxuICB9LFxuICB7XG4gICAga2V5OiAnaW50ZWdyaXR5JyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLkRPTVN0cmluZ1xuICB9LFxuICB7XG4gICAga2V5OiAna2VlcGFsaXZlJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLmJvb2xlYW5cbiAgfSxcbiAge1xuICAgIGtleTogJ3NpZ25hbCcsXG4gICAgY29udmVydGVyOiB3ZWJpZGwubnVsbGFibGVDb252ZXJ0ZXIoXG4gICAgICAoc2lnbmFsKSA9PiB3ZWJpZGwuY29udmVydGVycy5BYm9ydFNpZ25hbChcbiAgICAgICAgc2lnbmFsLFxuICAgICAgICAnUmVxdWVzdEluaXQnLFxuICAgICAgICAnc2lnbmFsJyxcbiAgICAgICAgeyBzdHJpY3Q6IGZhbHNlIH1cbiAgICAgIClcbiAgICApXG4gIH0sXG4gIHtcbiAgICBrZXk6ICd3aW5kb3cnLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuYW55XG4gIH0sXG4gIHtcbiAgICBrZXk6ICdkdXBsZXgnLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuRE9NU3RyaW5nLFxuICAgIGFsbG93ZWRWYWx1ZXM6IHJlcXVlc3REdXBsZXhcbiAgfSxcbiAge1xuICAgIGtleTogJ2Rpc3BhdGNoZXInLCAvLyB1bmRpY2kgc3BlY2lmaWMgb3B0aW9uXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5hbnlcbiAgfVxuXSlcblxubW9kdWxlLmV4cG9ydHMgPSB7IFJlcXVlc3QsIG1ha2VSZXF1ZXN0LCBmcm9tSW5uZXJSZXF1ZXN0LCBjbG9uZVJlcXVlc3QgfVxuIl0sIm5hbWVzIjpbImV4dHJhY3RCb2R5IiwibWl4aW5Cb2R5IiwiY2xvbmVCb2R5IiwicmVxdWlyZSIsIkhlYWRlcnMiLCJmaWxsIiwiZmlsbEhlYWRlcnMiLCJIZWFkZXJzTGlzdCIsInNldEhlYWRlcnNHdWFyZCIsImdldEhlYWRlcnNHdWFyZCIsInNldEhlYWRlcnNMaXN0IiwiZ2V0SGVhZGVyc0xpc3QiLCJGaW5hbGl6YXRpb25SZWdpc3RyeSIsInV0aWwiLCJub2RlVXRpbCIsImlzVmFsaWRIVFRQVG9rZW4iLCJzYW1lT3JpZ2luIiwiZW52aXJvbm1lbnRTZXR0aW5nc09iamVjdCIsImZvcmJpZGRlbk1ldGhvZHNTZXQiLCJjb3JzU2FmZUxpc3RlZE1ldGhvZHNTZXQiLCJyZWZlcnJlclBvbGljeSIsInJlcXVlc3RSZWRpcmVjdCIsInJlcXVlc3RNb2RlIiwicmVxdWVzdENyZWRlbnRpYWxzIiwicmVxdWVzdENhY2hlIiwicmVxdWVzdER1cGxleCIsImtFbnVtZXJhYmxlUHJvcGVydHkiLCJub3JtYWxpemVkTWV0aG9kUmVjb3Jkc0Jhc2UiLCJub3JtYWxpemVkTWV0aG9kUmVjb3JkcyIsImtIZWFkZXJzIiwia1NpZ25hbCIsImtTdGF0ZSIsImtEaXNwYXRjaGVyIiwid2ViaWRsIiwiVVJMU2VyaWFsaXplciIsImtDb25zdHJ1Y3QiLCJhc3NlcnQiLCJnZXRNYXhMaXN0ZW5lcnMiLCJzZXRNYXhMaXN0ZW5lcnMiLCJnZXRFdmVudExpc3RlbmVycyIsImRlZmF1bHRNYXhMaXN0ZW5lcnMiLCJrQWJvcnRDb250cm9sbGVyIiwiU3ltYm9sIiwicmVxdWVzdEZpbmFsaXplciIsInNpZ25hbCIsImFib3J0IiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImRlcGVuZGVudENvbnRyb2xsZXJNYXAiLCJXZWFrTWFwIiwiYnVpbGRBYm9ydCIsImFjUmVmIiwiYWMiLCJkZXJlZiIsInVuZGVmaW5lZCIsInVucmVnaXN0ZXIiLCJyZWFzb24iLCJjb250cm9sbGVyTGlzdCIsImdldCIsInNpemUiLCJyZWYiLCJjdHJsIiwiY2xlYXIiLCJkZWxldGUiLCJwYXRjaE1ldGhvZFdhcm5pbmciLCJSZXF1ZXN0IiwiY29uc3RydWN0b3IiLCJpbnB1dCIsImluaXQiLCJwcmVmaXgiLCJhcmd1bWVudExlbmd0aENoZWNrIiwiYXJndW1lbnRzIiwiY29udmVydGVycyIsIlJlcXVlc3RJbmZvIiwiUmVxdWVzdEluaXQiLCJyZXF1ZXN0IiwiZmFsbGJhY2tNb2RlIiwiYmFzZVVybCIsInNldHRpbmdzT2JqZWN0IiwiZGlzcGF0Y2hlciIsInBhcnNlZFVSTCIsIlVSTCIsImVyciIsIlR5cGVFcnJvciIsImNhdXNlIiwidXNlcm5hbWUiLCJwYXNzd29yZCIsIm1ha2VSZXF1ZXN0IiwidXJsTGlzdCIsIm9yaWdpbiIsIndpbmRvdyIsIm5hbWUiLCJtZXRob2QiLCJoZWFkZXJzTGlzdCIsInVuc2FmZVJlcXVlc3QiLCJjbGllbnQiLCJwcmlvcml0eSIsInJlZmVycmVyIiwibW9kZSIsImNyZWRlbnRpYWxzIiwiY2FjaGUiLCJyZWRpcmVjdCIsImludGVncml0eSIsImtlZXBhbGl2ZSIsInJlbG9hZE5hdmlnYXRpb24iLCJoaXN0b3J5TmF2aWdhdGlvbiIsImluaXRIYXNLZXkiLCJPYmplY3QiLCJrZXlzIiwibGVuZ3RoIiwidXJsIiwicGFyc2VkUmVmZXJyZXIiLCJwcm90b2NvbCIsImhvc3RuYW1lIiwiZXJyb3JzIiwiZXhjZXB0aW9uIiwiaGVhZGVyIiwibWVzc2FnZSIsIlN0cmluZyIsIkJvb2xlYW4iLCJtYXlCZU5vcm1hbGl6ZWQiLCJ1cHBlckNhc2UiLCJ0b1VwcGVyQ2FzZSIsImhhcyIsInByb2Nlc3MiLCJlbWl0V2FybmluZyIsImNvZGUiLCJBYm9ydENvbnRyb2xsZXIiLCJhYm9ydGVkIiwiYWRkRXZlbnRMaXN0ZW5lciIsIldlYWtSZWYiLCJhZGRBYm9ydExpc3RlbmVyIiwicmVnaXN0ZXIiLCJoZWFkZXJzIiwidmFsdWUiLCJyYXdWYWx1ZXMiLCJhcHBlbmQiLCJjb29raWVzIiwiaW5wdXRCb2R5IiwiYm9keSIsImluaXRCb2R5IiwiZXh0cmFjdGVkQm9keSIsImNvbnRlbnRUeXBlIiwiY29udGFpbnMiLCJpbnB1dE9ySW5pdEJvZHkiLCJzb3VyY2UiLCJkdXBsZXgiLCJ1c2VDT1JTUHJlZmxpZ2h0RmxhZyIsImZpbmFsQm9keSIsImlzRGlzdHVyYmVkIiwic3RyZWFtIiwibG9ja2VkIiwiaWRlbnRpdHlUcmFuc2Zvcm0iLCJUcmFuc2Zvcm1TdHJlYW0iLCJwaXBlVGhyb3VnaCIsInJlYWRhYmxlIiwiYnJhbmRDaGVjayIsImRlc3RpbmF0aW9uIiwidG9TdHJpbmciLCJpc1JlbG9hZE5hdmlnYXRpb24iLCJpc0hpc3RvcnlOYXZpZ2F0aW9uIiwiYm9keVVzZWQiLCJjbG9uZSIsImNsb25lZFJlcXVlc3QiLCJjbG9uZVJlcXVlc3QiLCJsaXN0IiwiU2V0Iiwic2V0IiwiYWRkIiwiZnJvbUlubmVyUmVxdWVzdCIsImluc3BlY3QiLCJjdXN0b20iLCJkZXB0aCIsIm9wdGlvbnMiLCJjb2xvcnMiLCJwcm9wZXJ0aWVzIiwiZm9ybWF0V2l0aE9wdGlvbnMiLCJsb2NhbFVSTHNPbmx5IiwicmVzZXJ2ZWRDbGllbnQiLCJyZXBsYWNlc0NsaWVudElkIiwic2VydmljZVdvcmtlcnMiLCJpbml0aWF0b3IiLCJwb2xpY3lDb250YWluZXIiLCJ1c2VDcmVkZW50aWFscyIsImNyeXB0b0dyYXBoaWNzTm9uY2VNZXRhZGF0YSIsInBhcnNlck1ldGFkYXRhIiwidXNlckFjdGl2YXRpb24iLCJ0YWludGVkT3JpZ2luIiwicmVkaXJlY3RDb3VudCIsInJlc3BvbnNlVGFpbnRpbmciLCJwcmV2ZW50Tm9DYWNoZUNhY2hlQ29udHJvbEhlYWRlck1vZGlmaWNhdGlvbiIsImRvbmUiLCJ0aW1pbmdBbGxvd0ZhaWxlZCIsIm5ld1JlcXVlc3QiLCJpbm5lclJlcXVlc3QiLCJndWFyZCIsImRlZmluZVByb3BlcnRpZXMiLCJwcm90b3R5cGUiLCJhdHRyaWJ1dGUiLCJ0b1N0cmluZ1RhZyIsImNvbmZpZ3VyYWJsZSIsImludGVyZmFjZUNvbnZlcnRlciIsIlYiLCJhcmd1bWVudCIsIlVTVlN0cmluZyIsIkFib3J0U2lnbmFsIiwiZGljdGlvbmFyeUNvbnZlcnRlciIsImtleSIsImNvbnZlcnRlciIsIkJ5dGVTdHJpbmciLCJIZWFkZXJzSW5pdCIsIm51bGxhYmxlQ29udmVydGVyIiwiQm9keUluaXQiLCJET01TdHJpbmciLCJhbGxvd2VkVmFsdWVzIiwiYm9vbGVhbiIsInN0cmljdCIsImFueSIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/fetch/request.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/fetch/response.js":
/*!*******************************************************!*\
  !*** ./node_modules/undici/lib/web/fetch/response.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { Headers, HeadersList, fill, getHeadersGuard, setHeadersGuard, setHeadersList } = __webpack_require__(/*! ./headers */ \"(ssr)/./node_modules/undici/lib/web/fetch/headers.js\");\nconst { extractBody, cloneBody, mixinBody } = __webpack_require__(/*! ./body */ \"(ssr)/./node_modules/undici/lib/web/fetch/body.js\");\nconst util = __webpack_require__(/*! ../../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\");\nconst nodeUtil = __webpack_require__(/*! node:util */ \"node:util\");\nconst { kEnumerableProperty } = util;\nconst { isValidReasonPhrase, isCancelled, isAborted, isBlobLike, serializeJavascriptValueToJSONString, isErrorLike, isomorphicEncode, environmentSettingsObject: relevantRealm } = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/undici/lib/web/fetch/util.js\");\nconst { redirectStatusSet, nullBodyStatus } = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/undici/lib/web/fetch/constants.js\");\nconst { kState, kHeaders } = __webpack_require__(/*! ./symbols */ \"(ssr)/./node_modules/undici/lib/web/fetch/symbols.js\");\nconst { webidl } = __webpack_require__(/*! ./webidl */ \"(ssr)/./node_modules/undici/lib/web/fetch/webidl.js\");\nconst { FormData } = __webpack_require__(/*! ./formdata */ \"(ssr)/./node_modules/undici/lib/web/fetch/formdata.js\");\nconst { URLSerializer } = __webpack_require__(/*! ./data-url */ \"(ssr)/./node_modules/undici/lib/web/fetch/data-url.js\");\nconst { kConstruct } = __webpack_require__(/*! ../../core/symbols */ \"(ssr)/./node_modules/undici/lib/core/symbols.js\");\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\");\nconst { types } = __webpack_require__(/*! node:util */ \"node:util\");\nconst { isDisturbed, isErrored } = __webpack_require__(/*! node:stream */ \"node:stream\");\nconst textEncoder = new TextEncoder(\"utf-8\");\nconst hasFinalizationRegistry = globalThis.FinalizationRegistry && process.version.indexOf(\"v18\") !== 0;\nlet registry;\nif (hasFinalizationRegistry) {\n    registry = new FinalizationRegistry((weakRef)=>{\n        const stream = weakRef.deref();\n        if (stream && !stream.locked && !isDisturbed(stream) && !isErrored(stream)) {\n            stream.cancel(\"Response object has been garbage collected\").catch(noop);\n        }\n    });\n}\nfunction noop() {}\n// https://fetch.spec.whatwg.org/#response-class\nclass Response {\n    // Creates network error Response.\n    static error() {\n        // The static error() method steps are to return the result of creating a\n        // Response object, given a new network error, \"immutable\", and thiss\n        // relevant Realm.\n        const responseObject = fromInnerResponse(makeNetworkError(), \"immutable\");\n        return responseObject;\n    }\n    // https://fetch.spec.whatwg.org/#dom-response-json\n    static json(data, init = {}) {\n        webidl.argumentLengthCheck(arguments, 1, \"Response.json\");\n        if (init !== null) {\n            init = webidl.converters.ResponseInit(init);\n        }\n        // 1. Let bytes the result of running serialize a JavaScript value to JSON bytes on data.\n        const bytes = textEncoder.encode(serializeJavascriptValueToJSONString(data));\n        // 2. Let body be the result of extracting bytes.\n        const body = extractBody(bytes);\n        // 3. Let responseObject be the result of creating a Response object, given a new response,\n        //    \"response\", and thiss relevant Realm.\n        const responseObject = fromInnerResponse(makeResponse({}), \"response\");\n        // 4. Perform initialize a response given responseObject, init, and (body, \"application/json\").\n        initializeResponse(responseObject, init, {\n            body: body[0],\n            type: \"application/json\"\n        });\n        // 5. Return responseObject.\n        return responseObject;\n    }\n    // Creates a redirect Response that redirects to url with status status.\n    static redirect(url, status = 302) {\n        webidl.argumentLengthCheck(arguments, 1, \"Response.redirect\");\n        url = webidl.converters.USVString(url);\n        status = webidl.converters[\"unsigned short\"](status);\n        // 1. Let parsedURL be the result of parsing url with current settings\n        // objects API base URL.\n        // 2. If parsedURL is failure, then throw a TypeError.\n        // TODO: base-URL?\n        let parsedURL;\n        try {\n            parsedURL = new URL(url, relevantRealm.settingsObject.baseUrl);\n        } catch (err) {\n            throw new TypeError(`Failed to parse URL from ${url}`, {\n                cause: err\n            });\n        }\n        // 3. If status is not a redirect status, then throw a RangeError.\n        if (!redirectStatusSet.has(status)) {\n            throw new RangeError(`Invalid status code ${status}`);\n        }\n        // 4. Let responseObject be the result of creating a Response object,\n        // given a new response, \"immutable\", and thiss relevant Realm.\n        const responseObject = fromInnerResponse(makeResponse({}), \"immutable\");\n        // 5. Set responseObjects responses status to status.\n        responseObject[kState].status = status;\n        // 6. Let value be parsedURL, serialized and isomorphic encoded.\n        const value = isomorphicEncode(URLSerializer(parsedURL));\n        // 7. Append `Location`/value to responseObjects responses header list.\n        responseObject[kState].headersList.append(\"location\", value, true);\n        // 8. Return responseObject.\n        return responseObject;\n    }\n    // https://fetch.spec.whatwg.org/#dom-response\n    constructor(body = null, init = {}){\n        if (body === kConstruct) {\n            return;\n        }\n        if (body !== null) {\n            body = webidl.converters.BodyInit(body);\n        }\n        init = webidl.converters.ResponseInit(init);\n        // 1. Set thiss response to a new response.\n        this[kState] = makeResponse({});\n        // 2. Set thiss headers to a new Headers object with thiss relevant\n        // Realm, whose header list is thiss responses header list and guard\n        // is \"response\".\n        this[kHeaders] = new Headers(kConstruct);\n        setHeadersGuard(this[kHeaders], \"response\");\n        setHeadersList(this[kHeaders], this[kState].headersList);\n        // 3. Let bodyWithType be null.\n        let bodyWithType = null;\n        // 4. If body is non-null, then set bodyWithType to the result of extracting body.\n        if (body != null) {\n            const [extractedBody, type] = extractBody(body);\n            bodyWithType = {\n                body: extractedBody,\n                type\n            };\n        }\n        // 5. Perform initialize a response given this, init, and bodyWithType.\n        initializeResponse(this, init, bodyWithType);\n    }\n    // Returns responses type, e.g., \"cors\".\n    get type() {\n        webidl.brandCheck(this, Response);\n        // The type getter steps are to return thiss responses type.\n        return this[kState].type;\n    }\n    // Returns responses URL, if it has one; otherwise the empty string.\n    get url() {\n        webidl.brandCheck(this, Response);\n        const urlList = this[kState].urlList;\n        // The url getter steps are to return the empty string if thiss\n        // responses URL is null; otherwise thiss responses URL,\n        // serialized with exclude fragment set to true.\n        const url = urlList[urlList.length - 1] ?? null;\n        if (url === null) {\n            return \"\";\n        }\n        return URLSerializer(url, true);\n    }\n    // Returns whether response was obtained through a redirect.\n    get redirected() {\n        webidl.brandCheck(this, Response);\n        // The redirected getter steps are to return true if thiss responses URL\n        // list has more than one item; otherwise false.\n        return this[kState].urlList.length > 1;\n    }\n    // Returns responses status.\n    get status() {\n        webidl.brandCheck(this, Response);\n        // The status getter steps are to return thiss responses status.\n        return this[kState].status;\n    }\n    // Returns whether responses status is an ok status.\n    get ok() {\n        webidl.brandCheck(this, Response);\n        // The ok getter steps are to return true if thiss responses status is an\n        // ok status; otherwise false.\n        return this[kState].status >= 200 && this[kState].status <= 299;\n    }\n    // Returns responses status message.\n    get statusText() {\n        webidl.brandCheck(this, Response);\n        // The statusText getter steps are to return thiss responses status\n        // message.\n        return this[kState].statusText;\n    }\n    // Returns responses headers as Headers.\n    get headers() {\n        webidl.brandCheck(this, Response);\n        // The headers getter steps are to return thiss headers.\n        return this[kHeaders];\n    }\n    get body() {\n        webidl.brandCheck(this, Response);\n        return this[kState].body ? this[kState].body.stream : null;\n    }\n    get bodyUsed() {\n        webidl.brandCheck(this, Response);\n        return !!this[kState].body && util.isDisturbed(this[kState].body.stream);\n    }\n    // Returns a clone of response.\n    clone() {\n        webidl.brandCheck(this, Response);\n        // 1. If this is unusable, then throw a TypeError.\n        if (this.bodyUsed || this.body?.locked) {\n            throw webidl.errors.exception({\n                header: \"Response.clone\",\n                message: \"Body has already been consumed.\"\n            });\n        }\n        // 2. Let clonedResponse be the result of cloning thiss response.\n        const clonedResponse = cloneResponse(this[kState]);\n        // 3. Return the result of creating a Response object, given\n        // clonedResponse, thiss headerss guard, and thiss relevant Realm.\n        return fromInnerResponse(clonedResponse, getHeadersGuard(this[kHeaders]));\n    }\n    [nodeUtil.inspect.custom](depth, options) {\n        if (options.depth === null) {\n            options.depth = 2;\n        }\n        options.colors ??= true;\n        const properties = {\n            status: this.status,\n            statusText: this.statusText,\n            headers: this.headers,\n            body: this.body,\n            bodyUsed: this.bodyUsed,\n            ok: this.ok,\n            redirected: this.redirected,\n            type: this.type,\n            url: this.url\n        };\n        return `Response ${nodeUtil.formatWithOptions(options, properties)}`;\n    }\n}\nmixinBody(Response);\nObject.defineProperties(Response.prototype, {\n    type: kEnumerableProperty,\n    url: kEnumerableProperty,\n    status: kEnumerableProperty,\n    ok: kEnumerableProperty,\n    redirected: kEnumerableProperty,\n    statusText: kEnumerableProperty,\n    headers: kEnumerableProperty,\n    clone: kEnumerableProperty,\n    body: kEnumerableProperty,\n    bodyUsed: kEnumerableProperty,\n    [Symbol.toStringTag]: {\n        value: \"Response\",\n        configurable: true\n    }\n});\nObject.defineProperties(Response, {\n    json: kEnumerableProperty,\n    redirect: kEnumerableProperty,\n    error: kEnumerableProperty\n});\n// https://fetch.spec.whatwg.org/#concept-response-clone\nfunction cloneResponse(response) {\n    // To clone a response response, run these steps:\n    // 1. If response is a filtered response, then return a new identical\n    // filtered response whose internal response is a clone of responses\n    // internal response.\n    if (response.internalResponse) {\n        return filterResponse(cloneResponse(response.internalResponse), response.type);\n    }\n    // 2. Let newResponse be a copy of response, except for its body.\n    const newResponse = makeResponse({\n        ...response,\n        body: null\n    });\n    // 3. If responses body is non-null, then set newResponses body to the\n    // result of cloning responses body.\n    if (response.body != null) {\n        newResponse.body = cloneBody(response.body);\n    }\n    // 4. Return newResponse.\n    return newResponse;\n}\nfunction makeResponse(init) {\n    return {\n        aborted: false,\n        rangeRequested: false,\n        timingAllowPassed: false,\n        requestIncludesCredentials: false,\n        type: \"default\",\n        status: 200,\n        timingInfo: null,\n        cacheState: \"\",\n        statusText: \"\",\n        ...init,\n        headersList: init?.headersList ? new HeadersList(init?.headersList) : new HeadersList(),\n        urlList: init?.urlList ? [\n            ...init.urlList\n        ] : []\n    };\n}\nfunction makeNetworkError(reason) {\n    const isError = isErrorLike(reason);\n    return makeResponse({\n        type: \"error\",\n        status: 0,\n        error: isError ? reason : new Error(reason ? String(reason) : reason),\n        aborted: reason && reason.name === \"AbortError\"\n    });\n}\n// @see https://fetch.spec.whatwg.org/#concept-network-error\nfunction isNetworkError(response) {\n    return(// A network error is a response whose type is \"error\",\n    response.type === \"error\" && // status is 0\n    response.status === 0);\n}\nfunction makeFilteredResponse(response, state) {\n    state = {\n        internalResponse: response,\n        ...state\n    };\n    return new Proxy(response, {\n        get (target, p) {\n            return p in state ? state[p] : target[p];\n        },\n        set (target, p, value) {\n            assert(!(p in state));\n            target[p] = value;\n            return true;\n        }\n    });\n}\n// https://fetch.spec.whatwg.org/#concept-filtered-response\nfunction filterResponse(response, type) {\n    // Set response to the following filtered response with response as its\n    // internal response, depending on requests response tainting:\n    if (type === \"basic\") {\n        // A basic filtered response is a filtered response whose type is \"basic\"\n        // and header list excludes any headers in internal responses header list\n        // whose name is a forbidden response-header name.\n        // Note: undici does not implement forbidden response-header names\n        return makeFilteredResponse(response, {\n            type: \"basic\",\n            headersList: response.headersList\n        });\n    } else if (type === \"cors\") {\n        // A CORS filtered response is a filtered response whose type is \"cors\"\n        // and header list excludes any headers in internal responses header\n        // list whose name is not a CORS-safelisted response-header name, given\n        // internal responses CORS-exposed header-name list.\n        // Note: undici does not implement CORS-safelisted response-header names\n        return makeFilteredResponse(response, {\n            type: \"cors\",\n            headersList: response.headersList\n        });\n    } else if (type === \"opaque\") {\n        // An opaque filtered response is a filtered response whose type is\n        // \"opaque\", URL list is the empty list, status is 0, status message\n        // is the empty byte sequence, header list is empty, and body is null.\n        return makeFilteredResponse(response, {\n            type: \"opaque\",\n            urlList: Object.freeze([]),\n            status: 0,\n            statusText: \"\",\n            body: null\n        });\n    } else if (type === \"opaqueredirect\") {\n        // An opaque-redirect filtered response is a filtered response whose type\n        // is \"opaqueredirect\", status is 0, status message is the empty byte\n        // sequence, header list is empty, and body is null.\n        return makeFilteredResponse(response, {\n            type: \"opaqueredirect\",\n            status: 0,\n            statusText: \"\",\n            headersList: [],\n            body: null\n        });\n    } else {\n        assert(false);\n    }\n}\n// https://fetch.spec.whatwg.org/#appropriate-network-error\nfunction makeAppropriateNetworkError(fetchParams, err = null) {\n    // 1. Assert: fetchParams is canceled.\n    assert(isCancelled(fetchParams));\n    // 2. Return an aborted network error if fetchParams is aborted;\n    // otherwise return a network error.\n    return isAborted(fetchParams) ? makeNetworkError(Object.assign(new DOMException(\"The operation was aborted.\", \"AbortError\"), {\n        cause: err\n    })) : makeNetworkError(Object.assign(new DOMException(\"Request was cancelled.\"), {\n        cause: err\n    }));\n}\n// https://whatpr.org/fetch/1392.html#initialize-a-response\nfunction initializeResponse(response, init, body) {\n    // 1. If init[\"status\"] is not in the range 200 to 599, inclusive, then\n    //    throw a RangeError.\n    if (init.status !== null && (init.status < 200 || init.status > 599)) {\n        throw new RangeError('init[\"status\"] must be in the range of 200 to 599, inclusive.');\n    }\n    // 2. If init[\"statusText\"] does not match the reason-phrase token production,\n    //    then throw a TypeError.\n    if (\"statusText\" in init && init.statusText != null) {\n        // See, https://datatracker.ietf.org/doc/html/rfc7230#section-3.1.2:\n        //   reason-phrase  = *( HTAB / SP / VCHAR / obs-text )\n        if (!isValidReasonPhrase(String(init.statusText))) {\n            throw new TypeError(\"Invalid statusText\");\n        }\n    }\n    // 3. Set responses responses status to init[\"status\"].\n    if (\"status\" in init && init.status != null) {\n        response[kState].status = init.status;\n    }\n    // 4. Set responses responses status message to init[\"statusText\"].\n    if (\"statusText\" in init && init.statusText != null) {\n        response[kState].statusText = init.statusText;\n    }\n    // 5. If init[\"headers\"] exists, then fill responses headers with init[\"headers\"].\n    if (\"headers\" in init && init.headers != null) {\n        fill(response[kHeaders], init.headers);\n    }\n    // 6. If body was given, then:\n    if (body) {\n        // 1. If response's status is a null body status, then throw a TypeError.\n        if (nullBodyStatus.includes(response.status)) {\n            throw webidl.errors.exception({\n                header: \"Response constructor\",\n                message: `Invalid response status code ${response.status}`\n            });\n        }\n        // 2. Set response's body to body's body.\n        response[kState].body = body.body;\n        // 3. If body's type is non-null and response's header list does not contain\n        //    `Content-Type`, then append (`Content-Type`, body's type) to response's header list.\n        if (body.type != null && !response[kState].headersList.contains(\"content-type\", true)) {\n            response[kState].headersList.append(\"content-type\", body.type, true);\n        }\n    }\n}\n/**\n * @see https://fetch.spec.whatwg.org/#response-create\n * @param {any} innerResponse\n * @param {'request' | 'immutable' | 'request-no-cors' | 'response' | 'none'} guard\n * @returns {Response}\n */ function fromInnerResponse(innerResponse, guard) {\n    const response = new Response(kConstruct);\n    response[kState] = innerResponse;\n    response[kHeaders] = new Headers(kConstruct);\n    setHeadersList(response[kHeaders], innerResponse.headersList);\n    setHeadersGuard(response[kHeaders], guard);\n    if (hasFinalizationRegistry && innerResponse.body?.stream) {\n        // If the target (response) is reclaimed, the cleanup callback may be called at some point with\n        // the held value provided for it (innerResponse.body.stream). The held value can be any value:\n        // a primitive or an object, even undefined. If the held value is an object, the registry keeps\n        // a strong reference to it (so it can pass it to the cleanup callback later). Reworded from\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/FinalizationRegistry\n        registry.register(response, new WeakRef(innerResponse.body.stream));\n    }\n    return response;\n}\nwebidl.converters.ReadableStream = webidl.interfaceConverter(ReadableStream);\nwebidl.converters.FormData = webidl.interfaceConverter(FormData);\nwebidl.converters.URLSearchParams = webidl.interfaceConverter(URLSearchParams);\n// https://fetch.spec.whatwg.org/#typedefdef-xmlhttprequestbodyinit\nwebidl.converters.XMLHttpRequestBodyInit = function(V, prefix, name) {\n    if (typeof V === \"string\") {\n        return webidl.converters.USVString(V, prefix, name);\n    }\n    if (isBlobLike(V)) {\n        return webidl.converters.Blob(V, prefix, name, {\n            strict: false\n        });\n    }\n    if (ArrayBuffer.isView(V) || types.isArrayBuffer(V)) {\n        return webidl.converters.BufferSource(V, prefix, name);\n    }\n    if (util.isFormDataLike(V)) {\n        return webidl.converters.FormData(V, prefix, name, {\n            strict: false\n        });\n    }\n    if (V instanceof URLSearchParams) {\n        return webidl.converters.URLSearchParams(V, prefix, name);\n    }\n    return webidl.converters.DOMString(V, prefix, name);\n};\n// https://fetch.spec.whatwg.org/#bodyinit\nwebidl.converters.BodyInit = function(V, prefix, argument) {\n    if (V instanceof ReadableStream) {\n        return webidl.converters.ReadableStream(V, prefix, argument);\n    }\n    // Note: the spec doesn't include async iterables,\n    // this is an undici extension.\n    if (V?.[Symbol.asyncIterator]) {\n        return V;\n    }\n    return webidl.converters.XMLHttpRequestBodyInit(V, prefix, argument);\n};\nwebidl.converters.ResponseInit = webidl.dictionaryConverter([\n    {\n        key: \"status\",\n        converter: webidl.converters[\"unsigned short\"],\n        defaultValue: ()=>200\n    },\n    {\n        key: \"statusText\",\n        converter: webidl.converters.ByteString,\n        defaultValue: ()=>\"\"\n    },\n    {\n        key: \"headers\",\n        converter: webidl.converters.HeadersInit\n    }\n]);\nmodule.exports = {\n    isNetworkError,\n    makeNetworkError,\n    makeResponse,\n    makeAppropriateNetworkError,\n    filterResponse,\n    Response,\n    cloneResponse,\n    fromInnerResponse\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZmV0Y2gvcmVzcG9uc2UuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNLEVBQUVBLE9BQU8sRUFBRUMsV0FBVyxFQUFFQyxJQUFJLEVBQUVDLGVBQWUsRUFBRUMsZUFBZSxFQUFFQyxjQUFBQSxFQUFnQixHQUFHQyxtQkFBT0EsQ0FBQztBQUNqRyxNQUFNLEVBQUVDLFdBQVcsRUFBRUMsU0FBUyxFQUFFQyxTQUFBQSxFQUFXLEdBQUdILG1CQUFPQSxDQUFDO0FBQ3RELE1BQU1JLE9BQU9KLG1CQUFPQSxDQUFDO0FBQ3JCLE1BQU1LLFdBQVdMLG1CQUFPQSxDQUFDO0FBQ3pCLE1BQU0sRUFBRU0sbUJBQUFBLEVBQXFCLEdBQUdGO0FBQ2hDLE1BQU0sRUFDSkcsbUJBQW1CLEVBQ25CQyxXQUFXLEVBQ1hDLFNBQVMsRUFDVEMsVUFBVSxFQUNWQyxvQ0FBb0MsRUFDcENDLFdBQVcsRUFDWEMsZ0JBQWdCLEVBQ2hCQywyQkFBMkJDLGFBQUFBLEVBQzVCLEdBQUdmLG1CQUFPQSxDQUFDO0FBQ1osTUFBTSxFQUNKZ0IsaUJBQWlCLEVBQ2pCQyxjQUFBQSxFQUNELEdBQUdqQixtQkFBT0EsQ0FBQztBQUNaLE1BQU0sRUFBRWtCLE1BQU0sRUFBRUMsUUFBQUEsRUFBVSxHQUFHbkIsbUJBQU9BLENBQUM7QUFDckMsTUFBTSxFQUFFb0IsTUFBQUEsRUFBUSxHQUFHcEIsbUJBQU9BLENBQUM7QUFDM0IsTUFBTSxFQUFFcUIsUUFBQUEsRUFBVSxHQUFHckIsbUJBQU9BLENBQUM7QUFDN0IsTUFBTSxFQUFFc0IsYUFBQUEsRUFBZSxHQUFHdEIsbUJBQU9BLENBQUM7QUFDbEMsTUFBTSxFQUFFdUIsVUFBQUEsRUFBWSxHQUFHdkIsbUJBQU9BLENBQUM7QUFDL0IsTUFBTXdCLFNBQVN4QixtQkFBT0EsQ0FBQztBQUN2QixNQUFNLEVBQUV5QixLQUFBQSxFQUFPLEdBQUd6QixtQkFBT0EsQ0FBQztBQUMxQixNQUFN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T2tDLFVBQVUsQ0FBQ3VHLFNBQVMsQ0FBQ1QsR0FBR0MsUUFBUXpCO0FBQ2hEO0FBRUE7QUFDQXhHLE9BQU9rQyxVQUFVLENBQUN5QixRQUFRLEdBQUcsU0FBVXFFLENBQUMsRUFBRUMsTUFBTSxFQUFFUyxRQUFRO0lBQ3hELElBQUlWLGFBQWFKLGdCQUFnQjtRQUMvQixPQUFPNUgsT0FBT2tDLFVBQVUsQ0FBQzBGLGNBQWMsQ0FBQ0ksR0FBR0MsUUFBUVM7SUFDckQ7SUFFQTtJQUNBO0lBQ0EsSUFBSVYsR0FBQyxDQUFHekMsT0FBT29ELGFBQWEsQ0FBQyxFQUFFO1FBQzdCLE9BQU9YO0lBQ1Q7SUFFQSxPQUFPaEksT0FBT2tDLFVBQVUsQ0FBQzZGLHNCQUFzQixDQUFDQyxHQUFHQyxRQUFRUztBQUM3RDtBQUVBMUksT0FBT2tDLFVBQVUsQ0FBQ0MsWUFBWSxHQUFHbkMsT0FBTzRJLG1CQUFtQixDQUFDO0lBQzFEO1FBQ0VDLEtBQUs7UUFDTEMsV0FBVzlJLE9BQU9rQyxVQUFVLENBQUMsaUJBQWlCO1FBQzlDNkcsY0FBY0EsSUFBTTtJQUN0QjtJQUNBO1FBQ0VGLEtBQUs7UUFDTEMsV0FBVzlJLE9BQU9rQyxVQUFVLENBQUM4RyxVQUFVO1FBQ3ZDRCxjQUFjQSxJQUFNO0lBQ3RCO0lBQ0E7UUFDRUYsS0FBSztRQUNMQyxXQUFXOUksT0FBT2tDLFVBQVUsQ0FBQytHLFdBQUFBO0lBQy9CO0NBQ0Q7QUFFREMsT0FBT0MsT0FBTyxHQUFHO0lBQ2YxQztJQUNBN0U7SUFDQVc7SUFDQTJFO0lBQ0F0QjtJQUNBcEU7SUFDQW9EO0lBQ0FqRDtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbW9ja3VwZmxvdy8uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL3dlYi9mZXRjaC9yZXNwb25zZS5qcz9hOWNlIiwid2VicGFjazovL21vY2t1cGZsb3cvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZmV0Y2gvcmVzcG9uc2UuanM/YTljZSoiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgSGVhZGVycywgSGVhZGVyc0xpc3QsIGZpbGwsIGdldEhlYWRlcnNHdWFyZCwgc2V0SGVhZGVyc0d1YXJkLCBzZXRIZWFkZXJzTGlzdCB9ID0gcmVxdWlyZSgnLi9oZWFkZXJzJylcbmNvbnN0IHsgZXh0cmFjdEJvZHksIGNsb25lQm9keSwgbWl4aW5Cb2R5IH0gPSByZXF1aXJlKCcuL2JvZHknKVxuY29uc3QgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvdXRpbCcpXG5jb25zdCBub2RlVXRpbCA9IHJlcXVpcmUoJ25vZGU6dXRpbCcpXG5jb25zdCB7IGtFbnVtZXJhYmxlUHJvcGVydHkgfSA9IHV0aWxcbmNvbnN0IHtcbiAgaXNWYWxpZFJlYXNvblBocmFzZSxcbiAgaXNDYW5jZWxsZWQsXG4gIGlzQWJvcnRlZCxcbiAgaXNCbG9iTGlrZSxcbiAgc2VyaWFsaXplSmF2YXNjcmlwdFZhbHVlVG9KU09OU3RyaW5nLFxuICBpc0Vycm9yTGlrZSxcbiAgaXNvbW9ycGhpY0VuY29kZSxcbiAgZW52aXJvbm1lbnRTZXR0aW5nc09iamVjdDogcmVsZXZhbnRSZWFsbVxufSA9IHJlcXVpcmUoJy4vdXRpbCcpXG5jb25zdCB7XG4gIHJlZGlyZWN0U3RhdHVzU2V0LFxuICBudWxsQm9keVN0YXR1c1xufSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJylcbmNvbnN0IHsga1N0YXRlLCBrSGVhZGVycyB9ID0gcmVxdWlyZSgnLi9zeW1ib2xzJylcbmNvbnN0IHsgd2ViaWRsIH0gPSByZXF1aXJlKCcuL3dlYmlkbCcpXG5jb25zdCB7IEZvcm1EYXRhIH0gPSByZXF1aXJlKCcuL2Zvcm1kYXRhJylcbmNvbnN0IHsgVVJMU2VyaWFsaXplciB9ID0gcmVxdWlyZSgnLi9kYXRhLXVybCcpXG5jb25zdCB7IGtDb25zdHJ1Y3QgfSA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvc3ltYm9scycpXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdub2RlOmFzc2VydCcpXG5jb25zdCB7IHR5cGVzIH0gPSByZXF1aXJlKCdub2RlOnV0aWwnKVxuY29uc3QgeyBpc0Rpc3R1cmJlZCwgaXNFcnJvcmVkIH0gPSByZXF1aXJlKCdub2RlOnN0cmVhbScpXG5cbmNvbnN0IHRleHRFbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCd1dGYtOCcpXG5cbmNvbnN0IGhhc0ZpbmFsaXphdGlvblJlZ2lzdHJ5ID0gZ2xvYmFsVGhpcy5GaW5hbGl6YXRpb25SZWdpc3RyeSAmJiBwcm9jZXNzLnZlcnNpb24uaW5kZXhPZigndjE4JykgIT09IDBcbmxldCByZWdpc3RyeVxuXG5pZiAoaGFzRmluYWxpemF0aW9uUmVnaXN0cnkpIHtcbiAgcmVnaXN0cnkgPSBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkoKHdlYWtSZWYpID0+IHtcbiAgICBjb25zdCBzdHJlYW0gPSB3ZWFrUmVmLmRlcmVmKClcbiAgICBpZiAoc3RyZWFtICYmICFzdHJlYW0ubG9ja2VkICYmICFpc0Rpc3R1cmJlZChzdHJlYW0pICYmICFpc0Vycm9yZWQoc3RyZWFtKSkge1xuICAgICAgc3RyZWFtLmNhbmNlbCgnUmVzcG9uc2Ugb2JqZWN0IGhhcyBiZWVuIGdhcmJhZ2UgY29sbGVjdGVkJykuY2F0Y2gobm9vcClcbiAgICB9XG4gIH0pXG59XG5cbmZ1bmN0aW9uIG5vb3AgKCkge31cblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI3Jlc3BvbnNlLWNsYXNzXG5jbGFzcyBSZXNwb25zZSB7XG4gIC8vIENyZWF0ZXMgbmV0d29yayBlcnJvciBSZXNwb25zZS5cbiAgc3RhdGljIGVycm9yICgpIHtcbiAgICAvLyBUaGUgc3RhdGljIGVycm9yKCkgbWV0aG9kIHN0ZXBzIGFyZSB0byByZXR1cm4gdGhlIHJlc3VsdCBvZiBjcmVhdGluZyBhXG4gICAgLy8gUmVzcG9uc2Ugb2JqZWN0LCBnaXZlbiBhIG5ldyBuZXR3b3JrIGVycm9yLCBcImltbXV0YWJsZVwiLCBhbmQgdGhpc+KAmXNcbiAgICAvLyByZWxldmFudCBSZWFsbS5cbiAgICBjb25zdCByZXNwb25zZU9iamVjdCA9IGZyb21Jbm5lclJlc3BvbnNlKG1ha2VOZXR3b3JrRXJyb3IoKSwgJ2ltbXV0YWJsZScpXG5cbiAgICByZXR1cm4gcmVzcG9uc2VPYmplY3RcbiAgfVxuXG4gIC8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNkb20tcmVzcG9uc2UtanNvblxuICBzdGF0aWMganNvbiAoZGF0YSwgaW5pdCA9IHt9KSB7XG4gICAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAxLCAnUmVzcG9uc2UuanNvbicpXG5cbiAgICBpZiAoaW5pdCAhPT0gbnVsbCkge1xuICAgICAgaW5pdCA9IHdlYmlkbC5jb252ZXJ0ZXJzLlJlc3BvbnNlSW5pdChpbml0KVxuICAgIH1cblxuICAgIC8vIDEuIExldCBieXRlcyB0aGUgcmVzdWx0IG9mIHJ1bm5pbmcgc2VyaWFsaXplIGEgSmF2YVNjcmlwdCB2YWx1ZSB0byBKU09OIGJ5dGVzIG9uIGRhdGEuXG4gICAgY29uc3QgYnl0ZXMgPSB0ZXh0RW5jb2Rlci5lbmNvZGUoXG4gICAgICBzZXJpYWxpemVKYXZhc2NyaXB0VmFsdWVUb0pTT05TdHJpbmcoZGF0YSlcbiAgICApXG5cbiAgICAvLyAyLiBMZXQgYm9keSBiZSB0aGUgcmVzdWx0IG9mIGV4dHJhY3RpbmcgYnl0ZXMuXG4gICAgY29uc3QgYm9keSA9IGV4dHJhY3RCb2R5KGJ5dGVzKVxuXG4gICAgLy8gMy4gTGV0IHJlc3BvbnNlT2JqZWN0IGJlIHRoZSByZXN1bHQgb2YgY3JlYXRpbmcgYSBSZXNwb25zZSBvYmplY3QsIGdpdmVuIGEgbmV3IHJlc3BvbnNlLFxuICAgIC8vICAgIFwicmVzcG9uc2VcIiwgYW5kIHRoaXPigJlzIHJlbGV2YW50IFJlYWxtLlxuICAgIGNvbnN0IHJlc3BvbnNlT2JqZWN0ID0gZnJvbUlubmVyUmVzcG9uc2UobWFrZVJlc3BvbnNlKHt9KSwgJ3Jlc3BvbnNlJylcblxuICAgIC8vIDQuIFBlcmZvcm0gaW5pdGlhbGl6ZSBhIHJlc3BvbnNlIGdpdmVuIHJlc3BvbnNlT2JqZWN0LCBpbml0LCBhbmQgKGJvZHksIFwiYXBwbGljYXRpb24vanNvblwiKS5cbiAgICBpbml0aWFsaXplUmVzcG9uc2UocmVzcG9uc2VPYmplY3QsIGluaXQsIHsgYm9keTogYm9keVswXSwgdHlwZTogJ2FwcGxpY2F0aW9uL2pzb24nIH0pXG5cbiAgICAvLyA1LiBSZXR1cm4gcmVzcG9uc2VPYmplY3QuXG4gICAgcmV0dXJuIHJlc3BvbnNlT2JqZWN0XG4gIH1cblxuICAvLyBDcmVhdGVzIGEgcmVkaXJlY3QgUmVzcG9uc2UgdGhhdCByZWRpcmVjdHMgdG8gdXJsIHdpdGggc3RhdHVzIHN0YXR1cy5cbiAgc3RhdGljIHJlZGlyZWN0ICh1cmwsIHN0YXR1cyA9IDMwMikge1xuICAgIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMSwgJ1Jlc3BvbnNlLnJlZGlyZWN0JylcblxuICAgIHVybCA9IHdlYmlkbC5jb252ZXJ0ZXJzLlVTVlN0cmluZyh1cmwpXG4gICAgc3RhdHVzID0gd2ViaWRsLmNvbnZlcnRlcnNbJ3Vuc2lnbmVkIHNob3J0J10oc3RhdHVzKVxuXG4gICAgLy8gMS4gTGV0IHBhcnNlZFVSTCBiZSB0aGUgcmVzdWx0IG9mIHBhcnNpbmcgdXJsIHdpdGggY3VycmVudCBzZXR0aW5nc1xuICAgIC8vIG9iamVjdOKAmXMgQVBJIGJhc2UgVVJMLlxuICAgIC8vIDIuIElmIHBhcnNlZFVSTCBpcyBmYWlsdXJlLCB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICAgIC8vIFRPRE86IGJhc2UtVVJMP1xuICAgIGxldCBwYXJzZWRVUkxcbiAgICB0cnkge1xuICAgICAgcGFyc2VkVVJMID0gbmV3IFVSTCh1cmwsIHJlbGV2YW50UmVhbG0uc2V0dGluZ3NPYmplY3QuYmFzZVVybClcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEZhaWxlZCB0byBwYXJzZSBVUkwgZnJvbSAke3VybH1gLCB7IGNhdXNlOiBlcnIgfSlcbiAgICB9XG5cbiAgICAvLyAzLiBJZiBzdGF0dXMgaXMgbm90IGEgcmVkaXJlY3Qgc3RhdHVzLCB0aGVuIHRocm93IGEgUmFuZ2VFcnJvci5cbiAgICBpZiAoIXJlZGlyZWN0U3RhdHVzU2V0LmhhcyhzdGF0dXMpKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgSW52YWxpZCBzdGF0dXMgY29kZSAke3N0YXR1c31gKVxuICAgIH1cblxuICAgIC8vIDQuIExldCByZXNwb25zZU9iamVjdCBiZSB0aGUgcmVzdWx0IG9mIGNyZWF0aW5nIGEgUmVzcG9uc2Ugb2JqZWN0LFxuICAgIC8vIGdpdmVuIGEgbmV3IHJlc3BvbnNlLCBcImltbXV0YWJsZVwiLCBhbmQgdGhpc+KAmXMgcmVsZXZhbnQgUmVhbG0uXG4gICAgY29uc3QgcmVzcG9uc2VPYmplY3QgPSBmcm9tSW5uZXJSZXNwb25zZShtYWtlUmVzcG9uc2Uoe30pLCAnaW1tdXRhYmxlJylcblxuICAgIC8vIDUuIFNldCByZXNwb25zZU9iamVjdOKAmXMgcmVzcG9uc2XigJlzIHN0YXR1cyB0byBzdGF0dXMuXG4gICAgcmVzcG9uc2VPYmplY3Rba1N0YXRlXS5zdGF0dXMgPSBzdGF0dXNcblxuICAgIC8vIDYuIExldCB2YWx1ZSBiZSBwYXJzZWRVUkwsIHNlcmlhbGl6ZWQgYW5kIGlzb21vcnBoaWMgZW5jb2RlZC5cbiAgICBjb25zdCB2YWx1ZSA9IGlzb21vcnBoaWNFbmNvZGUoVVJMU2VyaWFsaXplcihwYXJzZWRVUkwpKVxuXG4gICAgLy8gNy4gQXBwZW5kIGBMb2NhdGlvbmAvdmFsdWUgdG8gcmVzcG9uc2VPYmplY3TigJlzIHJlc3BvbnNl4oCZcyBoZWFkZXIgbGlzdC5cbiAgICByZXNwb25zZU9iamVjdFtrU3RhdGVdLmhlYWRlcnNMaXN0LmFwcGVuZCgnbG9jYXRpb24nLCB2YWx1ZSwgdHJ1ZSlcblxuICAgIC8vIDguIFJldHVybiByZXNwb25zZU9iamVjdC5cbiAgICByZXR1cm4gcmVzcG9uc2VPYmplY3RcbiAgfVxuXG4gIC8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNkb20tcmVzcG9uc2VcbiAgY29uc3RydWN0b3IgKGJvZHkgPSBudWxsLCBpbml0ID0ge30pIHtcbiAgICBpZiAoYm9keSA9PT0ga0NvbnN0cnVjdCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKGJvZHkgIT09IG51bGwpIHtcbiAgICAgIGJvZHkgPSB3ZWJpZGwuY29udmVydGVycy5Cb2R5SW5pdChib2R5KVxuICAgIH1cblxuICAgIGluaXQgPSB3ZWJpZGwuY29udmVydGVycy5SZXNwb25zZUluaXQoaW5pdClcblxuICAgIC8vIDEuIFNldCB0aGlz4oCZcyByZXNwb25zZSB0byBhIG5ldyByZXNwb25zZS5cbiAgICB0aGlzW2tTdGF0ZV0gPSBtYWtlUmVzcG9uc2Uoe30pXG5cbiAgICAvLyAyLiBTZXQgdGhpc+KAmXMgaGVhZGVycyB0byBhIG5ldyBIZWFkZXJzIG9iamVjdCB3aXRoIHRoaXPigJlzIHJlbGV2YW50XG4gICAgLy8gUmVhbG0sIHdob3NlIGhlYWRlciBsaXN0IGlzIHRoaXPigJlzIHJlc3BvbnNl4oCZcyBoZWFkZXIgbGlzdCBhbmQgZ3VhcmRcbiAgICAvLyBpcyBcInJlc3BvbnNlXCIuXG4gICAgdGhpc1trSGVhZGVyc10gPSBuZXcgSGVhZGVycyhrQ29uc3RydWN0KVxuICAgIHNldEhlYWRlcnNHdWFyZCh0aGlzW2tIZWFkZXJzXSwgJ3Jlc3BvbnNlJylcbiAgICBzZXRIZWFkZXJzTGlzdCh0aGlzW2tIZWFkZXJzXSwgdGhpc1trU3RhdGVdLmhlYWRlcnNMaXN0KVxuXG4gICAgLy8gMy4gTGV0IGJvZHlXaXRoVHlwZSBiZSBudWxsLlxuICAgIGxldCBib2R5V2l0aFR5cGUgPSBudWxsXG5cbiAgICAvLyA0LiBJZiBib2R5IGlzIG5vbi1udWxsLCB0aGVuIHNldCBib2R5V2l0aFR5cGUgdG8gdGhlIHJlc3VsdCBvZiBleHRyYWN0aW5nIGJvZHkuXG4gICAgaWYgKGJvZHkgIT0gbnVsbCkge1xuICAgICAgY29uc3QgW2V4dHJhY3RlZEJvZHksIHR5cGVdID0gZXh0cmFjdEJvZHkoYm9keSlcbiAgICAgIGJvZHlXaXRoVHlwZSA9IHsgYm9keTogZXh0cmFjdGVkQm9keSwgdHlwZSB9XG4gICAgfVxuXG4gICAgLy8gNS4gUGVyZm9ybSBpbml0aWFsaXplIGEgcmVzcG9uc2UgZ2l2ZW4gdGhpcywgaW5pdCwgYW5kIGJvZHlXaXRoVHlwZS5cbiAgICBpbml0aWFsaXplUmVzcG9uc2UodGhpcywgaW5pdCwgYm9keVdpdGhUeXBlKVxuICB9XG5cbiAgLy8gUmV0dXJucyByZXNwb25zZeKAmXMgdHlwZSwgZS5nLiwgXCJjb3JzXCIuXG4gIGdldCB0eXBlICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBSZXNwb25zZSlcblxuICAgIC8vIFRoZSB0eXBlIGdldHRlciBzdGVwcyBhcmUgdG8gcmV0dXJuIHRoaXPigJlzIHJlc3BvbnNl4oCZcyB0eXBlLlxuICAgIHJldHVybiB0aGlzW2tTdGF0ZV0udHlwZVxuICB9XG5cbiAgLy8gUmV0dXJucyByZXNwb25zZeKAmXMgVVJMLCBpZiBpdCBoYXMgb25lOyBvdGhlcndpc2UgdGhlIGVtcHR5IHN0cmluZy5cbiAgZ2V0IHVybCAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgUmVzcG9uc2UpXG5cbiAgICBjb25zdCB1cmxMaXN0ID0gdGhpc1trU3RhdGVdLnVybExpc3RcblxuICAgIC8vIFRoZSB1cmwgZ2V0dGVyIHN0ZXBzIGFyZSB0byByZXR1cm4gdGhlIGVtcHR5IHN0cmluZyBpZiB0aGlz4oCZc1xuICAgIC8vIHJlc3BvbnNl4oCZcyBVUkwgaXMgbnVsbDsgb3RoZXJ3aXNlIHRoaXPigJlzIHJlc3BvbnNl4oCZcyBVUkwsXG4gICAgLy8gc2VyaWFsaXplZCB3aXRoIGV4Y2x1ZGUgZnJhZ21lbnQgc2V0IHRvIHRydWUuXG4gICAgY29uc3QgdXJsID0gdXJsTGlzdFt1cmxMaXN0Lmxlbmd0aCAtIDFdID8/IG51bGxcblxuICAgIGlmICh1cmwgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiAnJ1xuICAgIH1cblxuICAgIHJldHVybiBVUkxTZXJpYWxpemVyKHVybCwgdHJ1ZSlcbiAgfVxuXG4gIC8vIFJldHVybnMgd2hldGhlciByZXNwb25zZSB3YXMgb2J0YWluZWQgdGhyb3VnaCBhIHJlZGlyZWN0LlxuICBnZXQgcmVkaXJlY3RlZCAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgUmVzcG9uc2UpXG5cbiAgICAvLyBUaGUgcmVkaXJlY3RlZCBnZXR0ZXIgc3RlcHMgYXJlIHRvIHJldHVybiB0cnVlIGlmIHRoaXPigJlzIHJlc3BvbnNl4oCZcyBVUkxcbiAgICAvLyBsaXN0IGhhcyBtb3JlIHRoYW4gb25lIGl0ZW07IG90aGVyd2lzZSBmYWxzZS5cbiAgICByZXR1cm4gdGhpc1trU3RhdGVdLnVybExpc3QubGVuZ3RoID4gMVxuICB9XG5cbiAgLy8gUmV0dXJucyByZXNwb25zZeKAmXMgc3RhdHVzLlxuICBnZXQgc3RhdHVzICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBSZXNwb25zZSlcblxuICAgIC8vIFRoZSBzdGF0dXMgZ2V0dGVyIHN0ZXBzIGFyZSB0byByZXR1cm4gdGhpc+KAmXMgcmVzcG9uc2XigJlzIHN0YXR1cy5cbiAgICByZXR1cm4gdGhpc1trU3RhdGVdLnN0YXR1c1xuICB9XG5cbiAgLy8gUmV0dXJucyB3aGV0aGVyIHJlc3BvbnNl4oCZcyBzdGF0dXMgaXMgYW4gb2sgc3RhdHVzLlxuICBnZXQgb2sgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFJlc3BvbnNlKVxuXG4gICAgLy8gVGhlIG9rIGdldHRlciBzdGVwcyBhcmUgdG8gcmV0dXJuIHRydWUgaWYgdGhpc+KAmXMgcmVzcG9uc2XigJlzIHN0YXR1cyBpcyBhblxuICAgIC8vIG9rIHN0YXR1czsgb3RoZXJ3aXNlIGZhbHNlLlxuICAgIHJldHVybiB0aGlzW2tTdGF0ZV0uc3RhdHVzID49IDIwMCAmJiB0aGlzW2tTdGF0ZV0uc3RhdHVzIDw9IDI5OVxuICB9XG5cbiAgLy8gUmV0dXJucyByZXNwb25zZeKAmXMgc3RhdHVzIG1lc3NhZ2UuXG4gIGdldCBzdGF0dXNUZXh0ICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBSZXNwb25zZSlcblxuICAgIC8vIFRoZSBzdGF0dXNUZXh0IGdldHRlciBzdGVwcyBhcmUgdG8gcmV0dXJuIHRoaXPigJlzIHJlc3BvbnNl4oCZcyBzdGF0dXNcbiAgICAvLyBtZXNzYWdlLlxuICAgIHJldHVybiB0aGlzW2tTdGF0ZV0uc3RhdHVzVGV4dFxuICB9XG5cbiAgLy8gUmV0dXJucyByZXNwb25zZeKAmXMgaGVhZGVycyBhcyBIZWFkZXJzLlxuICBnZXQgaGVhZGVycyAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgUmVzcG9uc2UpXG5cbiAgICAvLyBUaGUgaGVhZGVycyBnZXR0ZXIgc3RlcHMgYXJlIHRvIHJldHVybiB0aGlz4oCZcyBoZWFkZXJzLlxuICAgIHJldHVybiB0aGlzW2tIZWFkZXJzXVxuICB9XG5cbiAgZ2V0IGJvZHkgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFJlc3BvbnNlKVxuXG4gICAgcmV0dXJuIHRoaXNba1N0YXRlXS5ib2R5ID8gdGhpc1trU3RhdGVdLmJvZHkuc3RyZWFtIDogbnVsbFxuICB9XG5cbiAgZ2V0IGJvZHlVc2VkICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBSZXNwb25zZSlcblxuICAgIHJldHVybiAhIXRoaXNba1N0YXRlXS5ib2R5ICYmIHV0aWwuaXNEaXN0dXJiZWQodGhpc1trU3RhdGVdLmJvZHkuc3RyZWFtKVxuICB9XG5cbiAgLy8gUmV0dXJucyBhIGNsb25lIG9mIHJlc3BvbnNlLlxuICBjbG9uZSAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgUmVzcG9uc2UpXG5cbiAgICAvLyAxLiBJZiB0aGlzIGlzIHVudXNhYmxlLCB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICAgIGlmICh0aGlzLmJvZHlVc2VkIHx8IHRoaXMuYm9keT8ubG9ja2VkKSB7XG4gICAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICAgIGhlYWRlcjogJ1Jlc3BvbnNlLmNsb25lJyxcbiAgICAgICAgbWVzc2FnZTogJ0JvZHkgaGFzIGFscmVhZHkgYmVlbiBjb25zdW1lZC4nXG4gICAgICB9KVxuICAgIH1cblxuICAgIC8vIDIuIExldCBjbG9uZWRSZXNwb25zZSBiZSB0aGUgcmVzdWx0IG9mIGNsb25pbmcgdGhpc+KAmXMgcmVzcG9uc2UuXG4gICAgY29uc3QgY2xvbmVkUmVzcG9uc2UgPSBjbG9uZVJlc3BvbnNlKHRoaXNba1N0YXRlXSlcblxuICAgIC8vIDMuIFJldHVybiB0aGUgcmVzdWx0IG9mIGNyZWF0aW5nIGEgUmVzcG9uc2Ugb2JqZWN0LCBnaXZlblxuICAgIC8vIGNsb25lZFJlc3BvbnNlLCB0aGlz4oCZcyBoZWFkZXJz4oCZcyBndWFyZCwgYW5kIHRoaXPigJlzIHJlbGV2YW50IFJlYWxtLlxuICAgIHJldHVybiBmcm9tSW5uZXJSZXNwb25zZShjbG9uZWRSZXNwb25zZSwgZ2V0SGVhZGVyc0d1YXJkKHRoaXNba0hlYWRlcnNdKSlcbiAgfVxuXG4gIFtub2RlVXRpbC5pbnNwZWN0LmN1c3RvbV0gKGRlcHRoLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMuZGVwdGggPT09IG51bGwpIHtcbiAgICAgIG9wdGlvbnMuZGVwdGggPSAyXG4gICAgfVxuXG4gICAgb3B0aW9ucy5jb2xvcnMgPz89IHRydWVcblxuICAgIGNvbnN0IHByb3BlcnRpZXMgPSB7XG4gICAgICBzdGF0dXM6IHRoaXMuc3RhdHVzLFxuICAgICAgc3RhdHVzVGV4dDogdGhpcy5zdGF0dXNUZXh0LFxuICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgYm9keTogdGhpcy5ib2R5LFxuICAgICAgYm9keVVzZWQ6IHRoaXMuYm9keVVzZWQsXG4gICAgICBvazogdGhpcy5vayxcbiAgICAgIHJlZGlyZWN0ZWQ6IHRoaXMucmVkaXJlY3RlZCxcbiAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgIHVybDogdGhpcy51cmxcbiAgICB9XG5cbiAgICByZXR1cm4gYFJlc3BvbnNlICR7bm9kZVV0aWwuZm9ybWF0V2l0aE9wdGlvbnMob3B0aW9ucywgcHJvcGVydGllcyl9YFxuICB9XG59XG5cbm1peGluQm9keShSZXNwb25zZSlcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoUmVzcG9uc2UucHJvdG90eXBlLCB7XG4gIHR5cGU6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIHVybDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgc3RhdHVzOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBvazoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgcmVkaXJlY3RlZDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgc3RhdHVzVGV4dDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgaGVhZGVyczoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgY2xvbmU6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGJvZHk6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGJvZHlVc2VkOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBbU3ltYm9sLnRvU3RyaW5nVGFnXToge1xuICAgIHZhbHVlOiAnUmVzcG9uc2UnLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9XG59KVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhSZXNwb25zZSwge1xuICBqc29uOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICByZWRpcmVjdDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgZXJyb3I6IGtFbnVtZXJhYmxlUHJvcGVydHlcbn0pXG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LXJlc3BvbnNlLWNsb25lXG5mdW5jdGlvbiBjbG9uZVJlc3BvbnNlIChyZXNwb25zZSkge1xuICAvLyBUbyBjbG9uZSBhIHJlc3BvbnNlIHJlc3BvbnNlLCBydW4gdGhlc2Ugc3RlcHM6XG5cbiAgLy8gMS4gSWYgcmVzcG9uc2UgaXMgYSBmaWx0ZXJlZCByZXNwb25zZSwgdGhlbiByZXR1cm4gYSBuZXcgaWRlbnRpY2FsXG4gIC8vIGZpbHRlcmVkIHJlc3BvbnNlIHdob3NlIGludGVybmFsIHJlc3BvbnNlIGlzIGEgY2xvbmUgb2YgcmVzcG9uc2XigJlzXG4gIC8vIGludGVybmFsIHJlc3BvbnNlLlxuICBpZiAocmVzcG9uc2UuaW50ZXJuYWxSZXNwb25zZSkge1xuICAgIHJldHVybiBmaWx0ZXJSZXNwb25zZShcbiAgICAgIGNsb25lUmVzcG9uc2UocmVzcG9uc2UuaW50ZXJuYWxSZXNwb25zZSksXG4gICAgICByZXNwb25zZS50eXBlXG4gICAgKVxuICB9XG5cbiAgLy8gMi4gTGV0IG5ld1Jlc3BvbnNlIGJlIGEgY29weSBvZiByZXNwb25zZSwgZXhjZXB0IGZvciBpdHMgYm9keS5cbiAgY29uc3QgbmV3UmVzcG9uc2UgPSBtYWtlUmVzcG9uc2UoeyAuLi5yZXNwb25zZSwgYm9keTogbnVsbCB9KVxuXG4gIC8vIDMuIElmIHJlc3BvbnNl4oCZcyBib2R5IGlzIG5vbi1udWxsLCB0aGVuIHNldCBuZXdSZXNwb25zZeKAmXMgYm9keSB0byB0aGVcbiAgLy8gcmVzdWx0IG9mIGNsb25pbmcgcmVzcG9uc2XigJlzIGJvZHkuXG4gIGlmIChyZXNwb25zZS5ib2R5ICE9IG51bGwpIHtcbiAgICBuZXdSZXNwb25zZS5ib2R5ID0gY2xvbmVCb2R5KHJlc3BvbnNlLmJvZHkpXG4gIH1cblxuICAvLyA0LiBSZXR1cm4gbmV3UmVzcG9uc2UuXG4gIHJldHVybiBuZXdSZXNwb25zZVxufVxuXG5mdW5jdGlvbiBtYWtlUmVzcG9uc2UgKGluaXQpIHtcbiAgcmV0dXJuIHtcbiAgICBhYm9ydGVkOiBmYWxzZSxcbiAgICByYW5nZVJlcXVlc3RlZDogZmFsc2UsXG4gICAgdGltaW5nQWxsb3dQYXNzZWQ6IGZhbHNlLFxuICAgIHJlcXVlc3RJbmNsdWRlc0NyZWRlbnRpYWxzOiBmYWxzZSxcbiAgICB0eXBlOiAnZGVmYXVsdCcsXG4gICAgc3RhdHVzOiAyMDAsXG4gICAgdGltaW5nSW5mbzogbnVsbCxcbiAgICBjYWNoZVN0YXRlOiAnJyxcbiAgICBzdGF0dXNUZXh0OiAnJyxcbiAgICAuLi5pbml0LFxuICAgIGhlYWRlcnNMaXN0OiBpbml0Py5oZWFkZXJzTGlzdFxuICAgICAgPyBuZXcgSGVhZGVyc0xpc3QoaW5pdD8uaGVhZGVyc0xpc3QpXG4gICAgICA6IG5ldyBIZWFkZXJzTGlzdCgpLFxuICAgIHVybExpc3Q6IGluaXQ/LnVybExpc3QgPyBbLi4uaW5pdC51cmxMaXN0XSA6IFtdXG4gIH1cbn1cblxuZnVuY3Rpb24gbWFrZU5ldHdvcmtFcnJvciAocmVhc29uKSB7XG4gIGNvbnN0IGlzRXJyb3IgPSBpc0Vycm9yTGlrZShyZWFzb24pXG4gIHJldHVybiBtYWtlUmVzcG9uc2Uoe1xuICAgIHR5cGU6ICdlcnJvcicsXG4gICAgc3RhdHVzOiAwLFxuICAgIGVycm9yOiBpc0Vycm9yXG4gICAgICA/IHJlYXNvblxuICAgICAgOiBuZXcgRXJyb3IocmVhc29uID8gU3RyaW5nKHJlYXNvbikgOiByZWFzb24pLFxuICAgIGFib3J0ZWQ6IHJlYXNvbiAmJiByZWFzb24ubmFtZSA9PT0gJ0Fib3J0RXJyb3InXG4gIH0pXG59XG5cbi8vIEBzZWUgaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtbmV0d29yay1lcnJvclxuZnVuY3Rpb24gaXNOZXR3b3JrRXJyb3IgKHJlc3BvbnNlKSB7XG4gIHJldHVybiAoXG4gICAgLy8gQSBuZXR3b3JrIGVycm9yIGlzIGEgcmVzcG9uc2Ugd2hvc2UgdHlwZSBpcyBcImVycm9yXCIsXG4gICAgcmVzcG9uc2UudHlwZSA9PT0gJ2Vycm9yJyAmJlxuICAgIC8vIHN0YXR1cyBpcyAwXG4gICAgcmVzcG9uc2Uuc3RhdHVzID09PSAwXG4gIClcbn1cblxuZnVuY3Rpb24gbWFrZUZpbHRlcmVkUmVzcG9uc2UgKHJlc3BvbnNlLCBzdGF0ZSkge1xuICBzdGF0ZSA9IHtcbiAgICBpbnRlcm5hbFJlc3BvbnNlOiByZXNwb25zZSxcbiAgICAuLi5zdGF0ZVxuICB9XG5cbiAgcmV0dXJuIG5ldyBQcm94eShyZXNwb25zZSwge1xuICAgIGdldCAodGFyZ2V0LCBwKSB7XG4gICAgICByZXR1cm4gcCBpbiBzdGF0ZSA/IHN0YXRlW3BdIDogdGFyZ2V0W3BdXG4gICAgfSxcbiAgICBzZXQgKHRhcmdldCwgcCwgdmFsdWUpIHtcbiAgICAgIGFzc2VydCghKHAgaW4gc3RhdGUpKVxuICAgICAgdGFyZ2V0W3BdID0gdmFsdWVcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9KVxufVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1maWx0ZXJlZC1yZXNwb25zZVxuZnVuY3Rpb24gZmlsdGVyUmVzcG9uc2UgKHJlc3BvbnNlLCB0eXBlKSB7XG4gIC8vIFNldCByZXNwb25zZSB0byB0aGUgZm9sbG93aW5nIGZpbHRlcmVkIHJlc3BvbnNlIHdpdGggcmVzcG9uc2UgYXMgaXRzXG4gIC8vIGludGVybmFsIHJlc3BvbnNlLCBkZXBlbmRpbmcgb24gcmVxdWVzdOKAmXMgcmVzcG9uc2UgdGFpbnRpbmc6XG4gIGlmICh0eXBlID09PSAnYmFzaWMnKSB7XG4gICAgLy8gQSBiYXNpYyBmaWx0ZXJlZCByZXNwb25zZSBpcyBhIGZpbHRlcmVkIHJlc3BvbnNlIHdob3NlIHR5cGUgaXMgXCJiYXNpY1wiXG4gICAgLy8gYW5kIGhlYWRlciBsaXN0IGV4Y2x1ZGVzIGFueSBoZWFkZXJzIGluIGludGVybmFsIHJlc3BvbnNl4oCZcyBoZWFkZXIgbGlzdFxuICAgIC8vIHdob3NlIG5hbWUgaXMgYSBmb3JiaWRkZW4gcmVzcG9uc2UtaGVhZGVyIG5hbWUuXG5cbiAgICAvLyBOb3RlOiB1bmRpY2kgZG9lcyBub3QgaW1wbGVtZW50IGZvcmJpZGRlbiByZXNwb25zZS1oZWFkZXIgbmFtZXNcbiAgICByZXR1cm4gbWFrZUZpbHRlcmVkUmVzcG9uc2UocmVzcG9uc2UsIHtcbiAgICAgIHR5cGU6ICdiYXNpYycsXG4gICAgICBoZWFkZXJzTGlzdDogcmVzcG9uc2UuaGVhZGVyc0xpc3RcbiAgICB9KVxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdjb3JzJykge1xuICAgIC8vIEEgQ09SUyBmaWx0ZXJlZCByZXNwb25zZSBpcyBhIGZpbHRlcmVkIHJlc3BvbnNlIHdob3NlIHR5cGUgaXMgXCJjb3JzXCJcbiAgICAvLyBhbmQgaGVhZGVyIGxpc3QgZXhjbHVkZXMgYW55IGhlYWRlcnMgaW4gaW50ZXJuYWwgcmVzcG9uc2XigJlzIGhlYWRlclxuICAgIC8vIGxpc3Qgd2hvc2UgbmFtZSBpcyBub3QgYSBDT1JTLXNhZmVsaXN0ZWQgcmVzcG9uc2UtaGVhZGVyIG5hbWUsIGdpdmVuXG4gICAgLy8gaW50ZXJuYWwgcmVzcG9uc2XigJlzIENPUlMtZXhwb3NlZCBoZWFkZXItbmFtZSBsaXN0LlxuXG4gICAgLy8gTm90ZTogdW5kaWNpIGRvZXMgbm90IGltcGxlbWVudCBDT1JTLXNhZmVsaXN0ZWQgcmVzcG9uc2UtaGVhZGVyIG5hbWVzXG4gICAgcmV0dXJuIG1ha2VGaWx0ZXJlZFJlc3BvbnNlKHJlc3BvbnNlLCB7XG4gICAgICB0eXBlOiAnY29ycycsXG4gICAgICBoZWFkZXJzTGlzdDogcmVzcG9uc2UuaGVhZGVyc0xpc3RcbiAgICB9KVxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdvcGFxdWUnKSB7XG4gICAgLy8gQW4gb3BhcXVlIGZpbHRlcmVkIHJlc3BvbnNlIGlzIGEgZmlsdGVyZWQgcmVzcG9uc2Ugd2hvc2UgdHlwZSBpc1xuICAgIC8vIFwib3BhcXVlXCIsIFVSTCBsaXN0IGlzIHRoZSBlbXB0eSBsaXN0LCBzdGF0dXMgaXMgMCwgc3RhdHVzIG1lc3NhZ2VcbiAgICAvLyBpcyB0aGUgZW1wdHkgYnl0ZSBzZXF1ZW5jZSwgaGVhZGVyIGxpc3QgaXMgZW1wdHksIGFuZCBib2R5IGlzIG51bGwuXG5cbiAgICByZXR1cm4gbWFrZUZpbHRlcmVkUmVzcG9uc2UocmVzcG9uc2UsIHtcbiAgICAgIHR5cGU6ICdvcGFxdWUnLFxuICAgICAgdXJsTGlzdDogT2JqZWN0LmZyZWV6ZShbXSksXG4gICAgICBzdGF0dXM6IDAsXG4gICAgICBzdGF0dXNUZXh0OiAnJyxcbiAgICAgIGJvZHk6IG51bGxcbiAgICB9KVxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdvcGFxdWVyZWRpcmVjdCcpIHtcbiAgICAvLyBBbiBvcGFxdWUtcmVkaXJlY3QgZmlsdGVyZWQgcmVzcG9uc2UgaXMgYSBmaWx0ZXJlZCByZXNwb25zZSB3aG9zZSB0eXBlXG4gICAgLy8gaXMgXCJvcGFxdWVyZWRpcmVjdFwiLCBzdGF0dXMgaXMgMCwgc3RhdHVzIG1lc3NhZ2UgaXMgdGhlIGVtcHR5IGJ5dGVcbiAgICAvLyBzZXF1ZW5jZSwgaGVhZGVyIGxpc3QgaXMgZW1wdHksIGFuZCBib2R5IGlzIG51bGwuXG5cbiAgICByZXR1cm4gbWFrZUZpbHRlcmVkUmVzcG9uc2UocmVzcG9uc2UsIHtcbiAgICAgIHR5cGU6ICdvcGFxdWVyZWRpcmVjdCcsXG4gICAgICBzdGF0dXM6IDAsXG4gICAgICBzdGF0dXNUZXh0OiAnJyxcbiAgICAgIGhlYWRlcnNMaXN0OiBbXSxcbiAgICAgIGJvZHk6IG51bGxcbiAgICB9KVxuICB9IGVsc2Uge1xuICAgIGFzc2VydChmYWxzZSlcbiAgfVxufVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jYXBwcm9wcmlhdGUtbmV0d29yay1lcnJvclxuZnVuY3Rpb24gbWFrZUFwcHJvcHJpYXRlTmV0d29ya0Vycm9yIChmZXRjaFBhcmFtcywgZXJyID0gbnVsbCkge1xuICAvLyAxLiBBc3NlcnQ6IGZldGNoUGFyYW1zIGlzIGNhbmNlbGVkLlxuICBhc3NlcnQoaXNDYW5jZWxsZWQoZmV0Y2hQYXJhbXMpKVxuXG4gIC8vIDIuIFJldHVybiBhbiBhYm9ydGVkIG5ldHdvcmsgZXJyb3IgaWYgZmV0Y2hQYXJhbXMgaXMgYWJvcnRlZDtcbiAgLy8gb3RoZXJ3aXNlIHJldHVybiBhIG5ldHdvcmsgZXJyb3IuXG4gIHJldHVybiBpc0Fib3J0ZWQoZmV0Y2hQYXJhbXMpXG4gICAgPyBtYWtlTmV0d29ya0Vycm9yKE9iamVjdC5hc3NpZ24obmV3IERPTUV4Y2VwdGlvbignVGhlIG9wZXJhdGlvbiB3YXMgYWJvcnRlZC4nLCAnQWJvcnRFcnJvcicpLCB7IGNhdXNlOiBlcnIgfSkpXG4gICAgOiBtYWtlTmV0d29ya0Vycm9yKE9iamVjdC5hc3NpZ24obmV3IERPTUV4Y2VwdGlvbignUmVxdWVzdCB3YXMgY2FuY2VsbGVkLicpLCB7IGNhdXNlOiBlcnIgfSkpXG59XG5cbi8vIGh0dHBzOi8vd2hhdHByLm9yZy9mZXRjaC8xMzkyLmh0bWwjaW5pdGlhbGl6ZS1hLXJlc3BvbnNlXG5mdW5jdGlvbiBpbml0aWFsaXplUmVzcG9uc2UgKHJlc3BvbnNlLCBpbml0LCBib2R5KSB7XG4gIC8vIDEuIElmIGluaXRbXCJzdGF0dXNcIl0gaXMgbm90IGluIHRoZSByYW5nZSAyMDAgdG8gNTk5LCBpbmNsdXNpdmUsIHRoZW5cbiAgLy8gICAgdGhyb3cgYSBSYW5nZUVycm9yLlxuICBpZiAoaW5pdC5zdGF0dXMgIT09IG51bGwgJiYgKGluaXQuc3RhdHVzIDwgMjAwIHx8IGluaXQuc3RhdHVzID4gNTk5KSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdpbml0W1wic3RhdHVzXCJdIG11c3QgYmUgaW4gdGhlIHJhbmdlIG9mIDIwMCB0byA1OTksIGluY2x1c2l2ZS4nKVxuICB9XG5cbiAgLy8gMi4gSWYgaW5pdFtcInN0YXR1c1RleHRcIl0gZG9lcyBub3QgbWF0Y2ggdGhlIHJlYXNvbi1waHJhc2UgdG9rZW4gcHJvZHVjdGlvbixcbiAgLy8gICAgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgaWYgKCdzdGF0dXNUZXh0JyBpbiBpbml0ICYmIGluaXQuc3RhdHVzVGV4dCAhPSBudWxsKSB7XG4gICAgLy8gU2VlLCBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL3JmYzcyMzAjc2VjdGlvbi0zLjEuMjpcbiAgICAvLyAgIHJlYXNvbi1waHJhc2UgID0gKiggSFRBQiAvIFNQIC8gVkNIQVIgLyBvYnMtdGV4dCApXG4gICAgaWYgKCFpc1ZhbGlkUmVhc29uUGhyYXNlKFN0cmluZyhpbml0LnN0YXR1c1RleHQpKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBzdGF0dXNUZXh0JylcbiAgICB9XG4gIH1cblxuICAvLyAzLiBTZXQgcmVzcG9uc2XigJlzIHJlc3BvbnNl4oCZcyBzdGF0dXMgdG8gaW5pdFtcInN0YXR1c1wiXS5cbiAgaWYgKCdzdGF0dXMnIGluIGluaXQgJiYgaW5pdC5zdGF0dXMgIT0gbnVsbCkge1xuICAgIHJlc3BvbnNlW2tTdGF0ZV0uc3RhdHVzID0gaW5pdC5zdGF0dXNcbiAgfVxuXG4gIC8vIDQuIFNldCByZXNwb25zZeKAmXMgcmVzcG9uc2XigJlzIHN0YXR1cyBtZXNzYWdlIHRvIGluaXRbXCJzdGF0dXNUZXh0XCJdLlxuICBpZiAoJ3N0YXR1c1RleHQnIGluIGluaXQgJiYgaW5pdC5zdGF0dXNUZXh0ICE9IG51bGwpIHtcbiAgICByZXNwb25zZVtrU3RhdGVdLnN0YXR1c1RleHQgPSBpbml0LnN0YXR1c1RleHRcbiAgfVxuXG4gIC8vIDUuIElmIGluaXRbXCJoZWFkZXJzXCJdIGV4aXN0cywgdGhlbiBmaWxsIHJlc3BvbnNl4oCZcyBoZWFkZXJzIHdpdGggaW5pdFtcImhlYWRlcnNcIl0uXG4gIGlmICgnaGVhZGVycycgaW4gaW5pdCAmJiBpbml0LmhlYWRlcnMgIT0gbnVsbCkge1xuICAgIGZpbGwocmVzcG9uc2Vba0hlYWRlcnNdLCBpbml0LmhlYWRlcnMpXG4gIH1cblxuICAvLyA2LiBJZiBib2R5IHdhcyBnaXZlbiwgdGhlbjpcbiAgaWYgKGJvZHkpIHtcbiAgICAvLyAxLiBJZiByZXNwb25zZSdzIHN0YXR1cyBpcyBhIG51bGwgYm9keSBzdGF0dXMsIHRoZW4gdGhyb3cgYSBUeXBlRXJyb3IuXG4gICAgaWYgKG51bGxCb2R5U3RhdHVzLmluY2x1ZGVzKHJlc3BvbnNlLnN0YXR1cykpIHtcbiAgICAgIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgICAgaGVhZGVyOiAnUmVzcG9uc2UgY29uc3RydWN0b3InLFxuICAgICAgICBtZXNzYWdlOiBgSW52YWxpZCByZXNwb25zZSBzdGF0dXMgY29kZSAke3Jlc3BvbnNlLnN0YXR1c31gXG4gICAgICB9KVxuICAgIH1cblxuICAgIC8vIDIuIFNldCByZXNwb25zZSdzIGJvZHkgdG8gYm9keSdzIGJvZHkuXG4gICAgcmVzcG9uc2Vba1N0YXRlXS5ib2R5ID0gYm9keS5ib2R5XG5cbiAgICAvLyAzLiBJZiBib2R5J3MgdHlwZSBpcyBub24tbnVsbCBhbmQgcmVzcG9uc2UncyBoZWFkZXIgbGlzdCBkb2VzIG5vdCBjb250YWluXG4gICAgLy8gICAgYENvbnRlbnQtVHlwZWAsIHRoZW4gYXBwZW5kIChgQ29udGVudC1UeXBlYCwgYm9keSdzIHR5cGUpIHRvIHJlc3BvbnNlJ3MgaGVhZGVyIGxpc3QuXG4gICAgaWYgKGJvZHkudHlwZSAhPSBudWxsICYmICFyZXNwb25zZVtrU3RhdGVdLmhlYWRlcnNMaXN0LmNvbnRhaW5zKCdjb250ZW50LXR5cGUnLCB0cnVlKSkge1xuICAgICAgcmVzcG9uc2Vba1N0YXRlXS5oZWFkZXJzTGlzdC5hcHBlbmQoJ2NvbnRlbnQtdHlwZScsIGJvZHkudHlwZSwgdHJ1ZSlcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNyZXNwb25zZS1jcmVhdGVcbiAqIEBwYXJhbSB7YW55fSBpbm5lclJlc3BvbnNlXG4gKiBAcGFyYW0geydyZXF1ZXN0JyB8ICdpbW11dGFibGUnIHwgJ3JlcXVlc3Qtbm8tY29ycycgfCAncmVzcG9uc2UnIHwgJ25vbmUnfSBndWFyZFxuICogQHJldHVybnMge1Jlc3BvbnNlfVxuICovXG5mdW5jdGlvbiBmcm9tSW5uZXJSZXNwb25zZSAoaW5uZXJSZXNwb25zZSwgZ3VhcmQpIHtcbiAgY29uc3QgcmVzcG9uc2UgPSBuZXcgUmVzcG9uc2Uoa0NvbnN0cnVjdClcbiAgcmVzcG9uc2Vba1N0YXRlXSA9IGlubmVyUmVzcG9uc2VcbiAgcmVzcG9uc2Vba0hlYWRlcnNdID0gbmV3IEhlYWRlcnMoa0NvbnN0cnVjdClcbiAgc2V0SGVhZGVyc0xpc3QocmVzcG9uc2Vba0hlYWRlcnNdLCBpbm5lclJlc3BvbnNlLmhlYWRlcnNMaXN0KVxuICBzZXRIZWFkZXJzR3VhcmQocmVzcG9uc2Vba0hlYWRlcnNdLCBndWFyZClcblxuICBpZiAoaGFzRmluYWxpemF0aW9uUmVnaXN0cnkgJiYgaW5uZXJSZXNwb25zZS5ib2R5Py5zdHJlYW0pIHtcbiAgICAvLyBJZiB0aGUgdGFyZ2V0IChyZXNwb25zZSkgaXMgcmVjbGFpbWVkLCB0aGUgY2xlYW51cCBjYWxsYmFjayBtYXkgYmUgY2FsbGVkIGF0IHNvbWUgcG9pbnQgd2l0aFxuICAgIC8vIHRoZSBoZWxkIHZhbHVlIHByb3ZpZGVkIGZvciBpdCAoaW5uZXJSZXNwb25zZS5ib2R5LnN0cmVhbSkuIFRoZSBoZWxkIHZhbHVlIGNhbiBiZSBhbnkgdmFsdWU6XG4gICAgLy8gYSBwcmltaXRpdmUgb3IgYW4gb2JqZWN0LCBldmVuIHVuZGVmaW5lZC4gSWYgdGhlIGhlbGQgdmFsdWUgaXMgYW4gb2JqZWN0LCB0aGUgcmVnaXN0cnkga2VlcHNcbiAgICAvLyBhIHN0cm9uZyByZWZlcmVuY2UgdG8gaXQgKHNvIGl0IGNhbiBwYXNzIGl0IHRvIHRoZSBjbGVhbnVwIGNhbGxiYWNrIGxhdGVyKS4gUmV3b3JkZWQgZnJvbVxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0ZpbmFsaXphdGlvblJlZ2lzdHJ5XG4gICAgcmVnaXN0cnkucmVnaXN0ZXIocmVzcG9uc2UsIG5ldyBXZWFrUmVmKGlubmVyUmVzcG9uc2UuYm9keS5zdHJlYW0pKVxuICB9XG5cbiAgcmV0dXJuIHJlc3BvbnNlXG59XG5cbndlYmlkbC5jb252ZXJ0ZXJzLlJlYWRhYmxlU3RyZWFtID0gd2ViaWRsLmludGVyZmFjZUNvbnZlcnRlcihcbiAgUmVhZGFibGVTdHJlYW1cbilcblxud2ViaWRsLmNvbnZlcnRlcnMuRm9ybURhdGEgPSB3ZWJpZGwuaW50ZXJmYWNlQ29udmVydGVyKFxuICBGb3JtRGF0YVxuKVxuXG53ZWJpZGwuY29udmVydGVycy5VUkxTZWFyY2hQYXJhbXMgPSB3ZWJpZGwuaW50ZXJmYWNlQ29udmVydGVyKFxuICBVUkxTZWFyY2hQYXJhbXNcbilcblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI3R5cGVkZWZkZWYteG1saHR0cHJlcXVlc3Rib2R5aW5pdFxud2ViaWRsLmNvbnZlcnRlcnMuWE1MSHR0cFJlcXVlc3RCb2R5SW5pdCA9IGZ1bmN0aW9uIChWLCBwcmVmaXgsIG5hbWUpIHtcbiAgaWYgKHR5cGVvZiBWID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB3ZWJpZGwuY29udmVydGVycy5VU1ZTdHJpbmcoViwgcHJlZml4LCBuYW1lKVxuICB9XG5cbiAgaWYgKGlzQmxvYkxpa2UoVikpIHtcbiAgICByZXR1cm4gd2ViaWRsLmNvbnZlcnRlcnMuQmxvYihWLCBwcmVmaXgsIG5hbWUsIHsgc3RyaWN0OiBmYWxzZSB9KVxuICB9XG5cbiAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhWKSB8fCB0eXBlcy5pc0FycmF5QnVmZmVyKFYpKSB7XG4gICAgcmV0dXJuIHdlYmlkbC5jb252ZXJ0ZXJzLkJ1ZmZlclNvdXJjZShWLCBwcmVmaXgsIG5hbWUpXG4gIH1cblxuICBpZiAodXRpbC5pc0Zvcm1EYXRhTGlrZShWKSkge1xuICAgIHJldHVybiB3ZWJpZGwuY29udmVydGVycy5Gb3JtRGF0YShWLCBwcmVmaXgsIG5hbWUsIHsgc3RyaWN0OiBmYWxzZSB9KVxuICB9XG5cbiAgaWYgKFYgaW5zdGFuY2VvZiBVUkxTZWFyY2hQYXJhbXMpIHtcbiAgICByZXR1cm4gd2ViaWRsLmNvbnZlcnRlcnMuVVJMU2VhcmNoUGFyYW1zKFYsIHByZWZpeCwgbmFtZSlcbiAgfVxuXG4gIHJldHVybiB3ZWJpZGwuY29udmVydGVycy5ET01TdHJpbmcoViwgcHJlZml4LCBuYW1lKVxufVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jYm9keWluaXRcbndlYmlkbC5jb252ZXJ0ZXJzLkJvZHlJbml0ID0gZnVuY3Rpb24gKFYsIHByZWZpeCwgYXJndW1lbnQpIHtcbiAgaWYgKFYgaW5zdGFuY2VvZiBSZWFkYWJsZVN0cmVhbSkge1xuICAgIHJldHVybiB3ZWJpZGwuY29udmVydGVycy5SZWFkYWJsZVN0cmVhbShWLCBwcmVmaXgsIGFyZ3VtZW50KVxuICB9XG5cbiAgLy8gTm90ZTogdGhlIHNwZWMgZG9lc24ndCBpbmNsdWRlIGFzeW5jIGl0ZXJhYmxlcyxcbiAgLy8gdGhpcyBpcyBhbiB1bmRpY2kgZXh0ZW5zaW9uLlxuICBpZiAoVj8uW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSkge1xuICAgIHJldHVybiBWXG4gIH1cblxuICByZXR1cm4gd2ViaWRsLmNvbnZlcnRlcnMuWE1MSHR0cFJlcXVlc3RCb2R5SW5pdChWLCBwcmVmaXgsIGFyZ3VtZW50KVxufVxuXG53ZWJpZGwuY29udmVydGVycy5SZXNwb25zZUluaXQgPSB3ZWJpZGwuZGljdGlvbmFyeUNvbnZlcnRlcihbXG4gIHtcbiAgICBrZXk6ICdzdGF0dXMnLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnNbJ3Vuc2lnbmVkIHNob3J0J10sXG4gICAgZGVmYXVsdFZhbHVlOiAoKSA9PiAyMDBcbiAgfSxcbiAge1xuICAgIGtleTogJ3N0YXR1c1RleHQnLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuQnl0ZVN0cmluZyxcbiAgICBkZWZhdWx0VmFsdWU6ICgpID0+ICcnXG4gIH0sXG4gIHtcbiAgICBrZXk6ICdoZWFkZXJzJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLkhlYWRlcnNJbml0XG4gIH1cbl0pXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpc05ldHdvcmtFcnJvcixcbiAgbWFrZU5ldHdvcmtFcnJvcixcbiAgbWFrZVJlc3BvbnNlLFxuICBtYWtlQXBwcm9wcmlhdGVOZXR3b3JrRXJyb3IsXG4gIGZpbHRlclJlc3BvbnNlLFxuICBSZXNwb25zZSxcbiAgY2xvbmVSZXNwb25zZSxcbiAgZnJvbUlubmVyUmVzcG9uc2Vcbn1cbiJdLCJuYW1lcyI6WyJIZWFkZXJzIiwiSGVhZGVyc0xpc3QiLCJmaWxsIiwiZ2V0SGVhZGVyc0d1YXJkIiwic2V0SGVhZGVyc0d1YXJkIiwic2V0SGVhZGVyc0xpc3QiLCJyZXF1aXJlIiwiZXh0cmFjdEJvZHkiLCJjbG9uZUJvZHkiLCJtaXhpbkJvZHkiLCJ1dGlsIiwibm9kZVV0aWwiLCJrRW51bWVyYWJsZVByb3BlcnR5IiwiaXNWYWxpZFJlYXNvblBocmFzZSIsImlzQ2FuY2VsbGVkIiwiaXNBYm9ydGVkIiwiaXNCbG9iTGlrZSIsInNlcmlhbGl6ZUphdmFzY3JpcHRWYWx1ZVRvSlNPTlN0cmluZyIsImlzRXJyb3JMaWtlIiwiaXNvbW9ycGhpY0VuY29kZSIsImVudmlyb25tZW50U2V0dGluZ3NPYmplY3QiLCJyZWxldmFudFJlYWxtIiwicmVkaXJlY3RTdGF0dXNTZXQiLCJudWxsQm9keVN0YXR1cyIsImtTdGF0ZSIsImtIZWFkZXJzIiwid2ViaWRsIiwiRm9ybURhdGEiLCJVUkxTZXJpYWxpemVyIiwia0NvbnN0cnVjdCIsImFzc2VydCIsInR5cGVzIiwiaXNEaXN0dXJiZWQiLCJpc0Vycm9yZWQiLCJ0ZXh0RW5jb2RlciIsIlRleHRFbmNvZGVyIiwiaGFzRmluYWxpemF0aW9uUmVnaXN0cnkiLCJnbG9iYWxUaGlzIiwiRmluYWxpemF0aW9uUmVnaXN0cnkiLCJwcm9jZXNzIiwidmVyc2lvbiIsImluZGV4T2YiLCJyZWdpc3RyeSIsIndlYWtSZWYiLCJzdHJlYW0iLCJkZXJlZiIsImxvY2tlZCIsImNhbmNlbCIsImNhdGNoIiwibm9vcCIsIlJlc3BvbnNlIiwiZXJyb3IiLCJyZXNwb25zZU9iamVjdCIsImZyb21Jbm5lclJlc3BvbnNlIiwibWFrZU5ldHdvcmtFcnJvciIsImpzb24iLCJkYXRhIiwiaW5pdCIsImFyZ3VtZW50TGVuZ3RoQ2hlY2siLCJhcmd1bWVudHMiLCJjb252ZXJ0ZXJzIiwiUmVzcG9uc2VJbml0IiwiYnl0ZXMiLCJlbmNvZGUiLCJib2R5IiwibWFrZVJlc3BvbnNlIiwiaW5pdGlhbGl6ZVJlc3BvbnNlIiwidHlwZSIsInJlZGlyZWN0IiwidXJsIiwic3RhdHVzIiwiVVNWU3RyaW5nIiwicGFyc2VkVVJMIiwiVVJMIiwic2V0dGluZ3NPYmplY3QiLCJiYXNlVXJsIiwiZXJyIiwiVHlwZUVycm9yIiwiY2F1c2UiLCJoYXMiLCJSYW5nZUVycm9yIiwidmFsdWUiLCJoZWFkZXJzTGlzdCIsImFwcGVuZCIsImNvbnN0cnVjdG9yIiwiQm9keUluaXQiLCJib2R5V2l0aFR5cGUiLCJleHRyYWN0ZWRCb2R5IiwiYnJhbmRDaGVjayIsInVybExpc3QiLCJsZW5ndGgiLCJyZWRpcmVjdGVkIiwib2siLCJzdGF0dXNUZXh0IiwiaGVhZGVycyIsImJvZHlVc2VkIiwiY2xvbmUiLCJlcnJvcnMiLCJleGNlcHRpb24iLCJoZWFkZXIiLCJtZXNzYWdlIiwiY2xvbmVkUmVzcG9uc2UiLCJjbG9uZVJlc3BvbnNlIiwiaW5zcGVjdCIsImN1c3RvbSIsImRlcHRoIiwib3B0aW9ucyIsImNvbG9ycyIsInByb3BlcnRpZXMiLCJmb3JtYXRXaXRoT3B0aW9ucyIsIk9iamVjdCIsImRlZmluZVByb3BlcnRpZXMiLCJwcm90b3R5cGUiLCJTeW1ib2wiLCJ0b1N0cmluZ1RhZyIsImNvbmZpZ3VyYWJsZSIsInJlc3BvbnNlIiwiaW50ZXJuYWxSZXNwb25zZSIsImZpbHRlclJlc3BvbnNlIiwibmV3UmVzcG9uc2UiLCJhYm9ydGVkIiwicmFuZ2VSZXF1ZXN0ZWQiLCJ0aW1pbmdBbGxvd1Bhc3NlZCIsInJlcXVlc3RJbmNsdWRlc0NyZWRlbnRpYWxzIiwidGltaW5nSW5mbyIsImNhY2hlU3RhdGUiLCJyZWFzb24iLCJpc0Vycm9yIiwiRXJyb3IiLCJTdHJpbmciLCJuYW1lIiwiaXNOZXR3b3JrRXJyb3IiLCJtYWtlRmlsdGVyZWRSZXNwb25zZSIsInN0YXRlIiwiUHJveHkiLCJnZXQiLCJ0YXJnZXQiLCJwIiwic2V0IiwiZnJlZXplIiwibWFrZUFwcHJvcHJpYXRlTmV0d29ya0Vycm9yIiwiZmV0Y2hQYXJhbXMiLCJhc3NpZ24iLCJET01FeGNlcHRpb24iLCJpbmNsdWRlcyIsImNvbnRhaW5zIiwiaW5uZXJSZXNwb25zZSIsImd1YXJkIiwicmVnaXN0ZXIiLCJXZWFrUmVmIiwiUmVhZGFibGVTdHJlYW0iLCJpbnRlcmZhY2VDb252ZXJ0ZXIiLCJVUkxTZWFyY2hQYXJhbXMiLCJYTUxIdHRwUmVxdWVzdEJvZHlJbml0IiwiViIsInByZWZpeCIsIkJsb2IiLCJzdHJpY3QiLCJBcnJheUJ1ZmZlciIsImlzVmlldyIsImlzQXJyYXlCdWZmZXIiLCJCdWZmZXJTb3VyY2UiLCJpc0Zvcm1EYXRhTGlrZSIsIkRPTVN0cmluZyIsImFyZ3VtZW50IiwiYXN5bmNJdGVyYXRvciIsImRpY3Rpb25hcnlDb252ZXJ0ZXIiLCJrZXkiLCJjb252ZXJ0ZXIiLCJkZWZhdWx0VmFsdWUiLCJCeXRlU3RyaW5nIiwiSGVhZGVyc0luaXQiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/fetch/response.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/fetch/symbols.js":
/*!******************************************************!*\
  !*** ./node_modules/undici/lib/web/fetch/symbols.js ***!
  \******************************************************/
/***/ ((module) => {

eval("\nmodule.exports = {\n    kUrl: Symbol(\"url\"),\n    kHeaders: Symbol(\"headers\"),\n    kSignal: Symbol(\"signal\"),\n    kState: Symbol(\"state\"),\n    kDispatcher: Symbol(\"dispatcher\")\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZmV0Y2gvc3ltYm9scy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBQSxPQUFPQyxPQUFPLEdBQUc7SUFDZkMsTUFBTUMsT0FBTztJQUNiQyxVQUFVRCxPQUFPO0lBQ2pCRSxTQUFTRixPQUFPO0lBQ2hCRyxRQUFRSCxPQUFPO0lBQ2ZJLGFBQWFKLE9BQU87QUFDdEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tb2NrdXBmbG93Ly4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvd2ViL2ZldGNoL3N5bWJvbHMuanM/YzI2MCIsIndlYnBhY2s6Ly9tb2NrdXBmbG93Ly4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvd2ViL2ZldGNoL3N5bWJvbHMuanM/YzI2MCoiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBrVXJsOiBTeW1ib2woJ3VybCcpLFxuICBrSGVhZGVyczogU3ltYm9sKCdoZWFkZXJzJyksXG4gIGtTaWduYWw6IFN5bWJvbCgnc2lnbmFsJyksXG4gIGtTdGF0ZTogU3ltYm9sKCdzdGF0ZScpLFxuICBrRGlzcGF0Y2hlcjogU3ltYm9sKCdkaXNwYXRjaGVyJylcbn1cbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwia1VybCIsIlN5bWJvbCIsImtIZWFkZXJzIiwia1NpZ25hbCIsImtTdGF0ZSIsImtEaXNwYXRjaGVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/fetch/symbols.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/fetch/util.js":
/*!***************************************************!*\
  !*** ./node_modules/undici/lib/web/fetch/util.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nfunction _checkInRHS(e) {\n    if (Object(e) !== e) throw TypeError(\"right-hand side of 'in' should be an object, got \" + (null !== e ? typeof e : \"null\"));\n    return e;\n}\nconst { Transform } = __webpack_require__(/*! node:stream */ \"node:stream\");\nconst zlib = __webpack_require__(/*! node:zlib */ \"node:zlib\");\nconst { redirectStatusSet, referrerPolicySet: referrerPolicyTokens, badPortsSet } = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/undici/lib/web/fetch/constants.js\");\nconst { getGlobalOrigin } = __webpack_require__(/*! ./global */ \"(ssr)/./node_modules/undici/lib/web/fetch/global.js\");\nconst { collectASequenceOfCodePoints, collectAnHTTPQuotedString, removeChars, parseMIMEType } = __webpack_require__(/*! ./data-url */ \"(ssr)/./node_modules/undici/lib/web/fetch/data-url.js\");\nconst { performance } = __webpack_require__(/*! node:perf_hooks */ \"node:perf_hooks\");\nconst { isBlobLike, ReadableStreamFrom, isValidHTTPToken, normalizedMethodRecordsBase } = __webpack_require__(/*! ../../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\");\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\");\nconst { isUint8Array } = __webpack_require__(/*! node:util/types */ \"node:util/types\");\nconst { webidl } = __webpack_require__(/*! ./webidl */ \"(ssr)/./node_modules/undici/lib/web/fetch/webidl.js\");\nlet supportedHashes = [];\n// https://nodejs.org/api/crypto.html#determining-if-crypto-support-is-unavailable\n/** @type {import('crypto')} */ let crypto;\ntry {\n    crypto = __webpack_require__(/*! node:crypto */ \"node:crypto\");\n    const possibleRelevantHashes = [\n        \"sha256\",\n        \"sha384\",\n        \"sha512\"\n    ];\n    supportedHashes = crypto.getHashes().filter((hash)=>possibleRelevantHashes.includes(hash));\n/* c8 ignore next 3 */ } catch  {}\nfunction responseURL(response) {\n    // https://fetch.spec.whatwg.org/#responses\n    // A response has an associated URL. It is a pointer to the last URL\n    // in responses URL list and null if responses URL list is empty.\n    const urlList = response.urlList;\n    const length = urlList.length;\n    return length === 0 ? null : urlList[length - 1].toString();\n}\n// https://fetch.spec.whatwg.org/#concept-response-location-url\nfunction responseLocationURL(response, requestFragment) {\n    // 1. If responses status is not a redirect status, then return null.\n    if (!redirectStatusSet.has(response.status)) {\n        return null;\n    }\n    // 2. Let location be the result of extracting header list values given\n    // `Location` and responses header list.\n    let location = response.headersList.get(\"location\", true);\n    // 3. If location is a header value, then set location to the result of\n    //    parsing location with responses URL.\n    if (location !== null && isValidHeaderValue(location)) {\n        if (!isValidEncodedURL(location)) {\n            // Some websites respond location header in UTF-8 form without encoding them as ASCII\n            // and major browsers redirect them to correctly UTF-8 encoded addresses.\n            // Here, we handle that behavior in the same way.\n            location = normalizeBinaryStringToUtf8(location);\n        }\n        location = new URL(location, responseURL(response));\n    }\n    // 4. If location is a URL whose fragment is null, then set locations\n    // fragment to requestFragment.\n    if (location && !location.hash) {\n        location.hash = requestFragment;\n    }\n    // 5. Return location.\n    return location;\n}\n/**\n * @see https://www.rfc-editor.org/rfc/rfc1738#section-2.2\n * @param {string} url\n * @returns {boolean}\n */ function isValidEncodedURL(url) {\n    for(let i = 0; i < url.length; ++i){\n        const code = url.charCodeAt(i);\n        if (code > 0x7E || // Non-US-ASCII + DEL\n        code < 0x20 // Control characters NUL - US\n        ) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * If string contains non-ASCII characters, assumes it's UTF-8 encoded and decodes it.\n * Since UTF-8 is a superset of ASCII, this will work for ASCII strings as well.\n * @param {string} value\n * @returns {string}\n */ function normalizeBinaryStringToUtf8(value) {\n    return Buffer.from(value, \"binary\").toString(\"utf8\");\n}\n/** @returns {URL} */ function requestCurrentURL(request) {\n    return request.urlList[request.urlList.length - 1];\n}\nfunction requestBadPort(request) {\n    // 1. Let url be requests current URL.\n    const url = requestCurrentURL(request);\n    // 2. If urls scheme is an HTTP(S) scheme and urls port is a bad port,\n    // then return blocked.\n    if (urlIsHttpHttpsScheme(url) && badPortsSet.has(url.port)) {\n        return \"blocked\";\n    }\n    // 3. Return allowed.\n    return \"allowed\";\n}\nfunction isErrorLike(object) {\n    return object instanceof Error || object?.constructor?.name === \"Error\" || object?.constructor?.name === \"DOMException\";\n}\n// Check whether |statusText| is a ByteString and\n// matches the Reason-Phrase token production.\n// RFC 2616: https://tools.ietf.org/html/rfc2616\n// RFC 7230: https://tools.ietf.org/html/rfc7230\n// \"reason-phrase = *( HTAB / SP / VCHAR / obs-text )\"\n// https://github.com/chromium/chromium/blob/94.0.4604.1/third_party/blink/renderer/core/fetch/response.cc#L116\nfunction isValidReasonPhrase(statusText) {\n    for(let i = 0; i < statusText.length; ++i){\n        const c = statusText.charCodeAt(i);\n        if (!(c === 0x09 || // HTAB\n        c >= 0x20 && c <= 0x7e || // SP / VCHAR\n        c >= 0x80 && c <= 0xff)) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * @see https://fetch.spec.whatwg.org/#header-name\n * @param {string} potentialValue\n */ const isValidHeaderName = isValidHTTPToken;\n/**\n * @see https://fetch.spec.whatwg.org/#header-value\n * @param {string} potentialValue\n */ function isValidHeaderValue(potentialValue) {\n    // - Has no leading or trailing HTTP tab or space bytes.\n    // - Contains no 0x00 (NUL) or HTTP newline bytes.\n    return (potentialValue[0] === \"\t\" || potentialValue[0] === \" \" || potentialValue[potentialValue.length - 1] === \"\t\" || potentialValue[potentialValue.length - 1] === \" \" || potentialValue.includes(\"\\n\") || potentialValue.includes(\"\\r\") || potentialValue.includes(\"\\x00\")) === false;\n}\n// https://w3c.github.io/webappsec-referrer-policy/#set-requests-referrer-policy-on-redirect\nfunction setRequestReferrerPolicyOnRedirect(request, actualResponse) {\n    //  Given a request request and a response actualResponse, this algorithm\n    //  updates requests referrer policy according to the Referrer-Policy\n    //  header (if any) in actualResponse.\n    // 1. Let policy be the result of executing  8.1 Parse a referrer policy\n    // from a Referrer-Policy header on actualResponse.\n    // 8.1 Parse a referrer policy from a Referrer-Policy header\n    // 1. Let policy-tokens be the result of extracting header list values given `Referrer-Policy` and responses header list.\n    const { headersList } = actualResponse;\n    // 2. Let policy be the empty string.\n    // 3. For each token in policy-tokens, if token is a referrer policy and token is not the empty string, then set policy to token.\n    // 4. Return policy.\n    const policyHeader = (headersList.get(\"referrer-policy\", true) ?? \"\").split(\",\");\n    // Note: As the referrer-policy can contain multiple policies\n    // separated by comma, we need to loop through all of them\n    // and pick the first valid one.\n    // Ref: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referrer-Policy#specify_a_fallback_policy\n    let policy = \"\";\n    if (policyHeader.length > 0) {\n        // The right-most policy takes precedence.\n        // The left-most policy is the fallback.\n        for(let i = policyHeader.length; i !== 0; i--){\n            const token = policyHeader[i - 1].trim();\n            if (referrerPolicyTokens.has(token)) {\n                policy = token;\n                break;\n            }\n        }\n    }\n    // 2. If policy is not the empty string, then set requests referrer policy to policy.\n    if (policy !== \"\") {\n        request.referrerPolicy = policy;\n    }\n}\n// https://fetch.spec.whatwg.org/#cross-origin-resource-policy-check\nfunction crossOriginResourcePolicyCheck() {\n    // TODO\n    return \"allowed\";\n}\n// https://fetch.spec.whatwg.org/#concept-cors-check\nfunction corsCheck() {\n    // TODO\n    return \"success\";\n}\n// https://fetch.spec.whatwg.org/#concept-tao-check\nfunction TAOCheck() {\n    // TODO\n    return \"success\";\n}\nfunction appendFetchMetadata(httpRequest) {\n    //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-dest-header\n    //  TODO\n    //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-mode-header\n    //  1. Assert: rs url is a potentially trustworthy URL.\n    //  TODO\n    //  2. Let header be a Structured Header whose value is a token.\n    let header = null;\n    //  3. Set headers value to rs mode.\n    header = httpRequest.mode;\n    //  4. Set a structured field value `Sec-Fetch-Mode`/header in rs header list.\n    httpRequest.headersList.set(\"sec-fetch-mode\", header, true);\n//  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-site-header\n//  TODO\n//  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-user-header\n//  TODO\n}\n// https://fetch.spec.whatwg.org/#append-a-request-origin-header\nfunction appendRequestOriginHeader(request) {\n    // 1. Let serializedOrigin be the result of byte-serializing a request origin\n    //    with request.\n    // TODO: implement \"byte-serializing a request origin\"\n    let serializedOrigin = request.origin;\n    // - \"'client' is changed to an origin during fetching.\"\n    //   This doesn't happen in undici (in most cases) because undici, by default,\n    //   has no concept of origin.\n    // - request.origin can also be set to request.client.origin (client being\n    //   an environment settings object), which is undefined without using\n    //   setGlobalOrigin.\n    if (serializedOrigin === \"client\" || serializedOrigin === undefined) {\n        return;\n    }\n    // 2. If requests response tainting is \"cors\" or requests mode is \"websocket\",\n    //    then append (`Origin`, serializedOrigin) to requests header list.\n    // 3. Otherwise, if requests method is neither `GET` nor `HEAD`, then:\n    if (request.responseTainting === \"cors\" || request.mode === \"websocket\") {\n        request.headersList.append(\"origin\", serializedOrigin, true);\n    } else if (request.method !== \"GET\" && request.method !== \"HEAD\") {\n        // 1. Switch on requests referrer policy:\n        switch(request.referrerPolicy){\n            case \"no-referrer\":\n                // Set serializedOrigin to `null`.\n                serializedOrigin = null;\n                break;\n            case \"no-referrer-when-downgrade\":\n            case \"strict-origin\":\n            case \"strict-origin-when-cross-origin\":\n                // If requests origin is a tuple origin, its scheme is \"https\", and\n                // requests current URLs scheme is not \"https\", then set\n                // serializedOrigin to `null`.\n                if (request.origin && urlHasHttpsScheme(request.origin) && !urlHasHttpsScheme(requestCurrentURL(request))) {\n                    serializedOrigin = null;\n                }\n                break;\n            case \"same-origin\":\n                // If requests origin is not same origin with requests current URLs\n                // origin, then set serializedOrigin to `null`.\n                if (!sameOrigin(request, requestCurrentURL(request))) {\n                    serializedOrigin = null;\n                }\n                break;\n            default:\n        }\n        // 2. Append (`Origin`, serializedOrigin) to requests header list.\n        request.headersList.append(\"origin\", serializedOrigin, true);\n    }\n}\n// https://w3c.github.io/hr-time/#dfn-coarsen-time\nfunction coarsenTime(timestamp, crossOriginIsolatedCapability) {\n    // TODO\n    return timestamp;\n}\n// https://fetch.spec.whatwg.org/#clamp-and-coarsen-connection-timing-info\nfunction clampAndCoarsenConnectionTimingInfo(connectionTimingInfo, defaultStartTime, crossOriginIsolatedCapability) {\n    if (!connectionTimingInfo?.startTime || connectionTimingInfo.startTime < defaultStartTime) {\n        return {\n            domainLookupStartTime: defaultStartTime,\n            domainLookupEndTime: defaultStartTime,\n            connectionStartTime: defaultStartTime,\n            connectionEndTime: defaultStartTime,\n            secureConnectionStartTime: defaultStartTime,\n            ALPNNegotiatedProtocol: connectionTimingInfo?.ALPNNegotiatedProtocol\n        };\n    }\n    return {\n        domainLookupStartTime: coarsenTime(connectionTimingInfo.domainLookupStartTime, crossOriginIsolatedCapability),\n        domainLookupEndTime: coarsenTime(connectionTimingInfo.domainLookupEndTime, crossOriginIsolatedCapability),\n        connectionStartTime: coarsenTime(connectionTimingInfo.connectionStartTime, crossOriginIsolatedCapability),\n        connectionEndTime: coarsenTime(connectionTimingInfo.connectionEndTime, crossOriginIsolatedCapability),\n        secureConnectionStartTime: coarsenTime(connectionTimingInfo.secureConnectionStartTime, crossOriginIsolatedCapability),\n        ALPNNegotiatedProtocol: connectionTimingInfo.ALPNNegotiatedProtocol\n    };\n}\n// https://w3c.github.io/hr-time/#dfn-coarsened-shared-current-time\nfunction coarsenedSharedCurrentTime(crossOriginIsolatedCapability) {\n    return coarsenTime(performance.now(), crossOriginIsolatedCapability);\n}\n// https://fetch.spec.whatwg.org/#create-an-opaque-timing-info\nfunction createOpaqueTimingInfo(timingInfo) {\n    return {\n        startTime: timingInfo.startTime ?? 0,\n        redirectStartTime: 0,\n        redirectEndTime: 0,\n        postRedirectStartTime: timingInfo.startTime ?? 0,\n        finalServiceWorkerStartTime: 0,\n        finalNetworkResponseStartTime: 0,\n        finalNetworkRequestStartTime: 0,\n        endTime: 0,\n        encodedBodySize: 0,\n        decodedBodySize: 0,\n        finalConnectionTimingInfo: null\n    };\n}\n// https://html.spec.whatwg.org/multipage/origin.html#policy-container\nfunction makePolicyContainer() {\n    // Note: the fetch spec doesn't make use of embedder policy or CSP list\n    return {\n        referrerPolicy: \"strict-origin-when-cross-origin\"\n    };\n}\n// https://html.spec.whatwg.org/multipage/origin.html#clone-a-policy-container\nfunction clonePolicyContainer(policyContainer) {\n    return {\n        referrerPolicy: policyContainer.referrerPolicy\n    };\n}\n// https://w3c.github.io/webappsec-referrer-policy/#determine-requests-referrer\nfunction determineRequestsReferrer(request) {\n    // 1. Let policy be request's referrer policy.\n    const policy = request.referrerPolicy;\n    // Note: policy cannot (shouldn't) be null or an empty string.\n    assert(policy);\n    // 2. Let environment be requests client.\n    let referrerSource = null;\n    // 3. Switch on requests referrer:\n    if (request.referrer === \"client\") {\n        // Note: node isn't a browser and doesn't implement document/iframes,\n        // so we bypass this step and replace it with our own.\n        const globalOrigin = getGlobalOrigin();\n        if (!globalOrigin || globalOrigin.origin === \"null\") {\n            return \"no-referrer\";\n        }\n        // note: we need to clone it as it's mutated\n        referrerSource = new URL(globalOrigin);\n    } else if (request.referrer instanceof URL) {\n        // Let referrerSource be requests referrer.\n        referrerSource = request.referrer;\n    }\n    // 4. Let requests referrerURL be the result of stripping referrerSource for\n    //    use as a referrer.\n    let referrerURL = stripURLForReferrer(referrerSource);\n    // 5. Let referrerOrigin be the result of stripping referrerSource for use as\n    //    a referrer, with the origin-only flag set to true.\n    const referrerOrigin = stripURLForReferrer(referrerSource, true);\n    // 6. If the result of serializing referrerURL is a string whose length is\n    //    greater than 4096, set referrerURL to referrerOrigin.\n    if (referrerURL.toString().length > 4096) {\n        referrerURL = referrerOrigin;\n    }\n    const areSameOrigin = sameOrigin(request, referrerURL);\n    const isNonPotentiallyTrustWorthy = isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(request.url);\n    // 8. Execute the switch statements corresponding to the value of policy:\n    switch(policy){\n        case \"origin\":\n            return referrerOrigin != null ? referrerOrigin : stripURLForReferrer(referrerSource, true);\n        case \"unsafe-url\":\n            return referrerURL;\n        case \"same-origin\":\n            return areSameOrigin ? referrerOrigin : \"no-referrer\";\n        case \"origin-when-cross-origin\":\n            return areSameOrigin ? referrerURL : referrerOrigin;\n        case \"strict-origin-when-cross-origin\":\n            {\n                const currentURL = requestCurrentURL(request);\n                // 1. If the origin of referrerURL and the origin of requests current\n                //    URL are the same, then return referrerURL.\n                if (sameOrigin(referrerURL, currentURL)) {\n                    return referrerURL;\n                }\n                // 2. If referrerURL is a potentially trustworthy URL and requests\n                //    current URL is not a potentially trustworthy URL, then return no\n                //    referrer.\n                if (isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(currentURL)) {\n                    return \"no-referrer\";\n                }\n                // 3. Return referrerOrigin.\n                return referrerOrigin;\n            }\n        case \"strict-origin\":\n        /**\n       * 1. If referrerURL is a potentially trustworthy URL and\n       * requests current URL is not a potentially trustworthy URL,\n       * then return no referrer.\n       * 2. Return referrerOrigin\n      */ case \"no-referrer-when-downgrade\":\n        /**\n     * 1. If referrerURL is a potentially trustworthy URL and\n     * requests current URL is not a potentially trustworthy URL,\n     * then return no referrer.\n     * 2. Return referrerOrigin\n    */ default:\n            // eslint-disable-line\n            return isNonPotentiallyTrustWorthy ? \"no-referrer\" : referrerOrigin;\n    }\n}\n/**\n * @see https://w3c.github.io/webappsec-referrer-policy/#strip-url\n * @param {URL} url\n * @param {boolean|undefined} originOnly\n */ function stripURLForReferrer(url, originOnly) {\n    // 1. Assert: url is a URL.\n    assert(url instanceof URL);\n    url = new URL(url);\n    // 2. If urls scheme is a local scheme, then return no referrer.\n    if (url.protocol === \"file:\" || url.protocol === \"about:\" || url.protocol === \"blank:\") {\n        return \"no-referrer\";\n    }\n    // 3. Set urls username to the empty string.\n    url.username = \"\";\n    // 4. Set urls password to the empty string.\n    url.password = \"\";\n    // 5. Set urls fragment to null.\n    url.hash = \"\";\n    // 6. If the origin-only flag is true, then:\n    if (originOnly) {\n        // 1. Set urls path to  the empty string .\n        url.pathname = \"\";\n        // 2. Set urls query to null.\n        url.search = \"\";\n    }\n    // 7. Return url.\n    return url;\n}\nfunction isURLPotentiallyTrustworthy(url) {\n    if (!(url instanceof URL)) {\n        return false;\n    }\n    // If child of about, return true\n    if (url.href === \"about:blank\" || url.href === \"about:srcdoc\") {\n        return true;\n    }\n    // If scheme is data, return true\n    if (url.protocol === \"data:\") return true;\n    // If file, return true\n    if (url.protocol === \"file:\") return true;\n    return isOriginPotentiallyTrustworthy(url.origin);\n    function isOriginPotentiallyTrustworthy(origin) {\n        // If origin is explicitly null, return false\n        if (origin == null || origin === \"null\") return false;\n        const originAsURL = new URL(origin);\n        // If secure, return true\n        if (originAsURL.protocol === \"https:\" || originAsURL.protocol === \"wss:\") {\n            return true;\n        }\n        // If localhost or variants, return true\n        if (/^127(?:\\.[0-9]+){0,2}\\.[0-9]+$|^\\[(?:0*:)*?:?0*1\\]$/.test(originAsURL.hostname) || originAsURL.hostname === \"localhost\" || originAsURL.hostname.includes(\"localhost.\") || originAsURL.hostname.endsWith(\".localhost\")) {\n            return true;\n        }\n        // If any other, return false\n        return false;\n    }\n}\n/**\n * @see https://w3c.github.io/webappsec-subresource-integrity/#does-response-match-metadatalist\n * @param {Uint8Array} bytes\n * @param {string} metadataList\n */ function bytesMatch(bytes, metadataList) {\n    // If node is not built with OpenSSL support, we cannot check\n    // a request's integrity, so allow it by default (the spec will\n    // allow requests if an invalid hash is given, as precedence).\n    /* istanbul ignore if: only if node is built with --without-ssl */ if (crypto === undefined) {\n        return true;\n    }\n    // 1. Let parsedMetadata be the result of parsing metadataList.\n    const parsedMetadata = parseMetadata(metadataList);\n    // 2. If parsedMetadata is no metadata, return true.\n    if (parsedMetadata === \"no metadata\") {\n        return true;\n    }\n    // 3. If response is not eligible for integrity validation, return false.\n    // TODO\n    // 4. If parsedMetadata is the empty set, return true.\n    if (parsedMetadata.length === 0) {\n        return true;\n    }\n    // 5. Let metadata be the result of getting the strongest\n    //    metadata from parsedMetadata.\n    const strongest = getStrongestMetadata(parsedMetadata);\n    const metadata = filterMetadataListByAlgorithm(parsedMetadata, strongest);\n    // 6. For each item in metadata:\n    for (const item of metadata){\n        // 1. Let algorithm be the alg component of item.\n        const algorithm = item.algo;\n        // 2. Let expectedValue be the val component of item.\n        const expectedValue = item.hash;\n        // See https://github.com/web-platform-tests/wpt/commit/e4c5cc7a5e48093220528dfdd1c4012dc3837a0e\n        // \"be liberal with padding\". This is annoying, and it's not even in the spec.\n        // 3. Let actualValue be the result of applying algorithm to bytes.\n        let actualValue = crypto.createHash(algorithm).update(bytes).digest(\"base64\");\n        if (actualValue[actualValue.length - 1] === \"=\") {\n            if (actualValue[actualValue.length - 2] === \"=\") {\n                actualValue = actualValue.slice(0, -2);\n            } else {\n                actualValue = actualValue.slice(0, -1);\n            }\n        }\n        // 4. If actualValue is a case-sensitive match for expectedValue,\n        //    return true.\n        if (compareBase64Mixed(actualValue, expectedValue)) {\n            return true;\n        }\n    }\n    // 7. Return false.\n    return false;\n}\n// https://w3c.github.io/webappsec-subresource-integrity/#grammardef-hash-with-options\n// https://www.w3.org/TR/CSP2/#source-list-syntax\n// https://www.rfc-editor.org/rfc/rfc5234#appendix-B.1\nconst parseHashWithOptions = /(?<algo>sha256|sha384|sha512)-((?<hash>[A-Za-z0-9+/]+|[A-Za-z0-9_-]+)={0,2}(?:\\s|$)( +[!-~]*)?)?/i;\n/**\n * @see https://w3c.github.io/webappsec-subresource-integrity/#parse-metadata\n * @param {string} metadata\n */ function parseMetadata(metadata) {\n    // 1. Let result be the empty set.\n    /** @type {{ algo: string, hash: string }[]} */ const result = [];\n    // 2. Let empty be equal to true.\n    let empty = true;\n    // 3. For each token returned by splitting metadata on spaces:\n    for (const token of metadata.split(\" \")){\n        // 1. Set empty to false.\n        empty = false;\n        // 2. Parse token as a hash-with-options.\n        const parsedToken = parseHashWithOptions.exec(token);\n        // 3. If token does not parse, continue to the next token.\n        if (parsedToken === null || parsedToken.groups === undefined || parsedToken.groups.algo === undefined) {\n            continue;\n        }\n        // 4. Let algorithm be the hash-algo component of token.\n        const algorithm = parsedToken.groups.algo.toLowerCase();\n        // 5. If algorithm is a hash function recognized by the user\n        //    agent, add the parsed token to result.\n        if (supportedHashes.includes(algorithm)) {\n            result.push(parsedToken.groups);\n        }\n    }\n    // 4. Return no metadata if empty is true, otherwise return result.\n    if (empty === true) {\n        return \"no metadata\";\n    }\n    return result;\n}\n/**\n * @param {{ algo: 'sha256' | 'sha384' | 'sha512' }[]} metadataList\n */ function getStrongestMetadata(metadataList) {\n    // Let algorithm be the algo component of the first item in metadataList.\n    // Can be sha256\n    let algorithm = metadataList[0].algo;\n    // If the algorithm is sha512, then it is the strongest\n    // and we can return immediately\n    if (algorithm[3] === \"5\") {\n        return algorithm;\n    }\n    for(let i = 1; i < metadataList.length; ++i){\n        const metadata = metadataList[i];\n        // If the algorithm is sha512, then it is the strongest\n        // and we can break the loop immediately\n        if (metadata.algo[3] === \"5\") {\n            algorithm = \"sha512\";\n            break;\n        // If the algorithm is sha384, then a potential sha256 or sha384 is ignored\n        } else if (algorithm[3] === \"3\") {\n            continue;\n        // algorithm is sha256, check if algorithm is sha384 and if so, set it as\n        // the strongest\n        } else if (metadata.algo[3] === \"3\") {\n            algorithm = \"sha384\";\n        }\n    }\n    return algorithm;\n}\nfunction filterMetadataListByAlgorithm(metadataList, algorithm) {\n    if (metadataList.length === 1) {\n        return metadataList;\n    }\n    let pos = 0;\n    for(let i = 0; i < metadataList.length; ++i){\n        if (metadataList[i].algo === algorithm) {\n            metadataList[pos++] = metadataList[i];\n        }\n    }\n    metadataList.length = pos;\n    return metadataList;\n}\n/**\n * Compares two base64 strings, allowing for base64url\n * in the second string.\n *\n* @param {string} actualValue always base64\n * @param {string} expectedValue base64 or base64url\n * @returns {boolean}\n */ function compareBase64Mixed(actualValue, expectedValue) {\n    if (actualValue.length !== expectedValue.length) {\n        return false;\n    }\n    for(let i = 0; i < actualValue.length; ++i){\n        if (actualValue[i] !== expectedValue[i]) {\n            if (actualValue[i] === \"+\" && expectedValue[i] === \"-\" || actualValue[i] === \"/\" && expectedValue[i] === \"_\") {\n                continue;\n            }\n            return false;\n        }\n    }\n    return true;\n}\n// https://w3c.github.io/webappsec-upgrade-insecure-requests/#upgrade-request\nfunction tryUpgradeRequestToAPotentiallyTrustworthyURL(request) {\n// TODO\n}\n/**\n * @link {https://html.spec.whatwg.org/multipage/origin.html#same-origin}\n * @param {URL} A\n * @param {URL} B\n */ function sameOrigin(A, B) {\n    // 1. If A and B are the same opaque origin, then return true.\n    if (A.origin === B.origin && A.origin === \"null\") {\n        return true;\n    }\n    // 2. If A and B are both tuple origins and their schemes,\n    //    hosts, and port are identical, then return true.\n    if (A.protocol === B.protocol && A.hostname === B.hostname && A.port === B.port) {\n        return true;\n    }\n    // 3. Return false.\n    return false;\n}\nfunction createDeferredPromise() {\n    let res;\n    let rej;\n    const promise = new Promise((resolve, reject)=>{\n        res = resolve;\n        rej = reject;\n    });\n    return {\n        promise,\n        resolve: res,\n        reject: rej\n    };\n}\nfunction isAborted(fetchParams) {\n    return fetchParams.controller.state === \"aborted\";\n}\nfunction isCancelled(fetchParams) {\n    return fetchParams.controller.state === \"aborted\" || fetchParams.controller.state === \"terminated\";\n}\n/**\n * @see https://fetch.spec.whatwg.org/#concept-method-normalize\n * @param {string} method\n */ function normalizeMethod(method) {\n    return normalizedMethodRecordsBase[method.toLowerCase()] ?? method;\n}\n// https://infra.spec.whatwg.org/#serialize-a-javascript-value-to-a-json-string\nfunction serializeJavascriptValueToJSONString(value) {\n    // 1. Let result be ? Call(%JSON.stringify%, undefined,  value ).\n    const result = JSON.stringify(value);\n    // 2. If result is undefined, then throw a TypeError.\n    if (result === undefined) {\n        throw new TypeError(\"Value is not JSON serializable\");\n    }\n    // 3. Assert: result is a string.\n    assert(typeof result === \"string\");\n    // 4. Return result.\n    return result;\n}\n// https://tc39.es/ecma262/#sec-%25iteratorprototype%25-object\nconst esIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()));\n/**\n * @see https://webidl.spec.whatwg.org/#dfn-iterator-prototype-object\n * @param {string} name name of the instance\n * @param {symbol} kInternalIterator\n * @param {string | number} [keyIndex]\n * @param {string | number} [valueIndex]\n */ function createIterator(name, kInternalIterator, keyIndex = 0, valueIndex = 1) {\n    var _targetBrandCheck = /*#__PURE__*/ new WeakSet();\n    class FastIterableIterator {\n        /** @type {any} */ #target;\n        /** @type {'key' | 'value' | 'key+value'} */ #kind;\n        /** @type {number} */ #index;\n        /**\n     * @see https://webidl.spec.whatwg.org/#dfn-default-iterator-object\n     * @param {unknown} target\n     * @param {'key' | 'value' | 'key+value'} kind\n     */ constructor(target, kind){\n            this.#target = void _targetBrandCheck.add(this);\n            this.#target = target;\n            this.#kind = kind;\n            this.#index = 0;\n        }\n        next() {\n            // 1. Let interface be the interface for which the iterator prototype object exists.\n            // 2. Let thisValue be the this value.\n            // 3. Let object be ? ToObject(thisValue).\n            // 4. If object is a platform object, then perform a security\n            //    check, passing:\n            // 5. If object is not a default iterator object for interface,\n            //    then throw a TypeError.\n            if (typeof this !== \"object\" || this === null || !_targetBrandCheck.has(_checkInRHS(this))) {\n                throw new TypeError(`'next' called on an object that does not implement interface ${name} Iterator.`);\n            }\n            // 6. Let index be objects index.\n            // 7. Let kind be objects kind.\n            // 8. Let values be objects target's value pairs to iterate over.\n            const index = this.#index;\n            const values = this.#target[kInternalIterator];\n            // 9. Let len be the length of values.\n            const len = values.length;\n            // 10. If index is greater than or equal to len, then return\n            //     CreateIterResultObject(undefined, true).\n            if (index >= len) {\n                return {\n                    value: undefined,\n                    done: true\n                };\n            }\n            // 11. Let pair be the entry in values at index index.\n            const { [keyIndex]: key, [valueIndex]: value } = values[index];\n            // 12. Set objects index to index + 1.\n            this.#index = index + 1;\n            // 13. Return the iterator result for pair and kind.\n            // https://webidl.spec.whatwg.org/#iterator-result\n            // 1. Let result be a value determined by the value of kind:\n            let result;\n            switch(this.#kind){\n                case \"key\":\n                    // 1. Let idlKey be pairs key.\n                    // 2. Let key be the result of converting idlKey to an\n                    //    ECMAScript value.\n                    // 3. result is key.\n                    result = key;\n                    break;\n                case \"value\":\n                    // 1. Let idlValue be pairs value.\n                    // 2. Let value be the result of converting idlValue to\n                    //    an ECMAScript value.\n                    // 3. result is value.\n                    result = value;\n                    break;\n                case \"key+value\":\n                    // 1. Let idlKey be pairs key.\n                    // 2. Let idlValue be pairs value.\n                    // 3. Let key be the result of converting idlKey to an\n                    //    ECMAScript value.\n                    // 4. Let value be the result of converting idlValue to\n                    //    an ECMAScript value.\n                    // 5. Let array be ! ArrayCreate(2).\n                    // 6. Call ! CreateDataProperty(array, \"0\", key).\n                    // 7. Call ! CreateDataProperty(array, \"1\", value).\n                    // 8. result is array.\n                    result = [\n                        key,\n                        value\n                    ];\n                    break;\n            }\n            // 2. Return CreateIterResultObject(result, false).\n            return {\n                value: result,\n                done: false\n            };\n        }\n    }\n    // https://webidl.spec.whatwg.org/#dfn-iterator-prototype-object\n    // @ts-ignore\n    delete FastIterableIterator.prototype.constructor;\n    Object.setPrototypeOf(FastIterableIterator.prototype, esIteratorPrototype);\n    Object.defineProperties(FastIterableIterator.prototype, {\n        [Symbol.toStringTag]: {\n            writable: false,\n            enumerable: false,\n            configurable: true,\n            value: `${name} Iterator`\n        },\n        next: {\n            writable: true,\n            enumerable: true,\n            configurable: true\n        }\n    });\n    /**\n   * @param {unknown} target\n   * @param {'key' | 'value' | 'key+value'} kind\n   * @returns {IterableIterator<any>}\n   */ return function(target, kind) {\n        return new FastIterableIterator(target, kind);\n    };\n}\n/**\n * @see https://webidl.spec.whatwg.org/#dfn-iterator-prototype-object\n * @param {string} name name of the instance\n * @param {any} object class\n * @param {symbol} kInternalIterator\n * @param {string | number} [keyIndex]\n * @param {string | number} [valueIndex]\n */ function iteratorMixin(name, object, kInternalIterator, keyIndex = 0, valueIndex = 1) {\n    const makeIterator = createIterator(name, kInternalIterator, keyIndex, valueIndex);\n    const properties = {\n        keys: {\n            writable: true,\n            enumerable: true,\n            configurable: true,\n            value: function keys() {\n                webidl.brandCheck(this, object);\n                return makeIterator(this, \"key\");\n            }\n        },\n        values: {\n            writable: true,\n            enumerable: true,\n            configurable: true,\n            value: function values() {\n                webidl.brandCheck(this, object);\n                return makeIterator(this, \"value\");\n            }\n        },\n        entries: {\n            writable: true,\n            enumerable: true,\n            configurable: true,\n            value: function entries() {\n                webidl.brandCheck(this, object);\n                return makeIterator(this, \"key+value\");\n            }\n        },\n        forEach: {\n            writable: true,\n            enumerable: true,\n            configurable: true,\n            value: function forEach(callbackfn, thisArg = globalThis) {\n                webidl.brandCheck(this, object);\n                webidl.argumentLengthCheck(arguments, 1, `${name}.forEach`);\n                if (typeof callbackfn !== \"function\") {\n                    throw new TypeError(`Failed to execute 'forEach' on '${name}': parameter 1 is not of type 'Function'.`);\n                }\n                for (const { 0: key, 1: value } of makeIterator(this, \"key+value\")){\n                    callbackfn.call(thisArg, value, key, this);\n                }\n            }\n        }\n    };\n    return Object.defineProperties(object.prototype, {\n        ...properties,\n        [Symbol.iterator]: {\n            writable: true,\n            enumerable: false,\n            configurable: true,\n            value: properties.entries.value\n        }\n    });\n}\n/**\n * @see https://fetch.spec.whatwg.org/#body-fully-read\n */ async function fullyReadBody(body, processBody, processBodyError) {\n    // 1. If taskDestination is null, then set taskDestination to\n    //    the result of starting a new parallel queue.\n    // 2. Let successSteps given a byte sequence bytes be to queue a\n    //    fetch task to run processBody given bytes, with taskDestination.\n    const successSteps = processBody;\n    // 3. Let errorSteps be to queue a fetch task to run processBodyError,\n    //    with taskDestination.\n    const errorSteps = processBodyError;\n    // 4. Let reader be the result of getting a reader for bodys stream.\n    //    If that threw an exception, then run errorSteps with that\n    //    exception and return.\n    let reader;\n    try {\n        reader = body.stream.getReader();\n    } catch (e) {\n        errorSteps(e);\n        return;\n    }\n    // 5. Read all bytes from reader, given successSteps and errorSteps.\n    try {\n        successSteps(await readAllBytes(reader));\n    } catch (e) {\n        errorSteps(e);\n    }\n}\nfunction isReadableStreamLike(stream) {\n    return stream instanceof ReadableStream || stream[Symbol.toStringTag] === \"ReadableStream\" && typeof stream.tee === \"function\";\n}\n/**\n * @param {ReadableStreamController<Uint8Array>} controller\n */ function readableStreamClose(controller) {\n    try {\n        controller.close();\n        controller.byobRequest?.respond(0);\n    } catch (err) {\n        // TODO: add comment explaining why this error occurs.\n        if (!err.message.includes(\"Controller is already closed\") && !err.message.includes(\"ReadableStream is already closed\")) {\n            throw err;\n        }\n    }\n}\nconst invalidIsomorphicEncodeValueRegex = /[^\\x00-\\xFF]/; // eslint-disable-line\n/**\n * @see https://infra.spec.whatwg.org/#isomorphic-encode\n * @param {string} input\n */ function isomorphicEncode(input) {\n    // 1. Assert: input contains no code points greater than U+00FF.\n    assert(!invalidIsomorphicEncodeValueRegex.test(input));\n    // 2. Return a byte sequence whose length is equal to inputs code\n    //    point length and whose bytes have the same values as the\n    //    values of inputs code points, in the same order\n    return input;\n}\n/**\n * @see https://streams.spec.whatwg.org/#readablestreamdefaultreader-read-all-bytes\n * @see https://streams.spec.whatwg.org/#read-loop\n * @param {ReadableStreamDefaultReader} reader\n */ async function readAllBytes(reader) {\n    const bytes = [];\n    let byteLength = 0;\n    while(true){\n        const { done, value: chunk } = await reader.read();\n        if (done) {\n            // 1. Call successSteps with bytes.\n            return Buffer.concat(bytes, byteLength);\n        }\n        // 1. If chunk is not a Uint8Array object, call failureSteps\n        //    with a TypeError and abort these steps.\n        if (!isUint8Array(chunk)) {\n            throw new TypeError(\"Received non-Uint8Array chunk\");\n        }\n        // 2. Append the bytes represented by chunk to bytes.\n        bytes.push(chunk);\n        byteLength += chunk.length;\n    // 3. Read-loop given reader, bytes, successSteps, and failureSteps.\n    }\n}\n/**\n * @see https://fetch.spec.whatwg.org/#is-local\n * @param {URL} url\n */ function urlIsLocal(url) {\n    assert(\"protocol\" in url); // ensure it's a url object\n    const protocol = url.protocol;\n    return protocol === \"about:\" || protocol === \"blob:\" || protocol === \"data:\";\n}\n/**\n * @param {string|URL} url\n * @returns {boolean}\n */ function urlHasHttpsScheme(url) {\n    return typeof url === \"string\" && url[5] === \":\" && url[0] === \"h\" && url[1] === \"t\" && url[2] === \"t\" && url[3] === \"p\" && url[4] === \"s\" || url.protocol === \"https:\";\n}\n/**\n * @see https://fetch.spec.whatwg.org/#http-scheme\n * @param {URL} url\n */ function urlIsHttpHttpsScheme(url) {\n    assert(\"protocol\" in url); // ensure it's a url object\n    const protocol = url.protocol;\n    return protocol === \"http:\" || protocol === \"https:\";\n}\n/**\n * @see https://fetch.spec.whatwg.org/#simple-range-header-value\n * @param {string} value\n * @param {boolean} allowWhitespace\n */ function simpleRangeHeaderValue(value, allowWhitespace) {\n    // 1. Let data be the isomorphic decoding of value.\n    // Note: isomorphic decoding takes a sequence of bytes (ie. a Uint8Array) and turns it into a string,\n    // nothing more. We obviously don't need to do that if value is a string already.\n    const data = value;\n    // 2. If data does not start with \"bytes\", then return failure.\n    if (!data.startsWith(\"bytes\")) {\n        return \"failure\";\n    }\n    // 3. Let position be a position variable for data, initially pointing at the 5th code point of data.\n    const position = {\n        position: 5\n    };\n    // 4. If allowWhitespace is true, collect a sequence of code points that are HTTP tab or space,\n    //    from data given position.\n    if (allowWhitespace) {\n        collectASequenceOfCodePoints((char)=>char === \"\t\" || char === \" \", data, position);\n    }\n    // 5. If the code point at position within data is not U+003D (=), then return failure.\n    if (data.charCodeAt(position.position) !== 0x3D) {\n        return \"failure\";\n    }\n    // 6. Advance position by 1.\n    position.position++;\n    // 7. If allowWhitespace is true, collect a sequence of code points that are HTTP tab or space, from\n    //    data given position.\n    if (allowWhitespace) {\n        collectASequenceOfCodePoints((char)=>char === \"\t\" || char === \" \", data, position);\n    }\n    // 8. Let rangeStart be the result of collecting a sequence of code points that are ASCII digits,\n    //    from data given position.\n    const rangeStart = collectASequenceOfCodePoints((char)=>{\n        const code = char.charCodeAt(0);\n        return code >= 0x30 && code <= 0x39;\n    }, data, position);\n    // 9. Let rangeStartValue be rangeStart, interpreted as decimal number, if rangeStart is not the\n    //    empty string; otherwise null.\n    const rangeStartValue = rangeStart.length ? Number(rangeStart) : null;\n    // 10. If allowWhitespace is true, collect a sequence of code points that are HTTP tab or space,\n    //     from data given position.\n    if (allowWhitespace) {\n        collectASequenceOfCodePoints((char)=>char === \"\t\" || char === \" \", data, position);\n    }\n    // 11. If the code point at position within data is not U+002D (-), then return failure.\n    if (data.charCodeAt(position.position) !== 0x2D) {\n        return \"failure\";\n    }\n    // 12. Advance position by 1.\n    position.position++;\n    // 13. If allowWhitespace is true, collect a sequence of code points that are HTTP tab\n    //     or space, from data given position.\n    // Note from Khafra: its the same step as in #8 again lol\n    if (allowWhitespace) {\n        collectASequenceOfCodePoints((char)=>char === \"\t\" || char === \" \", data, position);\n    }\n    // 14. Let rangeEnd be the result of collecting a sequence of code points that are\n    //     ASCII digits, from data given position.\n    // Note from Khafra: you wouldn't guess it, but this is also the same step as #8\n    const rangeEnd = collectASequenceOfCodePoints((char)=>{\n        const code = char.charCodeAt(0);\n        return code >= 0x30 && code <= 0x39;\n    }, data, position);\n    // 15. Let rangeEndValue be rangeEnd, interpreted as decimal number, if rangeEnd\n    //     is not the empty string; otherwise null.\n    // Note from Khafra: THE SAME STEP, AGAIN!!!\n    // Note: why interpret as a decimal if we only collect ascii digits?\n    const rangeEndValue = rangeEnd.length ? Number(rangeEnd) : null;\n    // 16. If position is not past the end of data, then return failure.\n    if (position.position < data.length) {\n        return \"failure\";\n    }\n    // 17. If rangeEndValue and rangeStartValue are null, then return failure.\n    if (rangeEndValue === null && rangeStartValue === null) {\n        return \"failure\";\n    }\n    // 18. If rangeStartValue and rangeEndValue are numbers, and rangeStartValue is\n    //     greater than rangeEndValue, then return failure.\n    // Note: ... when can they not be numbers?\n    if (rangeStartValue > rangeEndValue) {\n        return \"failure\";\n    }\n    // 19. Return (rangeStartValue, rangeEndValue).\n    return {\n        rangeStartValue,\n        rangeEndValue\n    };\n}\n/**\n * @see https://fetch.spec.whatwg.org/#build-a-content-range\n * @param {number} rangeStart\n * @param {number} rangeEnd\n * @param {number} fullLength\n */ function buildContentRange(rangeStart, rangeEnd, fullLength) {\n    // 1. Let contentRange be `bytes `.\n    let contentRange = \"bytes \";\n    // 2. Append rangeStart, serialized and isomorphic encoded, to contentRange.\n    contentRange += isomorphicEncode(`${rangeStart}`);\n    // 3. Append 0x2D (-) to contentRange.\n    contentRange += \"-\";\n    // 4. Append rangeEnd, serialized and isomorphic encoded to contentRange.\n    contentRange += isomorphicEncode(`${rangeEnd}`);\n    // 5. Append 0x2F (/) to contentRange.\n    contentRange += \"/\";\n    // 6. Append fullLength, serialized and isomorphic encoded to contentRange.\n    contentRange += isomorphicEncode(`${fullLength}`);\n    // 7. Return contentRange.\n    return contentRange;\n}\n// A Stream, which pipes the response to zlib.createInflate() or\n// zlib.createInflateRaw() depending on the first byte of the Buffer.\n// If the lower byte of the first byte is 0x08, then the stream is\n// interpreted as a zlib stream, otherwise it's interpreted as a\n// raw deflate stream.\nclass InflateStream extends Transform {\n    _transform(chunk, encoding, callback) {\n        if (!this._inflateStream) {\n            if (chunk.length === 0) {\n                callback();\n                return;\n            }\n            this._inflateStream = (chunk[0] & 0x0F) === 0x08 ? zlib.createInflate() : zlib.createInflateRaw();\n            this._inflateStream.on(\"data\", this.push.bind(this));\n            this._inflateStream.on(\"end\", ()=>this.push(null));\n            this._inflateStream.on(\"error\", (err)=>this.destroy(err));\n        }\n        this._inflateStream.write(chunk, encoding, callback);\n    }\n    _final(callback) {\n        if (this._inflateStream) {\n            this._inflateStream.end();\n            this._inflateStream = null;\n        }\n        callback();\n    }\n}\nfunction createInflate() {\n    return new InflateStream();\n}\n/**\n * @see https://fetch.spec.whatwg.org/#concept-header-extract-mime-type\n * @param {import('./headers').HeadersList} headers\n */ function extractMimeType(headers) {\n    // 1. Let charset be null.\n    let charset = null;\n    // 2. Let essence be null.\n    let essence = null;\n    // 3. Let mimeType be null.\n    let mimeType = null;\n    // 4. Let values be the result of getting, decoding, and splitting `Content-Type` from headers.\n    const values = getDecodeSplit(\"content-type\", headers);\n    // 5. If values is null, then return failure.\n    if (values === null) {\n        return \"failure\";\n    }\n    // 6. For each value of values:\n    for (const value of values){\n        // 6.1. Let temporaryMimeType be the result of parsing value.\n        const temporaryMimeType = parseMIMEType(value);\n        // 6.2. If temporaryMimeType is failure or its essence is \"*/*\", then continue.\n        if (temporaryMimeType === \"failure\" || temporaryMimeType.essence === \"*/*\") {\n            continue;\n        }\n        // 6.3. Set mimeType to temporaryMimeType.\n        mimeType = temporaryMimeType;\n        // 6.4. If mimeTypes essence is not essence, then:\n        if (mimeType.essence !== essence) {\n            // 6.4.1. Set charset to null.\n            charset = null;\n            // 6.4.2. If mimeTypes parameters[\"charset\"] exists, then set charset to\n            //        mimeTypes parameters[\"charset\"].\n            if (mimeType.parameters.has(\"charset\")) {\n                charset = mimeType.parameters.get(\"charset\");\n            }\n            // 6.4.3. Set essence to mimeTypes essence.\n            essence = mimeType.essence;\n        } else if (!mimeType.parameters.has(\"charset\") && charset !== null) {\n            // 6.5. Otherwise, if mimeTypes parameters[\"charset\"] does not exist, and\n            //      charset is non-null, set mimeTypes parameters[\"charset\"] to charset.\n            mimeType.parameters.set(\"charset\", charset);\n        }\n    }\n    // 7. If mimeType is null, then return failure.\n    if (mimeType == null) {\n        return \"failure\";\n    }\n    // 8. Return mimeType.\n    return mimeType;\n}\n/**\n * @see https://fetch.spec.whatwg.org/#header-value-get-decode-and-split\n * @param {string|null} value\n */ function gettingDecodingSplitting(value) {\n    // 1. Let input be the result of isomorphic decoding value.\n    const input = value;\n    // 2. Let position be a position variable for input, initially pointing at the start of input.\n    const position = {\n        position: 0\n    };\n    // 3. Let values be a list of strings, initially empty.\n    const values = [];\n    // 4. Let temporaryValue be the empty string.\n    let temporaryValue = \"\";\n    // 5. While position is not past the end of input:\n    while(position.position < input.length){\n        // 5.1. Append the result of collecting a sequence of code points that are not U+0022 (\")\n        //      or U+002C (,) from input, given position, to temporaryValue.\n        temporaryValue += collectASequenceOfCodePoints((char)=>char !== '\"' && char !== \",\", input, position);\n        // 5.2. If position is not past the end of input, then:\n        if (position.position < input.length) {\n            // 5.2.1. If the code point at position within input is U+0022 (\"), then:\n            if (input.charCodeAt(position.position) === 0x22) {\n                // 5.2.1.1. Append the result of collecting an HTTP quoted string from input, given position, to temporaryValue.\n                temporaryValue += collectAnHTTPQuotedString(input, position);\n                // 5.2.1.2. If position is not past the end of input, then continue.\n                if (position.position < input.length) {\n                    continue;\n                }\n            } else {\n                // 5.2.2. Otherwise:\n                // 5.2.2.1. Assert: the code point at position within input is U+002C (,).\n                assert(input.charCodeAt(position.position) === 0x2C);\n                // 5.2.2.2. Advance position by 1.\n                position.position++;\n            }\n        }\n        // 5.3. Remove all HTTP tab or space from the start and end of temporaryValue.\n        temporaryValue = removeChars(temporaryValue, true, true, (char)=>char === 0x9 || char === 0x20);\n        // 5.4. Append temporaryValue to values.\n        values.push(temporaryValue);\n        // 5.6. Set temporaryValue to the empty string.\n        temporaryValue = \"\";\n    }\n    // 6. Return values.\n    return values;\n}\n/**\n * @see https://fetch.spec.whatwg.org/#concept-header-list-get-decode-split\n * @param {string} name lowercase header name\n * @param {import('./headers').HeadersList} list\n */ function getDecodeSplit(name, list) {\n    // 1. Let value be the result of getting name from list.\n    const value = list.get(name, true);\n    // 2. If value is null, then return null.\n    if (value === null) {\n        return null;\n    }\n    // 3. Return the result of getting, decoding, and splitting value.\n    return gettingDecodingSplitting(value);\n}\nconst textDecoder = new TextDecoder();\n/**\n * @see https://encoding.spec.whatwg.org/#utf-8-decode\n * @param {Buffer} buffer\n */ function utf8DecodeBytes(buffer) {\n    if (buffer.length === 0) {\n        return \"\";\n    }\n    // 1. Let buffer be the result of peeking three bytes from\n    //    ioQueue, converted to a byte sequence.\n    // 2. If buffer is 0xEF 0xBB 0xBF, then read three\n    //    bytes from ioQueue. (Do nothing with those bytes.)\n    if (buffer[0] === 0xEF && buffer[1] === 0xBB && buffer[2] === 0xBF) {\n        buffer = buffer.subarray(3);\n    }\n    // 3. Process a queue with an instance of UTF-8s\n    //    decoder, ioQueue, output, and \"replacement\".\n    const output = textDecoder.decode(buffer);\n    // 4. Return output.\n    return output;\n}\nclass EnvironmentSettingsObjectBase {\n    get baseUrl() {\n        return getGlobalOrigin();\n    }\n    get origin() {\n        return this.baseUrl?.origin;\n    }\n    constructor(){\n        this.policyContainer = makePolicyContainer();\n    }\n}\nclass EnvironmentSettingsObject {\n    constructor(){\n        this.settingsObject = new EnvironmentSettingsObjectBase();\n    }\n}\nconst environmentSettingsObject = new EnvironmentSettingsObject();\nmodule.exports = {\n    isAborted,\n    isCancelled,\n    isValidEncodedURL,\n    createDeferredPromise,\n    ReadableStreamFrom,\n    tryUpgradeRequestToAPotentiallyTrustworthyURL,\n    clampAndCoarsenConnectionTimingInfo,\n    coarsenedSharedCurrentTime,\n    determineRequestsReferrer,\n    makePolicyContainer,\n    clonePolicyContainer,\n    appendFetchMetadata,\n    appendRequestOriginHeader,\n    TAOCheck,\n    corsCheck,\n    crossOriginResourcePolicyCheck,\n    createOpaqueTimingInfo,\n    setRequestReferrerPolicyOnRedirect,\n    isValidHTTPToken,\n    requestBadPort,\n    requestCurrentURL,\n    responseURL,\n    responseLocationURL,\n    isBlobLike,\n    isURLPotentiallyTrustworthy,\n    isValidReasonPhrase,\n    sameOrigin,\n    normalizeMethod,\n    serializeJavascriptValueToJSONString,\n    iteratorMixin,\n    createIterator,\n    isValidHeaderName,\n    isValidHeaderValue,\n    isErrorLike,\n    fullyReadBody,\n    bytesMatch,\n    isReadableStreamLike,\n    readableStreamClose,\n    isomorphicEncode,\n    urlIsLocal,\n    urlHasHttpsScheme,\n    urlIsHttpHttpsScheme,\n    readAllBytes,\n    simpleRangeHeaderValue,\n    buildContentRange,\n    parseMetadata,\n    createInflate,\n    extractMimeType,\n    getDecodeSplit,\n    utf8DecodeBytes,\n    environmentSettingsObject\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZmV0Y2gvdXRpbC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUFZLFNBQUFBLFlBQUFDLENBQUE7SUFBQSxJQUFBQyxPQUFBRCxPQUFBQSxHQUFBLE1BQUFFLFVBQUEsZ0VBQUFGLElBQUEsT0FBQUEsSUFBQTtJQUFBLE9BQUFBO0FBQUE7QUFFWixNQUFNLEVBQUVHLFNBQUFBLEVBQVcsR0FBR0MsbUJBQU9BLENBQUM7QUFDOUIsTUFBTUMsT0FBT0QsbUJBQU9BLENBQUM7QUFDckIsTUFBTSxFQUFFRSxpQkFBaUIsRUFBRUMsbUJBQW1CQyxvQkFBb0IsRUFBRUMsV0FBQUEsRUFBYSxHQUFHTCxtQkFBT0EsQ0FBQztBQUM1RixNQUFNLEVBQUVNLGVBQUFBLEVBQWlCLEdBQUdOLG1CQUFPQSxDQUFDO0FBQ3BDLE1BQU0sRUFBRU8sNEJBQTRCLEVBQUVDLHlCQUF5QixFQUFFQyxXQUFXLEVBQUVDLGFBQUFBLEVBQWUsR0FBR1YsbUJBQU9BLENBQUM7QUFDeEcsTUFBTSxFQUFFVyxXQUFBQSxFQUFhLEdBQUdYLG1CQUFPQSxDQUFDO0FBQ2hDLE1BQU0sRUFBRVksVUFBVSxFQUFFQyxrQkFBa0IsRUFBRUMsZ0JBQWdCLEVBQUVDLDJCQUFBQSxFQUE2QixHQUFHZixtQkFBT0EsQ0FBQztBQUNsRyxNQUFNZ0IsU0FBU2hCLG1CQUFPQSxDQUFDO0FBQ3ZCLE1BQU0sRUFBRWlCLFlBQUFBLEVBQWMsR0FBR2pCLG1CQUFPQSxDQUFDO0FBQ2pDLE1BQU0sRUFBRWtCLE1BQUFBLEVBQVEsR0FBR2xCLG1CQUFPQSxDQUFDO0FBRTNCLElBQUltQixrQkFBa0IsRUFBRTtBQUV4QjtBQUNBLGdDQUNBLElBQUlDO0FBQ0osSUFBSTtJQUNGQSxTQUFTcEIsbUJBQU9BLENBQUM7SUFDakIsTUFBTXFCLHlCQUF5QjtRQUFDO1FBQVU7UUFBVTtLQUFTO0lBQzdERixrQkFBa0JDLE9BQU9FLFNBQVMsR0FBR0MsTUFBTSxDQUFFQyxD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TSxDQUFDLEVBQUUsS0FBSyxRQUFRQSxNQUFNLENBQUMsRUFBRSxLQUFLLFFBQVFBLE1BQU0sQ0FBQyxFQUFFLEtBQUssTUFBTTtRQUNsRUEsU0FBU0EsT0FBT0MsUUFBUSxDQUFDO0lBQzNCO0lBRUE7SUFDQTtJQUNBLE1BQU1DLFNBQVNMLFlBQVlNLE1BQU0sQ0FBQ0g7SUFFbEM7SUFDQSxPQUFPRTtBQUNUO0FBRUEsTUFBTUU7SUFDSixJQUFJQyxVQUFXO1FBQ2IsT0FBT3hTO0lBQ1Q7SUFFQSxJQUFJNEUsU0FBVTtRQUNaLE9BQU8sSUFBSSxDQUFDNE4sT0FBTyxFQUFFNU47SUFDdkI7O2FBRUFvQyxrQkFBa0JGOztBQUNwQjtBQUVBLE1BQU0yTDs7YUFDSkMsaUJBQWlCLElBQUlIOztBQUN2QjtBQUVBLE1BQU1JLDRCQUE0QixJQUFJRjtBQUV0Q0csT0FBT0MsT0FBTyxHQUFHO0lBQ2YvSDtJQUNBSTtJQUNBako7SUFDQXNJO0lBQ0FoSztJQUNBNko7SUFDQTlFO0lBQ0FVO0lBQ0FpQjtJQUNBSDtJQUNBQztJQUNBMUM7SUFDQUs7SUFDQU47SUFDQUQ7SUFDQUQ7SUFDQWdDO0lBQ0F4QztJQUNBbEQ7SUFDQXFDO0lBQ0FGO0lBQ0F2QjtJQUNBSztJQUNBbkI7SUFDQW9IO0lBQ0FyRTtJQUNBNkI7SUFDQWlHO0lBQ0FDO0lBQ0E4QjtJQUNBdkI7SUFDQW5JO0lBQ0F4QjtJQUNBZ0I7SUFDQStLO0lBQ0F2RjtJQUNBaUc7SUFDQUc7SUFDQU87SUFDQU07SUFDQXhLO0lBQ0FuQztJQUNBMEw7SUFDQWtCO0lBQ0FXO0lBQ0F6SDtJQUNBaUk7SUFDQVE7SUFDQUs7SUFDQVE7SUFDQVM7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL21vY2t1cGZsb3cvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZmV0Y2gvdXRpbC5qcz9lOGJmIiwid2VicGFjazovL21vY2t1cGZsb3cvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZmV0Y2gvdXRpbC5qcz9lOGJmKiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyBUcmFuc2Zvcm0gfSA9IHJlcXVpcmUoJ25vZGU6c3RyZWFtJylcbmNvbnN0IHpsaWIgPSByZXF1aXJlKCdub2RlOnpsaWInKVxuY29uc3QgeyByZWRpcmVjdFN0YXR1c1NldCwgcmVmZXJyZXJQb2xpY3lTZXQ6IHJlZmVycmVyUG9saWN5VG9rZW5zLCBiYWRQb3J0c1NldCB9ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKVxuY29uc3QgeyBnZXRHbG9iYWxPcmlnaW4gfSA9IHJlcXVpcmUoJy4vZ2xvYmFsJylcbmNvbnN0IHsgY29sbGVjdEFTZXF1ZW5jZU9mQ29kZVBvaW50cywgY29sbGVjdEFuSFRUUFF1b3RlZFN0cmluZywgcmVtb3ZlQ2hhcnMsIHBhcnNlTUlNRVR5cGUgfSA9IHJlcXVpcmUoJy4vZGF0YS11cmwnKVxuY29uc3QgeyBwZXJmb3JtYW5jZSB9ID0gcmVxdWlyZSgnbm9kZTpwZXJmX2hvb2tzJylcbmNvbnN0IHsgaXNCbG9iTGlrZSwgUmVhZGFibGVTdHJlYW1Gcm9tLCBpc1ZhbGlkSFRUUFRva2VuLCBub3JtYWxpemVkTWV0aG9kUmVjb3Jkc0Jhc2UgfSA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvdXRpbCcpXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdub2RlOmFzc2VydCcpXG5jb25zdCB7IGlzVWludDhBcnJheSB9ID0gcmVxdWlyZSgnbm9kZTp1dGlsL3R5cGVzJylcbmNvbnN0IHsgd2ViaWRsIH0gPSByZXF1aXJlKCcuL3dlYmlkbCcpXG5cbmxldCBzdXBwb3J0ZWRIYXNoZXMgPSBbXVxuXG4vLyBodHRwczovL25vZGVqcy5vcmcvYXBpL2NyeXB0by5odG1sI2RldGVybWluaW5nLWlmLWNyeXB0by1zdXBwb3J0LWlzLXVuYXZhaWxhYmxlXG4vKiogQHR5cGUge2ltcG9ydCgnY3J5cHRvJyl9ICovXG5sZXQgY3J5cHRvXG50cnkge1xuICBjcnlwdG8gPSByZXF1aXJlKCdub2RlOmNyeXB0bycpXG4gIGNvbnN0IHBvc3NpYmxlUmVsZXZhbnRIYXNoZXMgPSBbJ3NoYTI1NicsICdzaGEzODQnLCAnc2hhNTEyJ11cbiAgc3VwcG9ydGVkSGFzaGVzID0gY3J5cHRvLmdldEhhc2hlcygpLmZpbHRlcigoaGFzaCkgPT4gcG9zc2libGVSZWxldmFudEhhc2hlcy5pbmNsdWRlcyhoYXNoKSlcbi8qIGM4IGlnbm9yZSBuZXh0IDMgKi9cbn0gY2F0Y2gge1xuXG59XG5cbmZ1bmN0aW9uIHJlc3BvbnNlVVJMIChyZXNwb25zZSkge1xuICAvLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jcmVzcG9uc2VzXG4gIC8vIEEgcmVzcG9uc2UgaGFzIGFuIGFzc29jaWF0ZWQgVVJMLiBJdCBpcyBhIHBvaW50ZXIgdG8gdGhlIGxhc3QgVVJMXG4gIC8vIGluIHJlc3BvbnNl4oCZcyBVUkwgbGlzdCBhbmQgbnVsbCBpZiByZXNwb25zZeKAmXMgVVJMIGxpc3QgaXMgZW1wdHkuXG4gIGNvbnN0IHVybExpc3QgPSByZXNwb25zZS51cmxMaXN0XG4gIGNvbnN0IGxlbmd0aCA9IHVybExpc3QubGVuZ3RoXG4gIHJldHVybiBsZW5ndGggPT09IDAgPyBudWxsIDogdXJsTGlzdFtsZW5ndGggLSAxXS50b1N0cmluZygpXG59XG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LXJlc3BvbnNlLWxvY2F0aW9uLXVybFxuZnVuY3Rpb24gcmVzcG9uc2VMb2NhdGlvblVSTCAocmVzcG9uc2UsIHJlcXVlc3RGcmFnbWVudCkge1xuICAvLyAxLiBJZiByZXNwb25zZeKAmXMgc3RhdHVzIGlzIG5vdCBhIHJlZGlyZWN0IHN0YXR1cywgdGhlbiByZXR1cm4gbnVsbC5cbiAgaWYgKCFyZWRpcmVjdFN0YXR1c1NldC5oYXMocmVzcG9uc2Uuc3RhdHVzKSkge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICAvLyAyLiBMZXQgbG9jYXRpb24gYmUgdGhlIHJlc3VsdCBvZiBleHRyYWN0aW5nIGhlYWRlciBsaXN0IHZhbHVlcyBnaXZlblxuICAvLyBgTG9jYXRpb25gIGFuZCByZXNwb25zZeKAmXMgaGVhZGVyIGxpc3QuXG4gIGxldCBsb2NhdGlvbiA9IHJlc3BvbnNlLmhlYWRlcnNMaXN0LmdldCgnbG9jYXRpb24nLCB0cnVlKVxuXG4gIC8vIDMuIElmIGxvY2F0aW9uIGlzIGEgaGVhZGVyIHZhbHVlLCB0aGVuIHNldCBsb2NhdGlvbiB0byB0aGUgcmVzdWx0IG9mXG4gIC8vICAgIHBhcnNpbmcgbG9jYXRpb24gd2l0aCByZXNwb25zZeKAmXMgVVJMLlxuICBpZiAobG9jYXRpb24gIT09IG51bGwgJiYgaXNWYWxpZEhlYWRlclZhbHVlKGxvY2F0aW9uKSkge1xuICAgIGlmICghaXNWYWxpZEVuY29kZWRVUkwobG9jYXRpb24pKSB7XG4gICAgICAvLyBTb21lIHdlYnNpdGVzIHJlc3BvbmQgbG9jYXRpb24gaGVhZGVyIGluIFVURi04IGZvcm0gd2l0aG91dCBlbmNvZGluZyB0aGVtIGFzIEFTQ0lJXG4gICAgICAvLyBhbmQgbWFqb3IgYnJvd3NlcnMgcmVkaXJlY3QgdGhlbSB0byBjb3JyZWN0bHkgVVRGLTggZW5jb2RlZCBhZGRyZXNzZXMuXG4gICAgICAvLyBIZXJlLCB3ZSBoYW5kbGUgdGhhdCBiZWhhdmlvciBpbiB0aGUgc2FtZSB3YXkuXG4gICAgICBsb2NhdGlvbiA9IG5vcm1hbGl6ZUJpbmFyeVN0cmluZ1RvVXRmOChsb2NhdGlvbilcbiAgICB9XG4gICAgbG9jYXRpb24gPSBuZXcgVVJMKGxvY2F0aW9uLCByZXNwb25zZVVSTChyZXNwb25zZSkpXG4gIH1cblxuICAvLyA0LiBJZiBsb2NhdGlvbiBpcyBhIFVSTCB3aG9zZSBmcmFnbWVudCBpcyBudWxsLCB0aGVuIHNldCBsb2NhdGlvbuKAmXNcbiAgLy8gZnJhZ21lbnQgdG8gcmVxdWVzdEZyYWdtZW50LlxuICBpZiAobG9jYXRpb24gJiYgIWxvY2F0aW9uLmhhc2gpIHtcbiAgICBsb2NhdGlvbi5oYXNoID0gcmVxdWVzdEZyYWdtZW50XG4gIH1cblxuICAvLyA1LiBSZXR1cm4gbG9jYXRpb24uXG4gIHJldHVybiBsb2NhdGlvblxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzE3Mzgjc2VjdGlvbi0yLjJcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc1ZhbGlkRW5jb2RlZFVSTCAodXJsKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdXJsLmxlbmd0aDsgKytpKSB7XG4gICAgY29uc3QgY29kZSA9IHVybC5jaGFyQ29kZUF0KGkpXG5cbiAgICBpZiAoXG4gICAgICBjb2RlID4gMHg3RSB8fCAvLyBOb24tVVMtQVNDSUkgKyBERUxcbiAgICAgIGNvZGUgPCAweDIwIC8vIENvbnRyb2wgY2hhcmFjdGVycyBOVUwgLSBVU1xuICAgICkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlXG59XG5cbi8qKlxuICogSWYgc3RyaW5nIGNvbnRhaW5zIG5vbi1BU0NJSSBjaGFyYWN0ZXJzLCBhc3N1bWVzIGl0J3MgVVRGLTggZW5jb2RlZCBhbmQgZGVjb2RlcyBpdC5cbiAqIFNpbmNlIFVURi04IGlzIGEgc3VwZXJzZXQgb2YgQVNDSUksIHRoaXMgd2lsbCB3b3JrIGZvciBBU0NJSSBzdHJpbmdzIGFzIHdlbGwuXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZUJpbmFyeVN0cmluZ1RvVXRmOCAodmFsdWUpIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKHZhbHVlLCAnYmluYXJ5JykudG9TdHJpbmcoJ3V0ZjgnKVxufVxuXG4vKiogQHJldHVybnMge1VSTH0gKi9cbmZ1bmN0aW9uIHJlcXVlc3RDdXJyZW50VVJMIChyZXF1ZXN0KSB7XG4gIHJldHVybiByZXF1ZXN0LnVybExpc3RbcmVxdWVzdC51cmxMaXN0Lmxlbmd0aCAtIDFdXG59XG5cbmZ1bmN0aW9uIHJlcXVlc3RCYWRQb3J0IChyZXF1ZXN0KSB7XG4gIC8vIDEuIExldCB1cmwgYmUgcmVxdWVzdOKAmXMgY3VycmVudCBVUkwuXG4gIGNvbnN0IHVybCA9IHJlcXVlc3RDdXJyZW50VVJMKHJlcXVlc3QpXG5cbiAgLy8gMi4gSWYgdXJs4oCZcyBzY2hlbWUgaXMgYW4gSFRUUChTKSBzY2hlbWUgYW5kIHVybOKAmXMgcG9ydCBpcyBhIGJhZCBwb3J0LFxuICAvLyB0aGVuIHJldHVybiBibG9ja2VkLlxuICBpZiAodXJsSXNIdHRwSHR0cHNTY2hlbWUodXJsKSAmJiBiYWRQb3J0c1NldC5oYXModXJsLnBvcnQpKSB7XG4gICAgcmV0dXJuICdibG9ja2VkJ1xuICB9XG5cbiAgLy8gMy4gUmV0dXJuIGFsbG93ZWQuXG4gIHJldHVybiAnYWxsb3dlZCdcbn1cblxuZnVuY3Rpb24gaXNFcnJvckxpa2UgKG9iamVjdCkge1xuICByZXR1cm4gb2JqZWN0IGluc3RhbmNlb2YgRXJyb3IgfHwgKFxuICAgIG9iamVjdD8uY29uc3RydWN0b3I/Lm5hbWUgPT09ICdFcnJvcicgfHxcbiAgICBvYmplY3Q/LmNvbnN0cnVjdG9yPy5uYW1lID09PSAnRE9NRXhjZXB0aW9uJ1xuICApXG59XG5cbi8vIENoZWNrIHdoZXRoZXIgfHN0YXR1c1RleHR8IGlzIGEgQnl0ZVN0cmluZyBhbmRcbi8vIG1hdGNoZXMgdGhlIFJlYXNvbi1QaHJhc2UgdG9rZW4gcHJvZHVjdGlvbi5cbi8vIFJGQyAyNjE2OiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMjYxNlxuLy8gUkZDIDcyMzA6IGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3MjMwXG4vLyBcInJlYXNvbi1waHJhc2UgPSAqKCBIVEFCIC8gU1AgLyBWQ0hBUiAvIG9icy10ZXh0IClcIlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Nocm9taXVtL2Nocm9taXVtL2Jsb2IvOTQuMC40NjA0LjEvdGhpcmRfcGFydHkvYmxpbmsvcmVuZGVyZXIvY29yZS9mZXRjaC9yZXNwb25zZS5jYyNMMTE2XG5mdW5jdGlvbiBpc1ZhbGlkUmVhc29uUGhyYXNlIChzdGF0dXNUZXh0KSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhdHVzVGV4dC5sZW5ndGg7ICsraSkge1xuICAgIGNvbnN0IGMgPSBzdGF0dXNUZXh0LmNoYXJDb2RlQXQoaSlcbiAgICBpZiAoXG4gICAgICAhKFxuICAgICAgICAoXG4gICAgICAgICAgYyA9PT0gMHgwOSB8fCAvLyBIVEFCXG4gICAgICAgICAgKGMgPj0gMHgyMCAmJiBjIDw9IDB4N2UpIHx8IC8vIFNQIC8gVkNIQVJcbiAgICAgICAgICAoYyA+PSAweDgwICYmIGMgPD0gMHhmZilcbiAgICAgICAgKSAvLyBvYnMtdGV4dFxuICAgICAgKVxuICAgICkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlXG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jaGVhZGVyLW5hbWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBwb3RlbnRpYWxWYWx1ZVxuICovXG5jb25zdCBpc1ZhbGlkSGVhZGVyTmFtZSA9IGlzVmFsaWRIVFRQVG9rZW5cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNoZWFkZXItdmFsdWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBwb3RlbnRpYWxWYWx1ZVxuICovXG5mdW5jdGlvbiBpc1ZhbGlkSGVhZGVyVmFsdWUgKHBvdGVudGlhbFZhbHVlKSB7XG4gIC8vIC0gSGFzIG5vIGxlYWRpbmcgb3IgdHJhaWxpbmcgSFRUUCB0YWIgb3Igc3BhY2UgYnl0ZXMuXG4gIC8vIC0gQ29udGFpbnMgbm8gMHgwMCAoTlVMKSBvciBIVFRQIG5ld2xpbmUgYnl0ZXMuXG4gIHJldHVybiAoXG4gICAgcG90ZW50aWFsVmFsdWVbMF0gPT09ICdcXHQnIHx8XG4gICAgcG90ZW50aWFsVmFsdWVbMF0gPT09ICcgJyB8fFxuICAgIHBvdGVudGlhbFZhbHVlW3BvdGVudGlhbFZhbHVlLmxlbmd0aCAtIDFdID09PSAnXFx0JyB8fFxuICAgIHBvdGVudGlhbFZhbHVlW3BvdGVudGlhbFZhbHVlLmxlbmd0aCAtIDFdID09PSAnICcgfHxcbiAgICBwb3RlbnRpYWxWYWx1ZS5pbmNsdWRlcygnXFxuJykgfHxcbiAgICBwb3RlbnRpYWxWYWx1ZS5pbmNsdWRlcygnXFxyJykgfHxcbiAgICBwb3RlbnRpYWxWYWx1ZS5pbmNsdWRlcygnXFwwJylcbiAgKSA9PT0gZmFsc2Vcbn1cblxuLy8gaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmFwcHNlYy1yZWZlcnJlci1wb2xpY3kvI3NldC1yZXF1ZXN0cy1yZWZlcnJlci1wb2xpY3ktb24tcmVkaXJlY3RcbmZ1bmN0aW9uIHNldFJlcXVlc3RSZWZlcnJlclBvbGljeU9uUmVkaXJlY3QgKHJlcXVlc3QsIGFjdHVhbFJlc3BvbnNlKSB7XG4gIC8vICBHaXZlbiBhIHJlcXVlc3QgcmVxdWVzdCBhbmQgYSByZXNwb25zZSBhY3R1YWxSZXNwb25zZSwgdGhpcyBhbGdvcml0aG1cbiAgLy8gIHVwZGF0ZXMgcmVxdWVzdOKAmXMgcmVmZXJyZXIgcG9saWN5IGFjY29yZGluZyB0byB0aGUgUmVmZXJyZXItUG9saWN5XG4gIC8vICBoZWFkZXIgKGlmIGFueSkgaW4gYWN0dWFsUmVzcG9uc2UuXG5cbiAgLy8gMS4gTGV0IHBvbGljeSBiZSB0aGUgcmVzdWx0IG9mIGV4ZWN1dGluZyDCpyA4LjEgUGFyc2UgYSByZWZlcnJlciBwb2xpY3lcbiAgLy8gZnJvbSBhIFJlZmVycmVyLVBvbGljeSBoZWFkZXIgb24gYWN0dWFsUmVzcG9uc2UuXG5cbiAgLy8gOC4xIFBhcnNlIGEgcmVmZXJyZXIgcG9saWN5IGZyb20gYSBSZWZlcnJlci1Qb2xpY3kgaGVhZGVyXG4gIC8vIDEuIExldCBwb2xpY3ktdG9rZW5zIGJlIHRoZSByZXN1bHQgb2YgZXh0cmFjdGluZyBoZWFkZXIgbGlzdCB2YWx1ZXMgZ2l2ZW4gYFJlZmVycmVyLVBvbGljeWAgYW5kIHJlc3BvbnNl4oCZcyBoZWFkZXIgbGlzdC5cbiAgY29uc3QgeyBoZWFkZXJzTGlzdCB9ID0gYWN0dWFsUmVzcG9uc2VcbiAgLy8gMi4gTGV0IHBvbGljeSBiZSB0aGUgZW1wdHkgc3RyaW5nLlxuICAvLyAzLiBGb3IgZWFjaCB0b2tlbiBpbiBwb2xpY3ktdG9rZW5zLCBpZiB0b2tlbiBpcyBhIHJlZmVycmVyIHBvbGljeSBhbmQgdG9rZW4gaXMgbm90IHRoZSBlbXB0eSBzdHJpbmcsIHRoZW4gc2V0IHBvbGljeSB0byB0b2tlbi5cbiAgLy8gNC4gUmV0dXJuIHBvbGljeS5cbiAgY29uc3QgcG9saWN5SGVhZGVyID0gKGhlYWRlcnNMaXN0LmdldCgncmVmZXJyZXItcG9saWN5JywgdHJ1ZSkgPz8gJycpLnNwbGl0KCcsJylcblxuICAvLyBOb3RlOiBBcyB0aGUgcmVmZXJyZXItcG9saWN5IGNhbiBjb250YWluIG11bHRpcGxlIHBvbGljaWVzXG4gIC8vIHNlcGFyYXRlZCBieSBjb21tYSwgd2UgbmVlZCB0byBsb29wIHRocm91Z2ggYWxsIG9mIHRoZW1cbiAgLy8gYW5kIHBpY2sgdGhlIGZpcnN0IHZhbGlkIG9uZS5cbiAgLy8gUmVmOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVFRQL0hlYWRlcnMvUmVmZXJyZXItUG9saWN5I3NwZWNpZnlfYV9mYWxsYmFja19wb2xpY3lcbiAgbGV0IHBvbGljeSA9ICcnXG4gIGlmIChwb2xpY3lIZWFkZXIubGVuZ3RoID4gMCkge1xuICAgIC8vIFRoZSByaWdodC1tb3N0IHBvbGljeSB0YWtlcyBwcmVjZWRlbmNlLlxuICAgIC8vIFRoZSBsZWZ0LW1vc3QgcG9saWN5IGlzIHRoZSBmYWxsYmFjay5cbiAgICBmb3IgKGxldCBpID0gcG9saWN5SGVhZGVyLmxlbmd0aDsgaSAhPT0gMDsgaS0tKSB7XG4gICAgICBjb25zdCB0b2tlbiA9IHBvbGljeUhlYWRlcltpIC0gMV0udHJpbSgpXG4gICAgICBpZiAocmVmZXJyZXJQb2xpY3lUb2tlbnMuaGFzKHRva2VuKSkge1xuICAgICAgICBwb2xpY3kgPSB0b2tlblxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIDIuIElmIHBvbGljeSBpcyBub3QgdGhlIGVtcHR5IHN0cmluZywgdGhlbiBzZXQgcmVxdWVzdOKAmXMgcmVmZXJyZXIgcG9saWN5IHRvIHBvbGljeS5cbiAgaWYgKHBvbGljeSAhPT0gJycpIHtcbiAgICByZXF1ZXN0LnJlZmVycmVyUG9saWN5ID0gcG9saWN5XG4gIH1cbn1cblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2Nyb3NzLW9yaWdpbi1yZXNvdXJjZS1wb2xpY3ktY2hlY2tcbmZ1bmN0aW9uIGNyb3NzT3JpZ2luUmVzb3VyY2VQb2xpY3lDaGVjayAoKSB7XG4gIC8vIFRPRE9cbiAgcmV0dXJuICdhbGxvd2VkJ1xufVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1jb3JzLWNoZWNrXG5mdW5jdGlvbiBjb3JzQ2hlY2sgKCkge1xuICAvLyBUT0RPXG4gIHJldHVybiAnc3VjY2Vzcydcbn1cblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtdGFvLWNoZWNrXG5mdW5jdGlvbiBUQU9DaGVjayAoKSB7XG4gIC8vIFRPRE9cbiAgcmV0dXJuICdzdWNjZXNzJ1xufVxuXG5mdW5jdGlvbiBhcHBlbmRGZXRjaE1ldGFkYXRhIChodHRwUmVxdWVzdCkge1xuICAvLyAgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmFwcHNlYy1mZXRjaC1tZXRhZGF0YS8jc2VjLWZldGNoLWRlc3QtaGVhZGVyXG4gIC8vICBUT0RPXG5cbiAgLy8gIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJhcHBzZWMtZmV0Y2gtbWV0YWRhdGEvI3NlYy1mZXRjaC1tb2RlLWhlYWRlclxuXG4gIC8vICAxLiBBc3NlcnQ6IHLigJlzIHVybCBpcyBhIHBvdGVudGlhbGx5IHRydXN0d29ydGh5IFVSTC5cbiAgLy8gIFRPRE9cblxuICAvLyAgMi4gTGV0IGhlYWRlciBiZSBhIFN0cnVjdHVyZWQgSGVhZGVyIHdob3NlIHZhbHVlIGlzIGEgdG9rZW4uXG4gIGxldCBoZWFkZXIgPSBudWxsXG5cbiAgLy8gIDMuIFNldCBoZWFkZXLigJlzIHZhbHVlIHRvIHLigJlzIG1vZGUuXG4gIGhlYWRlciA9IGh0dHBSZXF1ZXN0Lm1vZGVcblxuICAvLyAgNC4gU2V0IGEgc3RydWN0dXJlZCBmaWVsZCB2YWx1ZSBgU2VjLUZldGNoLU1vZGVgL2hlYWRlciBpbiBy4oCZcyBoZWFkZXIgbGlzdC5cbiAgaHR0cFJlcXVlc3QuaGVhZGVyc0xpc3Quc2V0KCdzZWMtZmV0Y2gtbW9kZScsIGhlYWRlciwgdHJ1ZSlcblxuICAvLyAgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmFwcHNlYy1mZXRjaC1tZXRhZGF0YS8jc2VjLWZldGNoLXNpdGUtaGVhZGVyXG4gIC8vICBUT0RPXG5cbiAgLy8gIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJhcHBzZWMtZmV0Y2gtbWV0YWRhdGEvI3NlYy1mZXRjaC11c2VyLWhlYWRlclxuICAvLyAgVE9ET1xufVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jYXBwZW5kLWEtcmVxdWVzdC1vcmlnaW4taGVhZGVyXG5mdW5jdGlvbiBhcHBlbmRSZXF1ZXN0T3JpZ2luSGVhZGVyIChyZXF1ZXN0KSB7XG4gIC8vIDEuIExldCBzZXJpYWxpemVkT3JpZ2luIGJlIHRoZSByZXN1bHQgb2YgYnl0ZS1zZXJpYWxpemluZyBhIHJlcXVlc3Qgb3JpZ2luXG4gIC8vICAgIHdpdGggcmVxdWVzdC5cbiAgLy8gVE9ETzogaW1wbGVtZW50IFwiYnl0ZS1zZXJpYWxpemluZyBhIHJlcXVlc3Qgb3JpZ2luXCJcbiAgbGV0IHNlcmlhbGl6ZWRPcmlnaW4gPSByZXF1ZXN0Lm9yaWdpblxuXG4gIC8vIC0gXCInY2xpZW50JyBpcyBjaGFuZ2VkIHRvIGFuIG9yaWdpbiBkdXJpbmcgZmV0Y2hpbmcuXCJcbiAgLy8gICBUaGlzIGRvZXNuJ3QgaGFwcGVuIGluIHVuZGljaSAoaW4gbW9zdCBjYXNlcykgYmVjYXVzZSB1bmRpY2ksIGJ5IGRlZmF1bHQsXG4gIC8vICAgaGFzIG5vIGNvbmNlcHQgb2Ygb3JpZ2luLlxuICAvLyAtIHJlcXVlc3Qub3JpZ2luIGNhbiBhbHNvIGJlIHNldCB0byByZXF1ZXN0LmNsaWVudC5vcmlnaW4gKGNsaWVudCBiZWluZ1xuICAvLyAgIGFuIGVudmlyb25tZW50IHNldHRpbmdzIG9iamVjdCksIHdoaWNoIGlzIHVuZGVmaW5lZCB3aXRob3V0IHVzaW5nXG4gIC8vICAgc2V0R2xvYmFsT3JpZ2luLlxuICBpZiAoc2VyaWFsaXplZE9yaWdpbiA9PT0gJ2NsaWVudCcgfHwgc2VyaWFsaXplZE9yaWdpbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvLyAyLiBJZiByZXF1ZXN04oCZcyByZXNwb25zZSB0YWludGluZyBpcyBcImNvcnNcIiBvciByZXF1ZXN04oCZcyBtb2RlIGlzIFwid2Vic29ja2V0XCIsXG4gIC8vICAgIHRoZW4gYXBwZW5kIChgT3JpZ2luYCwgc2VyaWFsaXplZE9yaWdpbikgdG8gcmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QuXG4gIC8vIDMuIE90aGVyd2lzZSwgaWYgcmVxdWVzdOKAmXMgbWV0aG9kIGlzIG5laXRoZXIgYEdFVGAgbm9yIGBIRUFEYCwgdGhlbjpcbiAgaWYgKHJlcXVlc3QucmVzcG9uc2VUYWludGluZyA9PT0gJ2NvcnMnIHx8IHJlcXVlc3QubW9kZSA9PT0gJ3dlYnNvY2tldCcpIHtcbiAgICByZXF1ZXN0LmhlYWRlcnNMaXN0LmFwcGVuZCgnb3JpZ2luJywgc2VyaWFsaXplZE9yaWdpbiwgdHJ1ZSlcbiAgfSBlbHNlIGlmIChyZXF1ZXN0Lm1ldGhvZCAhPT0gJ0dFVCcgJiYgcmVxdWVzdC5tZXRob2QgIT09ICdIRUFEJykge1xuICAgIC8vIDEuIFN3aXRjaCBvbiByZXF1ZXN04oCZcyByZWZlcnJlciBwb2xpY3k6XG4gICAgc3dpdGNoIChyZXF1ZXN0LnJlZmVycmVyUG9saWN5KSB7XG4gICAgICBjYXNlICduby1yZWZlcnJlcic6XG4gICAgICAgIC8vIFNldCBzZXJpYWxpemVkT3JpZ2luIHRvIGBudWxsYC5cbiAgICAgICAgc2VyaWFsaXplZE9yaWdpbiA9IG51bGxcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ25vLXJlZmVycmVyLXdoZW4tZG93bmdyYWRlJzpcbiAgICAgIGNhc2UgJ3N0cmljdC1vcmlnaW4nOlxuICAgICAgY2FzZSAnc3RyaWN0LW9yaWdpbi13aGVuLWNyb3NzLW9yaWdpbic6XG4gICAgICAgIC8vIElmIHJlcXVlc3TigJlzIG9yaWdpbiBpcyBhIHR1cGxlIG9yaWdpbiwgaXRzIHNjaGVtZSBpcyBcImh0dHBzXCIsIGFuZFxuICAgICAgICAvLyByZXF1ZXN04oCZcyBjdXJyZW50IFVSTOKAmXMgc2NoZW1lIGlzIG5vdCBcImh0dHBzXCIsIHRoZW4gc2V0XG4gICAgICAgIC8vIHNlcmlhbGl6ZWRPcmlnaW4gdG8gYG51bGxgLlxuICAgICAgICBpZiAocmVxdWVzdC5vcmlnaW4gJiYgdXJsSGFzSHR0cHNTY2hlbWUocmVxdWVzdC5vcmlnaW4pICYmICF1cmxIYXNIdHRwc1NjaGVtZShyZXF1ZXN0Q3VycmVudFVSTChyZXF1ZXN0KSkpIHtcbiAgICAgICAgICBzZXJpYWxpemVkT3JpZ2luID0gbnVsbFxuICAgICAgICB9XG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdzYW1lLW9yaWdpbic6XG4gICAgICAgIC8vIElmIHJlcXVlc3TigJlzIG9yaWdpbiBpcyBub3Qgc2FtZSBvcmlnaW4gd2l0aCByZXF1ZXN04oCZcyBjdXJyZW50IFVSTOKAmXNcbiAgICAgICAgLy8gb3JpZ2luLCB0aGVuIHNldCBzZXJpYWxpemVkT3JpZ2luIHRvIGBudWxsYC5cbiAgICAgICAgaWYgKCFzYW1lT3JpZ2luKHJlcXVlc3QsIHJlcXVlc3RDdXJyZW50VVJMKHJlcXVlc3QpKSkge1xuICAgICAgICAgIHNlcmlhbGl6ZWRPcmlnaW4gPSBudWxsXG4gICAgICAgIH1cbiAgICAgICAgYnJlYWtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIC8vIERvIG5vdGhpbmcuXG4gICAgfVxuXG4gICAgLy8gMi4gQXBwZW5kIChgT3JpZ2luYCwgc2VyaWFsaXplZE9yaWdpbikgdG8gcmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QuXG4gICAgcmVxdWVzdC5oZWFkZXJzTGlzdC5hcHBlbmQoJ29yaWdpbicsIHNlcmlhbGl6ZWRPcmlnaW4sIHRydWUpXG4gIH1cbn1cblxuLy8gaHR0cHM6Ly93M2MuZ2l0aHViLmlvL2hyLXRpbWUvI2Rmbi1jb2Fyc2VuLXRpbWVcbmZ1bmN0aW9uIGNvYXJzZW5UaW1lICh0aW1lc3RhbXAsIGNyb3NzT3JpZ2luSXNvbGF0ZWRDYXBhYmlsaXR5KSB7XG4gIC8vIFRPRE9cbiAgcmV0dXJuIHRpbWVzdGFtcFxufVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jY2xhbXAtYW5kLWNvYXJzZW4tY29ubmVjdGlvbi10aW1pbmctaW5mb1xuZnVuY3Rpb24gY2xhbXBBbmRDb2Fyc2VuQ29ubmVjdGlvblRpbWluZ0luZm8gKGNvbm5lY3Rpb25UaW1pbmdJbmZvLCBkZWZhdWx0U3RhcnRUaW1lLCBjcm9zc09yaWdpbklzb2xhdGVkQ2FwYWJpbGl0eSkge1xuICBpZiAoIWNvbm5lY3Rpb25UaW1pbmdJbmZvPy5zdGFydFRpbWUgfHwgY29ubmVjdGlvblRpbWluZ0luZm8uc3RhcnRUaW1lIDwgZGVmYXVsdFN0YXJ0VGltZSkge1xuICAgIHJldHVybiB7XG4gICAgICBkb21haW5Mb29rdXBTdGFydFRpbWU6IGRlZmF1bHRTdGFydFRpbWUsXG4gICAgICBkb21haW5Mb29rdXBFbmRUaW1lOiBkZWZhdWx0U3RhcnRUaW1lLFxuICAgICAgY29ubmVjdGlvblN0YXJ0VGltZTogZGVmYXVsdFN0YXJ0VGltZSxcbiAgICAgIGNvbm5lY3Rpb25FbmRUaW1lOiBkZWZhdWx0U3RhcnRUaW1lLFxuICAgICAgc2VjdXJlQ29ubmVjdGlvblN0YXJ0VGltZTogZGVmYXVsdFN0YXJ0VGltZSxcbiAgICAgIEFMUE5OZWdvdGlhdGVkUHJvdG9jb2w6IGNvbm5lY3Rpb25UaW1pbmdJbmZvPy5BTFBOTmVnb3RpYXRlZFByb3RvY29sXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBkb21haW5Mb29rdXBTdGFydFRpbWU6IGNvYXJzZW5UaW1lKGNvbm5lY3Rpb25UaW1pbmdJbmZvLmRvbWFpbkxvb2t1cFN0YXJ0VGltZSwgY3Jvc3NPcmlnaW5Jc29sYXRlZENhcGFiaWxpdHkpLFxuICAgIGRvbWFpbkxvb2t1cEVuZFRpbWU6IGNvYXJzZW5UaW1lKGNvbm5lY3Rpb25UaW1pbmdJbmZvLmRvbWFpbkxvb2t1cEVuZFRpbWUsIGNyb3NzT3JpZ2luSXNvbGF0ZWRDYXBhYmlsaXR5KSxcbiAgICBjb25uZWN0aW9uU3RhcnRUaW1lOiBjb2Fyc2VuVGltZShjb25uZWN0aW9uVGltaW5nSW5mby5jb25uZWN0aW9uU3RhcnRUaW1lLCBjcm9zc09yaWdpbklzb2xhdGVkQ2FwYWJpbGl0eSksXG4gICAgY29ubmVjdGlvbkVuZFRpbWU6IGNvYXJzZW5UaW1lKGNvbm5lY3Rpb25UaW1pbmdJbmZvLmNvbm5lY3Rpb25FbmRUaW1lLCBjcm9zc09yaWdpbklzb2xhdGVkQ2FwYWJpbGl0eSksXG4gICAgc2VjdXJlQ29ubmVjdGlvblN0YXJ0VGltZTogY29hcnNlblRpbWUoY29ubmVjdGlvblRpbWluZ0luZm8uc2VjdXJlQ29ubmVjdGlvblN0YXJ0VGltZSwgY3Jvc3NPcmlnaW5Jc29sYXRlZENhcGFiaWxpdHkpLFxuICAgIEFMUE5OZWdvdGlhdGVkUHJvdG9jb2w6IGNvbm5lY3Rpb25UaW1pbmdJbmZvLkFMUE5OZWdvdGlhdGVkUHJvdG9jb2xcbiAgfVxufVxuXG4vLyBodHRwczovL3czYy5naXRodWIuaW8vaHItdGltZS8jZGZuLWNvYXJzZW5lZC1zaGFyZWQtY3VycmVudC10aW1lXG5mdW5jdGlvbiBjb2Fyc2VuZWRTaGFyZWRDdXJyZW50VGltZSAoY3Jvc3NPcmlnaW5Jc29sYXRlZENhcGFiaWxpdHkpIHtcbiAgcmV0dXJuIGNvYXJzZW5UaW1lKHBlcmZvcm1hbmNlLm5vdygpLCBjcm9zc09yaWdpbklzb2xhdGVkQ2FwYWJpbGl0eSlcbn1cblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NyZWF0ZS1hbi1vcGFxdWUtdGltaW5nLWluZm9cbmZ1bmN0aW9uIGNyZWF0ZU9wYXF1ZVRpbWluZ0luZm8gKHRpbWluZ0luZm8pIHtcbiAgcmV0dXJuIHtcbiAgICBzdGFydFRpbWU6IHRpbWluZ0luZm8uc3RhcnRUaW1lID8/IDAsXG4gICAgcmVkaXJlY3RTdGFydFRpbWU6IDAsXG4gICAgcmVkaXJlY3RFbmRUaW1lOiAwLFxuICAgIHBvc3RSZWRpcmVjdFN0YXJ0VGltZTogdGltaW5nSW5mby5zdGFydFRpbWUgPz8gMCxcbiAgICBmaW5hbFNlcnZpY2VXb3JrZXJTdGFydFRpbWU6IDAsXG4gICAgZmluYWxOZXR3b3JrUmVzcG9uc2VTdGFydFRpbWU6IDAsXG4gICAgZmluYWxOZXR3b3JrUmVxdWVzdFN0YXJ0VGltZTogMCxcbiAgICBlbmRUaW1lOiAwLFxuICAgIGVuY29kZWRCb2R5U2l6ZTogMCxcbiAgICBkZWNvZGVkQm9keVNpemU6IDAsXG4gICAgZmluYWxDb25uZWN0aW9uVGltaW5nSW5mbzogbnVsbFxuICB9XG59XG5cbi8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL29yaWdpbi5odG1sI3BvbGljeS1jb250YWluZXJcbmZ1bmN0aW9uIG1ha2VQb2xpY3lDb250YWluZXIgKCkge1xuICAvLyBOb3RlOiB0aGUgZmV0Y2ggc3BlYyBkb2Vzbid0IG1ha2UgdXNlIG9mIGVtYmVkZGVyIHBvbGljeSBvciBDU1AgbGlzdFxuICByZXR1cm4ge1xuICAgIHJlZmVycmVyUG9saWN5OiAnc3RyaWN0LW9yaWdpbi13aGVuLWNyb3NzLW9yaWdpbidcbiAgfVxufVxuXG4vLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9vcmlnaW4uaHRtbCNjbG9uZS1hLXBvbGljeS1jb250YWluZXJcbmZ1bmN0aW9uIGNsb25lUG9saWN5Q29udGFpbmVyIChwb2xpY3lDb250YWluZXIpIHtcbiAgcmV0dXJuIHtcbiAgICByZWZlcnJlclBvbGljeTogcG9saWN5Q29udGFpbmVyLnJlZmVycmVyUG9saWN5XG4gIH1cbn1cblxuLy8gaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmFwcHNlYy1yZWZlcnJlci1wb2xpY3kvI2RldGVybWluZS1yZXF1ZXN0cy1yZWZlcnJlclxuZnVuY3Rpb24gZGV0ZXJtaW5lUmVxdWVzdHNSZWZlcnJlciAocmVxdWVzdCkge1xuICAvLyAxLiBMZXQgcG9saWN5IGJlIHJlcXVlc3QncyByZWZlcnJlciBwb2xpY3kuXG4gIGNvbnN0IHBvbGljeSA9IHJlcXVlc3QucmVmZXJyZXJQb2xpY3lcblxuICAvLyBOb3RlOiBwb2xpY3kgY2Fubm90IChzaG91bGRuJ3QpIGJlIG51bGwgb3IgYW4gZW1wdHkgc3RyaW5nLlxuICBhc3NlcnQocG9saWN5KVxuXG4gIC8vIDIuIExldCBlbnZpcm9ubWVudCBiZSByZXF1ZXN04oCZcyBjbGllbnQuXG5cbiAgbGV0IHJlZmVycmVyU291cmNlID0gbnVsbFxuXG4gIC8vIDMuIFN3aXRjaCBvbiByZXF1ZXN04oCZcyByZWZlcnJlcjpcbiAgaWYgKHJlcXVlc3QucmVmZXJyZXIgPT09ICdjbGllbnQnKSB7XG4gICAgLy8gTm90ZTogbm9kZSBpc24ndCBhIGJyb3dzZXIgYW5kIGRvZXNuJ3QgaW1wbGVtZW50IGRvY3VtZW50L2lmcmFtZXMsXG4gICAgLy8gc28gd2UgYnlwYXNzIHRoaXMgc3RlcCBhbmQgcmVwbGFjZSBpdCB3aXRoIG91ciBvd24uXG5cbiAgICBjb25zdCBnbG9iYWxPcmlnaW4gPSBnZXRHbG9iYWxPcmlnaW4oKVxuXG4gICAgaWYgKCFnbG9iYWxPcmlnaW4gfHwgZ2xvYmFsT3JpZ2luLm9yaWdpbiA9PT0gJ251bGwnKSB7XG4gICAgICByZXR1cm4gJ25vLXJlZmVycmVyJ1xuICAgIH1cblxuICAgIC8vIG5vdGU6IHdlIG5lZWQgdG8gY2xvbmUgaXQgYXMgaXQncyBtdXRhdGVkXG4gICAgcmVmZXJyZXJTb3VyY2UgPSBuZXcgVVJMKGdsb2JhbE9yaWdpbilcbiAgfSBlbHNlIGlmIChyZXF1ZXN0LnJlZmVycmVyIGluc3RhbmNlb2YgVVJMKSB7XG4gICAgLy8gTGV0IHJlZmVycmVyU291cmNlIGJlIHJlcXVlc3TigJlzIHJlZmVycmVyLlxuICAgIHJlZmVycmVyU291cmNlID0gcmVxdWVzdC5yZWZlcnJlclxuICB9XG5cbiAgLy8gNC4gTGV0IHJlcXVlc3TigJlzIHJlZmVycmVyVVJMIGJlIHRoZSByZXN1bHQgb2Ygc3RyaXBwaW5nIHJlZmVycmVyU291cmNlIGZvclxuICAvLyAgICB1c2UgYXMgYSByZWZlcnJlci5cbiAgbGV0IHJlZmVycmVyVVJMID0gc3RyaXBVUkxGb3JSZWZlcnJlcihyZWZlcnJlclNvdXJjZSlcblxuICAvLyA1LiBMZXQgcmVmZXJyZXJPcmlnaW4gYmUgdGhlIHJlc3VsdCBvZiBzdHJpcHBpbmcgcmVmZXJyZXJTb3VyY2UgZm9yIHVzZSBhc1xuICAvLyAgICBhIHJlZmVycmVyLCB3aXRoIHRoZSBvcmlnaW4tb25seSBmbGFnIHNldCB0byB0cnVlLlxuICBjb25zdCByZWZlcnJlck9yaWdpbiA9IHN0cmlwVVJMRm9yUmVmZXJyZXIocmVmZXJyZXJTb3VyY2UsIHRydWUpXG5cbiAgLy8gNi4gSWYgdGhlIHJlc3VsdCBvZiBzZXJpYWxpemluZyByZWZlcnJlclVSTCBpcyBhIHN0cmluZyB3aG9zZSBsZW5ndGggaXNcbiAgLy8gICAgZ3JlYXRlciB0aGFuIDQwOTYsIHNldCByZWZlcnJlclVSTCB0byByZWZlcnJlck9yaWdpbi5cbiAgaWYgKHJlZmVycmVyVVJMLnRvU3RyaW5nKCkubGVuZ3RoID4gNDA5Nikge1xuICAgIHJlZmVycmVyVVJMID0gcmVmZXJyZXJPcmlnaW5cbiAgfVxuXG4gIGNvbnN0IGFyZVNhbWVPcmlnaW4gPSBzYW1lT3JpZ2luKHJlcXVlc3QsIHJlZmVycmVyVVJMKVxuICBjb25zdCBpc05vblBvdGVudGlhbGx5VHJ1c3RXb3J0aHkgPSBpc1VSTFBvdGVudGlhbGx5VHJ1c3R3b3J0aHkocmVmZXJyZXJVUkwpICYmXG4gICAgIWlzVVJMUG90ZW50aWFsbHlUcnVzdHdvcnRoeShyZXF1ZXN0LnVybClcblxuICAvLyA4LiBFeGVjdXRlIHRoZSBzd2l0Y2ggc3RhdGVtZW50cyBjb3JyZXNwb25kaW5nIHRvIHRoZSB2YWx1ZSBvZiBwb2xpY3k6XG4gIHN3aXRjaCAocG9saWN5KSB7XG4gICAgY2FzZSAnb3JpZ2luJzogcmV0dXJuIHJlZmVycmVyT3JpZ2luICE9IG51bGwgPyByZWZlcnJlck9yaWdpbiA6IHN0cmlwVVJMRm9yUmVmZXJyZXIocmVmZXJyZXJTb3VyY2UsIHRydWUpXG4gICAgY2FzZSAndW5zYWZlLXVybCc6IHJldHVybiByZWZlcnJlclVSTFxuICAgIGNhc2UgJ3NhbWUtb3JpZ2luJzpcbiAgICAgIHJldHVybiBhcmVTYW1lT3JpZ2luID8gcmVmZXJyZXJPcmlnaW4gOiAnbm8tcmVmZXJyZXInXG4gICAgY2FzZSAnb3JpZ2luLXdoZW4tY3Jvc3Mtb3JpZ2luJzpcbiAgICAgIHJldHVybiBhcmVTYW1lT3JpZ2luID8gcmVmZXJyZXJVUkwgOiByZWZlcnJlck9yaWdpblxuICAgIGNhc2UgJ3N0cmljdC1vcmlnaW4td2hlbi1jcm9zcy1vcmlnaW4nOiB7XG4gICAgICBjb25zdCBjdXJyZW50VVJMID0gcmVxdWVzdEN1cnJlbnRVUkwocmVxdWVzdClcblxuICAgICAgLy8gMS4gSWYgdGhlIG9yaWdpbiBvZiByZWZlcnJlclVSTCBhbmQgdGhlIG9yaWdpbiBvZiByZXF1ZXN04oCZcyBjdXJyZW50XG4gICAgICAvLyAgICBVUkwgYXJlIHRoZSBzYW1lLCB0aGVuIHJldHVybiByZWZlcnJlclVSTC5cbiAgICAgIGlmIChzYW1lT3JpZ2luKHJlZmVycmVyVVJMLCBjdXJyZW50VVJMKSkge1xuICAgICAgICByZXR1cm4gcmVmZXJyZXJVUkxcbiAgICAgIH1cblxuICAgICAgLy8gMi4gSWYgcmVmZXJyZXJVUkwgaXMgYSBwb3RlbnRpYWxseSB0cnVzdHdvcnRoeSBVUkwgYW5kIHJlcXVlc3TigJlzXG4gICAgICAvLyAgICBjdXJyZW50IFVSTCBpcyBub3QgYSBwb3RlbnRpYWxseSB0cnVzdHdvcnRoeSBVUkwsIHRoZW4gcmV0dXJuIG5vXG4gICAgICAvLyAgICByZWZlcnJlci5cbiAgICAgIGlmIChpc1VSTFBvdGVudGlhbGx5VHJ1c3R3b3J0aHkocmVmZXJyZXJVUkwpICYmICFpc1VSTFBvdGVudGlhbGx5VHJ1c3R3b3J0aHkoY3VycmVudFVSTCkpIHtcbiAgICAgICAgcmV0dXJuICduby1yZWZlcnJlcidcbiAgICAgIH1cblxuICAgICAgLy8gMy4gUmV0dXJuIHJlZmVycmVyT3JpZ2luLlxuICAgICAgcmV0dXJuIHJlZmVycmVyT3JpZ2luXG4gICAgfVxuICAgIGNhc2UgJ3N0cmljdC1vcmlnaW4nOiAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICAvKipcbiAgICAgICAgICogMS4gSWYgcmVmZXJyZXJVUkwgaXMgYSBwb3RlbnRpYWxseSB0cnVzdHdvcnRoeSBVUkwgYW5kXG4gICAgICAgICAqIHJlcXVlc3TigJlzIGN1cnJlbnQgVVJMIGlzIG5vdCBhIHBvdGVudGlhbGx5IHRydXN0d29ydGh5IFVSTCxcbiAgICAgICAgICogdGhlbiByZXR1cm4gbm8gcmVmZXJyZXIuXG4gICAgICAgICAqIDIuIFJldHVybiByZWZlcnJlck9yaWdpblxuICAgICAgICAqL1xuICAgIGNhc2UgJ25vLXJlZmVycmVyLXdoZW4tZG93bmdyYWRlJzogLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgLyoqXG4gICAgICAgKiAxLiBJZiByZWZlcnJlclVSTCBpcyBhIHBvdGVudGlhbGx5IHRydXN0d29ydGh5IFVSTCBhbmRcbiAgICAgICAqIHJlcXVlc3TigJlzIGN1cnJlbnQgVVJMIGlzIG5vdCBhIHBvdGVudGlhbGx5IHRydXN0d29ydGh5IFVSTCxcbiAgICAgICAqIHRoZW4gcmV0dXJuIG5vIHJlZmVycmVyLlxuICAgICAgICogMi4gUmV0dXJuIHJlZmVycmVyT3JpZ2luXG4gICAgICAqL1xuXG4gICAgZGVmYXVsdDogLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgcmV0dXJuIGlzTm9uUG90ZW50aWFsbHlUcnVzdFdvcnRoeSA/ICduby1yZWZlcnJlcicgOiByZWZlcnJlck9yaWdpblxuICB9XG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL3czYy5naXRodWIuaW8vd2ViYXBwc2VjLXJlZmVycmVyLXBvbGljeS8jc3RyaXAtdXJsXG4gKiBAcGFyYW0ge1VSTH0gdXJsXG4gKiBAcGFyYW0ge2Jvb2xlYW58dW5kZWZpbmVkfSBvcmlnaW5Pbmx5XG4gKi9cbmZ1bmN0aW9uIHN0cmlwVVJMRm9yUmVmZXJyZXIgKHVybCwgb3JpZ2luT25seSkge1xuICAvLyAxLiBBc3NlcnQ6IHVybCBpcyBhIFVSTC5cbiAgYXNzZXJ0KHVybCBpbnN0YW5jZW9mIFVSTClcblxuICB1cmwgPSBuZXcgVVJMKHVybClcblxuICAvLyAyLiBJZiB1cmzigJlzIHNjaGVtZSBpcyBhIGxvY2FsIHNjaGVtZSwgdGhlbiByZXR1cm4gbm8gcmVmZXJyZXIuXG4gIGlmICh1cmwucHJvdG9jb2wgPT09ICdmaWxlOicgfHwgdXJsLnByb3RvY29sID09PSAnYWJvdXQ6JyB8fCB1cmwucHJvdG9jb2wgPT09ICdibGFuazonKSB7XG4gICAgcmV0dXJuICduby1yZWZlcnJlcidcbiAgfVxuXG4gIC8vIDMuIFNldCB1cmzigJlzIHVzZXJuYW1lIHRvIHRoZSBlbXB0eSBzdHJpbmcuXG4gIHVybC51c2VybmFtZSA9ICcnXG5cbiAgLy8gNC4gU2V0IHVybOKAmXMgcGFzc3dvcmQgdG8gdGhlIGVtcHR5IHN0cmluZy5cbiAgdXJsLnBhc3N3b3JkID0gJydcblxuICAvLyA1LiBTZXQgdXJs4oCZcyBmcmFnbWVudCB0byBudWxsLlxuICB1cmwuaGFzaCA9ICcnXG5cbiAgLy8gNi4gSWYgdGhlIG9yaWdpbi1vbmx5IGZsYWcgaXMgdHJ1ZSwgdGhlbjpcbiAgaWYgKG9yaWdpbk9ubHkpIHtcbiAgICAvLyAxLiBTZXQgdXJs4oCZcyBwYXRoIHRvIMKrIHRoZSBlbXB0eSBzdHJpbmcgwrsuXG4gICAgdXJsLnBhdGhuYW1lID0gJydcblxuICAgIC8vIDIuIFNldCB1cmzigJlzIHF1ZXJ5IHRvIG51bGwuXG4gICAgdXJsLnNlYXJjaCA9ICcnXG4gIH1cblxuICAvLyA3LiBSZXR1cm4gdXJsLlxuICByZXR1cm4gdXJsXG59XG5cbmZ1bmN0aW9uIGlzVVJMUG90ZW50aWFsbHlUcnVzdHdvcnRoeSAodXJsKSB7XG4gIGlmICghKHVybCBpbnN0YW5jZW9mIFVSTCkpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8vIElmIGNoaWxkIG9mIGFib3V0LCByZXR1cm4gdHJ1ZVxuICBpZiAodXJsLmhyZWYgPT09ICdhYm91dDpibGFuaycgfHwgdXJsLmhyZWYgPT09ICdhYm91dDpzcmNkb2MnKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8vIElmIHNjaGVtZSBpcyBkYXRhLCByZXR1cm4gdHJ1ZVxuICBpZiAodXJsLnByb3RvY29sID09PSAnZGF0YTonKSByZXR1cm4gdHJ1ZVxuXG4gIC8vIElmIGZpbGUsIHJldHVybiB0cnVlXG4gIGlmICh1cmwucHJvdG9jb2wgPT09ICdmaWxlOicpIHJldHVybiB0cnVlXG5cbiAgcmV0dXJuIGlzT3JpZ2luUG90ZW50aWFsbHlUcnVzdHdvcnRoeSh1cmwub3JpZ2luKVxuXG4gIGZ1bmN0aW9uIGlzT3JpZ2luUG90ZW50aWFsbHlUcnVzdHdvcnRoeSAob3JpZ2luKSB7XG4gICAgLy8gSWYgb3JpZ2luIGlzIGV4cGxpY2l0bHkgbnVsbCwgcmV0dXJuIGZhbHNlXG4gICAgaWYgKG9yaWdpbiA9PSBudWxsIHx8IG9yaWdpbiA9PT0gJ251bGwnKSByZXR1cm4gZmFsc2VcblxuICAgIGNvbnN0IG9yaWdpbkFzVVJMID0gbmV3IFVSTChvcmlnaW4pXG5cbiAgICAvLyBJZiBzZWN1cmUsIHJldHVybiB0cnVlXG4gICAgaWYgKG9yaWdpbkFzVVJMLnByb3RvY29sID09PSAnaHR0cHM6JyB8fCBvcmlnaW5Bc1VSTC5wcm90b2NvbCA9PT0gJ3dzczonKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIC8vIElmIGxvY2FsaG9zdCBvciB2YXJpYW50cywgcmV0dXJuIHRydWVcbiAgICBpZiAoL14xMjcoPzpcXC5bMC05XSspezAsMn1cXC5bMC05XSskfF5cXFsoPzowKjopKj86PzAqMVxcXSQvLnRlc3Qob3JpZ2luQXNVUkwuaG9zdG5hbWUpIHx8XG4gICAgIChvcmlnaW5Bc1VSTC5ob3N0bmFtZSA9PT0gJ2xvY2FsaG9zdCcgfHwgb3JpZ2luQXNVUkwuaG9zdG5hbWUuaW5jbHVkZXMoJ2xvY2FsaG9zdC4nKSkgfHxcbiAgICAgKG9yaWdpbkFzVVJMLmhvc3RuYW1lLmVuZHNXaXRoKCcubG9jYWxob3N0JykpKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIC8vIElmIGFueSBvdGhlciwgcmV0dXJuIGZhbHNlXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJhcHBzZWMtc3VicmVzb3VyY2UtaW50ZWdyaXR5LyNkb2VzLXJlc3BvbnNlLW1hdGNoLW1ldGFkYXRhbGlzdFxuICogQHBhcmFtIHtVaW50OEFycmF5fSBieXRlc1xuICogQHBhcmFtIHtzdHJpbmd9IG1ldGFkYXRhTGlzdFxuICovXG5mdW5jdGlvbiBieXRlc01hdGNoIChieXRlcywgbWV0YWRhdGFMaXN0KSB7XG4gIC8vIElmIG5vZGUgaXMgbm90IGJ1aWx0IHdpdGggT3BlblNTTCBzdXBwb3J0LCB3ZSBjYW5ub3QgY2hlY2tcbiAgLy8gYSByZXF1ZXN0J3MgaW50ZWdyaXR5LCBzbyBhbGxvdyBpdCBieSBkZWZhdWx0ICh0aGUgc3BlYyB3aWxsXG4gIC8vIGFsbG93IHJlcXVlc3RzIGlmIGFuIGludmFsaWQgaGFzaCBpcyBnaXZlbiwgYXMgcHJlY2VkZW5jZSkuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZjogb25seSBpZiBub2RlIGlzIGJ1aWx0IHdpdGggLS13aXRob3V0LXNzbCAqL1xuICBpZiAoY3J5cHRvID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLy8gMS4gTGV0IHBhcnNlZE1ldGFkYXRhIGJlIHRoZSByZXN1bHQgb2YgcGFyc2luZyBtZXRhZGF0YUxpc3QuXG4gIGNvbnN0IHBhcnNlZE1ldGFkYXRhID0gcGFyc2VNZXRhZGF0YShtZXRhZGF0YUxpc3QpXG5cbiAgLy8gMi4gSWYgcGFyc2VkTWV0YWRhdGEgaXMgbm8gbWV0YWRhdGEsIHJldHVybiB0cnVlLlxuICBpZiAocGFyc2VkTWV0YWRhdGEgPT09ICdubyBtZXRhZGF0YScpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLy8gMy4gSWYgcmVzcG9uc2UgaXMgbm90IGVsaWdpYmxlIGZvciBpbnRlZ3JpdHkgdmFsaWRhdGlvbiwgcmV0dXJuIGZhbHNlLlxuICAvLyBUT0RPXG5cbiAgLy8gNC4gSWYgcGFyc2VkTWV0YWRhdGEgaXMgdGhlIGVtcHR5IHNldCwgcmV0dXJuIHRydWUuXG4gIGlmIChwYXJzZWRNZXRhZGF0YS5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLy8gNS4gTGV0IG1ldGFkYXRhIGJlIHRoZSByZXN1bHQgb2YgZ2V0dGluZyB0aGUgc3Ryb25nZXN0XG4gIC8vICAgIG1ldGFkYXRhIGZyb20gcGFyc2VkTWV0YWRhdGEuXG4gIGNvbnN0IHN0cm9uZ2VzdCA9IGdldFN0cm9uZ2VzdE1ldGFkYXRhKHBhcnNlZE1ldGFkYXRhKVxuICBjb25zdCBtZXRhZGF0YSA9IGZpbHRlck1ldGFkYXRhTGlzdEJ5QWxnb3JpdGhtKHBhcnNlZE1ldGFkYXRhLCBzdHJvbmdlc3QpXG5cbiAgLy8gNi4gRm9yIGVhY2ggaXRlbSBpbiBtZXRhZGF0YTpcbiAgZm9yIChjb25zdCBpdGVtIG9mIG1ldGFkYXRhKSB7XG4gICAgLy8gMS4gTGV0IGFsZ29yaXRobSBiZSB0aGUgYWxnIGNvbXBvbmVudCBvZiBpdGVtLlxuICAgIGNvbnN0IGFsZ29yaXRobSA9IGl0ZW0uYWxnb1xuXG4gICAgLy8gMi4gTGV0IGV4cGVjdGVkVmFsdWUgYmUgdGhlIHZhbCBjb21wb25lbnQgb2YgaXRlbS5cbiAgICBjb25zdCBleHBlY3RlZFZhbHVlID0gaXRlbS5oYXNoXG5cbiAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3dlYi1wbGF0Zm9ybS10ZXN0cy93cHQvY29tbWl0L2U0YzVjYzdhNWU0ODA5MzIyMDUyOGRmZGQxYzQwMTJkYzM4MzdhMGVcbiAgICAvLyBcImJlIGxpYmVyYWwgd2l0aCBwYWRkaW5nXCIuIFRoaXMgaXMgYW5ub3lpbmcsIGFuZCBpdCdzIG5vdCBldmVuIGluIHRoZSBzcGVjLlxuXG4gICAgLy8gMy4gTGV0IGFjdHVhbFZhbHVlIGJlIHRoZSByZXN1bHQgb2YgYXBwbHlpbmcgYWxnb3JpdGhtIHRvIGJ5dGVzLlxuICAgIGxldCBhY3R1YWxWYWx1ZSA9IGNyeXB0by5jcmVhdGVIYXNoKGFsZ29yaXRobSkudXBkYXRlKGJ5dGVzKS5kaWdlc3QoJ2Jhc2U2NCcpXG5cbiAgICBpZiAoYWN0dWFsVmFsdWVbYWN0dWFsVmFsdWUubGVuZ3RoIC0gMV0gPT09ICc9Jykge1xuICAgICAgaWYgKGFjdHVhbFZhbHVlW2FjdHVhbFZhbHVlLmxlbmd0aCAtIDJdID09PSAnPScpIHtcbiAgICAgICAgYWN0dWFsVmFsdWUgPSBhY3R1YWxWYWx1ZS5zbGljZSgwLCAtMilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFjdHVhbFZhbHVlID0gYWN0dWFsVmFsdWUuc2xpY2UoMCwgLTEpXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gNC4gSWYgYWN0dWFsVmFsdWUgaXMgYSBjYXNlLXNlbnNpdGl2ZSBtYXRjaCBmb3IgZXhwZWN0ZWRWYWx1ZSxcbiAgICAvLyAgICByZXR1cm4gdHJ1ZS5cbiAgICBpZiAoY29tcGFyZUJhc2U2NE1peGVkKGFjdHVhbFZhbHVlLCBleHBlY3RlZFZhbHVlKSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cblxuICAvLyA3LiBSZXR1cm4gZmFsc2UuXG4gIHJldHVybiBmYWxzZVxufVxuXG4vLyBodHRwczovL3czYy5naXRodWIuaW8vd2ViYXBwc2VjLXN1YnJlc291cmNlLWludGVncml0eS8jZ3JhbW1hcmRlZi1oYXNoLXdpdGgtb3B0aW9uc1xuLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL0NTUDIvI3NvdXJjZS1saXN0LXN5bnRheFxuLy8gaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzUyMzQjYXBwZW5kaXgtQi4xXG5jb25zdCBwYXJzZUhhc2hXaXRoT3B0aW9ucyA9IC8oPzxhbGdvPnNoYTI1NnxzaGEzODR8c2hhNTEyKS0oKD88aGFzaD5bQS1aYS16MC05Ky9dK3xbQS1aYS16MC05Xy1dKyk9ezAsMn0oPzpcXHN8JCkoICtbIS1+XSopPyk/L2lcblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJhcHBzZWMtc3VicmVzb3VyY2UtaW50ZWdyaXR5LyNwYXJzZS1tZXRhZGF0YVxuICogQHBhcmFtIHtzdHJpbmd9IG1ldGFkYXRhXG4gKi9cbmZ1bmN0aW9uIHBhcnNlTWV0YWRhdGEgKG1ldGFkYXRhKSB7XG4gIC8vIDEuIExldCByZXN1bHQgYmUgdGhlIGVtcHR5IHNldC5cbiAgLyoqIEB0eXBlIHt7IGFsZ286IHN0cmluZywgaGFzaDogc3RyaW5nIH1bXX0gKi9cbiAgY29uc3QgcmVzdWx0ID0gW11cblxuICAvLyAyLiBMZXQgZW1wdHkgYmUgZXF1YWwgdG8gdHJ1ZS5cbiAgbGV0IGVtcHR5ID0gdHJ1ZVxuXG4gIC8vIDMuIEZvciBlYWNoIHRva2VuIHJldHVybmVkIGJ5IHNwbGl0dGluZyBtZXRhZGF0YSBvbiBzcGFjZXM6XG4gIGZvciAoY29uc3QgdG9rZW4gb2YgbWV0YWRhdGEuc3BsaXQoJyAnKSkge1xuICAgIC8vIDEuIFNldCBlbXB0eSB0byBmYWxzZS5cbiAgICBlbXB0eSA9IGZhbHNlXG5cbiAgICAvLyAyLiBQYXJzZSB0b2tlbiBhcyBhIGhhc2gtd2l0aC1vcHRpb25zLlxuICAgIGNvbnN0IHBhcnNlZFRva2VuID0gcGFyc2VIYXNoV2l0aE9wdGlvbnMuZXhlYyh0b2tlbilcblxuICAgIC8vIDMuIElmIHRva2VuIGRvZXMgbm90IHBhcnNlLCBjb250aW51ZSB0byB0aGUgbmV4dCB0b2tlbi5cbiAgICBpZiAoXG4gICAgICBwYXJzZWRUb2tlbiA9PT0gbnVsbCB8fFxuICAgICAgcGFyc2VkVG9rZW4uZ3JvdXBzID09PSB1bmRlZmluZWQgfHxcbiAgICAgIHBhcnNlZFRva2VuLmdyb3Vwcy5hbGdvID09PSB1bmRlZmluZWRcbiAgICApIHtcbiAgICAgIC8vIE5vdGU6IENocm9taXVtIGJsb2NrcyB0aGUgcmVxdWVzdCBhdCB0aGlzIHBvaW50LCBidXQgRmlyZWZveFxuICAgICAgLy8gZ2l2ZXMgYSB3YXJuaW5nIHRoYXQgYW4gaW52YWxpZCBpbnRlZ3JpdHkgd2FzIGdpdmVuLiBUaGVcbiAgICAgIC8vIGNvcnJlY3QgYmVoYXZpb3IgaXMgdG8gaWdub3JlIHRoZXNlLCBhbmQgc3Vic2VxdWVudGx5IG5vdFxuICAgICAgLy8gY2hlY2sgdGhlIGludGVncml0eSBvZiB0aGUgcmVzb3VyY2UuXG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIC8vIDQuIExldCBhbGdvcml0aG0gYmUgdGhlIGhhc2gtYWxnbyBjb21wb25lbnQgb2YgdG9rZW4uXG4gICAgY29uc3QgYWxnb3JpdGhtID0gcGFyc2VkVG9rZW4uZ3JvdXBzLmFsZ28udG9Mb3dlckNhc2UoKVxuXG4gICAgLy8gNS4gSWYgYWxnb3JpdGhtIGlzIGEgaGFzaCBmdW5jdGlvbiByZWNvZ25pemVkIGJ5IHRoZSB1c2VyXG4gICAgLy8gICAgYWdlbnQsIGFkZCB0aGUgcGFyc2VkIHRva2VuIHRvIHJlc3VsdC5cbiAgICBpZiAoc3VwcG9ydGVkSGFzaGVzLmluY2x1ZGVzKGFsZ29yaXRobSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKHBhcnNlZFRva2VuLmdyb3VwcylcbiAgICB9XG4gIH1cblxuICAvLyA0LiBSZXR1cm4gbm8gbWV0YWRhdGEgaWYgZW1wdHkgaXMgdHJ1ZSwgb3RoZXJ3aXNlIHJldHVybiByZXN1bHQuXG4gIGlmIChlbXB0eSA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiAnbm8gbWV0YWRhdGEnXG4gIH1cblxuICByZXR1cm4gcmVzdWx0XG59XG5cbi8qKlxuICogQHBhcmFtIHt7IGFsZ286ICdzaGEyNTYnIHwgJ3NoYTM4NCcgfCAnc2hhNTEyJyB9W119IG1ldGFkYXRhTGlzdFxuICovXG5mdW5jdGlvbiBnZXRTdHJvbmdlc3RNZXRhZGF0YSAobWV0YWRhdGFMaXN0KSB7XG4gIC8vIExldCBhbGdvcml0aG0gYmUgdGhlIGFsZ28gY29tcG9uZW50IG9mIHRoZSBmaXJzdCBpdGVtIGluIG1ldGFkYXRhTGlzdC5cbiAgLy8gQ2FuIGJlIHNoYTI1NlxuICBsZXQgYWxnb3JpdGhtID0gbWV0YWRhdGFMaXN0WzBdLmFsZ29cbiAgLy8gSWYgdGhlIGFsZ29yaXRobSBpcyBzaGE1MTIsIHRoZW4gaXQgaXMgdGhlIHN0cm9uZ2VzdFxuICAvLyBhbmQgd2UgY2FuIHJldHVybiBpbW1lZGlhdGVseVxuICBpZiAoYWxnb3JpdGhtWzNdID09PSAnNScpIHtcbiAgICByZXR1cm4gYWxnb3JpdGhtXG4gIH1cblxuICBmb3IgKGxldCBpID0gMTsgaSA8IG1ldGFkYXRhTGlzdC5sZW5ndGg7ICsraSkge1xuICAgIGNvbnN0IG1ldGFkYXRhID0gbWV0YWRhdGFMaXN0W2ldXG4gICAgLy8gSWYgdGhlIGFsZ29yaXRobSBpcyBzaGE1MTIsIHRoZW4gaXQgaXMgdGhlIHN0cm9uZ2VzdFxuICAgIC8vIGFuZCB3ZSBjYW4gYnJlYWsgdGhlIGxvb3AgaW1tZWRpYXRlbHlcbiAgICBpZiAobWV0YWRhdGEuYWxnb1szXSA9PT0gJzUnKSB7XG4gICAgICBhbGdvcml0aG0gPSAnc2hhNTEyJ1xuICAgICAgYnJlYWtcbiAgICAvLyBJZiB0aGUgYWxnb3JpdGhtIGlzIHNoYTM4NCwgdGhlbiBhIHBvdGVudGlhbCBzaGEyNTYgb3Igc2hhMzg0IGlzIGlnbm9yZWRcbiAgICB9IGVsc2UgaWYgKGFsZ29yaXRobVszXSA9PT0gJzMnKSB7XG4gICAgICBjb250aW51ZVxuICAgIC8vIGFsZ29yaXRobSBpcyBzaGEyNTYsIGNoZWNrIGlmIGFsZ29yaXRobSBpcyBzaGEzODQgYW5kIGlmIHNvLCBzZXQgaXQgYXNcbiAgICAvLyB0aGUgc3Ryb25nZXN0XG4gICAgfSBlbHNlIGlmIChtZXRhZGF0YS5hbGdvWzNdID09PSAnMycpIHtcbiAgICAgIGFsZ29yaXRobSA9ICdzaGEzODQnXG4gICAgfVxuICB9XG4gIHJldHVybiBhbGdvcml0aG1cbn1cblxuZnVuY3Rpb24gZmlsdGVyTWV0YWRhdGFMaXN0QnlBbGdvcml0aG0gKG1ldGFkYXRhTGlzdCwgYWxnb3JpdGhtKSB7XG4gIGlmIChtZXRhZGF0YUxpc3QubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIG1ldGFkYXRhTGlzdFxuICB9XG5cbiAgbGV0IHBvcyA9IDBcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZXRhZGF0YUxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAobWV0YWRhdGFMaXN0W2ldLmFsZ28gPT09IGFsZ29yaXRobSkge1xuICAgICAgbWV0YWRhdGFMaXN0W3BvcysrXSA9IG1ldGFkYXRhTGlzdFtpXVxuICAgIH1cbiAgfVxuXG4gIG1ldGFkYXRhTGlzdC5sZW5ndGggPSBwb3NcblxuICByZXR1cm4gbWV0YWRhdGFMaXN0XG59XG5cbi8qKlxuICogQ29tcGFyZXMgdHdvIGJhc2U2NCBzdHJpbmdzLCBhbGxvd2luZyBmb3IgYmFzZTY0dXJsXG4gKiBpbiB0aGUgc2Vjb25kIHN0cmluZy5cbiAqXG4qIEBwYXJhbSB7c3RyaW5nfSBhY3R1YWxWYWx1ZSBhbHdheXMgYmFzZTY0XG4gKiBAcGFyYW0ge3N0cmluZ30gZXhwZWN0ZWRWYWx1ZSBiYXNlNjQgb3IgYmFzZTY0dXJsXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gY29tcGFyZUJhc2U2NE1peGVkIChhY3R1YWxWYWx1ZSwgZXhwZWN0ZWRWYWx1ZSkge1xuICBpZiAoYWN0dWFsVmFsdWUubGVuZ3RoICE9PSBleHBlY3RlZFZhbHVlLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYWN0dWFsVmFsdWUubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoYWN0dWFsVmFsdWVbaV0gIT09IGV4cGVjdGVkVmFsdWVbaV0pIHtcbiAgICAgIGlmIChcbiAgICAgICAgKGFjdHVhbFZhbHVlW2ldID09PSAnKycgJiYgZXhwZWN0ZWRWYWx1ZVtpXSA9PT0gJy0nKSB8fFxuICAgICAgICAoYWN0dWFsVmFsdWVbaV0gPT09ICcvJyAmJiBleHBlY3RlZFZhbHVlW2ldID09PSAnXycpXG4gICAgICApIHtcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG5cbi8vIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJhcHBzZWMtdXBncmFkZS1pbnNlY3VyZS1yZXF1ZXN0cy8jdXBncmFkZS1yZXF1ZXN0XG5mdW5jdGlvbiB0cnlVcGdyYWRlUmVxdWVzdFRvQVBvdGVudGlhbGx5VHJ1c3R3b3J0aHlVUkwgKHJlcXVlc3QpIHtcbiAgLy8gVE9ET1xufVxuXG4vKipcbiAqIEBsaW5rIHtodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9vcmlnaW4uaHRtbCNzYW1lLW9yaWdpbn1cbiAqIEBwYXJhbSB7VVJMfSBBXG4gKiBAcGFyYW0ge1VSTH0gQlxuICovXG5mdW5jdGlvbiBzYW1lT3JpZ2luIChBLCBCKSB7XG4gIC8vIDEuIElmIEEgYW5kIEIgYXJlIHRoZSBzYW1lIG9wYXF1ZSBvcmlnaW4sIHRoZW4gcmV0dXJuIHRydWUuXG4gIGlmIChBLm9yaWdpbiA9PT0gQi5vcmlnaW4gJiYgQS5vcmlnaW4gPT09ICdudWxsJykge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvLyAyLiBJZiBBIGFuZCBCIGFyZSBib3RoIHR1cGxlIG9yaWdpbnMgYW5kIHRoZWlyIHNjaGVtZXMsXG4gIC8vICAgIGhvc3RzLCBhbmQgcG9ydCBhcmUgaWRlbnRpY2FsLCB0aGVuIHJldHVybiB0cnVlLlxuICBpZiAoQS5wcm90b2NvbCA9PT0gQi5wcm90b2NvbCAmJiBBLmhvc3RuYW1lID09PSBCLmhvc3RuYW1lICYmIEEucG9ydCA9PT0gQi5wb3J0KSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8vIDMuIFJldHVybiBmYWxzZS5cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZURlZmVycmVkUHJvbWlzZSAoKSB7XG4gIGxldCByZXNcbiAgbGV0IHJlalxuICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHJlcyA9IHJlc29sdmVcbiAgICByZWogPSByZWplY3RcbiAgfSlcblxuICByZXR1cm4geyBwcm9taXNlLCByZXNvbHZlOiByZXMsIHJlamVjdDogcmVqIH1cbn1cblxuZnVuY3Rpb24gaXNBYm9ydGVkIChmZXRjaFBhcmFtcykge1xuICByZXR1cm4gZmV0Y2hQYXJhbXMuY29udHJvbGxlci5zdGF0ZSA9PT0gJ2Fib3J0ZWQnXG59XG5cbmZ1bmN0aW9uIGlzQ2FuY2VsbGVkIChmZXRjaFBhcmFtcykge1xuICByZXR1cm4gZmV0Y2hQYXJhbXMuY29udHJvbGxlci5zdGF0ZSA9PT0gJ2Fib3J0ZWQnIHx8XG4gICAgZmV0Y2hQYXJhbXMuY29udHJvbGxlci5zdGF0ZSA9PT0gJ3Rlcm1pbmF0ZWQnXG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1tZXRob2Qtbm9ybWFsaXplXG4gKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZU1ldGhvZCAobWV0aG9kKSB7XG4gIHJldHVybiBub3JtYWxpemVkTWV0aG9kUmVjb3Jkc0Jhc2VbbWV0aG9kLnRvTG93ZXJDYXNlKCldID8/IG1ldGhvZFxufVxuXG4vLyBodHRwczovL2luZnJhLnNwZWMud2hhdHdnLm9yZy8jc2VyaWFsaXplLWEtamF2YXNjcmlwdC12YWx1ZS10by1hLWpzb24tc3RyaW5nXG5mdW5jdGlvbiBzZXJpYWxpemVKYXZhc2NyaXB0VmFsdWVUb0pTT05TdHJpbmcgKHZhbHVlKSB7XG4gIC8vIDEuIExldCByZXN1bHQgYmUgPyBDYWxsKCVKU09OLnN0cmluZ2lmeSUsIHVuZGVmaW5lZCwgwqsgdmFsdWUgwrspLlxuICBjb25zdCByZXN1bHQgPSBKU09OLnN0cmluZ2lmeSh2YWx1ZSlcblxuICAvLyAyLiBJZiByZXN1bHQgaXMgdW5kZWZpbmVkLCB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdWYWx1ZSBpcyBub3QgSlNPTiBzZXJpYWxpemFibGUnKVxuICB9XG5cbiAgLy8gMy4gQXNzZXJ0OiByZXN1bHQgaXMgYSBzdHJpbmcuXG4gIGFzc2VydCh0eXBlb2YgcmVzdWx0ID09PSAnc3RyaW5nJylcblxuICAvLyA0LiBSZXR1cm4gcmVzdWx0LlxuICByZXR1cm4gcmVzdWx0XG59XG5cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtJTI1aXRlcmF0b3Jwcm90b3R5cGUlMjUtb2JqZWN0XG5jb25zdCBlc0l0ZXJhdG9yUHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKE9iamVjdC5nZXRQcm90b3R5cGVPZihbXVtTeW1ib2wuaXRlcmF0b3JdKCkpKVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly93ZWJpZGwuc3BlYy53aGF0d2cub3JnLyNkZm4taXRlcmF0b3ItcHJvdG90eXBlLW9iamVjdFxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgbmFtZSBvZiB0aGUgaW5zdGFuY2VcbiAqIEBwYXJhbSB7c3ltYm9sfSBrSW50ZXJuYWxJdGVyYXRvclxuICogQHBhcmFtIHtzdHJpbmcgfCBudW1iZXJ9IFtrZXlJbmRleF1cbiAqIEBwYXJhbSB7c3RyaW5nIHwgbnVtYmVyfSBbdmFsdWVJbmRleF1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlSXRlcmF0b3IgKG5hbWUsIGtJbnRlcm5hbEl0ZXJhdG9yLCBrZXlJbmRleCA9IDAsIHZhbHVlSW5kZXggPSAxKSB7XG4gIGNsYXNzIEZhc3RJdGVyYWJsZUl0ZXJhdG9yIHtcbiAgICAvKiogQHR5cGUge2FueX0gKi9cbiAgICAjdGFyZ2V0XG4gICAgLyoqIEB0eXBlIHsna2V5JyB8ICd2YWx1ZScgfCAna2V5K3ZhbHVlJ30gKi9cbiAgICAja2luZFxuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICNpbmRleFxuXG4gICAgLyoqXG4gICAgICogQHNlZSBodHRwczovL3dlYmlkbC5zcGVjLndoYXR3Zy5vcmcvI2Rmbi1kZWZhdWx0LWl0ZXJhdG9yLW9iamVjdFxuICAgICAqIEBwYXJhbSB7dW5rbm93bn0gdGFyZ2V0XG4gICAgICogQHBhcmFtIHsna2V5JyB8ICd2YWx1ZScgfCAna2V5K3ZhbHVlJ30ga2luZFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yICh0YXJnZXQsIGtpbmQpIHtcbiAgICAgIHRoaXMuI3RhcmdldCA9IHRhcmdldFxuICAgICAgdGhpcy4ja2luZCA9IGtpbmRcbiAgICAgIHRoaXMuI2luZGV4ID0gMFxuICAgIH1cblxuICAgIG5leHQgKCkge1xuICAgICAgLy8gMS4gTGV0IGludGVyZmFjZSBiZSB0aGUgaW50ZXJmYWNlIGZvciB3aGljaCB0aGUgaXRlcmF0b3IgcHJvdG90eXBlIG9iamVjdCBleGlzdHMuXG4gICAgICAvLyAyLiBMZXQgdGhpc1ZhbHVlIGJlIHRoZSB0aGlzIHZhbHVlLlxuICAgICAgLy8gMy4gTGV0IG9iamVjdCBiZSA/IFRvT2JqZWN0KHRoaXNWYWx1ZSkuXG4gICAgICAvLyA0LiBJZiBvYmplY3QgaXMgYSBwbGF0Zm9ybSBvYmplY3QsIHRoZW4gcGVyZm9ybSBhIHNlY3VyaXR5XG4gICAgICAvLyAgICBjaGVjaywgcGFzc2luZzpcbiAgICAgIC8vIDUuIElmIG9iamVjdCBpcyBub3QgYSBkZWZhdWx0IGl0ZXJhdG9yIG9iamVjdCBmb3IgaW50ZXJmYWNlLFxuICAgICAgLy8gICAgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgICAgIGlmICh0eXBlb2YgdGhpcyAhPT0gJ29iamVjdCcgfHwgdGhpcyA9PT0gbnVsbCB8fCAhKCN0YXJnZXQgaW4gdGhpcykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICBgJ25leHQnIGNhbGxlZCBvbiBhbiBvYmplY3QgdGhhdCBkb2VzIG5vdCBpbXBsZW1lbnQgaW50ZXJmYWNlICR7bmFtZX0gSXRlcmF0b3IuYFxuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIC8vIDYuIExldCBpbmRleCBiZSBvYmplY3TigJlzIGluZGV4LlxuICAgICAgLy8gNy4gTGV0IGtpbmQgYmUgb2JqZWN04oCZcyBraW5kLlxuICAgICAgLy8gOC4gTGV0IHZhbHVlcyBiZSBvYmplY3TigJlzIHRhcmdldCdzIHZhbHVlIHBhaXJzIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy4jaW5kZXhcbiAgICAgIGNvbnN0IHZhbHVlcyA9IHRoaXMuI3RhcmdldFtrSW50ZXJuYWxJdGVyYXRvcl1cblxuICAgICAgLy8gOS4gTGV0IGxlbiBiZSB0aGUgbGVuZ3RoIG9mIHZhbHVlcy5cbiAgICAgIGNvbnN0IGxlbiA9IHZhbHVlcy5sZW5ndGhcblxuICAgICAgLy8gMTAuIElmIGluZGV4IGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byBsZW4sIHRoZW4gcmV0dXJuXG4gICAgICAvLyAgICAgQ3JlYXRlSXRlclJlc3VsdE9iamVjdCh1bmRlZmluZWQsIHRydWUpLlxuICAgICAgaWYgKGluZGV4ID49IGxlbikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIDExLiBMZXQgcGFpciBiZSB0aGUgZW50cnkgaW4gdmFsdWVzIGF0IGluZGV4IGluZGV4LlxuICAgICAgY29uc3QgeyBba2V5SW5kZXhdOiBrZXksIFt2YWx1ZUluZGV4XTogdmFsdWUgfSA9IHZhbHVlc1tpbmRleF1cblxuICAgICAgLy8gMTIuIFNldCBvYmplY3TigJlzIGluZGV4IHRvIGluZGV4ICsgMS5cbiAgICAgIHRoaXMuI2luZGV4ID0gaW5kZXggKyAxXG5cbiAgICAgIC8vIDEzLiBSZXR1cm4gdGhlIGl0ZXJhdG9yIHJlc3VsdCBmb3IgcGFpciBhbmQga2luZC5cblxuICAgICAgLy8gaHR0cHM6Ly93ZWJpZGwuc3BlYy53aGF0d2cub3JnLyNpdGVyYXRvci1yZXN1bHRcblxuICAgICAgLy8gMS4gTGV0IHJlc3VsdCBiZSBhIHZhbHVlIGRldGVybWluZWQgYnkgdGhlIHZhbHVlIG9mIGtpbmQ6XG4gICAgICBsZXQgcmVzdWx0XG4gICAgICBzd2l0Y2ggKHRoaXMuI2tpbmQpIHtcbiAgICAgICAgY2FzZSAna2V5JzpcbiAgICAgICAgICAvLyAxLiBMZXQgaWRsS2V5IGJlIHBhaXLigJlzIGtleS5cbiAgICAgICAgICAvLyAyLiBMZXQga2V5IGJlIHRoZSByZXN1bHQgb2YgY29udmVydGluZyBpZGxLZXkgdG8gYW5cbiAgICAgICAgICAvLyAgICBFQ01BU2NyaXB0IHZhbHVlLlxuICAgICAgICAgIC8vIDMuIHJlc3VsdCBpcyBrZXkuXG4gICAgICAgICAgcmVzdWx0ID0ga2V5XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAndmFsdWUnOlxuICAgICAgICAgIC8vIDEuIExldCBpZGxWYWx1ZSBiZSBwYWly4oCZcyB2YWx1ZS5cbiAgICAgICAgICAvLyAyLiBMZXQgdmFsdWUgYmUgdGhlIHJlc3VsdCBvZiBjb252ZXJ0aW5nIGlkbFZhbHVlIHRvXG4gICAgICAgICAgLy8gICAgYW4gRUNNQVNjcmlwdCB2YWx1ZS5cbiAgICAgICAgICAvLyAzLiByZXN1bHQgaXMgdmFsdWUuXG4gICAgICAgICAgcmVzdWx0ID0gdmFsdWVcbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlICdrZXkrdmFsdWUnOlxuICAgICAgICAgIC8vIDEuIExldCBpZGxLZXkgYmUgcGFpcuKAmXMga2V5LlxuICAgICAgICAgIC8vIDIuIExldCBpZGxWYWx1ZSBiZSBwYWly4oCZcyB2YWx1ZS5cbiAgICAgICAgICAvLyAzLiBMZXQga2V5IGJlIHRoZSByZXN1bHQgb2YgY29udmVydGluZyBpZGxLZXkgdG8gYW5cbiAgICAgICAgICAvLyAgICBFQ01BU2NyaXB0IHZhbHVlLlxuICAgICAgICAgIC8vIDQuIExldCB2YWx1ZSBiZSB0aGUgcmVzdWx0IG9mIGNvbnZlcnRpbmcgaWRsVmFsdWUgdG9cbiAgICAgICAgICAvLyAgICBhbiBFQ01BU2NyaXB0IHZhbHVlLlxuICAgICAgICAgIC8vIDUuIExldCBhcnJheSBiZSAhIEFycmF5Q3JlYXRlKDIpLlxuICAgICAgICAgIC8vIDYuIENhbGwgISBDcmVhdGVEYXRhUHJvcGVydHkoYXJyYXksIFwiMFwiLCBrZXkpLlxuICAgICAgICAgIC8vIDcuIENhbGwgISBDcmVhdGVEYXRhUHJvcGVydHkoYXJyYXksIFwiMVwiLCB2YWx1ZSkuXG4gICAgICAgICAgLy8gOC4gcmVzdWx0IGlzIGFycmF5LlxuICAgICAgICAgIHJlc3VsdCA9IFtrZXksIHZhbHVlXVxuICAgICAgICAgIGJyZWFrXG4gICAgICB9XG5cbiAgICAgIC8vIDIuIFJldHVybiBDcmVhdGVJdGVyUmVzdWx0T2JqZWN0KHJlc3VsdCwgZmFsc2UpLlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IHJlc3VsdCxcbiAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBodHRwczovL3dlYmlkbC5zcGVjLndoYXR3Zy5vcmcvI2Rmbi1pdGVyYXRvci1wcm90b3R5cGUtb2JqZWN0XG4gIC8vIEB0cy1pZ25vcmVcbiAgZGVsZXRlIEZhc3RJdGVyYWJsZUl0ZXJhdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvclxuXG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihGYXN0SXRlcmFibGVJdGVyYXRvci5wcm90b3R5cGUsIGVzSXRlcmF0b3JQcm90b3R5cGUpXG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoRmFzdEl0ZXJhYmxlSXRlcmF0b3IucHJvdG90eXBlLCB7XG4gICAgW1N5bWJvbC50b1N0cmluZ1RhZ106IHtcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IGAke25hbWV9IEl0ZXJhdG9yYFxuICAgIH0sXG4gICAgbmV4dDogeyB3cml0YWJsZTogdHJ1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH1cbiAgfSlcblxuICAvKipcbiAgICogQHBhcmFtIHt1bmtub3dufSB0YXJnZXRcbiAgICogQHBhcmFtIHsna2V5JyB8ICd2YWx1ZScgfCAna2V5K3ZhbHVlJ30ga2luZFxuICAgKiBAcmV0dXJucyB7SXRlcmFibGVJdGVyYXRvcjxhbnk+fVxuICAgKi9cbiAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtpbmQpIHtcbiAgICByZXR1cm4gbmV3IEZhc3RJdGVyYWJsZUl0ZXJhdG9yKHRhcmdldCwga2luZClcbiAgfVxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly93ZWJpZGwuc3BlYy53aGF0d2cub3JnLyNkZm4taXRlcmF0b3ItcHJvdG90eXBlLW9iamVjdFxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgbmFtZSBvZiB0aGUgaW5zdGFuY2VcbiAqIEBwYXJhbSB7YW55fSBvYmplY3QgY2xhc3NcbiAqIEBwYXJhbSB7c3ltYm9sfSBrSW50ZXJuYWxJdGVyYXRvclxuICogQHBhcmFtIHtzdHJpbmcgfCBudW1iZXJ9IFtrZXlJbmRleF1cbiAqIEBwYXJhbSB7c3RyaW5nIHwgbnVtYmVyfSBbdmFsdWVJbmRleF1cbiAqL1xuZnVuY3Rpb24gaXRlcmF0b3JNaXhpbiAobmFtZSwgb2JqZWN0LCBrSW50ZXJuYWxJdGVyYXRvciwga2V5SW5kZXggPSAwLCB2YWx1ZUluZGV4ID0gMSkge1xuICBjb25zdCBtYWtlSXRlcmF0b3IgPSBjcmVhdGVJdGVyYXRvcihuYW1lLCBrSW50ZXJuYWxJdGVyYXRvciwga2V5SW5kZXgsIHZhbHVlSW5kZXgpXG5cbiAgY29uc3QgcHJvcGVydGllcyA9IHtcbiAgICBrZXlzOiB7XG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24ga2V5cyAoKSB7XG4gICAgICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIG9iamVjdClcbiAgICAgICAgcmV0dXJuIG1ha2VJdGVyYXRvcih0aGlzLCAna2V5JylcbiAgICAgIH1cbiAgICB9LFxuICAgIHZhbHVlczoge1xuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlcyAoKSB7XG4gICAgICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIG9iamVjdClcbiAgICAgICAgcmV0dXJuIG1ha2VJdGVyYXRvcih0aGlzLCAndmFsdWUnKVxuICAgICAgfVxuICAgIH0sXG4gICAgZW50cmllczoge1xuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGVudHJpZXMgKCkge1xuICAgICAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBvYmplY3QpXG4gICAgICAgIHJldHVybiBtYWtlSXRlcmF0b3IodGhpcywgJ2tleSt2YWx1ZScpXG4gICAgICB9XG4gICAgfSxcbiAgICBmb3JFYWNoOiB7XG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZm9yRWFjaCAoY2FsbGJhY2tmbiwgdGhpc0FyZyA9IGdsb2JhbFRoaXMpIHtcbiAgICAgICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgb2JqZWN0KVxuICAgICAgICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDEsIGAke25hbWV9LmZvckVhY2hgKVxuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgYEZhaWxlZCB0byBleGVjdXRlICdmb3JFYWNoJyBvbiAnJHtuYW1lfSc6IHBhcmFtZXRlciAxIGlzIG5vdCBvZiB0eXBlICdGdW5jdGlvbicuYFxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHsgMDoga2V5LCAxOiB2YWx1ZSB9IG9mIG1ha2VJdGVyYXRvcih0aGlzLCAna2V5K3ZhbHVlJykpIHtcbiAgICAgICAgICBjYWxsYmFja2ZuLmNhbGwodGhpc0FyZywgdmFsdWUsIGtleSwgdGhpcylcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhvYmplY3QucHJvdG90eXBlLCB7XG4gICAgLi4ucHJvcGVydGllcyxcbiAgICBbU3ltYm9sLml0ZXJhdG9yXToge1xuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBwcm9wZXJ0aWVzLmVudHJpZXMudmFsdWVcbiAgICB9XG4gIH0pXG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jYm9keS1mdWxseS1yZWFkXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGZ1bGx5UmVhZEJvZHkgKGJvZHksIHByb2Nlc3NCb2R5LCBwcm9jZXNzQm9keUVycm9yKSB7XG4gIC8vIDEuIElmIHRhc2tEZXN0aW5hdGlvbiBpcyBudWxsLCB0aGVuIHNldCB0YXNrRGVzdGluYXRpb24gdG9cbiAgLy8gICAgdGhlIHJlc3VsdCBvZiBzdGFydGluZyBhIG5ldyBwYXJhbGxlbCBxdWV1ZS5cblxuICAvLyAyLiBMZXQgc3VjY2Vzc1N0ZXBzIGdpdmVuIGEgYnl0ZSBzZXF1ZW5jZSBieXRlcyBiZSB0byBxdWV1ZSBhXG4gIC8vICAgIGZldGNoIHRhc2sgdG8gcnVuIHByb2Nlc3NCb2R5IGdpdmVuIGJ5dGVzLCB3aXRoIHRhc2tEZXN0aW5hdGlvbi5cbiAgY29uc3Qgc3VjY2Vzc1N0ZXBzID0gcHJvY2Vzc0JvZHlcblxuICAvLyAzLiBMZXQgZXJyb3JTdGVwcyBiZSB0byBxdWV1ZSBhIGZldGNoIHRhc2sgdG8gcnVuIHByb2Nlc3NCb2R5RXJyb3IsXG4gIC8vICAgIHdpdGggdGFza0Rlc3RpbmF0aW9uLlxuICBjb25zdCBlcnJvclN0ZXBzID0gcHJvY2Vzc0JvZHlFcnJvclxuXG4gIC8vIDQuIExldCByZWFkZXIgYmUgdGhlIHJlc3VsdCBvZiBnZXR0aW5nIGEgcmVhZGVyIGZvciBib2R54oCZcyBzdHJlYW0uXG4gIC8vICAgIElmIHRoYXQgdGhyZXcgYW4gZXhjZXB0aW9uLCB0aGVuIHJ1biBlcnJvclN0ZXBzIHdpdGggdGhhdFxuICAvLyAgICBleGNlcHRpb24gYW5kIHJldHVybi5cbiAgbGV0IHJlYWRlclxuXG4gIHRyeSB7XG4gICAgcmVhZGVyID0gYm9keS5zdHJlYW0uZ2V0UmVhZGVyKClcbiAgfSBjYXRjaCAoZSkge1xuICAgIGVycm9yU3RlcHMoZSlcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIDUuIFJlYWQgYWxsIGJ5dGVzIGZyb20gcmVhZGVyLCBnaXZlbiBzdWNjZXNzU3RlcHMgYW5kIGVycm9yU3RlcHMuXG4gIHRyeSB7XG4gICAgc3VjY2Vzc1N0ZXBzKGF3YWl0IHJlYWRBbGxCeXRlcyhyZWFkZXIpKVxuICB9IGNhdGNoIChlKSB7XG4gICAgZXJyb3JTdGVwcyhlKVxuICB9XG59XG5cbmZ1bmN0aW9uIGlzUmVhZGFibGVTdHJlYW1MaWtlIChzdHJlYW0pIHtcbiAgcmV0dXJuIHN0cmVhbSBpbnN0YW5jZW9mIFJlYWRhYmxlU3RyZWFtIHx8IChcbiAgICBzdHJlYW1bU3ltYm9sLnRvU3RyaW5nVGFnXSA9PT0gJ1JlYWRhYmxlU3RyZWFtJyAmJlxuICAgIHR5cGVvZiBzdHJlYW0udGVlID09PSAnZnVuY3Rpb24nXG4gIClcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcjxVaW50OEFycmF5Pn0gY29udHJvbGxlclxuICovXG5mdW5jdGlvbiByZWFkYWJsZVN0cmVhbUNsb3NlIChjb250cm9sbGVyKSB7XG4gIHRyeSB7XG4gICAgY29udHJvbGxlci5jbG9zZSgpXG4gICAgY29udHJvbGxlci5ieW9iUmVxdWVzdD8ucmVzcG9uZCgwKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyBUT0RPOiBhZGQgY29tbWVudCBleHBsYWluaW5nIHdoeSB0aGlzIGVycm9yIG9jY3Vycy5cbiAgICBpZiAoIWVyci5tZXNzYWdlLmluY2x1ZGVzKCdDb250cm9sbGVyIGlzIGFscmVhZHkgY2xvc2VkJykgJiYgIWVyci5tZXNzYWdlLmluY2x1ZGVzKCdSZWFkYWJsZVN0cmVhbSBpcyBhbHJlYWR5IGNsb3NlZCcpKSB7XG4gICAgICB0aHJvdyBlcnJcbiAgICB9XG4gIH1cbn1cblxuY29uc3QgaW52YWxpZElzb21vcnBoaWNFbmNvZGVWYWx1ZVJlZ2V4ID0gL1teXFx4MDAtXFx4RkZdLyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbi8qKlxuICogQHNlZSBodHRwczovL2luZnJhLnNwZWMud2hhdHdnLm9yZy8jaXNvbW9ycGhpYy1lbmNvZGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dFxuICovXG5mdW5jdGlvbiBpc29tb3JwaGljRW5jb2RlIChpbnB1dCkge1xuICAvLyAxLiBBc3NlcnQ6IGlucHV0IGNvbnRhaW5zIG5vIGNvZGUgcG9pbnRzIGdyZWF0ZXIgdGhhbiBVKzAwRkYuXG4gIGFzc2VydCghaW52YWxpZElzb21vcnBoaWNFbmNvZGVWYWx1ZVJlZ2V4LnRlc3QoaW5wdXQpKVxuXG4gIC8vIDIuIFJldHVybiBhIGJ5dGUgc2VxdWVuY2Ugd2hvc2UgbGVuZ3RoIGlzIGVxdWFsIHRvIGlucHV04oCZcyBjb2RlXG4gIC8vICAgIHBvaW50IGxlbmd0aCBhbmQgd2hvc2UgYnl0ZXMgaGF2ZSB0aGUgc2FtZSB2YWx1ZXMgYXMgdGhlXG4gIC8vICAgIHZhbHVlcyBvZiBpbnB1dOKAmXMgY29kZSBwb2ludHMsIGluIHRoZSBzYW1lIG9yZGVyXG4gIHJldHVybiBpbnB1dFxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9zdHJlYW1zLnNwZWMud2hhdHdnLm9yZy8jcmVhZGFibGVzdHJlYW1kZWZhdWx0cmVhZGVyLXJlYWQtYWxsLWJ5dGVzXG4gKiBAc2VlIGh0dHBzOi8vc3RyZWFtcy5zcGVjLndoYXR3Zy5vcmcvI3JlYWQtbG9vcFxuICogQHBhcmFtIHtSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXJ9IHJlYWRlclxuICovXG5hc3luYyBmdW5jdGlvbiByZWFkQWxsQnl0ZXMgKHJlYWRlcikge1xuICBjb25zdCBieXRlcyA9IFtdXG4gIGxldCBieXRlTGVuZ3RoID0gMFxuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgY29uc3QgeyBkb25lLCB2YWx1ZTogY2h1bmsgfSA9IGF3YWl0IHJlYWRlci5yZWFkKClcblxuICAgIGlmIChkb25lKSB7XG4gICAgICAvLyAxLiBDYWxsIHN1Y2Nlc3NTdGVwcyB3aXRoIGJ5dGVzLlxuICAgICAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoYnl0ZXMsIGJ5dGVMZW5ndGgpXG4gICAgfVxuXG4gICAgLy8gMS4gSWYgY2h1bmsgaXMgbm90IGEgVWludDhBcnJheSBvYmplY3QsIGNhbGwgZmFpbHVyZVN0ZXBzXG4gICAgLy8gICAgd2l0aCBhIFR5cGVFcnJvciBhbmQgYWJvcnQgdGhlc2Ugc3RlcHMuXG4gICAgaWYgKCFpc1VpbnQ4QXJyYXkoY2h1bmspKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdSZWNlaXZlZCBub24tVWludDhBcnJheSBjaHVuaycpXG4gICAgfVxuXG4gICAgLy8gMi4gQXBwZW5kIHRoZSBieXRlcyByZXByZXNlbnRlZCBieSBjaHVuayB0byBieXRlcy5cbiAgICBieXRlcy5wdXNoKGNodW5rKVxuICAgIGJ5dGVMZW5ndGggKz0gY2h1bmsubGVuZ3RoXG5cbiAgICAvLyAzLiBSZWFkLWxvb3AgZ2l2ZW4gcmVhZGVyLCBieXRlcywgc3VjY2Vzc1N0ZXBzLCBhbmQgZmFpbHVyZVN0ZXBzLlxuICB9XG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jaXMtbG9jYWxcbiAqIEBwYXJhbSB7VVJMfSB1cmxcbiAqL1xuZnVuY3Rpb24gdXJsSXNMb2NhbCAodXJsKSB7XG4gIGFzc2VydCgncHJvdG9jb2wnIGluIHVybCkgLy8gZW5zdXJlIGl0J3MgYSB1cmwgb2JqZWN0XG5cbiAgY29uc3QgcHJvdG9jb2wgPSB1cmwucHJvdG9jb2xcblxuICByZXR1cm4gcHJvdG9jb2wgPT09ICdhYm91dDonIHx8IHByb3RvY29sID09PSAnYmxvYjonIHx8IHByb3RvY29sID09PSAnZGF0YTonXG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd8VVJMfSB1cmxcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiB1cmxIYXNIdHRwc1NjaGVtZSAodXJsKSB7XG4gIHJldHVybiAoXG4gICAgKFxuICAgICAgdHlwZW9mIHVybCA9PT0gJ3N0cmluZycgJiZcbiAgICAgIHVybFs1XSA9PT0gJzonICYmXG4gICAgICB1cmxbMF0gPT09ICdoJyAmJlxuICAgICAgdXJsWzFdID09PSAndCcgJiZcbiAgICAgIHVybFsyXSA9PT0gJ3QnICYmXG4gICAgICB1cmxbM10gPT09ICdwJyAmJlxuICAgICAgdXJsWzRdID09PSAncydcbiAgICApIHx8XG4gICAgdXJsLnByb3RvY29sID09PSAnaHR0cHM6J1xuICApXG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jaHR0cC1zY2hlbWVcbiAqIEBwYXJhbSB7VVJMfSB1cmxcbiAqL1xuZnVuY3Rpb24gdXJsSXNIdHRwSHR0cHNTY2hlbWUgKHVybCkge1xuICBhc3NlcnQoJ3Byb3RvY29sJyBpbiB1cmwpIC8vIGVuc3VyZSBpdCdzIGEgdXJsIG9iamVjdFxuXG4gIGNvbnN0IHByb3RvY29sID0gdXJsLnByb3RvY29sXG5cbiAgcmV0dXJuIHByb3RvY29sID09PSAnaHR0cDonIHx8IHByb3RvY29sID09PSAnaHR0cHM6J1xufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI3NpbXBsZS1yYW5nZS1oZWFkZXItdmFsdWVcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICogQHBhcmFtIHtib29sZWFufSBhbGxvd1doaXRlc3BhY2VcbiAqL1xuZnVuY3Rpb24gc2ltcGxlUmFuZ2VIZWFkZXJWYWx1ZSAodmFsdWUsIGFsbG93V2hpdGVzcGFjZSkge1xuICAvLyAxLiBMZXQgZGF0YSBiZSB0aGUgaXNvbW9ycGhpYyBkZWNvZGluZyBvZiB2YWx1ZS5cbiAgLy8gTm90ZTogaXNvbW9ycGhpYyBkZWNvZGluZyB0YWtlcyBhIHNlcXVlbmNlIG9mIGJ5dGVzIChpZS4gYSBVaW50OEFycmF5KSBhbmQgdHVybnMgaXQgaW50byBhIHN0cmluZyxcbiAgLy8gbm90aGluZyBtb3JlLiBXZSBvYnZpb3VzbHkgZG9uJ3QgbmVlZCB0byBkbyB0aGF0IGlmIHZhbHVlIGlzIGEgc3RyaW5nIGFscmVhZHkuXG4gIGNvbnN0IGRhdGEgPSB2YWx1ZVxuXG4gIC8vIDIuIElmIGRhdGEgZG9lcyBub3Qgc3RhcnQgd2l0aCBcImJ5dGVzXCIsIHRoZW4gcmV0dXJuIGZhaWx1cmUuXG4gIGlmICghZGF0YS5zdGFydHNXaXRoKCdieXRlcycpKSB7XG4gICAgcmV0dXJuICdmYWlsdXJlJ1xuICB9XG5cbiAgLy8gMy4gTGV0IHBvc2l0aW9uIGJlIGEgcG9zaXRpb24gdmFyaWFibGUgZm9yIGRhdGEsIGluaXRpYWxseSBwb2ludGluZyBhdCB0aGUgNXRoIGNvZGUgcG9pbnQgb2YgZGF0YS5cbiAgY29uc3QgcG9zaXRpb24gPSB7IHBvc2l0aW9uOiA1IH1cblxuICAvLyA0LiBJZiBhbGxvd1doaXRlc3BhY2UgaXMgdHJ1ZSwgY29sbGVjdCBhIHNlcXVlbmNlIG9mIGNvZGUgcG9pbnRzIHRoYXQgYXJlIEhUVFAgdGFiIG9yIHNwYWNlLFxuICAvLyAgICBmcm9tIGRhdGEgZ2l2ZW4gcG9zaXRpb24uXG4gIGlmIChhbGxvd1doaXRlc3BhY2UpIHtcbiAgICBjb2xsZWN0QVNlcXVlbmNlT2ZDb2RlUG9pbnRzKFxuICAgICAgKGNoYXIpID0+IGNoYXIgPT09ICdcXHQnIHx8IGNoYXIgPT09ICcgJyxcbiAgICAgIGRhdGEsXG4gICAgICBwb3NpdGlvblxuICAgIClcbiAgfVxuXG4gIC8vIDUuIElmIHRoZSBjb2RlIHBvaW50IGF0IHBvc2l0aW9uIHdpdGhpbiBkYXRhIGlzIG5vdCBVKzAwM0QgKD0pLCB0aGVuIHJldHVybiBmYWlsdXJlLlxuICBpZiAoZGF0YS5jaGFyQ29kZUF0KHBvc2l0aW9uLnBvc2l0aW9uKSAhPT0gMHgzRCkge1xuICAgIHJldHVybiAnZmFpbHVyZSdcbiAgfVxuXG4gIC8vIDYuIEFkdmFuY2UgcG9zaXRpb24gYnkgMS5cbiAgcG9zaXRpb24ucG9zaXRpb24rK1xuXG4gIC8vIDcuIElmIGFsbG93V2hpdGVzcGFjZSBpcyB0cnVlLCBjb2xsZWN0IGEgc2VxdWVuY2Ugb2YgY29kZSBwb2ludHMgdGhhdCBhcmUgSFRUUCB0YWIgb3Igc3BhY2UsIGZyb21cbiAgLy8gICAgZGF0YSBnaXZlbiBwb3NpdGlvbi5cbiAgaWYgKGFsbG93V2hpdGVzcGFjZSkge1xuICAgIGNvbGxlY3RBU2VxdWVuY2VPZkNvZGVQb2ludHMoXG4gICAgICAoY2hhcikgPT4gY2hhciA9PT0gJ1xcdCcgfHwgY2hhciA9PT0gJyAnLFxuICAgICAgZGF0YSxcbiAgICAgIHBvc2l0aW9uXG4gICAgKVxuICB9XG5cbiAgLy8gOC4gTGV0IHJhbmdlU3RhcnQgYmUgdGhlIHJlc3VsdCBvZiBjb2xsZWN0aW5nIGEgc2VxdWVuY2Ugb2YgY29kZSBwb2ludHMgdGhhdCBhcmUgQVNDSUkgZGlnaXRzLFxuICAvLyAgICBmcm9tIGRhdGEgZ2l2ZW4gcG9zaXRpb24uXG4gIGNvbnN0IHJhbmdlU3RhcnQgPSBjb2xsZWN0QVNlcXVlbmNlT2ZDb2RlUG9pbnRzKFxuICAgIChjaGFyKSA9PiB7XG4gICAgICBjb25zdCBjb2RlID0gY2hhci5jaGFyQ29kZUF0KDApXG5cbiAgICAgIHJldHVybiBjb2RlID49IDB4MzAgJiYgY29kZSA8PSAweDM5XG4gICAgfSxcbiAgICBkYXRhLFxuICAgIHBvc2l0aW9uXG4gIClcblxuICAvLyA5LiBMZXQgcmFuZ2VTdGFydFZhbHVlIGJlIHJhbmdlU3RhcnQsIGludGVycHJldGVkIGFzIGRlY2ltYWwgbnVtYmVyLCBpZiByYW5nZVN0YXJ0IGlzIG5vdCB0aGVcbiAgLy8gICAgZW1wdHkgc3RyaW5nOyBvdGhlcndpc2UgbnVsbC5cbiAgY29uc3QgcmFuZ2VTdGFydFZhbHVlID0gcmFuZ2VTdGFydC5sZW5ndGggPyBOdW1iZXIocmFuZ2VTdGFydCkgOiBudWxsXG5cbiAgLy8gMTAuIElmIGFsbG93V2hpdGVzcGFjZSBpcyB0cnVlLCBjb2xsZWN0IGEgc2VxdWVuY2Ugb2YgY29kZSBwb2ludHMgdGhhdCBhcmUgSFRUUCB0YWIgb3Igc3BhY2UsXG4gIC8vICAgICBmcm9tIGRhdGEgZ2l2ZW4gcG9zaXRpb24uXG4gIGlmIChhbGxvd1doaXRlc3BhY2UpIHtcbiAgICBjb2xsZWN0QVNlcXVlbmNlT2ZDb2RlUG9pbnRzKFxuICAgICAgKGNoYXIpID0+IGNoYXIgPT09ICdcXHQnIHx8IGNoYXIgPT09ICcgJyxcbiAgICAgIGRhdGEsXG4gICAgICBwb3NpdGlvblxuICAgIClcbiAgfVxuXG4gIC8vIDExLiBJZiB0aGUgY29kZSBwb2ludCBhdCBwb3NpdGlvbiB3aXRoaW4gZGF0YSBpcyBub3QgVSswMDJEICgtKSwgdGhlbiByZXR1cm4gZmFpbHVyZS5cbiAgaWYgKGRhdGEuY2hhckNvZGVBdChwb3NpdGlvbi5wb3NpdGlvbikgIT09IDB4MkQpIHtcbiAgICByZXR1cm4gJ2ZhaWx1cmUnXG4gIH1cblxuICAvLyAxMi4gQWR2YW5jZSBwb3NpdGlvbiBieSAxLlxuICBwb3NpdGlvbi5wb3NpdGlvbisrXG5cbiAgLy8gMTMuIElmIGFsbG93V2hpdGVzcGFjZSBpcyB0cnVlLCBjb2xsZWN0IGEgc2VxdWVuY2Ugb2YgY29kZSBwb2ludHMgdGhhdCBhcmUgSFRUUCB0YWJcbiAgLy8gICAgIG9yIHNwYWNlLCBmcm9tIGRhdGEgZ2l2ZW4gcG9zaXRpb24uXG4gIC8vIE5vdGUgZnJvbSBLaGFmcmE6IGl0cyB0aGUgc2FtZSBzdGVwIGFzIGluICM4IGFnYWluIGxvbFxuICBpZiAoYWxsb3dXaGl0ZXNwYWNlKSB7XG4gICAgY29sbGVjdEFTZXF1ZW5jZU9mQ29kZVBvaW50cyhcbiAgICAgIChjaGFyKSA9PiBjaGFyID09PSAnXFx0JyB8fCBjaGFyID09PSAnICcsXG4gICAgICBkYXRhLFxuICAgICAgcG9zaXRpb25cbiAgICApXG4gIH1cblxuICAvLyAxNC4gTGV0IHJhbmdlRW5kIGJlIHRoZSByZXN1bHQgb2YgY29sbGVjdGluZyBhIHNlcXVlbmNlIG9mIGNvZGUgcG9pbnRzIHRoYXQgYXJlXG4gIC8vICAgICBBU0NJSSBkaWdpdHMsIGZyb20gZGF0YSBnaXZlbiBwb3NpdGlvbi5cbiAgLy8gTm90ZSBmcm9tIEtoYWZyYTogeW91IHdvdWxkbid0IGd1ZXNzIGl0LCBidXQgdGhpcyBpcyBhbHNvIHRoZSBzYW1lIHN0ZXAgYXMgIzhcbiAgY29uc3QgcmFuZ2VFbmQgPSBjb2xsZWN0QVNlcXVlbmNlT2ZDb2RlUG9pbnRzKFxuICAgIChjaGFyKSA9PiB7XG4gICAgICBjb25zdCBjb2RlID0gY2hhci5jaGFyQ29kZUF0KDApXG5cbiAgICAgIHJldHVybiBjb2RlID49IDB4MzAgJiYgY29kZSA8PSAweDM5XG4gICAgfSxcbiAgICBkYXRhLFxuICAgIHBvc2l0aW9uXG4gIClcblxuICAvLyAxNS4gTGV0IHJhbmdlRW5kVmFsdWUgYmUgcmFuZ2VFbmQsIGludGVycHJldGVkIGFzIGRlY2ltYWwgbnVtYmVyLCBpZiByYW5nZUVuZFxuICAvLyAgICAgaXMgbm90IHRoZSBlbXB0eSBzdHJpbmc7IG90aGVyd2lzZSBudWxsLlxuICAvLyBOb3RlIGZyb20gS2hhZnJhOiBUSEUgU0FNRSBTVEVQLCBBR0FJTiEhIVxuICAvLyBOb3RlOiB3aHkgaW50ZXJwcmV0IGFzIGEgZGVjaW1hbCBpZiB3ZSBvbmx5IGNvbGxlY3QgYXNjaWkgZGlnaXRzP1xuICBjb25zdCByYW5nZUVuZFZhbHVlID0gcmFuZ2VFbmQubGVuZ3RoID8gTnVtYmVyKHJhbmdlRW5kKSA6IG51bGxcblxuICAvLyAxNi4gSWYgcG9zaXRpb24gaXMgbm90IHBhc3QgdGhlIGVuZCBvZiBkYXRhLCB0aGVuIHJldHVybiBmYWlsdXJlLlxuICBpZiAocG9zaXRpb24ucG9zaXRpb24gPCBkYXRhLmxlbmd0aCkge1xuICAgIHJldHVybiAnZmFpbHVyZSdcbiAgfVxuXG4gIC8vIDE3LiBJZiByYW5nZUVuZFZhbHVlIGFuZCByYW5nZVN0YXJ0VmFsdWUgYXJlIG51bGwsIHRoZW4gcmV0dXJuIGZhaWx1cmUuXG4gIGlmIChyYW5nZUVuZFZhbHVlID09PSBudWxsICYmIHJhbmdlU3RhcnRWYWx1ZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiAnZmFpbHVyZSdcbiAgfVxuXG4gIC8vIDE4LiBJZiByYW5nZVN0YXJ0VmFsdWUgYW5kIHJhbmdlRW5kVmFsdWUgYXJlIG51bWJlcnMsIGFuZCByYW5nZVN0YXJ0VmFsdWUgaXNcbiAgLy8gICAgIGdyZWF0ZXIgdGhhbiByYW5nZUVuZFZhbHVlLCB0aGVuIHJldHVybiBmYWlsdXJlLlxuICAvLyBOb3RlOiAuLi4gd2hlbiBjYW4gdGhleSBub3QgYmUgbnVtYmVycz9cbiAgaWYgKHJhbmdlU3RhcnRWYWx1ZSA+IHJhbmdlRW5kVmFsdWUpIHtcbiAgICByZXR1cm4gJ2ZhaWx1cmUnXG4gIH1cblxuICAvLyAxOS4gUmV0dXJuIChyYW5nZVN0YXJ0VmFsdWUsIHJhbmdlRW5kVmFsdWUpLlxuICByZXR1cm4geyByYW5nZVN0YXJ0VmFsdWUsIHJhbmdlRW5kVmFsdWUgfVxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2J1aWxkLWEtY29udGVudC1yYW5nZVxuICogQHBhcmFtIHtudW1iZXJ9IHJhbmdlU3RhcnRcbiAqIEBwYXJhbSB7bnVtYmVyfSByYW5nZUVuZFxuICogQHBhcmFtIHtudW1iZXJ9IGZ1bGxMZW5ndGhcbiAqL1xuZnVuY3Rpb24gYnVpbGRDb250ZW50UmFuZ2UgKHJhbmdlU3RhcnQsIHJhbmdlRW5kLCBmdWxsTGVuZ3RoKSB7XG4gIC8vIDEuIExldCBjb250ZW50UmFuZ2UgYmUgYGJ5dGVzIGAuXG4gIGxldCBjb250ZW50UmFuZ2UgPSAnYnl0ZXMgJ1xuXG4gIC8vIDIuIEFwcGVuZCByYW5nZVN0YXJ0LCBzZXJpYWxpemVkIGFuZCBpc29tb3JwaGljIGVuY29kZWQsIHRvIGNvbnRlbnRSYW5nZS5cbiAgY29udGVudFJhbmdlICs9IGlzb21vcnBoaWNFbmNvZGUoYCR7cmFuZ2VTdGFydH1gKVxuXG4gIC8vIDMuIEFwcGVuZCAweDJEICgtKSB0byBjb250ZW50UmFuZ2UuXG4gIGNvbnRlbnRSYW5nZSArPSAnLSdcblxuICAvLyA0LiBBcHBlbmQgcmFuZ2VFbmQsIHNlcmlhbGl6ZWQgYW5kIGlzb21vcnBoaWMgZW5jb2RlZCB0byBjb250ZW50UmFuZ2UuXG4gIGNvbnRlbnRSYW5nZSArPSBpc29tb3JwaGljRW5jb2RlKGAke3JhbmdlRW5kfWApXG5cbiAgLy8gNS4gQXBwZW5kIDB4MkYgKC8pIHRvIGNvbnRlbnRSYW5nZS5cbiAgY29udGVudFJhbmdlICs9ICcvJ1xuXG4gIC8vIDYuIEFwcGVuZCBmdWxsTGVuZ3RoLCBzZXJpYWxpemVkIGFuZCBpc29tb3JwaGljIGVuY29kZWQgdG8gY29udGVudFJhbmdlLlxuICBjb250ZW50UmFuZ2UgKz0gaXNvbW9ycGhpY0VuY29kZShgJHtmdWxsTGVuZ3RofWApXG5cbiAgLy8gNy4gUmV0dXJuIGNvbnRlbnRSYW5nZS5cbiAgcmV0dXJuIGNvbnRlbnRSYW5nZVxufVxuXG4vLyBBIFN0cmVhbSwgd2hpY2ggcGlwZXMgdGhlIHJlc3BvbnNlIHRvIHpsaWIuY3JlYXRlSW5mbGF0ZSgpIG9yXG4vLyB6bGliLmNyZWF0ZUluZmxhdGVSYXcoKSBkZXBlbmRpbmcgb24gdGhlIGZpcnN0IGJ5dGUgb2YgdGhlIEJ1ZmZlci5cbi8vIElmIHRoZSBsb3dlciBieXRlIG9mIHRoZSBmaXJzdCBieXRlIGlzIDB4MDgsIHRoZW4gdGhlIHN0cmVhbSBpc1xuLy8gaW50ZXJwcmV0ZWQgYXMgYSB6bGliIHN0cmVhbSwgb3RoZXJ3aXNlIGl0J3MgaW50ZXJwcmV0ZWQgYXMgYVxuLy8gcmF3IGRlZmxhdGUgc3RyZWFtLlxuY2xhc3MgSW5mbGF0ZVN0cmVhbSBleHRlbmRzIFRyYW5zZm9ybSB7XG4gIF90cmFuc2Zvcm0gKGNodW5rLCBlbmNvZGluZywgY2FsbGJhY2spIHtcbiAgICBpZiAoIXRoaXMuX2luZmxhdGVTdHJlYW0pIHtcbiAgICAgIGlmIChjaHVuay5sZW5ndGggPT09IDApIHtcbiAgICAgICAgY2FsbGJhY2soKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIHRoaXMuX2luZmxhdGVTdHJlYW0gPSAoY2h1bmtbMF0gJiAweDBGKSA9PT0gMHgwOFxuICAgICAgICA/IHpsaWIuY3JlYXRlSW5mbGF0ZSgpXG4gICAgICAgIDogemxpYi5jcmVhdGVJbmZsYXRlUmF3KClcblxuICAgICAgdGhpcy5faW5mbGF0ZVN0cmVhbS5vbignZGF0YScsIHRoaXMucHVzaC5iaW5kKHRoaXMpKVxuICAgICAgdGhpcy5faW5mbGF0ZVN0cmVhbS5vbignZW5kJywgKCkgPT4gdGhpcy5wdXNoKG51bGwpKVxuICAgICAgdGhpcy5faW5mbGF0ZVN0cmVhbS5vbignZXJyb3InLCAoZXJyKSA9PiB0aGlzLmRlc3Ryb3koZXJyKSlcbiAgICB9XG5cbiAgICB0aGlzLl9pbmZsYXRlU3RyZWFtLndyaXRlKGNodW5rLCBlbmNvZGluZywgY2FsbGJhY2spXG4gIH1cblxuICBfZmluYWwgKGNhbGxiYWNrKSB7XG4gICAgaWYgKHRoaXMuX2luZmxhdGVTdHJlYW0pIHtcbiAgICAgIHRoaXMuX2luZmxhdGVTdHJlYW0uZW5kKClcbiAgICAgIHRoaXMuX2luZmxhdGVTdHJlYW0gPSBudWxsXG4gICAgfVxuICAgIGNhbGxiYWNrKClcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVJbmZsYXRlICgpIHtcbiAgcmV0dXJuIG5ldyBJbmZsYXRlU3RyZWFtKClcbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LWhlYWRlci1leHRyYWN0LW1pbWUtdHlwZVxuICogQHBhcmFtIHtpbXBvcnQoJy4vaGVhZGVycycpLkhlYWRlcnNMaXN0fSBoZWFkZXJzXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RNaW1lVHlwZSAoaGVhZGVycykge1xuICAvLyAxLiBMZXQgY2hhcnNldCBiZSBudWxsLlxuICBsZXQgY2hhcnNldCA9IG51bGxcblxuICAvLyAyLiBMZXQgZXNzZW5jZSBiZSBudWxsLlxuICBsZXQgZXNzZW5jZSA9IG51bGxcblxuICAvLyAzLiBMZXQgbWltZVR5cGUgYmUgbnVsbC5cbiAgbGV0IG1pbWVUeXBlID0gbnVsbFxuXG4gIC8vIDQuIExldCB2YWx1ZXMgYmUgdGhlIHJlc3VsdCBvZiBnZXR0aW5nLCBkZWNvZGluZywgYW5kIHNwbGl0dGluZyBgQ29udGVudC1UeXBlYCBmcm9tIGhlYWRlcnMuXG4gIGNvbnN0IHZhbHVlcyA9IGdldERlY29kZVNwbGl0KCdjb250ZW50LXR5cGUnLCBoZWFkZXJzKVxuXG4gIC8vIDUuIElmIHZhbHVlcyBpcyBudWxsLCB0aGVuIHJldHVybiBmYWlsdXJlLlxuICBpZiAodmFsdWVzID09PSBudWxsKSB7XG4gICAgcmV0dXJuICdmYWlsdXJlJ1xuICB9XG5cbiAgLy8gNi4gRm9yIGVhY2ggdmFsdWUgb2YgdmFsdWVzOlxuICBmb3IgKGNvbnN0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgIC8vIDYuMS4gTGV0IHRlbXBvcmFyeU1pbWVUeXBlIGJlIHRoZSByZXN1bHQgb2YgcGFyc2luZyB2YWx1ZS5cbiAgICBjb25zdCB0ZW1wb3JhcnlNaW1lVHlwZSA9IHBhcnNlTUlNRVR5cGUodmFsdWUpXG5cbiAgICAvLyA2LjIuIElmIHRlbXBvcmFyeU1pbWVUeXBlIGlzIGZhaWx1cmUgb3IgaXRzIGVzc2VuY2UgaXMgXCIqLypcIiwgdGhlbiBjb250aW51ZS5cbiAgICBpZiAodGVtcG9yYXJ5TWltZVR5cGUgPT09ICdmYWlsdXJlJyB8fCB0ZW1wb3JhcnlNaW1lVHlwZS5lc3NlbmNlID09PSAnKi8qJykge1xuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICAvLyA2LjMuIFNldCBtaW1lVHlwZSB0byB0ZW1wb3JhcnlNaW1lVHlwZS5cbiAgICBtaW1lVHlwZSA9IHRlbXBvcmFyeU1pbWVUeXBlXG5cbiAgICAvLyA2LjQuIElmIG1pbWVUeXBl4oCZcyBlc3NlbmNlIGlzIG5vdCBlc3NlbmNlLCB0aGVuOlxuICAgIGlmIChtaW1lVHlwZS5lc3NlbmNlICE9PSBlc3NlbmNlKSB7XG4gICAgICAvLyA2LjQuMS4gU2V0IGNoYXJzZXQgdG8gbnVsbC5cbiAgICAgIGNoYXJzZXQgPSBudWxsXG5cbiAgICAgIC8vIDYuNC4yLiBJZiBtaW1lVHlwZeKAmXMgcGFyYW1ldGVyc1tcImNoYXJzZXRcIl0gZXhpc3RzLCB0aGVuIHNldCBjaGFyc2V0IHRvXG4gICAgICAvLyAgICAgICAgbWltZVR5cGXigJlzIHBhcmFtZXRlcnNbXCJjaGFyc2V0XCJdLlxuICAgICAgaWYgKG1pbWVUeXBlLnBhcmFtZXRlcnMuaGFzKCdjaGFyc2V0JykpIHtcbiAgICAgICAgY2hhcnNldCA9IG1pbWVUeXBlLnBhcmFtZXRlcnMuZ2V0KCdjaGFyc2V0JylcbiAgICAgIH1cblxuICAgICAgLy8gNi40LjMuIFNldCBlc3NlbmNlIHRvIG1pbWVUeXBl4oCZcyBlc3NlbmNlLlxuICAgICAgZXNzZW5jZSA9IG1pbWVUeXBlLmVzc2VuY2VcbiAgICB9IGVsc2UgaWYgKCFtaW1lVHlwZS5wYXJhbWV0ZXJzLmhhcygnY2hhcnNldCcpICYmIGNoYXJzZXQgIT09IG51bGwpIHtcbiAgICAgIC8vIDYuNS4gT3RoZXJ3aXNlLCBpZiBtaW1lVHlwZeKAmXMgcGFyYW1ldGVyc1tcImNoYXJzZXRcIl0gZG9lcyBub3QgZXhpc3QsIGFuZFxuICAgICAgLy8gICAgICBjaGFyc2V0IGlzIG5vbi1udWxsLCBzZXQgbWltZVR5cGXigJlzIHBhcmFtZXRlcnNbXCJjaGFyc2V0XCJdIHRvIGNoYXJzZXQuXG4gICAgICBtaW1lVHlwZS5wYXJhbWV0ZXJzLnNldCgnY2hhcnNldCcsIGNoYXJzZXQpXG4gICAgfVxuICB9XG5cbiAgLy8gNy4gSWYgbWltZVR5cGUgaXMgbnVsbCwgdGhlbiByZXR1cm4gZmFpbHVyZS5cbiAgaWYgKG1pbWVUeXBlID09IG51bGwpIHtcbiAgICByZXR1cm4gJ2ZhaWx1cmUnXG4gIH1cblxuICAvLyA4LiBSZXR1cm4gbWltZVR5cGUuXG4gIHJldHVybiBtaW1lVHlwZVxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2hlYWRlci12YWx1ZS1nZXQtZGVjb2RlLWFuZC1zcGxpdFxuICogQHBhcmFtIHtzdHJpbmd8bnVsbH0gdmFsdWVcbiAqL1xuZnVuY3Rpb24gZ2V0dGluZ0RlY29kaW5nU3BsaXR0aW5nICh2YWx1ZSkge1xuICAvLyAxLiBMZXQgaW5wdXQgYmUgdGhlIHJlc3VsdCBvZiBpc29tb3JwaGljIGRlY29kaW5nIHZhbHVlLlxuICBjb25zdCBpbnB1dCA9IHZhbHVlXG5cbiAgLy8gMi4gTGV0IHBvc2l0aW9uIGJlIGEgcG9zaXRpb24gdmFyaWFibGUgZm9yIGlucHV0LCBpbml0aWFsbHkgcG9pbnRpbmcgYXQgdGhlIHN0YXJ0IG9mIGlucHV0LlxuICBjb25zdCBwb3NpdGlvbiA9IHsgcG9zaXRpb246IDAgfVxuXG4gIC8vIDMuIExldCB2YWx1ZXMgYmUgYSBsaXN0IG9mIHN0cmluZ3MsIGluaXRpYWxseSBlbXB0eS5cbiAgY29uc3QgdmFsdWVzID0gW11cblxuICAvLyA0LiBMZXQgdGVtcG9yYXJ5VmFsdWUgYmUgdGhlIGVtcHR5IHN0cmluZy5cbiAgbGV0IHRlbXBvcmFyeVZhbHVlID0gJydcblxuICAvLyA1LiBXaGlsZSBwb3NpdGlvbiBpcyBub3QgcGFzdCB0aGUgZW5kIG9mIGlucHV0OlxuICB3aGlsZSAocG9zaXRpb24ucG9zaXRpb24gPCBpbnB1dC5sZW5ndGgpIHtcbiAgICAvLyA1LjEuIEFwcGVuZCB0aGUgcmVzdWx0IG9mIGNvbGxlY3RpbmcgYSBzZXF1ZW5jZSBvZiBjb2RlIHBvaW50cyB0aGF0IGFyZSBub3QgVSswMDIyIChcIilcbiAgICAvLyAgICAgIG9yIFUrMDAyQyAoLCkgZnJvbSBpbnB1dCwgZ2l2ZW4gcG9zaXRpb24sIHRvIHRlbXBvcmFyeVZhbHVlLlxuICAgIHRlbXBvcmFyeVZhbHVlICs9IGNvbGxlY3RBU2VxdWVuY2VPZkNvZGVQb2ludHMoXG4gICAgICAoY2hhcikgPT4gY2hhciAhPT0gJ1wiJyAmJiBjaGFyICE9PSAnLCcsXG4gICAgICBpbnB1dCxcbiAgICAgIHBvc2l0aW9uXG4gICAgKVxuXG4gICAgLy8gNS4yLiBJZiBwb3NpdGlvbiBpcyBub3QgcGFzdCB0aGUgZW5kIG9mIGlucHV0LCB0aGVuOlxuICAgIGlmIChwb3NpdGlvbi5wb3NpdGlvbiA8IGlucHV0Lmxlbmd0aCkge1xuICAgICAgLy8gNS4yLjEuIElmIHRoZSBjb2RlIHBvaW50IGF0IHBvc2l0aW9uIHdpdGhpbiBpbnB1dCBpcyBVKzAwMjIgKFwiKSwgdGhlbjpcbiAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBvc2l0aW9uLnBvc2l0aW9uKSA9PT0gMHgyMikge1xuICAgICAgICAvLyA1LjIuMS4xLiBBcHBlbmQgdGhlIHJlc3VsdCBvZiBjb2xsZWN0aW5nIGFuIEhUVFAgcXVvdGVkIHN0cmluZyBmcm9tIGlucHV0LCBnaXZlbiBwb3NpdGlvbiwgdG8gdGVtcG9yYXJ5VmFsdWUuXG4gICAgICAgIHRlbXBvcmFyeVZhbHVlICs9IGNvbGxlY3RBbkhUVFBRdW90ZWRTdHJpbmcoXG4gICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgcG9zaXRpb25cbiAgICAgICAgKVxuXG4gICAgICAgIC8vIDUuMi4xLjIuIElmIHBvc2l0aW9uIGlzIG5vdCBwYXN0IHRoZSBlbmQgb2YgaW5wdXQsIHRoZW4gY29udGludWUuXG4gICAgICAgIGlmIChwb3NpdGlvbi5wb3NpdGlvbiA8IGlucHV0Lmxlbmd0aCkge1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIDUuMi4yLiBPdGhlcndpc2U6XG5cbiAgICAgICAgLy8gNS4yLjIuMS4gQXNzZXJ0OiB0aGUgY29kZSBwb2ludCBhdCBwb3NpdGlvbiB3aXRoaW4gaW5wdXQgaXMgVSswMDJDICgsKS5cbiAgICAgICAgYXNzZXJ0KGlucHV0LmNoYXJDb2RlQXQocG9zaXRpb24ucG9zaXRpb24pID09PSAweDJDKVxuXG4gICAgICAgIC8vIDUuMi4yLjIuIEFkdmFuY2UgcG9zaXRpb24gYnkgMS5cbiAgICAgICAgcG9zaXRpb24ucG9zaXRpb24rK1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIDUuMy4gUmVtb3ZlIGFsbCBIVFRQIHRhYiBvciBzcGFjZSBmcm9tIHRoZSBzdGFydCBhbmQgZW5kIG9mIHRlbXBvcmFyeVZhbHVlLlxuICAgIHRlbXBvcmFyeVZhbHVlID0gcmVtb3ZlQ2hhcnModGVtcG9yYXJ5VmFsdWUsIHRydWUsIHRydWUsIChjaGFyKSA9PiBjaGFyID09PSAweDkgfHwgY2hhciA9PT0gMHgyMClcblxuICAgIC8vIDUuNC4gQXBwZW5kIHRlbXBvcmFyeVZhbHVlIHRvIHZhbHVlcy5cbiAgICB2YWx1ZXMucHVzaCh0ZW1wb3JhcnlWYWx1ZSlcblxuICAgIC8vIDUuNi4gU2V0IHRlbXBvcmFyeVZhbHVlIHRvIHRoZSBlbXB0eSBzdHJpbmcuXG4gICAgdGVtcG9yYXJ5VmFsdWUgPSAnJ1xuICB9XG5cbiAgLy8gNi4gUmV0dXJuIHZhbHVlcy5cbiAgcmV0dXJuIHZhbHVlc1xufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtaGVhZGVyLWxpc3QtZ2V0LWRlY29kZS1zcGxpdFxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgbG93ZXJjYXNlIGhlYWRlciBuYW1lXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9oZWFkZXJzJykuSGVhZGVyc0xpc3R9IGxpc3RcbiAqL1xuZnVuY3Rpb24gZ2V0RGVjb2RlU3BsaXQgKG5hbWUsIGxpc3QpIHtcbiAgLy8gMS4gTGV0IHZhbHVlIGJlIHRoZSByZXN1bHQgb2YgZ2V0dGluZyBuYW1lIGZyb20gbGlzdC5cbiAgY29uc3QgdmFsdWUgPSBsaXN0LmdldChuYW1lLCB0cnVlKVxuXG4gIC8vIDIuIElmIHZhbHVlIGlzIG51bGwsIHRoZW4gcmV0dXJuIG51bGwuXG4gIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICAvLyAzLiBSZXR1cm4gdGhlIHJlc3VsdCBvZiBnZXR0aW5nLCBkZWNvZGluZywgYW5kIHNwbGl0dGluZyB2YWx1ZS5cbiAgcmV0dXJuIGdldHRpbmdEZWNvZGluZ1NwbGl0dGluZyh2YWx1ZSlcbn1cblxuY29uc3QgdGV4dERlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9lbmNvZGluZy5zcGVjLndoYXR3Zy5vcmcvI3V0Zi04LWRlY29kZVxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZmZlclxuICovXG5mdW5jdGlvbiB1dGY4RGVjb2RlQnl0ZXMgKGJ1ZmZlcikge1xuICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgLy8gMS4gTGV0IGJ1ZmZlciBiZSB0aGUgcmVzdWx0IG9mIHBlZWtpbmcgdGhyZWUgYnl0ZXMgZnJvbVxuICAvLyAgICBpb1F1ZXVlLCBjb252ZXJ0ZWQgdG8gYSBieXRlIHNlcXVlbmNlLlxuXG4gIC8vIDIuIElmIGJ1ZmZlciBpcyAweEVGIDB4QkIgMHhCRiwgdGhlbiByZWFkIHRocmVlXG4gIC8vICAgIGJ5dGVzIGZyb20gaW9RdWV1ZS4gKERvIG5vdGhpbmcgd2l0aCB0aG9zZSBieXRlcy4pXG4gIGlmIChidWZmZXJbMF0gPT09IDB4RUYgJiYgYnVmZmVyWzFdID09PSAweEJCICYmIGJ1ZmZlclsyXSA9PT0gMHhCRikge1xuICAgIGJ1ZmZlciA9IGJ1ZmZlci5zdWJhcnJheSgzKVxuICB9XG5cbiAgLy8gMy4gUHJvY2VzcyBhIHF1ZXVlIHdpdGggYW4gaW5zdGFuY2Ugb2YgVVRGLTjigJlzXG4gIC8vICAgIGRlY29kZXIsIGlvUXVldWUsIG91dHB1dCwgYW5kIFwicmVwbGFjZW1lbnRcIi5cbiAgY29uc3Qgb3V0cHV0ID0gdGV4dERlY29kZXIuZGVjb2RlKGJ1ZmZlcilcblxuICAvLyA0LiBSZXR1cm4gb3V0cHV0LlxuICByZXR1cm4gb3V0cHV0XG59XG5cbmNsYXNzIEVudmlyb25tZW50U2V0dGluZ3NPYmplY3RCYXNlIHtcbiAgZ2V0IGJhc2VVcmwgKCkge1xuICAgIHJldHVybiBnZXRHbG9iYWxPcmlnaW4oKVxuICB9XG5cbiAgZ2V0IG9yaWdpbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuYmFzZVVybD8ub3JpZ2luXG4gIH1cblxuICBwb2xpY3lDb250YWluZXIgPSBtYWtlUG9saWN5Q29udGFpbmVyKClcbn1cblxuY2xhc3MgRW52aXJvbm1lbnRTZXR0aW5nc09iamVjdCB7XG4gIHNldHRpbmdzT2JqZWN0ID0gbmV3IEVudmlyb25tZW50U2V0dGluZ3NPYmplY3RCYXNlKClcbn1cblxuY29uc3QgZW52aXJvbm1lbnRTZXR0aW5nc09iamVjdCA9IG5ldyBFbnZpcm9ubWVudFNldHRpbmdzT2JqZWN0KClcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGlzQWJvcnRlZCxcbiAgaXNDYW5jZWxsZWQsXG4gIGlzVmFsaWRFbmNvZGVkVVJMLFxuICBjcmVhdGVEZWZlcnJlZFByb21pc2UsXG4gIFJlYWRhYmxlU3RyZWFtRnJvbSxcbiAgdHJ5VXBncmFkZVJlcXVlc3RUb0FQb3RlbnRpYWxseVRydXN0d29ydGh5VVJMLFxuICBjbGFtcEFuZENvYXJzZW5Db25uZWN0aW9uVGltaW5nSW5mbyxcbiAgY29hcnNlbmVkU2hhcmVkQ3VycmVudFRpbWUsXG4gIGRldGVybWluZVJlcXVlc3RzUmVmZXJyZXIsXG4gIG1ha2VQb2xpY3lDb250YWluZXIsXG4gIGNsb25lUG9saWN5Q29udGFpbmVyLFxuICBhcHBlbmRGZXRjaE1ldGFkYXRhLFxuICBhcHBlbmRSZXF1ZXN0T3JpZ2luSGVhZGVyLFxuICBUQU9DaGVjayxcbiAgY29yc0NoZWNrLFxuICBjcm9zc09yaWdpblJlc291cmNlUG9saWN5Q2hlY2ssXG4gIGNyZWF0ZU9wYXF1ZVRpbWluZ0luZm8sXG4gIHNldFJlcXVlc3RSZWZlcnJlclBvbGljeU9uUmVkaXJlY3QsXG4gIGlzVmFsaWRIVFRQVG9rZW4sXG4gIHJlcXVlc3RCYWRQb3J0LFxuICByZXF1ZXN0Q3VycmVudFVSTCxcbiAgcmVzcG9uc2VVUkwsXG4gIHJlc3BvbnNlTG9jYXRpb25VUkwsXG4gIGlzQmxvYkxpa2UsXG4gIGlzVVJMUG90ZW50aWFsbHlUcnVzdHdvcnRoeSxcbiAgaXNWYWxpZFJlYXNvblBocmFzZSxcbiAgc2FtZU9yaWdpbixcbiAgbm9ybWFsaXplTWV0aG9kLFxuICBzZXJpYWxpemVKYXZhc2NyaXB0VmFsdWVUb0pTT05TdHJpbmcsXG4gIGl0ZXJhdG9yTWl4aW4sXG4gIGNyZWF0ZUl0ZXJhdG9yLFxuICBpc1ZhbGlkSGVhZGVyTmFtZSxcbiAgaXNWYWxpZEhlYWRlclZhbHVlLFxuICBpc0Vycm9yTGlrZSxcbiAgZnVsbHlSZWFkQm9keSxcbiAgYnl0ZXNNYXRjaCxcbiAgaXNSZWFkYWJsZVN0cmVhbUxpa2UsXG4gIHJlYWRhYmxlU3RyZWFtQ2xvc2UsXG4gIGlzb21vcnBoaWNFbmNvZGUsXG4gIHVybElzTG9jYWwsXG4gIHVybEhhc0h0dHBzU2NoZW1lLFxuICB1cmxJc0h0dHBIdHRwc1NjaGVtZSxcbiAgcmVhZEFsbEJ5dGVzLFxuICBzaW1wbGVSYW5nZUhlYWRlclZhbHVlLFxuICBidWlsZENvbnRlbnRSYW5nZSxcbiAgcGFyc2VNZXRhZGF0YSxcbiAgY3JlYXRlSW5mbGF0ZSxcbiAgZXh0cmFjdE1pbWVUeXBlLFxuICBnZXREZWNvZGVTcGxpdCxcbiAgdXRmOERlY29kZUJ5dGVzLFxuICBlbnZpcm9ubWVudFNldHRpbmdzT2JqZWN0XG59XG4iXSwibmFtZXMiOlsiX2NoZWNrSW5SSFMiLCJlIiwiT2JqZWN0IiwiVHlwZUVycm9yIiwiVHJhbnNmb3JtIiwicmVxdWlyZSIsInpsaWIiLCJyZWRpcmVjdFN0YXR1c1NldCIsInJlZmVycmVyUG9saWN5U2V0IiwicmVmZXJyZXJQb2xpY3lUb2tlbnMiLCJiYWRQb3J0c1NldCIsImdldEdsb2JhbE9yaWdpbiIsImNvbGxlY3RBU2VxdWVuY2VPZkNvZGVQb2ludHMiLCJjb2xsZWN0QW5IVFRQUXVvdGVkU3RyaW5nIiwicmVtb3ZlQ2hhcnMiLCJwYXJzZU1JTUVUeXBlIiwicGVyZm9ybWFuY2UiLCJpc0Jsb2JMaWtlIiwiUmVhZGFibGVTdHJlYW1Gcm9tIiwiaXNWYWxpZEhUVFBUb2tlbiIsIm5vcm1hbGl6ZWRNZXRob2RSZWNvcmRzQmFzZSIsImFzc2VydCIsImlzVWludDhBcnJheSIsIndlYmlkbCIsInN1cHBvcnRlZEhhc2hlcyIsImNyeXB0byIsInBvc3NpYmxlUmVsZXZhbnRIYXNoZXMiLCJnZXRIYXNoZXMiLCJmaWx0ZXIiLCJoYXNoIiwiaW5jbHVkZXMiLCJyZXNwb25zZVVSTCIsInJlc3BvbnNlIiwidXJsTGlzdCIsImxlbmd0aCIsInRvU3RyaW5nIiwicmVzcG9uc2VMb2NhdGlvblVSTCIsInJlcXVlc3RGcmFnbWVudCIsImhhcyIsInN0YXR1cyIsImxvY2F0aW9uIiwiaGVhZGVyc0xpc3QiLCJnZXQiLCJpc1ZhbGlkSGVhZGVyVmFsdWUiLCJpc1ZhbGlkRW5jb2RlZFVSTCIsIm5vcm1hbGl6ZUJpbmFyeVN0cmluZ1RvVXRmOCIsIlVSTCIsInVybCIsImkiLCJjb2RlIiwiY2hhckNvZGVBdCIsInZhbHVlIiwiQnVmZmVyIiwiZnJvbSIsInJlcXVlc3RDdXJyZW50VVJMIiwicmVxdWVzdCIsInJlcXVlc3RCYWRQb3J0IiwidXJsSXNIdHRwSHR0cHNTY2hlbWUiLCJwb3J0IiwiaXNFcnJvckxpa2UiLCJvYmplY3QiLCJFcnJvciIsImNvbnN0cnVjdG9yIiwibmFtZSIsImlzVmFsaWRSZWFzb25QaHJhc2UiLCJzdGF0dXNUZXh0IiwiYyIsImlzVmFsaWRIZWFkZXJOYW1lIiwicG90ZW50aWFsVmFsdWUiLCJzZXRSZXF1ZXN0UmVmZXJyZXJQb2xpY3lPblJlZGlyZWN0IiwiYWN0dWFsUmVzcG9uc2UiLCJwb2xpY3lIZWFkZXIiLCJzcGxpdCIsInBvbGljeSIsInRva2VuIiwidHJpbSIsInJlZmVycmVyUG9saWN5IiwiY3Jvc3NPcmlnaW5SZXNvdXJjZVBvbGljeUNoZWNrIiwiY29yc0NoZWNrIiwiVEFPQ2hlY2siLCJhcHBlbmRGZXRjaE1ldGFkYXRhIiwiaHR0cFJlcXVlc3QiLCJoZWFkZXIiLCJtb2RlIiwic2V0IiwiYXBwZW5kUmVxdWVzdE9yaWdpbkhlYWRlciIsInNlcmlhbGl6ZWRPcmlnaW4iLCJvcmlnaW4iLCJ1bmRlZmluZWQiLCJyZXNwb25zZVRhaW50aW5nIiwiYXBwZW5kIiwibWV0aG9kIiwidXJsSGFzSHR0cHNTY2hlbWUiLCJzYW1lT3JpZ2luIiwiY29hcnNlblRpbWUiLCJ0aW1lc3RhbXAiLCJjcm9zc09yaWdpbklzb2xhdGVkQ2FwYWJpbGl0eSIsImNsYW1wQW5kQ29hcnNlbkNvbm5lY3Rpb25UaW1pbmdJbmZvIiwiY29ubmVjdGlvblRpbWluZ0luZm8iLCJkZWZhdWx0U3RhcnRUaW1lIiwic3RhcnRUaW1lIiwiZG9tYWluTG9va3VwU3RhcnRUaW1lIiwiZG9tYWluTG9va3VwRW5kVGltZSIsImNvbm5lY3Rpb25TdGFydFRpbWUiLCJjb25uZWN0aW9uRW5kVGltZSIsInNlY3VyZUNvbm5lY3Rpb25TdGFydFRpbWUiLCJBTFBOTmVnb3RpYXRlZFByb3RvY29sIiwiY29hcnNlbmVkU2hhcmVkQ3VycmVudFRpbWUiLCJub3ciLCJjcmVhdGVPcGFxdWVUaW1pbmdJbmZvIiwidGltaW5nSW5mbyIsInJlZGlyZWN0U3RhcnRUaW1lIiwicmVkaXJlY3RFbmRUaW1lIiwicG9zdFJlZGlyZWN0U3RhcnRUaW1lIiwiZmluYWxTZXJ2aWNlV29ya2VyU3RhcnRUaW1lIiwiZmluYWxOZXR3b3JrUmVzcG9uc2VTdGFydFRpbWUiLCJmaW5hbE5ldHdvcmtSZXF1ZXN0U3RhcnRUaW1lIiwiZW5kVGltZSIsImVuY29kZWRCb2R5U2l6ZSIsImRlY29kZWRCb2R5U2l6ZSIsImZpbmFsQ29ubmVjdGlvblRpbWluZ0luZm8iLCJtYWtlUG9saWN5Q29udGFpbmVyIiwiY2xvbmVQb2xpY3lDb250YWluZXIiLCJwb2xpY3lDb250YWluZXIiLCJkZXRlcm1pbmVSZXF1ZXN0c1JlZmVycmVyIiwicmVmZXJyZXJTb3VyY2UiLCJyZWZlcnJlciIsImdsb2JhbE9yaWdpbiIsInJlZmVycmVyVVJMIiwic3RyaXBVUkxGb3JSZWZlcnJlciIsInJlZmVycmVyT3JpZ2luIiwiYXJlU2FtZU9yaWdpbiIsImlzTm9uUG90ZW50aWFsbHlUcnVzdFdvcnRoeSIsImlzVVJMUG90ZW50aWFsbHlUcnVzdHdvcnRoeSIsImN1cnJlbnRVUkwiLCJvcmlnaW5Pbmx5IiwicHJvdG9jb2wiLCJ1c2VybmFtZSIsInBhc3N3b3JkIiwicGF0aG5hbWUiLCJzZWFyY2giLCJocmVmIiwiaXNPcmlnaW5Qb3RlbnRpYWxseVRydXN0d29ydGh5Iiwib3JpZ2luQXNVUkwiLCJ0ZXN0IiwiaG9zdG5hbWUiLCJlbmRzV2l0aCIsImJ5dGVzTWF0Y2giLCJieXRlcyIsIm1ldGFkYXRhTGlzdCIsInBhcnNlZE1ldGFkYXRhIiwicGFyc2VNZXRhZGF0YSIsInN0cm9uZ2VzdCIsImdldFN0cm9uZ2VzdE1ldGFkYXRhIiwibWV0YWRhdGEiLCJmaWx0ZXJNZXRhZGF0YUxpc3RCeUFsZ29yaXRobSIsIml0ZW0iLCJhbGdvcml0aG0iLCJhbGdvIiwiZXhwZWN0ZWRWYWx1ZSIsImFjdHVhbFZhbHVlIiwiY3JlYXRlSGFzaCIsInVwZGF0ZSIsImRpZ2VzdCIsInNsaWNlIiwiY29tcGFyZUJhc2U2NE1peGVkIiwicGFyc2VIYXNoV2l0aE9wdGlvbnMiLCJyZXN1bHQiLCJlbXB0eSIsInBhcnNlZFRva2VuIiwiZXhlYyIsImdyb3VwcyIsInRvTG93ZXJDYXNlIiwicHVzaCIsInBvcyIsInRyeVVwZ3JhZGVSZXF1ZXN0VG9BUG90ZW50aWFsbHlUcnVzdHdvcnRoeVVSTCIsIkEiLCJCIiwiY3JlYXRlRGVmZXJyZWRQcm9taXNlIiwicmVzIiwicmVqIiwicHJvbWlzZSIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiaXNBYm9ydGVkIiwiZmV0Y2hQYXJhbXMiLCJjb250cm9sbGVyIiwic3RhdGUiLCJpc0NhbmNlbGxlZCIsIm5vcm1hbGl6ZU1ldGhvZCIsInNlcmlhbGl6ZUphdmFzY3JpcHRWYWx1ZVRvSlNPTlN0cmluZyIsIkpTT04iLCJzdHJpbmdpZnkiLCJlc0l0ZXJhdG9yUHJvdG90eXBlIiwiZ2V0UHJvdG90eXBlT2YiLCJTeW1ib2wiLCJpdGVyYXRvciIsImNyZWF0ZUl0ZXJhdG9yIiwia0ludGVybmFsSXRlcmF0b3IiLCJrZXlJbmRleCIsInZhbHVlSW5kZXgiLCJfdGFyZ2V0QnJhbmRDaGVjayIsIldlYWtTZXQiLCJGYXN0SXRlcmFibGVJdGVyYXRvciIsInRhcmdldCIsImtpbmQiLCJpbmRleCIsImFkZCIsIm5leHQiLCJ2YWx1ZXMiLCJsZW4iLCJkb25lIiwia2V5IiwicHJvdG90eXBlIiwic2V0UHJvdG90eXBlT2YiLCJkZWZpbmVQcm9wZXJ0aWVzIiwidG9TdHJpbmdUYWciLCJ3cml0YWJsZSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJpdGVyYXRvck1peGluIiwibWFrZUl0ZXJhdG9yIiwicHJvcGVydGllcyIsImtleXMiLCJicmFuZENoZWNrIiwiZW50cmllcyIsImZvckVhY2giLCJjYWxsYmFja2ZuIiwidGhpc0FyZyIsImdsb2JhbFRoaXMiLCJhcmd1bWVudExlbmd0aENoZWNrIiwiYXJndW1lbnRzIiwiY2FsbCIsImZ1bGx5UmVhZEJvZHkiLCJib2R5IiwicHJvY2Vzc0JvZHkiLCJwcm9jZXNzQm9keUVycm9yIiwic3VjY2Vzc1N0ZXBzIiwiZXJyb3JTdGVwcyIsInJlYWRlciIsInN0cmVhbSIsImdldFJlYWRlciIsInJlYWRBbGxCeXRlcyIsImlzUmVhZGFibGVTdHJlYW1MaWtlIiwiUmVhZGFibGVTdHJlYW0iLCJ0ZWUiLCJyZWFkYWJsZVN0cmVhbUNsb3NlIiwiY2xvc2UiLCJieW9iUmVxdWVzdCIsInJlc3BvbmQiLCJlcnIiLCJtZXNzYWdlIiwiaW52YWxpZElzb21vcnBoaWNFbmNvZGVWYWx1ZVJlZ2V4IiwiaXNvbW9ycGhpY0VuY29kZSIsImlucHV0IiwiYnl0ZUxlbmd0aCIsImNodW5rIiwicmVhZCIsImNvbmNhdCIsInVybElzTG9jYWwiLCJzaW1wbGVSYW5nZUhlYWRlclZhbHVlIiwiYWxsb3dXaGl0ZXNwYWNlIiwiZGF0YSIsInN0YXJ0c1dpdGgiLCJwb3NpdGlvbiIsImNoYXIiLCJyYW5nZVN0YXJ0IiwicmFuZ2VTdGFydFZhbHVlIiwiTnVtYmVyIiwicmFuZ2VFbmQiLCJyYW5nZUVuZFZhbHVlIiwiYnVpbGRDb250ZW50UmFuZ2UiLCJmdWxsTGVuZ3RoIiwiY29udGVudFJhbmdlIiwiSW5mbGF0ZVN0cmVhbSIsIl90cmFuc2Zvcm0iLCJlbmNvZGluZyIsImNhbGxiYWNrIiwiX2luZmxhdGVTdHJlYW0iLCJjcmVhdGVJbmZsYXRlIiwiY3JlYXRlSW5mbGF0ZVJhdyIsIm9uIiwiYmluZCIsImRlc3Ryb3kiLCJ3cml0ZSIsIl9maW5hbCIsImVuZCIsImV4dHJhY3RNaW1lVHlwZSIsImhlYWRlcnMiLCJjaGFyc2V0IiwiZXNzZW5jZSIsIm1pbWVUeXBlIiwiZ2V0RGVjb2RlU3BsaXQiLCJ0ZW1wb3JhcnlNaW1lVHlwZSIsInBhcmFtZXRlcnMiLCJnZXR0aW5nRGVjb2RpbmdTcGxpdHRpbmciLCJ0ZW1wb3JhcnlWYWx1ZSIsImxpc3QiLCJ0ZXh0RGVjb2RlciIsIlRleHREZWNvZGVyIiwidXRmOERlY29kZUJ5dGVzIiwiYnVmZmVyIiwic3ViYXJyYXkiLCJvdXRwdXQiLCJkZWNvZGUiLCJFbnZpcm9ubWVudFNldHRpbmdzT2JqZWN0QmFzZSIsImJhc2VVcmwiLCJFbnZpcm9ubWVudFNldHRpbmdzT2JqZWN0Iiwic2V0dGluZ3NPYmplY3QiLCJlbnZpcm9ubWVudFNldHRpbmdzT2JqZWN0IiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/fetch/util.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/fetch/webidl.js":
/*!*****************************************************!*\
  !*** ./node_modules/undici/lib/web/fetch/webidl.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { types, inspect } = __webpack_require__(/*! node:util */ \"node:util\");\nconst { toUSVString } = __webpack_require__(/*! ../../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\");\n/** @type {import('../../../types/webidl').Webidl} */ const webidl = {};\nwebidl.converters = {};\nwebidl.util = {};\nwebidl.errors = {};\nwebidl.errors.exception = function(message) {\n    return new TypeError(`${message.header}: ${message.message}`);\n};\nwebidl.errors.conversionFailed = function(context) {\n    const plural = context.types.length === 1 ? \"\" : \" one of\";\n    const message = `${context.argument} could not be converted to` + `${plural}: ${context.types.join(\", \")}.`;\n    return webidl.errors.exception({\n        header: context.prefix,\n        message\n    });\n};\nwebidl.errors.invalidArgument = function(context) {\n    return webidl.errors.exception({\n        header: context.prefix,\n        message: `\"${context.value}\" is an invalid ${context.type}.`\n    });\n};\n// https://webidl.spec.whatwg.org/#implements\nwebidl.brandCheck = function(V, I, opts) {\n    if (opts?.strict !== false) {\n        if (!(V instanceof I)) {\n            const err = new TypeError(\"Illegal invocation\");\n            err.code = \"ERR_INVALID_THIS\"; // node compat.\n            throw err;\n        }\n    } else {\n        if (V?.[Symbol.toStringTag] !== I.prototype[Symbol.toStringTag]) {\n            const err = new TypeError(\"Illegal invocation\");\n            err.code = \"ERR_INVALID_THIS\"; // node compat.\n            throw err;\n        }\n    }\n};\nwebidl.argumentLengthCheck = function({ length }, min, ctx) {\n    if (length < min) {\n        throw webidl.errors.exception({\n            message: `${min} argument${min !== 1 ? \"s\" : \"\"} required, ` + `but${length ? \" only\" : \"\"} ${length} found.`,\n            header: ctx\n        });\n    }\n};\nwebidl.illegalConstructor = function() {\n    throw webidl.errors.exception({\n        header: \"TypeError\",\n        message: \"Illegal constructor\"\n    });\n};\n// https://tc39.es/ecma262/#sec-ecmascript-data-types-and-values\nwebidl.util.Type = function(V) {\n    switch(typeof V){\n        case \"undefined\":\n            return \"Undefined\";\n        case \"boolean\":\n            return \"Boolean\";\n        case \"string\":\n            return \"String\";\n        case \"symbol\":\n            return \"Symbol\";\n        case \"number\":\n            return \"Number\";\n        case \"bigint\":\n            return \"BigInt\";\n        case \"function\":\n        case \"object\":\n            {\n                if (V === null) {\n                    return \"Null\";\n                }\n                return \"Object\";\n            }\n    }\n};\n// https://webidl.spec.whatwg.org/#abstract-opdef-converttoint\nwebidl.util.ConvertToInt = function(V, bitLength, signedness, opts) {\n    let upperBound;\n    let lowerBound;\n    // 1. If bitLength is 64, then:\n    if (bitLength === 64) {\n        // 1. Let upperBound be 2^53  1.\n        upperBound = Math.pow(2, 53) - 1;\n        // 2. If signedness is \"unsigned\", then let lowerBound be 0.\n        if (signedness === \"unsigned\") {\n            lowerBound = 0;\n        } else {\n            // 3. Otherwise let lowerBound be 2^53 + 1.\n            lowerBound = Math.pow(-2, 53) + 1;\n        }\n    } else if (signedness === \"unsigned\") {\n        // 2. Otherwise, if signedness is \"unsigned\", then:\n        // 1. Let lowerBound be 0.\n        lowerBound = 0;\n        // 2. Let upperBound be 2^bitLength  1.\n        upperBound = Math.pow(2, bitLength) - 1;\n    } else {\n        // 3. Otherwise:\n        // 1. Let lowerBound be -2^bitLength  1.\n        lowerBound = Math.pow(-2, bitLength) - 1;\n        // 2. Let upperBound be 2^bitLength  1  1.\n        upperBound = Math.pow(2, bitLength - 1) - 1;\n    }\n    // 4. Let x be ? ToNumber(V).\n    let x = Number(V);\n    // 5. If x is 0, then set x to +0.\n    if (x === 0) {\n        x = 0;\n    }\n    // 6. If the conversion is to an IDL type associated\n    //    with the [EnforceRange] extended attribute, then:\n    if (opts?.enforceRange === true) {\n        // 1. If x is NaN, +, or , then throw a TypeError.\n        if (Number.isNaN(x) || x === Number.POSITIVE_INFINITY || x === Number.NEGATIVE_INFINITY) {\n            throw webidl.errors.exception({\n                header: \"Integer conversion\",\n                message: `Could not convert ${webidl.util.Stringify(V)} to an integer.`\n            });\n        }\n        // 2. Set x to IntegerPart(x).\n        x = webidl.util.IntegerPart(x);\n        // 3. If x < lowerBound or x > upperBound, then\n        //    throw a TypeError.\n        if (x < lowerBound || x > upperBound) {\n            throw webidl.errors.exception({\n                header: \"Integer conversion\",\n                message: `Value must be between ${lowerBound}-${upperBound}, got ${x}.`\n            });\n        }\n        // 4. Return x.\n        return x;\n    }\n    // 7. If x is not NaN and the conversion is to an IDL\n    //    type associated with the [Clamp] extended\n    //    attribute, then:\n    if (!Number.isNaN(x) && opts?.clamp === true) {\n        // 1. Set x to min(max(x, lowerBound), upperBound).\n        x = Math.min(Math.max(x, lowerBound), upperBound);\n        // 2. Round x to the nearest integer, choosing the\n        //    even integer if it lies halfway between two,\n        //    and choosing +0 rather than 0.\n        if (Math.floor(x) % 2 === 0) {\n            x = Math.floor(x);\n        } else {\n            x = Math.ceil(x);\n        }\n        // 3. Return x.\n        return x;\n    }\n    // 8. If x is NaN, +0, +, or , then return +0.\n    if (Number.isNaN(x) || x === 0 && Object.is(0, x) || x === Number.POSITIVE_INFINITY || x === Number.NEGATIVE_INFINITY) {\n        return 0;\n    }\n    // 9. Set x to IntegerPart(x).\n    x = webidl.util.IntegerPart(x);\n    // 10. Set x to x modulo 2^bitLength.\n    x = x % Math.pow(2, bitLength);\n    // 11. If signedness is \"signed\" and x  2^bitLength  1,\n    //    then return x  2^bitLength.\n    if (signedness === \"signed\" && x >= Math.pow(2, bitLength) - 1) {\n        return x - Math.pow(2, bitLength);\n    }\n    // 12. Otherwise, return x.\n    return x;\n};\n// https://webidl.spec.whatwg.org/#abstract-opdef-integerpart\nwebidl.util.IntegerPart = function(n) {\n    // 1. Let r be floor(abs(n)).\n    const r = Math.floor(Math.abs(n));\n    // 2. If n < 0, then return -1  r.\n    if (n < 0) {\n        return -1 * r;\n    }\n    // 3. Otherwise, return r.\n    return r;\n};\nwebidl.util.Stringify = function(V) {\n    const type = webidl.util.Type(V);\n    switch(type){\n        case \"Symbol\":\n            return `Symbol(${V.description})`;\n        case \"Object\":\n            return inspect(V);\n        case \"String\":\n            return `\"${V}\"`;\n        default:\n            return `${V}`;\n    }\n};\n// https://webidl.spec.whatwg.org/#es-sequence\nwebidl.sequenceConverter = function(converter) {\n    return (V, prefix, argument, Iterable)=>{\n        // 1. If Type(V) is not Object, throw a TypeError.\n        if (webidl.util.Type(V) !== \"Object\") {\n            throw webidl.errors.exception({\n                header: prefix,\n                message: `${argument} (${webidl.util.Stringify(V)}) is not iterable.`\n            });\n        }\n        // 2. Let method be ? GetMethod(V, @@iterator).\n        /** @type {Generator} */ const method = typeof Iterable === \"function\" ? Iterable() : V?.[Symbol.iterator]?.();\n        const seq = [];\n        let index = 0;\n        // 3. If method is undefined, throw a TypeError.\n        if (method === undefined || typeof method.next !== \"function\") {\n            throw webidl.errors.exception({\n                header: prefix,\n                message: `${argument} is not iterable.`\n            });\n        }\n        // https://webidl.spec.whatwg.org/#create-sequence-from-iterable\n        while(true){\n            const { done, value } = method.next();\n            if (done) {\n                break;\n            }\n            seq.push(converter(value, prefix, `${argument}[${index++}]`));\n        }\n        return seq;\n    };\n};\n// https://webidl.spec.whatwg.org/#es-to-record\nwebidl.recordConverter = function(keyConverter, valueConverter) {\n    return (O, prefix, argument)=>{\n        // 1. If Type(O) is not Object, throw a TypeError.\n        if (webidl.util.Type(O) !== \"Object\") {\n            throw webidl.errors.exception({\n                header: prefix,\n                message: `${argument} (\"${webidl.util.Type(O)}\") is not an Object.`\n            });\n        }\n        // 2. Let result be a new empty instance of record<K, V>.\n        const result = {};\n        if (!types.isProxy(O)) {\n            // 1. Let desc be ? O.[[GetOwnProperty]](key).\n            const keys = [\n                ...Object.getOwnPropertyNames(O),\n                ...Object.getOwnPropertySymbols(O)\n            ];\n            for (const key of keys){\n                // 1. Let typedKey be key converted to an IDL value of type K.\n                const typedKey = keyConverter(key, prefix, argument);\n                // 2. Let value be ? Get(O, key).\n                // 3. Let typedValue be value converted to an IDL value of type V.\n                const typedValue = valueConverter(O[key], prefix, argument);\n                // 4. Set result[typedKey] to typedValue.\n                result[typedKey] = typedValue;\n            }\n            // 5. Return result.\n            return result;\n        }\n        // 3. Let keys be ? O.[[OwnPropertyKeys]]().\n        const keys = Reflect.ownKeys(O);\n        // 4. For each key of keys.\n        for (const key of keys){\n            // 1. Let desc be ? O.[[GetOwnProperty]](key).\n            const desc = Reflect.getOwnPropertyDescriptor(O, key);\n            // 2. If desc is not undefined and desc.[[Enumerable]] is true:\n            if (desc?.enumerable) {\n                // 1. Let typedKey be key converted to an IDL value of type K.\n                const typedKey = keyConverter(key, prefix, argument);\n                // 2. Let value be ? Get(O, key).\n                // 3. Let typedValue be value converted to an IDL value of type V.\n                const typedValue = valueConverter(O[key], prefix, argument);\n                // 4. Set result[typedKey] to typedValue.\n                result[typedKey] = typedValue;\n            }\n        }\n        // 5. Return result.\n        return result;\n    };\n};\nwebidl.interfaceConverter = function(i) {\n    return (V, prefix, argument, opts)=>{\n        if (opts?.strict !== false && !(V instanceof i)) {\n            throw webidl.errors.exception({\n                header: prefix,\n                message: `Expected ${argument} (\"${webidl.util.Stringify(V)}\") to be an instance of ${i.name}.`\n            });\n        }\n        return V;\n    };\n};\nwebidl.dictionaryConverter = function(converters) {\n    return (dictionary, prefix, argument)=>{\n        const type = webidl.util.Type(dictionary);\n        const dict = {};\n        if (type === \"Null\" || type === \"Undefined\") {\n            return dict;\n        } else if (type !== \"Object\") {\n            throw webidl.errors.exception({\n                header: prefix,\n                message: `Expected ${dictionary} to be one of: Null, Undefined, Object.`\n            });\n        }\n        for (const options of converters){\n            const { key, defaultValue, required, converter } = options;\n            if (required === true) {\n                if (!Object.hasOwn(dictionary, key)) {\n                    throw webidl.errors.exception({\n                        header: prefix,\n                        message: `Missing required key \"${key}\".`\n                    });\n                }\n            }\n            let value = dictionary[key];\n            const hasDefault = Object.hasOwn(options, \"defaultValue\");\n            // Only use defaultValue if value is undefined and\n            // a defaultValue options was provided.\n            if (hasDefault && value !== null) {\n                value ??= defaultValue();\n            }\n            // A key can be optional and have no default value.\n            // When this happens, do not perform a conversion,\n            // and do not assign the key a value.\n            if (required || hasDefault || value !== undefined) {\n                value = converter(value, prefix, `${argument}.${key}`);\n                if (options.allowedValues && !options.allowedValues.includes(value)) {\n                    throw webidl.errors.exception({\n                        header: prefix,\n                        message: `${value} is not an accepted type. Expected one of ${options.allowedValues.join(\", \")}.`\n                    });\n                }\n                dict[key] = value;\n            }\n        }\n        return dict;\n    };\n};\nwebidl.nullableConverter = function(converter) {\n    return (V, prefix, argument)=>{\n        if (V === null) {\n            return V;\n        }\n        return converter(V, prefix, argument);\n    };\n};\n// https://webidl.spec.whatwg.org/#es-DOMString\nwebidl.converters.DOMString = function(V, prefix, argument, opts) {\n    // 1. If V is null and the conversion is to an IDL type\n    //    associated with the [LegacyNullToEmptyString]\n    //    extended attribute, then return the DOMString value\n    //    that represents the empty string.\n    if (V === null && opts?.legacyNullToEmptyString) {\n        return \"\";\n    }\n    // 2. Let x be ? ToString(V).\n    if (typeof V === \"symbol\") {\n        throw webidl.errors.exception({\n            header: prefix,\n            message: `${argument} is a symbol, which cannot be converted to a DOMString.`\n        });\n    }\n    // 3. Return the IDL DOMString value that represents the\n    //    same sequence of code units as the one the\n    //    ECMAScript String value x represents.\n    return String(V);\n};\n// https://webidl.spec.whatwg.org/#es-ByteString\nwebidl.converters.ByteString = function(V, prefix, argument) {\n    // 1. Let x be ? ToString(V).\n    // Note: DOMString converter perform ? ToString(V)\n    const x = webidl.converters.DOMString(V, prefix, argument);\n    // 2. If the value of any element of x is greater than\n    //    255, then throw a TypeError.\n    for(let index = 0; index < x.length; index++){\n        if (x.charCodeAt(index) > 255) {\n            throw new TypeError(\"Cannot convert argument to a ByteString because the character at \" + `index ${index} has a value of ${x.charCodeAt(index)} which is greater than 255.`);\n        }\n    }\n    // 3. Return an IDL ByteString value whose length is the\n    //    length of x, and where the value of each element is\n    //    the value of the corresponding element of x.\n    return x;\n};\n// https://webidl.spec.whatwg.org/#es-USVString\n// TODO: rewrite this so we can control the errors thrown\nwebidl.converters.USVString = toUSVString;\n// https://webidl.spec.whatwg.org/#es-boolean\nwebidl.converters.boolean = function(V) {\n    // 1. Let x be the result of computing ToBoolean(V).\n    const x = Boolean(V);\n    // 2. Return the IDL boolean value that is the one that represents\n    //    the same truth value as the ECMAScript Boolean value x.\n    return x;\n};\n// https://webidl.spec.whatwg.org/#es-any\nwebidl.converters.any = function(V) {\n    return V;\n};\n// https://webidl.spec.whatwg.org/#es-long-long\nwebidl.converters[\"long long\"] = function(V, prefix, argument) {\n    // 1. Let x be ? ConvertToInt(V, 64, \"signed\").\n    const x = webidl.util.ConvertToInt(V, 64, \"signed\", undefined, prefix, argument);\n    // 2. Return the IDL long long value that represents\n    //    the same numeric value as x.\n    return x;\n};\n// https://webidl.spec.whatwg.org/#es-unsigned-long-long\nwebidl.converters[\"unsigned long long\"] = function(V, prefix, argument) {\n    // 1. Let x be ? ConvertToInt(V, 64, \"unsigned\").\n    const x = webidl.util.ConvertToInt(V, 64, \"unsigned\", undefined, prefix, argument);\n    // 2. Return the IDL unsigned long long value that\n    //    represents the same numeric value as x.\n    return x;\n};\n// https://webidl.spec.whatwg.org/#es-unsigned-long\nwebidl.converters[\"unsigned long\"] = function(V, prefix, argument) {\n    // 1. Let x be ? ConvertToInt(V, 32, \"unsigned\").\n    const x = webidl.util.ConvertToInt(V, 32, \"unsigned\", undefined, prefix, argument);\n    // 2. Return the IDL unsigned long value that\n    //    represents the same numeric value as x.\n    return x;\n};\n// https://webidl.spec.whatwg.org/#es-unsigned-short\nwebidl.converters[\"unsigned short\"] = function(V, prefix, argument, opts) {\n    // 1. Let x be ? ConvertToInt(V, 16, \"unsigned\").\n    const x = webidl.util.ConvertToInt(V, 16, \"unsigned\", opts, prefix, argument);\n    // 2. Return the IDL unsigned short value that represents\n    //    the same numeric value as x.\n    return x;\n};\n// https://webidl.spec.whatwg.org/#idl-ArrayBuffer\nwebidl.converters.ArrayBuffer = function(V, prefix, argument, opts) {\n    // 1. If Type(V) is not Object, or V does not have an\n    //    [[ArrayBufferData]] internal slot, then throw a\n    //    TypeError.\n    // see: https://tc39.es/ecma262/#sec-properties-of-the-arraybuffer-instances\n    // see: https://tc39.es/ecma262/#sec-properties-of-the-sharedarraybuffer-instances\n    if (webidl.util.Type(V) !== \"Object\" || !types.isAnyArrayBuffer(V)) {\n        throw webidl.errors.conversionFailed({\n            prefix,\n            argument: `${argument} (\"${webidl.util.Stringify(V)}\")`,\n            types: [\n                \"ArrayBuffer\"\n            ]\n        });\n    }\n    // 2. If the conversion is not to an IDL type associated\n    //    with the [AllowShared] extended attribute, and\n    //    IsSharedArrayBuffer(V) is true, then throw a\n    //    TypeError.\n    if (opts?.allowShared === false && types.isSharedArrayBuffer(V)) {\n        throw webidl.errors.exception({\n            header: \"ArrayBuffer\",\n            message: \"SharedArrayBuffer is not allowed.\"\n        });\n    }\n    // 3. If the conversion is not to an IDL type associated\n    //    with the [AllowResizable] extended attribute, and\n    //    IsResizableArrayBuffer(V) is true, then throw a\n    //    TypeError.\n    if (V.resizable || V.growable) {\n        throw webidl.errors.exception({\n            header: \"ArrayBuffer\",\n            message: \"Received a resizable ArrayBuffer.\"\n        });\n    }\n    // 4. Return the IDL ArrayBuffer value that is a\n    //    reference to the same object as V.\n    return V;\n};\nwebidl.converters.TypedArray = function(V, T, prefix, name, opts) {\n    // 1. Let T be the IDL type V is being converted to.\n    // 2. If Type(V) is not Object, or V does not have a\n    //    [[TypedArrayName]] internal slot with a value\n    //    equal to Ts name, then throw a TypeError.\n    if (webidl.util.Type(V) !== \"Object\" || !types.isTypedArray(V) || V.constructor.name !== T.name) {\n        throw webidl.errors.conversionFailed({\n            prefix,\n            argument: `${name} (\"${webidl.util.Stringify(V)}\")`,\n            types: [\n                T.name\n            ]\n        });\n    }\n    // 3. If the conversion is not to an IDL type associated\n    //    with the [AllowShared] extended attribute, and\n    //    IsSharedArrayBuffer(V.[[ViewedArrayBuffer]]) is\n    //    true, then throw a TypeError.\n    if (opts?.allowShared === false && types.isSharedArrayBuffer(V.buffer)) {\n        throw webidl.errors.exception({\n            header: \"ArrayBuffer\",\n            message: \"SharedArrayBuffer is not allowed.\"\n        });\n    }\n    // 4. If the conversion is not to an IDL type associated\n    //    with the [AllowResizable] extended attribute, and\n    //    IsResizableArrayBuffer(V.[[ViewedArrayBuffer]]) is\n    //    true, then throw a TypeError.\n    if (V.buffer.resizable || V.buffer.growable) {\n        throw webidl.errors.exception({\n            header: \"ArrayBuffer\",\n            message: \"Received a resizable ArrayBuffer.\"\n        });\n    }\n    // 5. Return the IDL value of type T that is a reference\n    //    to the same object as V.\n    return V;\n};\nwebidl.converters.DataView = function(V, prefix, name, opts) {\n    // 1. If Type(V) is not Object, or V does not have a\n    //    [[DataView]] internal slot, then throw a TypeError.\n    if (webidl.util.Type(V) !== \"Object\" || !types.isDataView(V)) {\n        throw webidl.errors.exception({\n            header: prefix,\n            message: `${name} is not a DataView.`\n        });\n    }\n    // 2. If the conversion is not to an IDL type associated\n    //    with the [AllowShared] extended attribute, and\n    //    IsSharedArrayBuffer(V.[[ViewedArrayBuffer]]) is true,\n    //    then throw a TypeError.\n    if (opts?.allowShared === false && types.isSharedArrayBuffer(V.buffer)) {\n        throw webidl.errors.exception({\n            header: \"ArrayBuffer\",\n            message: \"SharedArrayBuffer is not allowed.\"\n        });\n    }\n    // 3. If the conversion is not to an IDL type associated\n    //    with the [AllowResizable] extended attribute, and\n    //    IsResizableArrayBuffer(V.[[ViewedArrayBuffer]]) is\n    //    true, then throw a TypeError.\n    if (V.buffer.resizable || V.buffer.growable) {\n        throw webidl.errors.exception({\n            header: \"ArrayBuffer\",\n            message: \"Received a resizable ArrayBuffer.\"\n        });\n    }\n    // 4. Return the IDL DataView value that is a reference\n    //    to the same object as V.\n    return V;\n};\n// https://webidl.spec.whatwg.org/#BufferSource\nwebidl.converters.BufferSource = function(V, prefix, name, opts) {\n    if (types.isAnyArrayBuffer(V)) {\n        return webidl.converters.ArrayBuffer(V, prefix, name, {\n            ...opts,\n            allowShared: false\n        });\n    }\n    if (types.isTypedArray(V)) {\n        return webidl.converters.TypedArray(V, V.constructor, prefix, name, {\n            ...opts,\n            allowShared: false\n        });\n    }\n    if (types.isDataView(V)) {\n        return webidl.converters.DataView(V, prefix, name, {\n            ...opts,\n            allowShared: false\n        });\n    }\n    throw webidl.errors.conversionFailed({\n        prefix,\n        argument: `${name} (\"${webidl.util.Stringify(V)}\")`,\n        types: [\n            \"BufferSource\"\n        ]\n    });\n};\nwebidl.converters[\"sequence<ByteString>\"] = webidl.sequenceConverter(webidl.converters.ByteString);\nwebidl.converters[\"sequence<sequence<ByteString>>\"] = webidl.sequenceConverter(webidl.converters[\"sequence<ByteString>\"]);\nwebidl.converters[\"record<ByteString, ByteString>\"] = webidl.recordConverter(webidl.converters.ByteString, webidl.converters.ByteString);\nmodule.exports = {\n    webidl\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZmV0Y2gvd2ViaWRsLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTSxFQUFFQSxLQUFLLEVBQUVDLE9BQUFBLEVBQVMsR0FBR0MsbUJBQU9BLENBQUM7QUFDbkMsTUFBTSxFQUFFQyxXQUFBQSxFQUFhLEdBQUdELG1CQUFPQSxDQUFDO0FBRWhDLHNEQUNBLE1BQU1FLFNBQVMsQ0FBQztBQUNoQkEsT0FBT0MsVUFBVSxHQUFHLENBQUM7QUFDckJELE9BQU9FLElBQUksR0FBRyxDQUFDO0FBQ2ZGLE9BQU9HLE1BQU0sR0FBRyxDQUFDO0FBRWpCSCxPQUFPRyxNQUFNLENBQUNDLFNBQVMsR0FBRyxTQUFVQyxPQUFPO0lBQ3pDLE9BQU8sSUFBSUMsVUFBVSxHQUFHRCxRQUFRRSxNQUFNLEtBQUtGLFFBQVFBLE9BQU8sRUFBRTtBQUM5RDtBQUVBTCxPQUFPRyxNQUFNLENBQUNLLGdCQUFnQixHQUFHLFNBQVVDLE9BQU87SUFDaEQsTUFBTUMsU0FBU0QsUUFBUWIsS0FBSyxDQUFDZSxNQUFNLEtBQUssSUFBSSxLQUFLO0lBQ2pELE1BQU1OLFVBQ0osR0FBR0ksUUFBUUcsUUFBUSw0QkFBNEIsR0FDL0MsR0FBR0YsT0FBTSxJQUFLRCxRQUFRYixLQUFLLENBQUNpQixJQUFJLENBQUMsTUFBSyxFQUFHO0lBRTNDLE9BQU9iLE9BQU9HLE1BQU0sQ0FBQ0MsU0FBUyxDQUFDO1FBQzdCRyxRQUFRRSxRQUFRSyxNQUFNO1FBQ3RCVDtJQUNGO0FBQ0Y7QUFFQUwsT0FBT0csTUFBTSxDQUFDWSxlQUFlLEdBQUcsU0FBVU4sT0FBTztJQUMvQyxPQUFPVCxPQUFPRyxNQUFNLENBQUNDLFNBQVMsQ0FBQztRQUM3QkcsUUFBUUUsUUFBUUssTUFBTTtRQUN0QlQsU0FBUyxJQUFJSSxRQUFRTyxLQUFLLG1CQUFtQlAsUUFBUVEsSUFBSTtJQUMzRDtBQUNGO0FBRUE7QUFDQWpCLE9BQU9rQixVQUFVLEdBQUcsU0FBVUMs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TzBELGlCQUFpQixDQUNsRTFELE9BQU9DLFVBQVUsQ0FBQ3NHLFVBQ3BCO0FBRUF2RyxPQUFPQyxVQUFVLENBQUMsaUNBQWlDLEdBQUdELE9BQU8wRCxpQkFBaUIsQ0FDNUUxRCxPQUFPQyxVQUFVLENBQUMsdUJBQ3BCO0FBRUFELE9BQU9DLFVBQVUsQ0FBQyxpQ0FBaUMsR0FBR0QsT0FBT3FFLGVBQWUsQ0FDMUVyRSxPQUFPQyxVQUFVLENBQUNzRyxVQUFVLEVBQzVCdkcsT0FBT0MsVUFBVSxDQUFDc0csVUFDcEI7QUFFQW9CLE9BQU9DLE9BQU8sR0FBRztJQUNmNUg7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL21vY2t1cGZsb3cvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZmV0Y2gvd2ViaWRsLmpzP2EyZmQiLCJ3ZWJwYWNrOi8vbW9ja3VwZmxvdy8uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL3dlYi9mZXRjaC93ZWJpZGwuanM/YTJmZCoiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgdHlwZXMsIGluc3BlY3QgfSA9IHJlcXVpcmUoJ25vZGU6dXRpbCcpXG5jb25zdCB7IHRvVVNWU3RyaW5nIH0gPSByZXF1aXJlKCcuLi8uLi9jb3JlL3V0aWwnKVxuXG4vKiogQHR5cGUge2ltcG9ydCgnLi4vLi4vLi4vdHlwZXMvd2ViaWRsJykuV2ViaWRsfSAqL1xuY29uc3Qgd2ViaWRsID0ge31cbndlYmlkbC5jb252ZXJ0ZXJzID0ge31cbndlYmlkbC51dGlsID0ge31cbndlYmlkbC5lcnJvcnMgPSB7fVxuXG53ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbiA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gIHJldHVybiBuZXcgVHlwZUVycm9yKGAke21lc3NhZ2UuaGVhZGVyfTogJHttZXNzYWdlLm1lc3NhZ2V9YClcbn1cblxud2ViaWRsLmVycm9ycy5jb252ZXJzaW9uRmFpbGVkID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgY29uc3QgcGx1cmFsID0gY29udGV4dC50eXBlcy5sZW5ndGggPT09IDEgPyAnJyA6ICcgb25lIG9mJ1xuICBjb25zdCBtZXNzYWdlID1cbiAgICBgJHtjb250ZXh0LmFyZ3VtZW50fSBjb3VsZCBub3QgYmUgY29udmVydGVkIHRvYCArXG4gICAgYCR7cGx1cmFsfTogJHtjb250ZXh0LnR5cGVzLmpvaW4oJywgJyl9LmBcblxuICByZXR1cm4gd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgIGhlYWRlcjogY29udGV4dC5wcmVmaXgsXG4gICAgbWVzc2FnZVxuICB9KVxufVxuXG53ZWJpZGwuZXJyb3JzLmludmFsaWRBcmd1bWVudCA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gIHJldHVybiB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgaGVhZGVyOiBjb250ZXh0LnByZWZpeCxcbiAgICBtZXNzYWdlOiBgXCIke2NvbnRleHQudmFsdWV9XCIgaXMgYW4gaW52YWxpZCAke2NvbnRleHQudHlwZX0uYFxuICB9KVxufVxuXG4vLyBodHRwczovL3dlYmlkbC5zcGVjLndoYXR3Zy5vcmcvI2ltcGxlbWVudHNcbndlYmlkbC5icmFuZENoZWNrID0gZnVuY3Rpb24gKFYsIEksIG9wdHMpIHtcbiAgaWYgKG9wdHM/LnN0cmljdCAhPT0gZmFsc2UpIHtcbiAgICBpZiAoIShWIGluc3RhbmNlb2YgSSkpIHtcbiAgICAgIGNvbnN0IGVyciA9IG5ldyBUeXBlRXJyb3IoJ0lsbGVnYWwgaW52b2NhdGlvbicpXG4gICAgICBlcnIuY29kZSA9ICdFUlJfSU5WQUxJRF9USElTJyAvLyBub2RlIGNvbXBhdC5cbiAgICAgIHRocm93IGVyclxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoVj8uW1N5bWJvbC50b1N0cmluZ1RhZ10gIT09IEkucHJvdG90eXBlW1N5bWJvbC50b1N0cmluZ1RhZ10pIHtcbiAgICAgIGNvbnN0IGVyciA9IG5ldyBUeXBlRXJyb3IoJ0lsbGVnYWwgaW52b2NhdGlvbicpXG4gICAgICBlcnIuY29kZSA9ICdFUlJfSU5WQUxJRF9USElTJyAvLyBub2RlIGNvbXBhdC5cbiAgICAgIHRocm93IGVyclxuICAgIH1cbiAgfVxufVxuXG53ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayA9IGZ1bmN0aW9uICh7IGxlbmd0aCB9LCBtaW4sIGN0eCkge1xuICBpZiAobGVuZ3RoIDwgbWluKSB7XG4gICAgdGhyb3cgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgbWVzc2FnZTogYCR7bWlufSBhcmd1bWVudCR7bWluICE9PSAxID8gJ3MnIDogJyd9IHJlcXVpcmVkLCBgICtcbiAgICAgICAgICAgICAgIGBidXQke2xlbmd0aCA/ICcgb25seScgOiAnJ30gJHtsZW5ndGh9IGZvdW5kLmAsXG4gICAgICBoZWFkZXI6IGN0eFxuICAgIH0pXG4gIH1cbn1cblxud2ViaWRsLmlsbGVnYWxDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uICgpIHtcbiAgdGhyb3cgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgIGhlYWRlcjogJ1R5cGVFcnJvcicsXG4gICAgbWVzc2FnZTogJ0lsbGVnYWwgY29uc3RydWN0b3InXG4gIH0pXG59XG5cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtZWNtYXNjcmlwdC1kYXRhLXR5cGVzLWFuZC12YWx1ZXNcbndlYmlkbC51dGlsLlR5cGUgPSBmdW5jdGlvbiAoVikge1xuICBzd2l0Y2ggKHR5cGVvZiBWKSB7XG4gICAgY2FzZSAndW5kZWZpbmVkJzogcmV0dXJuICdVbmRlZmluZWQnXG4gICAgY2FzZSAnYm9vbGVhbic6IHJldHVybiAnQm9vbGVhbidcbiAgICBjYXNlICdzdHJpbmcnOiByZXR1cm4gJ1N0cmluZydcbiAgICBjYXNlICdzeW1ib2wnOiByZXR1cm4gJ1N5bWJvbCdcbiAgICBjYXNlICdudW1iZXInOiByZXR1cm4gJ051bWJlcidcbiAgICBjYXNlICdiaWdpbnQnOiByZXR1cm4gJ0JpZ0ludCdcbiAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgY2FzZSAnb2JqZWN0Jzoge1xuICAgICAgaWYgKFYgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuICdOdWxsJ1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gJ09iamVjdCdcbiAgICB9XG4gIH1cbn1cblxuLy8gaHR0cHM6Ly93ZWJpZGwuc3BlYy53aGF0d2cub3JnLyNhYnN0cmFjdC1vcGRlZi1jb252ZXJ0dG9pbnRcbndlYmlkbC51dGlsLkNvbnZlcnRUb0ludCA9IGZ1bmN0aW9uIChWLCBiaXRMZW5ndGgsIHNpZ25lZG5lc3MsIG9wdHMpIHtcbiAgbGV0IHVwcGVyQm91bmRcbiAgbGV0IGxvd2VyQm91bmRcblxuICAvLyAxLiBJZiBiaXRMZW5ndGggaXMgNjQsIHRoZW46XG4gIGlmIChiaXRMZW5ndGggPT09IDY0KSB7XG4gICAgLy8gMS4gTGV0IHVwcGVyQm91bmQgYmUgMl41MyDiiJIgMS5cbiAgICB1cHBlckJvdW5kID0gTWF0aC5wb3coMiwgNTMpIC0gMVxuXG4gICAgLy8gMi4gSWYgc2lnbmVkbmVzcyBpcyBcInVuc2lnbmVkXCIsIHRoZW4gbGV0IGxvd2VyQm91bmQgYmUgMC5cbiAgICBpZiAoc2lnbmVkbmVzcyA9PT0gJ3Vuc2lnbmVkJykge1xuICAgICAgbG93ZXJCb3VuZCA9IDBcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gMy4gT3RoZXJ3aXNlIGxldCBsb3dlckJvdW5kIGJlIOKIkjJeNTMgKyAxLlxuICAgICAgbG93ZXJCb3VuZCA9IE1hdGgucG93KC0yLCA1MykgKyAxXG4gICAgfVxuICB9IGVsc2UgaWYgKHNpZ25lZG5lc3MgPT09ICd1bnNpZ25lZCcpIHtcbiAgICAvLyAyLiBPdGhlcndpc2UsIGlmIHNpZ25lZG5lc3MgaXMgXCJ1bnNpZ25lZFwiLCB0aGVuOlxuXG4gICAgLy8gMS4gTGV0IGxvd2VyQm91bmQgYmUgMC5cbiAgICBsb3dlckJvdW5kID0gMFxuXG4gICAgLy8gMi4gTGV0IHVwcGVyQm91bmQgYmUgMl5iaXRMZW5ndGgg4oiSIDEuXG4gICAgdXBwZXJCb3VuZCA9IE1hdGgucG93KDIsIGJpdExlbmd0aCkgLSAxXG4gIH0gZWxzZSB7XG4gICAgLy8gMy4gT3RoZXJ3aXNlOlxuXG4gICAgLy8gMS4gTGV0IGxvd2VyQm91bmQgYmUgLTJeYml0TGVuZ3RoIOKIkiAxLlxuICAgIGxvd2VyQm91bmQgPSBNYXRoLnBvdygtMiwgYml0TGVuZ3RoKSAtIDFcblxuICAgIC8vIDIuIExldCB1cHBlckJvdW5kIGJlIDJeYml0TGVuZ3RoIOKIkiAxIOKIkiAxLlxuICAgIHVwcGVyQm91bmQgPSBNYXRoLnBvdygyLCBiaXRMZW5ndGggLSAxKSAtIDFcbiAgfVxuXG4gIC8vIDQuIExldCB4IGJlID8gVG9OdW1iZXIoVikuXG4gIGxldCB4ID0gTnVtYmVyKFYpXG5cbiAgLy8gNS4gSWYgeCBpcyDiiJIwLCB0aGVuIHNldCB4IHRvICswLlxuICBpZiAoeCA9PT0gMCkge1xuICAgIHggPSAwXG4gIH1cblxuICAvLyA2LiBJZiB0aGUgY29udmVyc2lvbiBpcyB0byBhbiBJREwgdHlwZSBhc3NvY2lhdGVkXG4gIC8vICAgIHdpdGggdGhlIFtFbmZvcmNlUmFuZ2VdIGV4dGVuZGVkIGF0dHJpYnV0ZSwgdGhlbjpcbiAgaWYgKG9wdHM/LmVuZm9yY2VSYW5nZSA9PT0gdHJ1ZSkge1xuICAgIC8vIDEuIElmIHggaXMgTmFOLCAr4oieLCBvciDiiJLiiJ4sIHRoZW4gdGhyb3cgYSBUeXBlRXJyb3IuXG4gICAgaWYgKFxuICAgICAgTnVtYmVyLmlzTmFOKHgpIHx8XG4gICAgICB4ID09PSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkgfHxcbiAgICAgIHggPT09IE51bWJlci5ORUdBVElWRV9JTkZJTklUWVxuICAgICkge1xuICAgICAgdGhyb3cgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgICBoZWFkZXI6ICdJbnRlZ2VyIGNvbnZlcnNpb24nLFxuICAgICAgICBtZXNzYWdlOiBgQ291bGQgbm90IGNvbnZlcnQgJHt3ZWJpZGwudXRpbC5TdHJpbmdpZnkoVil9IHRvIGFuIGludGVnZXIuYFxuICAgICAgfSlcbiAgICB9XG5cbiAgICAvLyAyLiBTZXQgeCB0byBJbnRlZ2VyUGFydCh4KS5cbiAgICB4ID0gd2ViaWRsLnV0aWwuSW50ZWdlclBhcnQoeClcblxuICAgIC8vIDMuIElmIHggPCBsb3dlckJvdW5kIG9yIHggPiB1cHBlckJvdW5kLCB0aGVuXG4gICAgLy8gICAgdGhyb3cgYSBUeXBlRXJyb3IuXG4gICAgaWYgKHggPCBsb3dlckJvdW5kIHx8IHggPiB1cHBlckJvdW5kKSB7XG4gICAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICAgIGhlYWRlcjogJ0ludGVnZXIgY29udmVyc2lvbicsXG4gICAgICAgIG1lc3NhZ2U6IGBWYWx1ZSBtdXN0IGJlIGJldHdlZW4gJHtsb3dlckJvdW5kfS0ke3VwcGVyQm91bmR9LCBnb3QgJHt4fS5gXG4gICAgICB9KVxuICAgIH1cblxuICAgIC8vIDQuIFJldHVybiB4LlxuICAgIHJldHVybiB4XG4gIH1cblxuICAvLyA3LiBJZiB4IGlzIG5vdCBOYU4gYW5kIHRoZSBjb252ZXJzaW9uIGlzIHRvIGFuIElETFxuICAvLyAgICB0eXBlIGFzc29jaWF0ZWQgd2l0aCB0aGUgW0NsYW1wXSBleHRlbmRlZFxuICAvLyAgICBhdHRyaWJ1dGUsIHRoZW46XG4gIGlmICghTnVtYmVyLmlzTmFOKHgpICYmIG9wdHM/LmNsYW1wID09PSB0cnVlKSB7XG4gICAgLy8gMS4gU2V0IHggdG8gbWluKG1heCh4LCBsb3dlckJvdW5kKSwgdXBwZXJCb3VuZCkuXG4gICAgeCA9IE1hdGgubWluKE1hdGgubWF4KHgsIGxvd2VyQm91bmQpLCB1cHBlckJvdW5kKVxuXG4gICAgLy8gMi4gUm91bmQgeCB0byB0aGUgbmVhcmVzdCBpbnRlZ2VyLCBjaG9vc2luZyB0aGVcbiAgICAvLyAgICBldmVuIGludGVnZXIgaWYgaXQgbGllcyBoYWxmd2F5IGJldHdlZW4gdHdvLFxuICAgIC8vICAgIGFuZCBjaG9vc2luZyArMCByYXRoZXIgdGhhbiDiiJIwLlxuICAgIGlmIChNYXRoLmZsb29yKHgpICUgMiA9PT0gMCkge1xuICAgICAgeCA9IE1hdGguZmxvb3IoeClcbiAgICB9IGVsc2Uge1xuICAgICAgeCA9IE1hdGguY2VpbCh4KVxuICAgIH1cblxuICAgIC8vIDMuIFJldHVybiB4LlxuICAgIHJldHVybiB4XG4gIH1cblxuICAvLyA4LiBJZiB4IGlzIE5hTiwgKzAsICviiJ4sIG9yIOKIkuKIniwgdGhlbiByZXR1cm4gKzAuXG4gIGlmIChcbiAgICBOdW1iZXIuaXNOYU4oeCkgfHxcbiAgICAoeCA9PT0gMCAmJiBPYmplY3QuaXMoMCwgeCkpIHx8XG4gICAgeCA9PT0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZIHx8XG4gICAgeCA9PT0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZXG4gICkge1xuICAgIHJldHVybiAwXG4gIH1cblxuICAvLyA5LiBTZXQgeCB0byBJbnRlZ2VyUGFydCh4KS5cbiAgeCA9IHdlYmlkbC51dGlsLkludGVnZXJQYXJ0KHgpXG5cbiAgLy8gMTAuIFNldCB4IHRvIHggbW9kdWxvIDJeYml0TGVuZ3RoLlxuICB4ID0geCAlIE1hdGgucG93KDIsIGJpdExlbmd0aClcblxuICAvLyAxMS4gSWYgc2lnbmVkbmVzcyBpcyBcInNpZ25lZFwiIGFuZCB4IOKJpSAyXmJpdExlbmd0aCDiiJIgMSxcbiAgLy8gICAgdGhlbiByZXR1cm4geCDiiJIgMl5iaXRMZW5ndGguXG4gIGlmIChzaWduZWRuZXNzID09PSAnc2lnbmVkJyAmJiB4ID49IE1hdGgucG93KDIsIGJpdExlbmd0aCkgLSAxKSB7XG4gICAgcmV0dXJuIHggLSBNYXRoLnBvdygyLCBiaXRMZW5ndGgpXG4gIH1cblxuICAvLyAxMi4gT3RoZXJ3aXNlLCByZXR1cm4geC5cbiAgcmV0dXJuIHhcbn1cblxuLy8gaHR0cHM6Ly93ZWJpZGwuc3BlYy53aGF0d2cub3JnLyNhYnN0cmFjdC1vcGRlZi1pbnRlZ2VycGFydFxud2ViaWRsLnV0aWwuSW50ZWdlclBhcnQgPSBmdW5jdGlvbiAobikge1xuICAvLyAxLiBMZXQgciBiZSBmbG9vcihhYnMobikpLlxuICBjb25zdCByID0gTWF0aC5mbG9vcihNYXRoLmFicyhuKSlcblxuICAvLyAyLiBJZiBuIDwgMCwgdGhlbiByZXR1cm4gLTEgw5cgci5cbiAgaWYgKG4gPCAwKSB7XG4gICAgcmV0dXJuIC0xICogclxuICB9XG5cbiAgLy8gMy4gT3RoZXJ3aXNlLCByZXR1cm4gci5cbiAgcmV0dXJuIHJcbn1cblxud2ViaWRsLnV0aWwuU3RyaW5naWZ5ID0gZnVuY3Rpb24gKFYpIHtcbiAgY29uc3QgdHlwZSA9IHdlYmlkbC51dGlsLlR5cGUoVilcblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdTeW1ib2wnOlxuICAgICAgcmV0dXJuIGBTeW1ib2woJHtWLmRlc2NyaXB0aW9ufSlgXG4gICAgY2FzZSAnT2JqZWN0JzpcbiAgICAgIHJldHVybiBpbnNwZWN0KFYpXG4gICAgY2FzZSAnU3RyaW5nJzpcbiAgICAgIHJldHVybiBgXCIke1Z9XCJgXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBgJHtWfWBcbiAgfVxufVxuXG4vLyBodHRwczovL3dlYmlkbC5zcGVjLndoYXR3Zy5vcmcvI2VzLXNlcXVlbmNlXG53ZWJpZGwuc2VxdWVuY2VDb252ZXJ0ZXIgPSBmdW5jdGlvbiAoY29udmVydGVyKSB7XG4gIHJldHVybiAoViwgcHJlZml4LCBhcmd1bWVudCwgSXRlcmFibGUpID0+IHtcbiAgICAvLyAxLiBJZiBUeXBlKFYpIGlzIG5vdCBPYmplY3QsIHRocm93IGEgVHlwZUVycm9yLlxuICAgIGlmICh3ZWJpZGwudXRpbC5UeXBlKFYpICE9PSAnT2JqZWN0Jykge1xuICAgICAgdGhyb3cgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgICBoZWFkZXI6IHByZWZpeCxcbiAgICAgICAgbWVzc2FnZTogYCR7YXJndW1lbnR9ICgke3dlYmlkbC51dGlsLlN0cmluZ2lmeShWKX0pIGlzIG5vdCBpdGVyYWJsZS5gXG4gICAgICB9KVxuICAgIH1cblxuICAgIC8vIDIuIExldCBtZXRob2QgYmUgPyBHZXRNZXRob2QoViwgQEBpdGVyYXRvcikuXG4gICAgLyoqIEB0eXBlIHtHZW5lcmF0b3J9ICovXG4gICAgY29uc3QgbWV0aG9kID0gdHlwZW9mIEl0ZXJhYmxlID09PSAnZnVuY3Rpb24nID8gSXRlcmFibGUoKSA6IFY/LltTeW1ib2wuaXRlcmF0b3JdPy4oKVxuICAgIGNvbnN0IHNlcSA9IFtdXG4gICAgbGV0IGluZGV4ID0gMFxuXG4gICAgLy8gMy4gSWYgbWV0aG9kIGlzIHVuZGVmaW5lZCwgdGhyb3cgYSBUeXBlRXJyb3IuXG4gICAgaWYgKFxuICAgICAgbWV0aG9kID09PSB1bmRlZmluZWQgfHxcbiAgICAgIHR5cGVvZiBtZXRob2QubmV4dCAhPT0gJ2Z1bmN0aW9uJ1xuICAgICkge1xuICAgICAgdGhyb3cgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgICBoZWFkZXI6IHByZWZpeCxcbiAgICAgICAgbWVzc2FnZTogYCR7YXJndW1lbnR9IGlzIG5vdCBpdGVyYWJsZS5gXG4gICAgICB9KVxuICAgIH1cblxuICAgIC8vIGh0dHBzOi8vd2ViaWRsLnNwZWMud2hhdHdnLm9yZy8jY3JlYXRlLXNlcXVlbmNlLWZyb20taXRlcmFibGVcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gbWV0aG9kLm5leHQoKVxuXG4gICAgICBpZiAoZG9uZSkge1xuICAgICAgICBicmVha1xuICAgICAgfVxuXG4gICAgICBzZXEucHVzaChjb252ZXJ0ZXIodmFsdWUsIHByZWZpeCwgYCR7YXJndW1lbnR9WyR7aW5kZXgrK31dYCkpXG4gICAgfVxuXG4gICAgcmV0dXJuIHNlcVxuICB9XG59XG5cbi8vIGh0dHBzOi8vd2ViaWRsLnNwZWMud2hhdHdnLm9yZy8jZXMtdG8tcmVjb3JkXG53ZWJpZGwucmVjb3JkQ29udmVydGVyID0gZnVuY3Rpb24gKGtleUNvbnZlcnRlciwgdmFsdWVDb252ZXJ0ZXIpIHtcbiAgcmV0dXJuIChPLCBwcmVmaXgsIGFyZ3VtZW50KSA9PiB7XG4gICAgLy8gMS4gSWYgVHlwZShPKSBpcyBub3QgT2JqZWN0LCB0aHJvdyBhIFR5cGVFcnJvci5cbiAgICBpZiAod2ViaWRsLnV0aWwuVHlwZShPKSAhPT0gJ09iamVjdCcpIHtcbiAgICAgIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgICAgaGVhZGVyOiBwcmVmaXgsXG4gICAgICAgIG1lc3NhZ2U6IGAke2FyZ3VtZW50fSAoXCIke3dlYmlkbC51dGlsLlR5cGUoTyl9XCIpIGlzIG5vdCBhbiBPYmplY3QuYFxuICAgICAgfSlcbiAgICB9XG5cbiAgICAvLyAyLiBMZXQgcmVzdWx0IGJlIGEgbmV3IGVtcHR5IGluc3RhbmNlIG9mIHJlY29yZDxLLCBWPi5cbiAgICBjb25zdCByZXN1bHQgPSB7fVxuXG4gICAgaWYgKCF0eXBlcy5pc1Byb3h5KE8pKSB7XG4gICAgICAvLyAxLiBMZXQgZGVzYyBiZSA/IE8uW1tHZXRPd25Qcm9wZXJ0eV1dKGtleSkuXG4gICAgICBjb25zdCBrZXlzID0gWy4uLk9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE8pLCAuLi5PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKE8pXVxuXG4gICAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICAgIC8vIDEuIExldCB0eXBlZEtleSBiZSBrZXkgY29udmVydGVkIHRvIGFuIElETCB2YWx1ZSBvZiB0eXBlIEsuXG4gICAgICAgIGNvbnN0IHR5cGVkS2V5ID0ga2V5Q29udmVydGVyKGtleSwgcHJlZml4LCBhcmd1bWVudClcblxuICAgICAgICAvLyAyLiBMZXQgdmFsdWUgYmUgPyBHZXQoTywga2V5KS5cbiAgICAgICAgLy8gMy4gTGV0IHR5cGVkVmFsdWUgYmUgdmFsdWUgY29udmVydGVkIHRvIGFuIElETCB2YWx1ZSBvZiB0eXBlIFYuXG4gICAgICAgIGNvbnN0IHR5cGVkVmFsdWUgPSB2YWx1ZUNvbnZlcnRlcihPW2tleV0sIHByZWZpeCwgYXJndW1lbnQpXG5cbiAgICAgICAgLy8gNC4gU2V0IHJlc3VsdFt0eXBlZEtleV0gdG8gdHlwZWRWYWx1ZS5cbiAgICAgICAgcmVzdWx0W3R5cGVkS2V5XSA9IHR5cGVkVmFsdWVcbiAgICAgIH1cblxuICAgICAgLy8gNS4gUmV0dXJuIHJlc3VsdC5cbiAgICAgIHJldHVybiByZXN1bHRcbiAgICB9XG5cbiAgICAvLyAzLiBMZXQga2V5cyBiZSA/IE8uW1tPd25Qcm9wZXJ0eUtleXNdXSgpLlxuICAgIGNvbnN0IGtleXMgPSBSZWZsZWN0Lm93bktleXMoTylcblxuICAgIC8vIDQuIEZvciBlYWNoIGtleSBvZiBrZXlzLlxuICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgIC8vIDEuIExldCBkZXNjIGJlID8gTy5bW0dldE93blByb3BlcnR5XV0oa2V5KS5cbiAgICAgIGNvbnN0IGRlc2MgPSBSZWZsZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBrZXkpXG5cbiAgICAgIC8vIDIuIElmIGRlc2MgaXMgbm90IHVuZGVmaW5lZCBhbmQgZGVzYy5bW0VudW1lcmFibGVdXSBpcyB0cnVlOlxuICAgICAgaWYgKGRlc2M/LmVudW1lcmFibGUpIHtcbiAgICAgICAgLy8gMS4gTGV0IHR5cGVkS2V5IGJlIGtleSBjb252ZXJ0ZWQgdG8gYW4gSURMIHZhbHVlIG9mIHR5cGUgSy5cbiAgICAgICAgY29uc3QgdHlwZWRLZXkgPSBrZXlDb252ZXJ0ZXIoa2V5LCBwcmVmaXgsIGFyZ3VtZW50KVxuXG4gICAgICAgIC8vIDIuIExldCB2YWx1ZSBiZSA/IEdldChPLCBrZXkpLlxuICAgICAgICAvLyAzLiBMZXQgdHlwZWRWYWx1ZSBiZSB2YWx1ZSBjb252ZXJ0ZWQgdG8gYW4gSURMIHZhbHVlIG9mIHR5cGUgVi5cbiAgICAgICAgY29uc3QgdHlwZWRWYWx1ZSA9IHZhbHVlQ29udmVydGVyKE9ba2V5XSwgcHJlZml4LCBhcmd1bWVudClcblxuICAgICAgICAvLyA0LiBTZXQgcmVzdWx0W3R5cGVkS2V5XSB0byB0eXBlZFZhbHVlLlxuICAgICAgICByZXN1bHRbdHlwZWRLZXldID0gdHlwZWRWYWx1ZVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIDUuIFJldHVybiByZXN1bHQuXG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG59XG5cbndlYmlkbC5pbnRlcmZhY2VDb252ZXJ0ZXIgPSBmdW5jdGlvbiAoaSkge1xuICByZXR1cm4gKFYsIHByZWZpeCwgYXJndW1lbnQsIG9wdHMpID0+IHtcbiAgICBpZiAob3B0cz8uc3RyaWN0ICE9PSBmYWxzZSAmJiAhKFYgaW5zdGFuY2VvZiBpKSkge1xuICAgICAgdGhyb3cgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgICBoZWFkZXI6IHByZWZpeCxcbiAgICAgICAgbWVzc2FnZTogYEV4cGVjdGVkICR7YXJndW1lbnR9IChcIiR7d2ViaWRsLnV0aWwuU3RyaW5naWZ5KFYpfVwiKSB0byBiZSBhbiBpbnN0YW5jZSBvZiAke2kubmFtZX0uYFxuICAgICAgfSlcbiAgICB9XG5cbiAgICByZXR1cm4gVlxuICB9XG59XG5cbndlYmlkbC5kaWN0aW9uYXJ5Q29udmVydGVyID0gZnVuY3Rpb24gKGNvbnZlcnRlcnMpIHtcbiAgcmV0dXJuIChkaWN0aW9uYXJ5LCBwcmVmaXgsIGFyZ3VtZW50KSA9PiB7XG4gICAgY29uc3QgdHlwZSA9IHdlYmlkbC51dGlsLlR5cGUoZGljdGlvbmFyeSlcbiAgICBjb25zdCBkaWN0ID0ge31cblxuICAgIGlmICh0eXBlID09PSAnTnVsbCcgfHwgdHlwZSA9PT0gJ1VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBkaWN0XG4gICAgfSBlbHNlIGlmICh0eXBlICE9PSAnT2JqZWN0Jykge1xuICAgICAgdGhyb3cgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgICBoZWFkZXI6IHByZWZpeCxcbiAgICAgICAgbWVzc2FnZTogYEV4cGVjdGVkICR7ZGljdGlvbmFyeX0gdG8gYmUgb25lIG9mOiBOdWxsLCBVbmRlZmluZWQsIE9iamVjdC5gXG4gICAgICB9KVxuICAgIH1cblxuICAgIGZvciAoY29uc3Qgb3B0aW9ucyBvZiBjb252ZXJ0ZXJzKSB7XG4gICAgICBjb25zdCB7IGtleSwgZGVmYXVsdFZhbHVlLCByZXF1aXJlZCwgY29udmVydGVyIH0gPSBvcHRpb25zXG5cbiAgICAgIGlmIChyZXF1aXJlZCA9PT0gdHJ1ZSkge1xuICAgICAgICBpZiAoIU9iamVjdC5oYXNPd24oZGljdGlvbmFyeSwga2V5KSkge1xuICAgICAgICAgIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgICAgICAgIGhlYWRlcjogcHJlZml4LFxuICAgICAgICAgICAgbWVzc2FnZTogYE1pc3NpbmcgcmVxdWlyZWQga2V5IFwiJHtrZXl9XCIuYFxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbGV0IHZhbHVlID0gZGljdGlvbmFyeVtrZXldXG4gICAgICBjb25zdCBoYXNEZWZhdWx0ID0gT2JqZWN0Lmhhc093bihvcHRpb25zLCAnZGVmYXVsdFZhbHVlJylcblxuICAgICAgLy8gT25seSB1c2UgZGVmYXVsdFZhbHVlIGlmIHZhbHVlIGlzIHVuZGVmaW5lZCBhbmRcbiAgICAgIC8vIGEgZGVmYXVsdFZhbHVlIG9wdGlvbnMgd2FzIHByb3ZpZGVkLlxuICAgICAgaWYgKGhhc0RlZmF1bHQgJiYgdmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgdmFsdWUgPz89IGRlZmF1bHRWYWx1ZSgpXG4gICAgICB9XG5cbiAgICAgIC8vIEEga2V5IGNhbiBiZSBvcHRpb25hbCBhbmQgaGF2ZSBubyBkZWZhdWx0IHZhbHVlLlxuICAgICAgLy8gV2hlbiB0aGlzIGhhcHBlbnMsIGRvIG5vdCBwZXJmb3JtIGEgY29udmVyc2lvbixcbiAgICAgIC8vIGFuZCBkbyBub3QgYXNzaWduIHRoZSBrZXkgYSB2YWx1ZS5cbiAgICAgIGlmIChyZXF1aXJlZCB8fCBoYXNEZWZhdWx0IHx8IHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFsdWUgPSBjb252ZXJ0ZXIodmFsdWUsIHByZWZpeCwgYCR7YXJndW1lbnR9LiR7a2V5fWApXG5cbiAgICAgICAgaWYgKFxuICAgICAgICAgIG9wdGlvbnMuYWxsb3dlZFZhbHVlcyAmJlxuICAgICAgICAgICFvcHRpb25zLmFsbG93ZWRWYWx1ZXMuaW5jbHVkZXModmFsdWUpXG4gICAgICAgICkge1xuICAgICAgICAgIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgICAgICAgIGhlYWRlcjogcHJlZml4LFxuICAgICAgICAgICAgbWVzc2FnZTogYCR7dmFsdWV9IGlzIG5vdCBhbiBhY2NlcHRlZCB0eXBlLiBFeHBlY3RlZCBvbmUgb2YgJHtvcHRpb25zLmFsbG93ZWRWYWx1ZXMuam9pbignLCAnKX0uYFxuICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICBkaWN0W2tleV0gPSB2YWx1ZVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBkaWN0XG4gIH1cbn1cblxud2ViaWRsLm51bGxhYmxlQ29udmVydGVyID0gZnVuY3Rpb24gKGNvbnZlcnRlcikge1xuICByZXR1cm4gKFYsIHByZWZpeCwgYXJndW1lbnQpID0+IHtcbiAgICBpZiAoViA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIFZcbiAgICB9XG5cbiAgICByZXR1cm4gY29udmVydGVyKFYsIHByZWZpeCwgYXJndW1lbnQpXG4gIH1cbn1cblxuLy8gaHR0cHM6Ly93ZWJpZGwuc3BlYy53aGF0d2cub3JnLyNlcy1ET01TdHJpbmdcbndlYmlkbC5jb252ZXJ0ZXJzLkRPTVN0cmluZyA9IGZ1bmN0aW9uIChWLCBwcmVmaXgsIGFyZ3VtZW50LCBvcHRzKSB7XG4gIC8vIDEuIElmIFYgaXMgbnVsbCBhbmQgdGhlIGNvbnZlcnNpb24gaXMgdG8gYW4gSURMIHR5cGVcbiAgLy8gICAgYXNzb2NpYXRlZCB3aXRoIHRoZSBbTGVnYWN5TnVsbFRvRW1wdHlTdHJpbmddXG4gIC8vICAgIGV4dGVuZGVkIGF0dHJpYnV0ZSwgdGhlbiByZXR1cm4gdGhlIERPTVN0cmluZyB2YWx1ZVxuICAvLyAgICB0aGF0IHJlcHJlc2VudHMgdGhlIGVtcHR5IHN0cmluZy5cbiAgaWYgKFYgPT09IG51bGwgJiYgb3B0cz8ubGVnYWN5TnVsbFRvRW1wdHlTdHJpbmcpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIC8vIDIuIExldCB4IGJlID8gVG9TdHJpbmcoVikuXG4gIGlmICh0eXBlb2YgViA9PT0gJ3N5bWJvbCcpIHtcbiAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICBoZWFkZXI6IHByZWZpeCxcbiAgICAgIG1lc3NhZ2U6IGAke2FyZ3VtZW50fSBpcyBhIHN5bWJvbCwgd2hpY2ggY2Fubm90IGJlIGNvbnZlcnRlZCB0byBhIERPTVN0cmluZy5gXG4gICAgfSlcbiAgfVxuXG4gIC8vIDMuIFJldHVybiB0aGUgSURMIERPTVN0cmluZyB2YWx1ZSB0aGF0IHJlcHJlc2VudHMgdGhlXG4gIC8vICAgIHNhbWUgc2VxdWVuY2Ugb2YgY29kZSB1bml0cyBhcyB0aGUgb25lIHRoZVxuICAvLyAgICBFQ01BU2NyaXB0IFN0cmluZyB2YWx1ZSB4IHJlcHJlc2VudHMuXG4gIHJldHVybiBTdHJpbmcoVilcbn1cblxuLy8gaHR0cHM6Ly93ZWJpZGwuc3BlYy53aGF0d2cub3JnLyNlcy1CeXRlU3RyaW5nXG53ZWJpZGwuY29udmVydGVycy5CeXRlU3RyaW5nID0gZnVuY3Rpb24gKFYsIHByZWZpeCwgYXJndW1lbnQpIHtcbiAgLy8gMS4gTGV0IHggYmUgPyBUb1N0cmluZyhWKS5cbiAgLy8gTm90ZTogRE9NU3RyaW5nIGNvbnZlcnRlciBwZXJmb3JtID8gVG9TdHJpbmcoVilcbiAgY29uc3QgeCA9IHdlYmlkbC5jb252ZXJ0ZXJzLkRPTVN0cmluZyhWLCBwcmVmaXgsIGFyZ3VtZW50KVxuXG4gIC8vIDIuIElmIHRoZSB2YWx1ZSBvZiBhbnkgZWxlbWVudCBvZiB4IGlzIGdyZWF0ZXIgdGhhblxuICAvLyAgICAyNTUsIHRoZW4gdGhyb3cgYSBUeXBlRXJyb3IuXG4gIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCB4Lmxlbmd0aDsgaW5kZXgrKykge1xuICAgIGlmICh4LmNoYXJDb2RlQXQoaW5kZXgpID4gMjU1KSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAnQ2Fubm90IGNvbnZlcnQgYXJndW1lbnQgdG8gYSBCeXRlU3RyaW5nIGJlY2F1c2UgdGhlIGNoYXJhY3RlciBhdCAnICtcbiAgICAgICAgYGluZGV4ICR7aW5kZXh9IGhhcyBhIHZhbHVlIG9mICR7eC5jaGFyQ29kZUF0KGluZGV4KX0gd2hpY2ggaXMgZ3JlYXRlciB0aGFuIDI1NS5gXG4gICAgICApXG4gICAgfVxuICB9XG5cbiAgLy8gMy4gUmV0dXJuIGFuIElETCBCeXRlU3RyaW5nIHZhbHVlIHdob3NlIGxlbmd0aCBpcyB0aGVcbiAgLy8gICAgbGVuZ3RoIG9mIHgsIGFuZCB3aGVyZSB0aGUgdmFsdWUgb2YgZWFjaCBlbGVtZW50IGlzXG4gIC8vICAgIHRoZSB2YWx1ZSBvZiB0aGUgY29ycmVzcG9uZGluZyBlbGVtZW50IG9mIHguXG4gIHJldHVybiB4XG59XG5cbi8vIGh0dHBzOi8vd2ViaWRsLnNwZWMud2hhdHdnLm9yZy8jZXMtVVNWU3RyaW5nXG4vLyBUT0RPOiByZXdyaXRlIHRoaXMgc28gd2UgY2FuIGNvbnRyb2wgdGhlIGVycm9ycyB0aHJvd25cbndlYmlkbC5jb252ZXJ0ZXJzLlVTVlN0cmluZyA9IHRvVVNWU3RyaW5nXG5cbi8vIGh0dHBzOi8vd2ViaWRsLnNwZWMud2hhdHdnLm9yZy8jZXMtYm9vbGVhblxud2ViaWRsLmNvbnZlcnRlcnMuYm9vbGVhbiA9IGZ1bmN0aW9uIChWKSB7XG4gIC8vIDEuIExldCB4IGJlIHRoZSByZXN1bHQgb2YgY29tcHV0aW5nIFRvQm9vbGVhbihWKS5cbiAgY29uc3QgeCA9IEJvb2xlYW4oVilcblxuICAvLyAyLiBSZXR1cm4gdGhlIElETCBib29sZWFuIHZhbHVlIHRoYXQgaXMgdGhlIG9uZSB0aGF0IHJlcHJlc2VudHNcbiAgLy8gICAgdGhlIHNhbWUgdHJ1dGggdmFsdWUgYXMgdGhlIEVDTUFTY3JpcHQgQm9vbGVhbiB2YWx1ZSB4LlxuICByZXR1cm4geFxufVxuXG4vLyBodHRwczovL3dlYmlkbC5zcGVjLndoYXR3Zy5vcmcvI2VzLWFueVxud2ViaWRsLmNvbnZlcnRlcnMuYW55ID0gZnVuY3Rpb24gKFYpIHtcbiAgcmV0dXJuIFZcbn1cblxuLy8gaHR0cHM6Ly93ZWJpZGwuc3BlYy53aGF0d2cub3JnLyNlcy1sb25nLWxvbmdcbndlYmlkbC5jb252ZXJ0ZXJzWydsb25nIGxvbmcnXSA9IGZ1bmN0aW9uIChWLCBwcmVmaXgsIGFyZ3VtZW50KSB7XG4gIC8vIDEuIExldCB4IGJlID8gQ29udmVydFRvSW50KFYsIDY0LCBcInNpZ25lZFwiKS5cbiAgY29uc3QgeCA9IHdlYmlkbC51dGlsLkNvbnZlcnRUb0ludChWLCA2NCwgJ3NpZ25lZCcsIHVuZGVmaW5lZCwgcHJlZml4LCBhcmd1bWVudClcblxuICAvLyAyLiBSZXR1cm4gdGhlIElETCBsb25nIGxvbmcgdmFsdWUgdGhhdCByZXByZXNlbnRzXG4gIC8vICAgIHRoZSBzYW1lIG51bWVyaWMgdmFsdWUgYXMgeC5cbiAgcmV0dXJuIHhcbn1cblxuLy8gaHR0cHM6Ly93ZWJpZGwuc3BlYy53aGF0d2cub3JnLyNlcy11bnNpZ25lZC1sb25nLWxvbmdcbndlYmlkbC5jb252ZXJ0ZXJzWyd1bnNpZ25lZCBsb25nIGxvbmcnXSA9IGZ1bmN0aW9uIChWLCBwcmVmaXgsIGFyZ3VtZW50KSB7XG4gIC8vIDEuIExldCB4IGJlID8gQ29udmVydFRvSW50KFYsIDY0LCBcInVuc2lnbmVkXCIpLlxuICBjb25zdCB4ID0gd2ViaWRsLnV0aWwuQ29udmVydFRvSW50KFYsIDY0LCAndW5zaWduZWQnLCB1bmRlZmluZWQsIHByZWZpeCwgYXJndW1lbnQpXG5cbiAgLy8gMi4gUmV0dXJuIHRoZSBJREwgdW5zaWduZWQgbG9uZyBsb25nIHZhbHVlIHRoYXRcbiAgLy8gICAgcmVwcmVzZW50cyB0aGUgc2FtZSBudW1lcmljIHZhbHVlIGFzIHguXG4gIHJldHVybiB4XG59XG5cbi8vIGh0dHBzOi8vd2ViaWRsLnNwZWMud2hhdHdnLm9yZy8jZXMtdW5zaWduZWQtbG9uZ1xud2ViaWRsLmNvbnZlcnRlcnNbJ3Vuc2lnbmVkIGxvbmcnXSA9IGZ1bmN0aW9uIChWLCBwcmVmaXgsIGFyZ3VtZW50KSB7XG4gIC8vIDEuIExldCB4IGJlID8gQ29udmVydFRvSW50KFYsIDMyLCBcInVuc2lnbmVkXCIpLlxuICBjb25zdCB4ID0gd2ViaWRsLnV0aWwuQ29udmVydFRvSW50KFYsIDMyLCAndW5zaWduZWQnLCB1bmRlZmluZWQsIHByZWZpeCwgYXJndW1lbnQpXG5cbiAgLy8gMi4gUmV0dXJuIHRoZSBJREwgdW5zaWduZWQgbG9uZyB2YWx1ZSB0aGF0XG4gIC8vICAgIHJlcHJlc2VudHMgdGhlIHNhbWUgbnVtZXJpYyB2YWx1ZSBhcyB4LlxuICByZXR1cm4geFxufVxuXG4vLyBodHRwczovL3dlYmlkbC5zcGVjLndoYXR3Zy5vcmcvI2VzLXVuc2lnbmVkLXNob3J0XG53ZWJpZGwuY29udmVydGVyc1sndW5zaWduZWQgc2hvcnQnXSA9IGZ1bmN0aW9uIChWLCBwcmVmaXgsIGFyZ3VtZW50LCBvcHRzKSB7XG4gIC8vIDEuIExldCB4IGJlID8gQ29udmVydFRvSW50KFYsIDE2LCBcInVuc2lnbmVkXCIpLlxuICBjb25zdCB4ID0gd2ViaWRsLnV0aWwuQ29udmVydFRvSW50KFYsIDE2LCAndW5zaWduZWQnLCBvcHRzLCBwcmVmaXgsIGFyZ3VtZW50KVxuXG4gIC8vIDIuIFJldHVybiB0aGUgSURMIHVuc2lnbmVkIHNob3J0IHZhbHVlIHRoYXQgcmVwcmVzZW50c1xuICAvLyAgICB0aGUgc2FtZSBudW1lcmljIHZhbHVlIGFzIHguXG4gIHJldHVybiB4XG59XG5cbi8vIGh0dHBzOi8vd2ViaWRsLnNwZWMud2hhdHdnLm9yZy8jaWRsLUFycmF5QnVmZmVyXG53ZWJpZGwuY29udmVydGVycy5BcnJheUJ1ZmZlciA9IGZ1bmN0aW9uIChWLCBwcmVmaXgsIGFyZ3VtZW50LCBvcHRzKSB7XG4gIC8vIDEuIElmIFR5cGUoVikgaXMgbm90IE9iamVjdCwgb3IgViBkb2VzIG5vdCBoYXZlIGFuXG4gIC8vICAgIFtbQXJyYXlCdWZmZXJEYXRhXV0gaW50ZXJuYWwgc2xvdCwgdGhlbiB0aHJvdyBhXG4gIC8vICAgIFR5cGVFcnJvci5cbiAgLy8gc2VlOiBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXByb3BlcnRpZXMtb2YtdGhlLWFycmF5YnVmZmVyLWluc3RhbmNlc1xuICAvLyBzZWU6IGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtcHJvcGVydGllcy1vZi10aGUtc2hhcmVkYXJyYXlidWZmZXItaW5zdGFuY2VzXG4gIGlmIChcbiAgICB3ZWJpZGwudXRpbC5UeXBlKFYpICE9PSAnT2JqZWN0JyB8fFxuICAgICF0eXBlcy5pc0FueUFycmF5QnVmZmVyKFYpXG4gICkge1xuICAgIHRocm93IHdlYmlkbC5lcnJvcnMuY29udmVyc2lvbkZhaWxlZCh7XG4gICAgICBwcmVmaXgsXG4gICAgICBhcmd1bWVudDogYCR7YXJndW1lbnR9IChcIiR7d2ViaWRsLnV0aWwuU3RyaW5naWZ5KFYpfVwiKWAsXG4gICAgICB0eXBlczogWydBcnJheUJ1ZmZlciddXG4gICAgfSlcbiAgfVxuXG4gIC8vIDIuIElmIHRoZSBjb252ZXJzaW9uIGlzIG5vdCB0byBhbiBJREwgdHlwZSBhc3NvY2lhdGVkXG4gIC8vICAgIHdpdGggdGhlIFtBbGxvd1NoYXJlZF0gZXh0ZW5kZWQgYXR0cmlidXRlLCBhbmRcbiAgLy8gICAgSXNTaGFyZWRBcnJheUJ1ZmZlcihWKSBpcyB0cnVlLCB0aGVuIHRocm93IGFcbiAgLy8gICAgVHlwZUVycm9yLlxuICBpZiAob3B0cz8uYWxsb3dTaGFyZWQgPT09IGZhbHNlICYmIHR5cGVzLmlzU2hhcmVkQXJyYXlCdWZmZXIoVikpIHtcbiAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICBoZWFkZXI6ICdBcnJheUJ1ZmZlcicsXG4gICAgICBtZXNzYWdlOiAnU2hhcmVkQXJyYXlCdWZmZXIgaXMgbm90IGFsbG93ZWQuJ1xuICAgIH0pXG4gIH1cblxuICAvLyAzLiBJZiB0aGUgY29udmVyc2lvbiBpcyBub3QgdG8gYW4gSURMIHR5cGUgYXNzb2NpYXRlZFxuICAvLyAgICB3aXRoIHRoZSBbQWxsb3dSZXNpemFibGVdIGV4dGVuZGVkIGF0dHJpYnV0ZSwgYW5kXG4gIC8vICAgIElzUmVzaXphYmxlQXJyYXlCdWZmZXIoVikgaXMgdHJ1ZSwgdGhlbiB0aHJvdyBhXG4gIC8vICAgIFR5cGVFcnJvci5cbiAgaWYgKFYucmVzaXphYmxlIHx8IFYuZ3Jvd2FibGUpIHtcbiAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICBoZWFkZXI6ICdBcnJheUJ1ZmZlcicsXG4gICAgICBtZXNzYWdlOiAnUmVjZWl2ZWQgYSByZXNpemFibGUgQXJyYXlCdWZmZXIuJ1xuICAgIH0pXG4gIH1cblxuICAvLyA0LiBSZXR1cm4gdGhlIElETCBBcnJheUJ1ZmZlciB2YWx1ZSB0aGF0IGlzIGFcbiAgLy8gICAgcmVmZXJlbmNlIHRvIHRoZSBzYW1lIG9iamVjdCBhcyBWLlxuICByZXR1cm4gVlxufVxuXG53ZWJpZGwuY29udmVydGVycy5UeXBlZEFycmF5ID0gZnVuY3Rpb24gKFYsIFQsIHByZWZpeCwgbmFtZSwgb3B0cykge1xuICAvLyAxLiBMZXQgVCBiZSB0aGUgSURMIHR5cGUgViBpcyBiZWluZyBjb252ZXJ0ZWQgdG8uXG5cbiAgLy8gMi4gSWYgVHlwZShWKSBpcyBub3QgT2JqZWN0LCBvciBWIGRvZXMgbm90IGhhdmUgYVxuICAvLyAgICBbW1R5cGVkQXJyYXlOYW1lXV0gaW50ZXJuYWwgc2xvdCB3aXRoIGEgdmFsdWVcbiAgLy8gICAgZXF1YWwgdG8gVOKAmXMgbmFtZSwgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgaWYgKFxuICAgIHdlYmlkbC51dGlsLlR5cGUoVikgIT09ICdPYmplY3QnIHx8XG4gICAgIXR5cGVzLmlzVHlwZWRBcnJheShWKSB8fFxuICAgIFYuY29uc3RydWN0b3IubmFtZSAhPT0gVC5uYW1lXG4gICkge1xuICAgIHRocm93IHdlYmlkbC5lcnJvcnMuY29udmVyc2lvbkZhaWxlZCh7XG4gICAgICBwcmVmaXgsXG4gICAgICBhcmd1bWVudDogYCR7bmFtZX0gKFwiJHt3ZWJpZGwudXRpbC5TdHJpbmdpZnkoVil9XCIpYCxcbiAgICAgIHR5cGVzOiBbVC5uYW1lXVxuICAgIH0pXG4gIH1cblxuICAvLyAzLiBJZiB0aGUgY29udmVyc2lvbiBpcyBub3QgdG8gYW4gSURMIHR5cGUgYXNzb2NpYXRlZFxuICAvLyAgICB3aXRoIHRoZSBbQWxsb3dTaGFyZWRdIGV4dGVuZGVkIGF0dHJpYnV0ZSwgYW5kXG4gIC8vICAgIElzU2hhcmVkQXJyYXlCdWZmZXIoVi5bW1ZpZXdlZEFycmF5QnVmZmVyXV0pIGlzXG4gIC8vICAgIHRydWUsIHRoZW4gdGhyb3cgYSBUeXBlRXJyb3IuXG4gIGlmIChvcHRzPy5hbGxvd1NoYXJlZCA9PT0gZmFsc2UgJiYgdHlwZXMuaXNTaGFyZWRBcnJheUJ1ZmZlcihWLmJ1ZmZlcikpIHtcbiAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICBoZWFkZXI6ICdBcnJheUJ1ZmZlcicsXG4gICAgICBtZXNzYWdlOiAnU2hhcmVkQXJyYXlCdWZmZXIgaXMgbm90IGFsbG93ZWQuJ1xuICAgIH0pXG4gIH1cblxuICAvLyA0LiBJZiB0aGUgY29udmVyc2lvbiBpcyBub3QgdG8gYW4gSURMIHR5cGUgYXNzb2NpYXRlZFxuICAvLyAgICB3aXRoIHRoZSBbQWxsb3dSZXNpemFibGVdIGV4dGVuZGVkIGF0dHJpYnV0ZSwgYW5kXG4gIC8vICAgIElzUmVzaXphYmxlQXJyYXlCdWZmZXIoVi5bW1ZpZXdlZEFycmF5QnVmZmVyXV0pIGlzXG4gIC8vICAgIHRydWUsIHRoZW4gdGhyb3cgYSBUeXBlRXJyb3IuXG4gIGlmIChWLmJ1ZmZlci5yZXNpemFibGUgfHwgVi5idWZmZXIuZ3Jvd2FibGUpIHtcbiAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICBoZWFkZXI6ICdBcnJheUJ1ZmZlcicsXG4gICAgICBtZXNzYWdlOiAnUmVjZWl2ZWQgYSByZXNpemFibGUgQXJyYXlCdWZmZXIuJ1xuICAgIH0pXG4gIH1cblxuICAvLyA1LiBSZXR1cm4gdGhlIElETCB2YWx1ZSBvZiB0eXBlIFQgdGhhdCBpcyBhIHJlZmVyZW5jZVxuICAvLyAgICB0byB0aGUgc2FtZSBvYmplY3QgYXMgVi5cbiAgcmV0dXJuIFZcbn1cblxud2ViaWRsLmNvbnZlcnRlcnMuRGF0YVZpZXcgPSBmdW5jdGlvbiAoViwgcHJlZml4LCBuYW1lLCBvcHRzKSB7XG4gIC8vIDEuIElmIFR5cGUoVikgaXMgbm90IE9iamVjdCwgb3IgViBkb2VzIG5vdCBoYXZlIGFcbiAgLy8gICAgW1tEYXRhVmlld11dIGludGVybmFsIHNsb3QsIHRoZW4gdGhyb3cgYSBUeXBlRXJyb3IuXG4gIGlmICh3ZWJpZGwudXRpbC5UeXBlKFYpICE9PSAnT2JqZWN0JyB8fCAhdHlwZXMuaXNEYXRhVmlldyhWKSkge1xuICAgIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgIGhlYWRlcjogcHJlZml4LFxuICAgICAgbWVzc2FnZTogYCR7bmFtZX0gaXMgbm90IGEgRGF0YVZpZXcuYFxuICAgIH0pXG4gIH1cblxuICAvLyAyLiBJZiB0aGUgY29udmVyc2lvbiBpcyBub3QgdG8gYW4gSURMIHR5cGUgYXNzb2NpYXRlZFxuICAvLyAgICB3aXRoIHRoZSBbQWxsb3dTaGFyZWRdIGV4dGVuZGVkIGF0dHJpYnV0ZSwgYW5kXG4gIC8vICAgIElzU2hhcmVkQXJyYXlCdWZmZXIoVi5bW1ZpZXdlZEFycmF5QnVmZmVyXV0pIGlzIHRydWUsXG4gIC8vICAgIHRoZW4gdGhyb3cgYSBUeXBlRXJyb3IuXG4gIGlmIChvcHRzPy5hbGxvd1NoYXJlZCA9PT0gZmFsc2UgJiYgdHlwZXMuaXNTaGFyZWRBcnJheUJ1ZmZlcihWLmJ1ZmZlcikpIHtcbiAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICBoZWFkZXI6ICdBcnJheUJ1ZmZlcicsXG4gICAgICBtZXNzYWdlOiAnU2hhcmVkQXJyYXlCdWZmZXIgaXMgbm90IGFsbG93ZWQuJ1xuICAgIH0pXG4gIH1cblxuICAvLyAzLiBJZiB0aGUgY29udmVyc2lvbiBpcyBub3QgdG8gYW4gSURMIHR5cGUgYXNzb2NpYXRlZFxuICAvLyAgICB3aXRoIHRoZSBbQWxsb3dSZXNpemFibGVdIGV4dGVuZGVkIGF0dHJpYnV0ZSwgYW5kXG4gIC8vICAgIElzUmVzaXphYmxlQXJyYXlCdWZmZXIoVi5bW1ZpZXdlZEFycmF5QnVmZmVyXV0pIGlzXG4gIC8vICAgIHRydWUsIHRoZW4gdGhyb3cgYSBUeXBlRXJyb3IuXG4gIGlmIChWLmJ1ZmZlci5yZXNpemFibGUgfHwgVi5idWZmZXIuZ3Jvd2FibGUpIHtcbiAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICBoZWFkZXI6ICdBcnJheUJ1ZmZlcicsXG4gICAgICBtZXNzYWdlOiAnUmVjZWl2ZWQgYSByZXNpemFibGUgQXJyYXlCdWZmZXIuJ1xuICAgIH0pXG4gIH1cblxuICAvLyA0LiBSZXR1cm4gdGhlIElETCBEYXRhVmlldyB2YWx1ZSB0aGF0IGlzIGEgcmVmZXJlbmNlXG4gIC8vICAgIHRvIHRoZSBzYW1lIG9iamVjdCBhcyBWLlxuICByZXR1cm4gVlxufVxuXG4vLyBodHRwczovL3dlYmlkbC5zcGVjLndoYXR3Zy5vcmcvI0J1ZmZlclNvdXJjZVxud2ViaWRsLmNvbnZlcnRlcnMuQnVmZmVyU291cmNlID0gZnVuY3Rpb24gKFYsIHByZWZpeCwgbmFtZSwgb3B0cykge1xuICBpZiAodHlwZXMuaXNBbnlBcnJheUJ1ZmZlcihWKSkge1xuICAgIHJldHVybiB3ZWJpZGwuY29udmVydGVycy5BcnJheUJ1ZmZlcihWLCBwcmVmaXgsIG5hbWUsIHsgLi4ub3B0cywgYWxsb3dTaGFyZWQ6IGZhbHNlIH0pXG4gIH1cblxuICBpZiAodHlwZXMuaXNUeXBlZEFycmF5KFYpKSB7XG4gICAgcmV0dXJuIHdlYmlkbC5jb252ZXJ0ZXJzLlR5cGVkQXJyYXkoViwgVi5jb25zdHJ1Y3RvciwgcHJlZml4LCBuYW1lLCB7IC4uLm9wdHMsIGFsbG93U2hhcmVkOiBmYWxzZSB9KVxuICB9XG5cbiAgaWYgKHR5cGVzLmlzRGF0YVZpZXcoVikpIHtcbiAgICByZXR1cm4gd2ViaWRsLmNvbnZlcnRlcnMuRGF0YVZpZXcoViwgcHJlZml4LCBuYW1lLCB7IC4uLm9wdHMsIGFsbG93U2hhcmVkOiBmYWxzZSB9KVxuICB9XG5cbiAgdGhyb3cgd2ViaWRsLmVycm9ycy5jb252ZXJzaW9uRmFpbGVkKHtcbiAgICBwcmVmaXgsXG4gICAgYXJndW1lbnQ6IGAke25hbWV9IChcIiR7d2ViaWRsLnV0aWwuU3RyaW5naWZ5KFYpfVwiKWAsXG4gICAgdHlwZXM6IFsnQnVmZmVyU291cmNlJ11cbiAgfSlcbn1cblxud2ViaWRsLmNvbnZlcnRlcnNbJ3NlcXVlbmNlPEJ5dGVTdHJpbmc+J10gPSB3ZWJpZGwuc2VxdWVuY2VDb252ZXJ0ZXIoXG4gIHdlYmlkbC5jb252ZXJ0ZXJzLkJ5dGVTdHJpbmdcbilcblxud2ViaWRsLmNvbnZlcnRlcnNbJ3NlcXVlbmNlPHNlcXVlbmNlPEJ5dGVTdHJpbmc+PiddID0gd2ViaWRsLnNlcXVlbmNlQ29udmVydGVyKFxuICB3ZWJpZGwuY29udmVydGVyc1snc2VxdWVuY2U8Qnl0ZVN0cmluZz4nXVxuKVxuXG53ZWJpZGwuY29udmVydGVyc1sncmVjb3JkPEJ5dGVTdHJpbmcsIEJ5dGVTdHJpbmc+J10gPSB3ZWJpZGwucmVjb3JkQ29udmVydGVyKFxuICB3ZWJpZGwuY29udmVydGVycy5CeXRlU3RyaW5nLFxuICB3ZWJpZGwuY29udmVydGVycy5CeXRlU3RyaW5nXG4pXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICB3ZWJpZGxcbn1cbiJdLCJuYW1lcyI6WyJ0eXBlcyIsImluc3BlY3QiLCJyZXF1aXJlIiwidG9VU1ZTdHJpbmciLCJ3ZWJpZGwiLCJjb252ZXJ0ZXJzIiwidXRpbCIsImVycm9ycyIsImV4Y2VwdGlvbiIsIm1lc3NhZ2UiLCJUeXBlRXJyb3IiLCJoZWFkZXIiLCJjb252ZXJzaW9uRmFpbGVkIiwiY29udGV4dCIsInBsdXJhbCIsImxlbmd0aCIsImFyZ3VtZW50Iiwiam9pbiIsInByZWZpeCIsImludmFsaWRBcmd1bWVudCIsInZhbHVlIiwidHlwZSIsImJyYW5kQ2hlY2siLCJWIiwiSSIsIm9wdHMiLCJzdHJpY3QiLCJlcnIiLCJjb2RlIiwiU3ltYm9sIiwidG9TdHJpbmdUYWciLCJwcm90b3R5cGUiLCJhcmd1bWVudExlbmd0aENoZWNrIiwibWluIiwiY3R4IiwiaWxsZWdhbENvbnN0cnVjdG9yIiwiVHlwZSIsIkNvbnZlcnRUb0ludCIsImJpdExlbmd0aCIsInNpZ25lZG5lc3MiLCJ1cHBlckJvdW5kIiwibG93ZXJCb3VuZCIsIk1hdGgiLCJwb3ciLCJ4IiwiTnVtYmVyIiwiZW5mb3JjZVJhbmdlIiwiaXNOYU4iLCJQT1NJVElWRV9JTkZJTklUWSIsIk5FR0FUSVZFX0lORklOSVRZIiwiU3RyaW5naWZ5IiwiSW50ZWdlclBhcnQiLCJjbGFtcCIsIm1heCIsImZsb29yIiwiY2VpbCIsIk9iamVjdCIsImlzIiwibiIsInIiLCJhYnMiLCJkZXNjcmlwdGlvbiIsInNlcXVlbmNlQ29udmVydGVyIiwiY29udmVydGVyIiwiSXRlcmFibGUiLCJtZXRob2QiLCJpdGVyYXRvciIsInNlcSIsImluZGV4IiwidW5kZWZpbmVkIiwibmV4dCIsImRvbmUiLCJwdXNoIiwicmVjb3JkQ29udmVydGVyIiwia2V5Q29udmVydGVyIiwidmFsdWVDb252ZXJ0ZXIiLCJPIiwicmVzdWx0IiwiaXNQcm94eSIsImtleXMiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwia2V5IiwidHlwZWRLZXkiLCJ0eXBlZFZhbHVlIiwiUmVmbGVjdCIsIm93bktleXMiLCJkZXNjIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsImludGVyZmFjZUNvbnZlcnRlciIsImkiLCJuYW1lIiwiZGljdGlvbmFyeUNvbnZlcnRlciIsImRpY3Rpb25hcnkiLCJkaWN0Iiwib3B0aW9ucyIsImRlZmF1bHRWYWx1ZSIsInJlcXVpcmVkIiwiaGFzT3duIiwiaGFzRGVmYXVsdCIsImFsbG93ZWRWYWx1ZXMiLCJpbmNsdWRlcyIsIm51bGxhYmxlQ29udmVydGVyIiwiRE9NU3RyaW5nIiwibGVnYWN5TnVsbFRvRW1wdHlTdHJpbmciLCJTdHJpbmciLCJCeXRlU3RyaW5nIiwiY2hhckNvZGVBdCIsIlVTVlN0cmluZyIsImJvb2xlYW4iLCJCb29sZWFuIiwiYW55IiwiQXJyYXlCdWZmZXIiLCJpc0FueUFycmF5QnVmZmVyIiwiYWxsb3dTaGFyZWQiLCJpc1NoYXJlZEFycmF5QnVmZmVyIiwicmVzaXphYmxlIiwiZ3Jvd2FibGUiLCJUeXBlZEFycmF5IiwiVCIsImlzVHlwZWRBcnJheSIsImNvbnN0cnVjdG9yIiwiYnVmZmVyIiwiRGF0YVZpZXciLCJpc0RhdGFWaWV3IiwiQnVmZmVyU291cmNlIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/fetch/webidl.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/fileapi/encoding.js":
/*!*********************************************************!*\
  !*** ./node_modules/undici/lib/web/fileapi/encoding.js ***!
  \*********************************************************/
/***/ ((module) => {

eval("\n/**\n * @see https://encoding.spec.whatwg.org/#concept-encoding-get\n * @param {string|undefined} label\n */ function getEncoding(label) {\n    if (!label) {\n        return \"failure\";\n    }\n    // 1. Remove any leading and trailing ASCII whitespace from label.\n    // 2. If label is an ASCII case-insensitive match for any of the\n    //    labels listed in the table below, then return the\n    //    corresponding encoding; otherwise return failure.\n    switch(label.trim().toLowerCase()){\n        case \"unicode-1-1-utf-8\":\n        case \"unicode11utf8\":\n        case \"unicode20utf8\":\n        case \"utf-8\":\n        case \"utf8\":\n        case \"x-unicode20utf8\":\n            return \"UTF-8\";\n        case \"866\":\n        case \"cp866\":\n        case \"csibm866\":\n        case \"ibm866\":\n            return \"IBM866\";\n        case \"csisolatin2\":\n        case \"iso-8859-2\":\n        case \"iso-ir-101\":\n        case \"iso8859-2\":\n        case \"iso88592\":\n        case \"iso_8859-2\":\n        case \"iso_8859-2:1987\":\n        case \"l2\":\n        case \"latin2\":\n            return \"ISO-8859-2\";\n        case \"csisolatin3\":\n        case \"iso-8859-3\":\n        case \"iso-ir-109\":\n        case \"iso8859-3\":\n        case \"iso88593\":\n        case \"iso_8859-3\":\n        case \"iso_8859-3:1988\":\n        case \"l3\":\n        case \"latin3\":\n            return \"ISO-8859-3\";\n        case \"csisolatin4\":\n        case \"iso-8859-4\":\n        case \"iso-ir-110\":\n        case \"iso8859-4\":\n        case \"iso88594\":\n        case \"iso_8859-4\":\n        case \"iso_8859-4:1988\":\n        case \"l4\":\n        case \"latin4\":\n            return \"ISO-8859-4\";\n        case \"csisolatincyrillic\":\n        case \"cyrillic\":\n        case \"iso-8859-5\":\n        case \"iso-ir-144\":\n        case \"iso8859-5\":\n        case \"iso88595\":\n        case \"iso_8859-5\":\n        case \"iso_8859-5:1988\":\n            return \"ISO-8859-5\";\n        case \"arabic\":\n        case \"asmo-708\":\n        case \"csiso88596e\":\n        case \"csiso88596i\":\n        case \"csisolatinarabic\":\n        case \"ecma-114\":\n        case \"iso-8859-6\":\n        case \"iso-8859-6-e\":\n        case \"iso-8859-6-i\":\n        case \"iso-ir-127\":\n        case \"iso8859-6\":\n        case \"iso88596\":\n        case \"iso_8859-6\":\n        case \"iso_8859-6:1987\":\n            return \"ISO-8859-6\";\n        case \"csisolatingreek\":\n        case \"ecma-118\":\n        case \"elot_928\":\n        case \"greek\":\n        case \"greek8\":\n        case \"iso-8859-7\":\n        case \"iso-ir-126\":\n        case \"iso8859-7\":\n        case \"iso88597\":\n        case \"iso_8859-7\":\n        case \"iso_8859-7:1987\":\n        case \"sun_eu_greek\":\n            return \"ISO-8859-7\";\n        case \"csiso88598e\":\n        case \"csisolatinhebrew\":\n        case \"hebrew\":\n        case \"iso-8859-8\":\n        case \"iso-8859-8-e\":\n        case \"iso-ir-138\":\n        case \"iso8859-8\":\n        case \"iso88598\":\n        case \"iso_8859-8\":\n        case \"iso_8859-8:1988\":\n        case \"visual\":\n            return \"ISO-8859-8\";\n        case \"csiso88598i\":\n        case \"iso-8859-8-i\":\n        case \"logical\":\n            return \"ISO-8859-8-I\";\n        case \"csisolatin6\":\n        case \"iso-8859-10\":\n        case \"iso-ir-157\":\n        case \"iso8859-10\":\n        case \"iso885910\":\n        case \"l6\":\n        case \"latin6\":\n            return \"ISO-8859-10\";\n        case \"iso-8859-13\":\n        case \"iso8859-13\":\n        case \"iso885913\":\n            return \"ISO-8859-13\";\n        case \"iso-8859-14\":\n        case \"iso8859-14\":\n        case \"iso885914\":\n            return \"ISO-8859-14\";\n        case \"csisolatin9\":\n        case \"iso-8859-15\":\n        case \"iso8859-15\":\n        case \"iso885915\":\n        case \"iso_8859-15\":\n        case \"l9\":\n            return \"ISO-8859-15\";\n        case \"iso-8859-16\":\n            return \"ISO-8859-16\";\n        case \"cskoi8r\":\n        case \"koi\":\n        case \"koi8\":\n        case \"koi8-r\":\n        case \"koi8_r\":\n            return \"KOI8-R\";\n        case \"koi8-ru\":\n        case \"koi8-u\":\n            return \"KOI8-U\";\n        case \"csmacintosh\":\n        case \"mac\":\n        case \"macintosh\":\n        case \"x-mac-roman\":\n            return \"macintosh\";\n        case \"iso-8859-11\":\n        case \"iso8859-11\":\n        case \"iso885911\":\n        case \"tis-620\":\n        case \"windows-874\":\n            return \"windows-874\";\n        case \"cp1250\":\n        case \"windows-1250\":\n        case \"x-cp1250\":\n            return \"windows-1250\";\n        case \"cp1251\":\n        case \"windows-1251\":\n        case \"x-cp1251\":\n            return \"windows-1251\";\n        case \"ansi_x3.4-1968\":\n        case \"ascii\":\n        case \"cp1252\":\n        case \"cp819\":\n        case \"csisolatin1\":\n        case \"ibm819\":\n        case \"iso-8859-1\":\n        case \"iso-ir-100\":\n        case \"iso8859-1\":\n        case \"iso88591\":\n        case \"iso_8859-1\":\n        case \"iso_8859-1:1987\":\n        case \"l1\":\n        case \"latin1\":\n        case \"us-ascii\":\n        case \"windows-1252\":\n        case \"x-cp1252\":\n            return \"windows-1252\";\n        case \"cp1253\":\n        case \"windows-1253\":\n        case \"x-cp1253\":\n            return \"windows-1253\";\n        case \"cp1254\":\n        case \"csisolatin5\":\n        case \"iso-8859-9\":\n        case \"iso-ir-148\":\n        case \"iso8859-9\":\n        case \"iso88599\":\n        case \"iso_8859-9\":\n        case \"iso_8859-9:1989\":\n        case \"l5\":\n        case \"latin5\":\n        case \"windows-1254\":\n        case \"x-cp1254\":\n            return \"windows-1254\";\n        case \"cp1255\":\n        case \"windows-1255\":\n        case \"x-cp1255\":\n            return \"windows-1255\";\n        case \"cp1256\":\n        case \"windows-1256\":\n        case \"x-cp1256\":\n            return \"windows-1256\";\n        case \"cp1257\":\n        case \"windows-1257\":\n        case \"x-cp1257\":\n            return \"windows-1257\";\n        case \"cp1258\":\n        case \"windows-1258\":\n        case \"x-cp1258\":\n            return \"windows-1258\";\n        case \"x-mac-cyrillic\":\n        case \"x-mac-ukrainian\":\n            return \"x-mac-cyrillic\";\n        case \"chinese\":\n        case \"csgb2312\":\n        case \"csiso58gb231280\":\n        case \"gb2312\":\n        case \"gb_2312\":\n        case \"gb_2312-80\":\n        case \"gbk\":\n        case \"iso-ir-58\":\n        case \"x-gbk\":\n            return \"GBK\";\n        case \"gb18030\":\n            return \"gb18030\";\n        case \"big5\":\n        case \"big5-hkscs\":\n        case \"cn-big5\":\n        case \"csbig5\":\n        case \"x-x-big5\":\n            return \"Big5\";\n        case \"cseucpkdfmtjapanese\":\n        case \"euc-jp\":\n        case \"x-euc-jp\":\n            return \"EUC-JP\";\n        case \"csiso2022jp\":\n        case \"iso-2022-jp\":\n            return \"ISO-2022-JP\";\n        case \"csshiftjis\":\n        case \"ms932\":\n        case \"ms_kanji\":\n        case \"shift-jis\":\n        case \"shift_jis\":\n        case \"sjis\":\n        case \"windows-31j\":\n        case \"x-sjis\":\n            return \"Shift_JIS\";\n        case \"cseuckr\":\n        case \"csksc56011987\":\n        case \"euc-kr\":\n        case \"iso-ir-149\":\n        case \"korean\":\n        case \"ks_c_5601-1987\":\n        case \"ks_c_5601-1989\":\n        case \"ksc5601\":\n        case \"ksc_5601\":\n        case \"windows-949\":\n            return \"EUC-KR\";\n        case \"csiso2022kr\":\n        case \"hz-gb-2312\":\n        case \"iso-2022-cn\":\n        case \"iso-2022-cn-ext\":\n        case \"iso-2022-kr\":\n        case \"replacement\":\n            return \"replacement\";\n        case \"unicodefffe\":\n        case \"utf-16be\":\n            return \"UTF-16BE\";\n        case \"csunicode\":\n        case \"iso-10646-ucs-2\":\n        case \"ucs-2\":\n        case \"unicode\":\n        case \"unicodefeff\":\n        case \"utf-16\":\n        case \"utf-16le\":\n            return \"UTF-16LE\";\n        case \"x-user-defined\":\n            return \"x-user-defined\";\n        default:\n            return \"failure\";\n    }\n}\nmodule.exports = {\n    getEncoding\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZmlsZWFwaS9lbmNvZGluZy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBOzs7Q0FHQSxHQUNBLFNBQVNBLFlBQWFDLEtBQUs7SUFDekIsSUFBSSxDQUFDQSxPQUFPO1FBQ1YsT0FBTztJQUNUO0lBRUE7SUFDQTtJQUNBO0lBQ0E7SUFDQSxPQUFRQSxNQUFNQyxJQUFJLEdBQUdDLFdBQVc7UUFDOUIsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7WUFDSCxPQUFPO1FBQ1QsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztZQUNILE9BQU87UUFDVCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7WUFDSCxPQUFPO1FBQ1QsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7WUFDSCxPQUFPO1FBQ1QsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7WUFDSCxPQUFPO1FBQ1QsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztZQUNILE9BQU87UUFDVCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztZQUNILE9BQU87UUFDVCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7WUFDSCxPQUFPO1FBQ1QsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7WUFDSCxPQUFPO1FBQ1QsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7WUFDSCxPQUFPO1FBQ1QsS0FBSztRQUNMLEtBQUs7WUFDSCxPQUFPO1FBQ1QsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztZQUNILE9BQU87UUFDVCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztZQUNILE9BQU87UUFDVCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7WUFDSCxPQUFPO1FBQ1QsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztZQUNILE9BQU87UUFDVCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7WUFDSCxPQUFPO1FBQ1QsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztZQUNILE9BQU87UUFDVCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7WUFDSCxPQUFPO1FBQ1QsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7UUFDTCxLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztZQUNILE9BQU87UUFDVCxLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztZQUNILE9BQU87UUFDVCxLQUFLO1FBQ0wsS0FBSztZQUNILE9BQU87UUFDVCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztZQUNILE9BQU87UUFDVCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztZQUNILE9BQU87UUFDVCxLQUFLO1FBQ0wsS0FBSztZQUNILE9BQU87UUFDVCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7WUFDSCxPQUFPO1FBQ1Q7WUFBUyxPQUFPO0lBQ2xCO0FBQ0Y7QUFFQUMsT0FBT0MsT0FBTyxHQUFHO0lBQ2ZMO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tb2NrdXBmbG93Ly4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvd2ViL2ZpbGVhcGkvZW5jb2RpbmcuanM/NDhiNCIsIndlYnBhY2s6Ly9tb2NrdXBmbG93Ly4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvd2ViL2ZpbGVhcGkvZW5jb2RpbmcuanM/NDhiNCoiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbi8qKlxuICogQHNlZSBodHRwczovL2VuY29kaW5nLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1lbmNvZGluZy1nZXRcbiAqIEBwYXJhbSB7c3RyaW5nfHVuZGVmaW5lZH0gbGFiZWxcbiAqL1xuZnVuY3Rpb24gZ2V0RW5jb2RpbmcgKGxhYmVsKSB7XG4gIGlmICghbGFiZWwpIHtcbiAgICByZXR1cm4gJ2ZhaWx1cmUnXG4gIH1cblxuICAvLyAxLiBSZW1vdmUgYW55IGxlYWRpbmcgYW5kIHRyYWlsaW5nIEFTQ0lJIHdoaXRlc3BhY2UgZnJvbSBsYWJlbC5cbiAgLy8gMi4gSWYgbGFiZWwgaXMgYW4gQVNDSUkgY2FzZS1pbnNlbnNpdGl2ZSBtYXRjaCBmb3IgYW55IG9mIHRoZVxuICAvLyAgICBsYWJlbHMgbGlzdGVkIGluIHRoZSB0YWJsZSBiZWxvdywgdGhlbiByZXR1cm4gdGhlXG4gIC8vICAgIGNvcnJlc3BvbmRpbmcgZW5jb2Rpbmc7IG90aGVyd2lzZSByZXR1cm4gZmFpbHVyZS5cbiAgc3dpdGNoIChsYWJlbC50cmltKCkudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ3VuaWNvZGUtMS0xLXV0Zi04JzpcbiAgICBjYXNlICd1bmljb2RlMTF1dGY4JzpcbiAgICBjYXNlICd1bmljb2RlMjB1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAneC11bmljb2RlMjB1dGY4JzpcbiAgICAgIHJldHVybiAnVVRGLTgnXG4gICAgY2FzZSAnODY2JzpcbiAgICBjYXNlICdjcDg2Nic6XG4gICAgY2FzZSAnY3NpYm04NjYnOlxuICAgIGNhc2UgJ2libTg2Nic6XG4gICAgICByZXR1cm4gJ0lCTTg2NidcbiAgICBjYXNlICdjc2lzb2xhdGluMic6XG4gICAgY2FzZSAnaXNvLTg4NTktMic6XG4gICAgY2FzZSAnaXNvLWlyLTEwMSc6XG4gICAgY2FzZSAnaXNvODg1OS0yJzpcbiAgICBjYXNlICdpc284ODU5Mic6XG4gICAgY2FzZSAnaXNvXzg4NTktMic6XG4gICAgY2FzZSAnaXNvXzg4NTktMjoxOTg3JzpcbiAgICBjYXNlICdsMic6XG4gICAgY2FzZSAnbGF0aW4yJzpcbiAgICAgIHJldHVybiAnSVNPLTg4NTktMidcbiAgICBjYXNlICdjc2lzb2xhdGluMyc6XG4gICAgY2FzZSAnaXNvLTg4NTktMyc6XG4gICAgY2FzZSAnaXNvLWlyLTEwOSc6XG4gICAgY2FzZSAnaXNvODg1OS0zJzpcbiAgICBjYXNlICdpc284ODU5Myc6XG4gICAgY2FzZSAnaXNvXzg4NTktMyc6XG4gICAgY2FzZSAnaXNvXzg4NTktMzoxOTg4JzpcbiAgICBjYXNlICdsMyc6XG4gICAgY2FzZSAnbGF0aW4zJzpcbiAgICAgIHJldHVybiAnSVNPLTg4NTktMydcbiAgICBjYXNlICdjc2lzb2xhdGluNCc6XG4gICAgY2FzZSAnaXNvLTg4NTktNCc6XG4gICAgY2FzZSAnaXNvLWlyLTExMCc6XG4gICAgY2FzZSAnaXNvODg1OS00JzpcbiAgICBjYXNlICdpc284ODU5NCc6XG4gICAgY2FzZSAnaXNvXzg4NTktNCc6XG4gICAgY2FzZSAnaXNvXzg4NTktNDoxOTg4JzpcbiAgICBjYXNlICdsNCc6XG4gICAgY2FzZSAnbGF0aW40JzpcbiAgICAgIHJldHVybiAnSVNPLTg4NTktNCdcbiAgICBjYXNlICdjc2lzb2xhdGluY3lyaWxsaWMnOlxuICAgIGNhc2UgJ2N5cmlsbGljJzpcbiAgICBjYXNlICdpc28tODg1OS01JzpcbiAgICBjYXNlICdpc28taXItMTQ0JzpcbiAgICBjYXNlICdpc284ODU5LTUnOlxuICAgIGNhc2UgJ2lzbzg4NTk1JzpcbiAgICBjYXNlICdpc29fODg1OS01JzpcbiAgICBjYXNlICdpc29fODg1OS01OjE5ODgnOlxuICAgICAgcmV0dXJuICdJU08tODg1OS01J1xuICAgIGNhc2UgJ2FyYWJpYyc6XG4gICAgY2FzZSAnYXNtby03MDgnOlxuICAgIGNhc2UgJ2NzaXNvODg1OTZlJzpcbiAgICBjYXNlICdjc2lzbzg4NTk2aSc6XG4gICAgY2FzZSAnY3Npc29sYXRpbmFyYWJpYyc6XG4gICAgY2FzZSAnZWNtYS0xMTQnOlxuICAgIGNhc2UgJ2lzby04ODU5LTYnOlxuICAgIGNhc2UgJ2lzby04ODU5LTYtZSc6XG4gICAgY2FzZSAnaXNvLTg4NTktNi1pJzpcbiAgICBjYXNlICdpc28taXItMTI3JzpcbiAgICBjYXNlICdpc284ODU5LTYnOlxuICAgIGNhc2UgJ2lzbzg4NTk2JzpcbiAgICBjYXNlICdpc29fODg1OS02JzpcbiAgICBjYXNlICdpc29fODg1OS02OjE5ODcnOlxuICAgICAgcmV0dXJuICdJU08tODg1OS02J1xuICAgIGNhc2UgJ2NzaXNvbGF0aW5ncmVlayc6XG4gICAgY2FzZSAnZWNtYS0xMTgnOlxuICAgIGNhc2UgJ2Vsb3RfOTI4JzpcbiAgICBjYXNlICdncmVlayc6XG4gICAgY2FzZSAnZ3JlZWs4JzpcbiAgICBjYXNlICdpc28tODg1OS03JzpcbiAgICBjYXNlICdpc28taXItMTI2JzpcbiAgICBjYXNlICdpc284ODU5LTcnOlxuICAgIGNhc2UgJ2lzbzg4NTk3JzpcbiAgICBjYXNlICdpc29fODg1OS03JzpcbiAgICBjYXNlICdpc29fODg1OS03OjE5ODcnOlxuICAgIGNhc2UgJ3N1bl9ldV9ncmVlayc6XG4gICAgICByZXR1cm4gJ0lTTy04ODU5LTcnXG4gICAgY2FzZSAnY3Npc284ODU5OGUnOlxuICAgIGNhc2UgJ2NzaXNvbGF0aW5oZWJyZXcnOlxuICAgIGNhc2UgJ2hlYnJldyc6XG4gICAgY2FzZSAnaXNvLTg4NTktOCc6XG4gICAgY2FzZSAnaXNvLTg4NTktOC1lJzpcbiAgICBjYXNlICdpc28taXItMTM4JzpcbiAgICBjYXNlICdpc284ODU5LTgnOlxuICAgIGNhc2UgJ2lzbzg4NTk4JzpcbiAgICBjYXNlICdpc29fODg1OS04JzpcbiAgICBjYXNlICdpc29fODg1OS04OjE5ODgnOlxuICAgIGNhc2UgJ3Zpc3VhbCc6XG4gICAgICByZXR1cm4gJ0lTTy04ODU5LTgnXG4gICAgY2FzZSAnY3Npc284ODU5OGknOlxuICAgIGNhc2UgJ2lzby04ODU5LTgtaSc6XG4gICAgY2FzZSAnbG9naWNhbCc6XG4gICAgICByZXR1cm4gJ0lTTy04ODU5LTgtSSdcbiAgICBjYXNlICdjc2lzb2xhdGluNic6XG4gICAgY2FzZSAnaXNvLTg4NTktMTAnOlxuICAgIGNhc2UgJ2lzby1pci0xNTcnOlxuICAgIGNhc2UgJ2lzbzg4NTktMTAnOlxuICAgIGNhc2UgJ2lzbzg4NTkxMCc6XG4gICAgY2FzZSAnbDYnOlxuICAgIGNhc2UgJ2xhdGluNic6XG4gICAgICByZXR1cm4gJ0lTTy04ODU5LTEwJ1xuICAgIGNhc2UgJ2lzby04ODU5LTEzJzpcbiAgICBjYXNlICdpc284ODU5LTEzJzpcbiAgICBjYXNlICdpc284ODU5MTMnOlxuICAgICAgcmV0dXJuICdJU08tODg1OS0xMydcbiAgICBjYXNlICdpc28tODg1OS0xNCc6XG4gICAgY2FzZSAnaXNvODg1OS0xNCc6XG4gICAgY2FzZSAnaXNvODg1OTE0JzpcbiAgICAgIHJldHVybiAnSVNPLTg4NTktMTQnXG4gICAgY2FzZSAnY3Npc29sYXRpbjknOlxuICAgIGNhc2UgJ2lzby04ODU5LTE1JzpcbiAgICBjYXNlICdpc284ODU5LTE1JzpcbiAgICBjYXNlICdpc284ODU5MTUnOlxuICAgIGNhc2UgJ2lzb184ODU5LTE1JzpcbiAgICBjYXNlICdsOSc6XG4gICAgICByZXR1cm4gJ0lTTy04ODU5LTE1J1xuICAgIGNhc2UgJ2lzby04ODU5LTE2JzpcbiAgICAgIHJldHVybiAnSVNPLTg4NTktMTYnXG4gICAgY2FzZSAnY3Nrb2k4cic6XG4gICAgY2FzZSAna29pJzpcbiAgICBjYXNlICdrb2k4JzpcbiAgICBjYXNlICdrb2k4LXInOlxuICAgIGNhc2UgJ2tvaThfcic6XG4gICAgICByZXR1cm4gJ0tPSTgtUidcbiAgICBjYXNlICdrb2k4LXJ1JzpcbiAgICBjYXNlICdrb2k4LXUnOlxuICAgICAgcmV0dXJuICdLT0k4LVUnXG4gICAgY2FzZSAnY3NtYWNpbnRvc2gnOlxuICAgIGNhc2UgJ21hYyc6XG4gICAgY2FzZSAnbWFjaW50b3NoJzpcbiAgICBjYXNlICd4LW1hYy1yb21hbic6XG4gICAgICByZXR1cm4gJ21hY2ludG9zaCdcbiAgICBjYXNlICdpc28tODg1OS0xMSc6XG4gICAgY2FzZSAnaXNvODg1OS0xMSc6XG4gICAgY2FzZSAnaXNvODg1OTExJzpcbiAgICBjYXNlICd0aXMtNjIwJzpcbiAgICBjYXNlICd3aW5kb3dzLTg3NCc6XG4gICAgICByZXR1cm4gJ3dpbmRvd3MtODc0J1xuICAgIGNhc2UgJ2NwMTI1MCc6XG4gICAgY2FzZSAnd2luZG93cy0xMjUwJzpcbiAgICBjYXNlICd4LWNwMTI1MCc6XG4gICAgICByZXR1cm4gJ3dpbmRvd3MtMTI1MCdcbiAgICBjYXNlICdjcDEyNTEnOlxuICAgIGNhc2UgJ3dpbmRvd3MtMTI1MSc6XG4gICAgY2FzZSAneC1jcDEyNTEnOlxuICAgICAgcmV0dXJuICd3aW5kb3dzLTEyNTEnXG4gICAgY2FzZSAnYW5zaV94My40LTE5NjgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdjcDEyNTInOlxuICAgIGNhc2UgJ2NwODE5JzpcbiAgICBjYXNlICdjc2lzb2xhdGluMSc6XG4gICAgY2FzZSAnaWJtODE5JzpcbiAgICBjYXNlICdpc28tODg1OS0xJzpcbiAgICBjYXNlICdpc28taXItMTAwJzpcbiAgICBjYXNlICdpc284ODU5LTEnOlxuICAgIGNhc2UgJ2lzbzg4NTkxJzpcbiAgICBjYXNlICdpc29fODg1OS0xJzpcbiAgICBjYXNlICdpc29fODg1OS0xOjE5ODcnOlxuICAgIGNhc2UgJ2wxJzpcbiAgICBjYXNlICdsYXRpbjEnOlxuICAgIGNhc2UgJ3VzLWFzY2lpJzpcbiAgICBjYXNlICd3aW5kb3dzLTEyNTInOlxuICAgIGNhc2UgJ3gtY3AxMjUyJzpcbiAgICAgIHJldHVybiAnd2luZG93cy0xMjUyJ1xuICAgIGNhc2UgJ2NwMTI1Myc6XG4gICAgY2FzZSAnd2luZG93cy0xMjUzJzpcbiAgICBjYXNlICd4LWNwMTI1Myc6XG4gICAgICByZXR1cm4gJ3dpbmRvd3MtMTI1MydcbiAgICBjYXNlICdjcDEyNTQnOlxuICAgIGNhc2UgJ2NzaXNvbGF0aW41JzpcbiAgICBjYXNlICdpc28tODg1OS05JzpcbiAgICBjYXNlICdpc28taXItMTQ4JzpcbiAgICBjYXNlICdpc284ODU5LTknOlxuICAgIGNhc2UgJ2lzbzg4NTk5JzpcbiAgICBjYXNlICdpc29fODg1OS05JzpcbiAgICBjYXNlICdpc29fODg1OS05OjE5ODknOlxuICAgIGNhc2UgJ2w1JzpcbiAgICBjYXNlICdsYXRpbjUnOlxuICAgIGNhc2UgJ3dpbmRvd3MtMTI1NCc6XG4gICAgY2FzZSAneC1jcDEyNTQnOlxuICAgICAgcmV0dXJuICd3aW5kb3dzLTEyNTQnXG4gICAgY2FzZSAnY3AxMjU1JzpcbiAgICBjYXNlICd3aW5kb3dzLTEyNTUnOlxuICAgIGNhc2UgJ3gtY3AxMjU1JzpcbiAgICAgIHJldHVybiAnd2luZG93cy0xMjU1J1xuICAgIGNhc2UgJ2NwMTI1Nic6XG4gICAgY2FzZSAnd2luZG93cy0xMjU2JzpcbiAgICBjYXNlICd4LWNwMTI1Nic6XG4gICAgICByZXR1cm4gJ3dpbmRvd3MtMTI1NidcbiAgICBjYXNlICdjcDEyNTcnOlxuICAgIGNhc2UgJ3dpbmRvd3MtMTI1Nyc6XG4gICAgY2FzZSAneC1jcDEyNTcnOlxuICAgICAgcmV0dXJuICd3aW5kb3dzLTEyNTcnXG4gICAgY2FzZSAnY3AxMjU4JzpcbiAgICBjYXNlICd3aW5kb3dzLTEyNTgnOlxuICAgIGNhc2UgJ3gtY3AxMjU4JzpcbiAgICAgIHJldHVybiAnd2luZG93cy0xMjU4J1xuICAgIGNhc2UgJ3gtbWFjLWN5cmlsbGljJzpcbiAgICBjYXNlICd4LW1hYy11a3JhaW5pYW4nOlxuICAgICAgcmV0dXJuICd4LW1hYy1jeXJpbGxpYydcbiAgICBjYXNlICdjaGluZXNlJzpcbiAgICBjYXNlICdjc2diMjMxMic6XG4gICAgY2FzZSAnY3Npc281OGdiMjMxMjgwJzpcbiAgICBjYXNlICdnYjIzMTInOlxuICAgIGNhc2UgJ2diXzIzMTInOlxuICAgIGNhc2UgJ2diXzIzMTItODAnOlxuICAgIGNhc2UgJ2diayc6XG4gICAgY2FzZSAnaXNvLWlyLTU4JzpcbiAgICBjYXNlICd4LWdiayc6XG4gICAgICByZXR1cm4gJ0dCSydcbiAgICBjYXNlICdnYjE4MDMwJzpcbiAgICAgIHJldHVybiAnZ2IxODAzMCdcbiAgICBjYXNlICdiaWc1JzpcbiAgICBjYXNlICdiaWc1LWhrc2NzJzpcbiAgICBjYXNlICdjbi1iaWc1JzpcbiAgICBjYXNlICdjc2JpZzUnOlxuICAgIGNhc2UgJ3gteC1iaWc1JzpcbiAgICAgIHJldHVybiAnQmlnNSdcbiAgICBjYXNlICdjc2V1Y3BrZGZtdGphcGFuZXNlJzpcbiAgICBjYXNlICdldWMtanAnOlxuICAgIGNhc2UgJ3gtZXVjLWpwJzpcbiAgICAgIHJldHVybiAnRVVDLUpQJ1xuICAgIGNhc2UgJ2NzaXNvMjAyMmpwJzpcbiAgICBjYXNlICdpc28tMjAyMi1qcCc6XG4gICAgICByZXR1cm4gJ0lTTy0yMDIyLUpQJ1xuICAgIGNhc2UgJ2Nzc2hpZnRqaXMnOlxuICAgIGNhc2UgJ21zOTMyJzpcbiAgICBjYXNlICdtc19rYW5qaSc6XG4gICAgY2FzZSAnc2hpZnQtamlzJzpcbiAgICBjYXNlICdzaGlmdF9qaXMnOlxuICAgIGNhc2UgJ3NqaXMnOlxuICAgIGNhc2UgJ3dpbmRvd3MtMzFqJzpcbiAgICBjYXNlICd4LXNqaXMnOlxuICAgICAgcmV0dXJuICdTaGlmdF9KSVMnXG4gICAgY2FzZSAnY3NldWNrcic6XG4gICAgY2FzZSAnY3Nrc2M1NjAxMTk4Nyc6XG4gICAgY2FzZSAnZXVjLWtyJzpcbiAgICBjYXNlICdpc28taXItMTQ5JzpcbiAgICBjYXNlICdrb3JlYW4nOlxuICAgIGNhc2UgJ2tzX2NfNTYwMS0xOTg3JzpcbiAgICBjYXNlICdrc19jXzU2MDEtMTk4OSc6XG4gICAgY2FzZSAna3NjNTYwMSc6XG4gICAgY2FzZSAna3NjXzU2MDEnOlxuICAgIGNhc2UgJ3dpbmRvd3MtOTQ5JzpcbiAgICAgIHJldHVybiAnRVVDLUtSJ1xuICAgIGNhc2UgJ2NzaXNvMjAyMmtyJzpcbiAgICBjYXNlICdoei1nYi0yMzEyJzpcbiAgICBjYXNlICdpc28tMjAyMi1jbic6XG4gICAgY2FzZSAnaXNvLTIwMjItY24tZXh0JzpcbiAgICBjYXNlICdpc28tMjAyMi1rcic6XG4gICAgY2FzZSAncmVwbGFjZW1lbnQnOlxuICAgICAgcmV0dXJuICdyZXBsYWNlbWVudCdcbiAgICBjYXNlICd1bmljb2RlZmZmZSc6XG4gICAgY2FzZSAndXRmLTE2YmUnOlxuICAgICAgcmV0dXJuICdVVEYtMTZCRSdcbiAgICBjYXNlICdjc3VuaWNvZGUnOlxuICAgIGNhc2UgJ2lzby0xMDY0Ni11Y3MtMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3VuaWNvZGUnOlxuICAgIGNhc2UgJ3VuaWNvZGVmZWZmJzpcbiAgICBjYXNlICd1dGYtMTYnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiAnVVRGLTE2TEUnXG4gICAgY2FzZSAneC11c2VyLWRlZmluZWQnOlxuICAgICAgcmV0dXJuICd4LXVzZXItZGVmaW5lZCdcbiAgICBkZWZhdWx0OiByZXR1cm4gJ2ZhaWx1cmUnXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGdldEVuY29kaW5nXG59XG4iXSwibmFtZXMiOlsiZ2V0RW5jb2RpbmciLCJsYWJlbCIsInRyaW0iLCJ0b0xvd2VyQ2FzZSIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/fileapi/encoding.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/fileapi/filereader.js":
/*!***********************************************************!*\
  !*** ./node_modules/undici/lib/web/fileapi/filereader.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { staticPropertyDescriptors, readOperation, fireAProgressEvent } = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/undici/lib/web/fileapi/util.js\");\nconst { kState, kError, kResult, kEvents, kAborted } = __webpack_require__(/*! ./symbols */ \"(ssr)/./node_modules/undici/lib/web/fileapi/symbols.js\");\nconst { webidl } = __webpack_require__(/*! ../fetch/webidl */ \"(ssr)/./node_modules/undici/lib/web/fetch/webidl.js\");\nconst { kEnumerableProperty } = __webpack_require__(/*! ../../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\");\nclass FileReader extends EventTarget {\n    constructor(){\n        super();\n        this[kState] = \"empty\";\n        this[kResult] = null;\n        this[kError] = null;\n        this[kEvents] = {\n            loadend: null,\n            error: null,\n            abort: null,\n            load: null,\n            progress: null,\n            loadstart: null\n        };\n    }\n    /**\n   * @see https://w3c.github.io/FileAPI/#dfn-readAsArrayBuffer\n   * @param {import('buffer').Blob} blob\n   */ readAsArrayBuffer(blob) {\n        webidl.brandCheck(this, FileReader);\n        webidl.argumentLengthCheck(arguments, 1, \"FileReader.readAsArrayBuffer\");\n        blob = webidl.converters.Blob(blob, {\n            strict: false\n        });\n        // The readAsArrayBuffer(blob) method, when invoked,\n        // must initiate a read operation for blob with ArrayBuffer.\n        readOperation(this, blob, \"ArrayBuffer\");\n    }\n    /**\n   * @see https://w3c.github.io/FileAPI/#readAsBinaryString\n   * @param {import('buffer').Blob} blob\n   */ readAsBinaryString(blob) {\n        webidl.brandCheck(this, FileReader);\n        webidl.argumentLengthCheck(arguments, 1, \"FileReader.readAsBinaryString\");\n        blob = webidl.converters.Blob(blob, {\n            strict: false\n        });\n        // The readAsBinaryString(blob) method, when invoked,\n        // must initiate a read operation for blob with BinaryString.\n        readOperation(this, blob, \"BinaryString\");\n    }\n    /**\n   * @see https://w3c.github.io/FileAPI/#readAsDataText\n   * @param {import('buffer').Blob} blob\n   * @param {string?} encoding\n   */ readAsText(blob, encoding = undefined) {\n        webidl.brandCheck(this, FileReader);\n        webidl.argumentLengthCheck(arguments, 1, \"FileReader.readAsText\");\n        blob = webidl.converters.Blob(blob, {\n            strict: false\n        });\n        if (encoding !== undefined) {\n            encoding = webidl.converters.DOMString(encoding, \"FileReader.readAsText\", \"encoding\");\n        }\n        // The readAsText(blob, encoding) method, when invoked,\n        // must initiate a read operation for blob with Text and encoding.\n        readOperation(this, blob, \"Text\", encoding);\n    }\n    /**\n   * @see https://w3c.github.io/FileAPI/#dfn-readAsDataURL\n   * @param {import('buffer').Blob} blob\n   */ readAsDataURL(blob) {\n        webidl.brandCheck(this, FileReader);\n        webidl.argumentLengthCheck(arguments, 1, \"FileReader.readAsDataURL\");\n        blob = webidl.converters.Blob(blob, {\n            strict: false\n        });\n        // The readAsDataURL(blob) method, when invoked, must\n        // initiate a read operation for blob with DataURL.\n        readOperation(this, blob, \"DataURL\");\n    }\n    /**\n   * @see https://w3c.github.io/FileAPI/#dfn-abort\n   */ abort() {\n        // 1. If this's state is \"empty\" or if this's state is\n        //    \"done\" set this's result to null and terminate\n        //    this algorithm.\n        if (this[kState] === \"empty\" || this[kState] === \"done\") {\n            this[kResult] = null;\n            return;\n        }\n        // 2. If this's state is \"loading\" set this's state to\n        //    \"done\" and set this's result to null.\n        if (this[kState] === \"loading\") {\n            this[kState] = \"done\";\n            this[kResult] = null;\n        }\n        // 3. If there are any tasks from this on the file reading\n        //    task source in an affiliated task queue, then remove\n        //    those tasks from that task queue.\n        this[kAborted] = true;\n        // 4. Terminate the algorithm for the read method being processed.\n        // TODO\n        // 5. Fire a progress event called abort at this.\n        fireAProgressEvent(\"abort\", this);\n        // 6. If this's state is not \"loading\", fire a progress\n        //    event called loadend at this.\n        if (this[kState] !== \"loading\") {\n            fireAProgressEvent(\"loadend\", this);\n        }\n    }\n    /**\n   * @see https://w3c.github.io/FileAPI/#dom-filereader-readystate\n   */ get readyState() {\n        webidl.brandCheck(this, FileReader);\n        switch(this[kState]){\n            case \"empty\":\n                return this.EMPTY;\n            case \"loading\":\n                return this.LOADING;\n            case \"done\":\n                return this.DONE;\n        }\n    }\n    /**\n   * @see https://w3c.github.io/FileAPI/#dom-filereader-result\n   */ get result() {\n        webidl.brandCheck(this, FileReader);\n        // The result attributes getter, when invoked, must return\n        // this's result.\n        return this[kResult];\n    }\n    /**\n   * @see https://w3c.github.io/FileAPI/#dom-filereader-error\n   */ get error() {\n        webidl.brandCheck(this, FileReader);\n        // The error attributes getter, when invoked, must return\n        // this's error.\n        return this[kError];\n    }\n    get onloadend() {\n        webidl.brandCheck(this, FileReader);\n        return this[kEvents].loadend;\n    }\n    set onloadend(fn) {\n        webidl.brandCheck(this, FileReader);\n        if (this[kEvents].loadend) {\n            this.removeEventListener(\"loadend\", this[kEvents].loadend);\n        }\n        if (typeof fn === \"function\") {\n            this[kEvents].loadend = fn;\n            this.addEventListener(\"loadend\", fn);\n        } else {\n            this[kEvents].loadend = null;\n        }\n    }\n    get onerror() {\n        webidl.brandCheck(this, FileReader);\n        return this[kEvents].error;\n    }\n    set onerror(fn) {\n        webidl.brandCheck(this, FileReader);\n        if (this[kEvents].error) {\n            this.removeEventListener(\"error\", this[kEvents].error);\n        }\n        if (typeof fn === \"function\") {\n            this[kEvents].error = fn;\n            this.addEventListener(\"error\", fn);\n        } else {\n            this[kEvents].error = null;\n        }\n    }\n    get onloadstart() {\n        webidl.brandCheck(this, FileReader);\n        return this[kEvents].loadstart;\n    }\n    set onloadstart(fn) {\n        webidl.brandCheck(this, FileReader);\n        if (this[kEvents].loadstart) {\n            this.removeEventListener(\"loadstart\", this[kEvents].loadstart);\n        }\n        if (typeof fn === \"function\") {\n            this[kEvents].loadstart = fn;\n            this.addEventListener(\"loadstart\", fn);\n        } else {\n            this[kEvents].loadstart = null;\n        }\n    }\n    get onprogress() {\n        webidl.brandCheck(this, FileReader);\n        return this[kEvents].progress;\n    }\n    set onprogress(fn) {\n        webidl.brandCheck(this, FileReader);\n        if (this[kEvents].progress) {\n            this.removeEventListener(\"progress\", this[kEvents].progress);\n        }\n        if (typeof fn === \"function\") {\n            this[kEvents].progress = fn;\n            this.addEventListener(\"progress\", fn);\n        } else {\n            this[kEvents].progress = null;\n        }\n    }\n    get onload() {\n        webidl.brandCheck(this, FileReader);\n        return this[kEvents].load;\n    }\n    set onload(fn) {\n        webidl.brandCheck(this, FileReader);\n        if (this[kEvents].load) {\n            this.removeEventListener(\"load\", this[kEvents].load);\n        }\n        if (typeof fn === \"function\") {\n            this[kEvents].load = fn;\n            this.addEventListener(\"load\", fn);\n        } else {\n            this[kEvents].load = null;\n        }\n    }\n    get onabort() {\n        webidl.brandCheck(this, FileReader);\n        return this[kEvents].abort;\n    }\n    set onabort(fn) {\n        webidl.brandCheck(this, FileReader);\n        if (this[kEvents].abort) {\n            this.removeEventListener(\"abort\", this[kEvents].abort);\n        }\n        if (typeof fn === \"function\") {\n            this[kEvents].abort = fn;\n            this.addEventListener(\"abort\", fn);\n        } else {\n            this[kEvents].abort = null;\n        }\n    }\n}\n// https://w3c.github.io/FileAPI/#dom-filereader-empty\nFileReader.EMPTY = FileReader.prototype.EMPTY = 0;\n// https://w3c.github.io/FileAPI/#dom-filereader-loading\nFileReader.LOADING = FileReader.prototype.LOADING = 1;\n// https://w3c.github.io/FileAPI/#dom-filereader-done\nFileReader.DONE = FileReader.prototype.DONE = 2;\nObject.defineProperties(FileReader.prototype, {\n    EMPTY: staticPropertyDescriptors,\n    LOADING: staticPropertyDescriptors,\n    DONE: staticPropertyDescriptors,\n    readAsArrayBuffer: kEnumerableProperty,\n    readAsBinaryString: kEnumerableProperty,\n    readAsText: kEnumerableProperty,\n    readAsDataURL: kEnumerableProperty,\n    abort: kEnumerableProperty,\n    readyState: kEnumerableProperty,\n    result: kEnumerableProperty,\n    error: kEnumerableProperty,\n    onloadstart: kEnumerableProperty,\n    onprogress: kEnumerableProperty,\n    onload: kEnumerableProperty,\n    onabort: kEnumerableProperty,\n    onerror: kEnumerableProperty,\n    onloadend: kEnumerableProperty,\n    [Symbol.toStringTag]: {\n        value: \"FileReader\",\n        writable: false,\n        enumerable: false,\n        configurable: true\n    }\n});\nObject.defineProperties(FileReader, {\n    EMPTY: staticPropertyDescriptors,\n    LOADING: staticPropertyDescriptors,\n    DONE: staticPropertyDescriptors\n});\nmodule.exports = {\n    FileReader\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZmlsZWFwaS9maWxlcmVhZGVyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTSxFQUNKQSx5QkFBeUIsRUFDekJDLGFBQWEsRUFDYkMsa0JBQUFBLEVBQ0QsR0FBR0MsbUJBQU9BLENBQUM7QUFDWixNQUFNLEVBQ0pDLE1BQU0sRUFDTkMsTUFBTSxFQUNOQyxPQUFPLEVBQ1BDLE9BQU8sRUFDUEMsUUFBQUEsRUFDRCxHQUFHTCxtQkFBT0EsQ0FBQztBQUNaLE1BQU0sRUFBRU0sTUFBQUEsRUFBUSxHQUFHTixtQkFBT0EsQ0FBQztBQUMzQixNQUFNLEVBQUVPLG1CQUFBQSxFQUFxQixHQUFHUCxtQkFBT0EsQ0FBQztBQUV4QyxNQUFNUSxtQkFBbUJDO0lBQ3ZCQyxhQUFlO1FBQ2IsS0FBSztRQUVMLElBQUksQ0FBQ1QsT0FBTyxHQUFHO1FBQ2YsSUFBSSxDQUFDRSxRQUFRLEdBQUc7UUFDaEIsSUFBSSxDQUFDRCxPQUFPLEdBQUc7UUFDZixJQUFJLENBQUNFLFFBQVEsR0FBRztZQUNkTyxTQUFTO1lBQ1RDLE9BQU87WUFDUEMsT0FBTztZQUNQQyxNQUFNO1lBQ05DLFVBQVU7WUFDVkMsV0FBVztRQUNiO0lBQ0Y7SUFFQTs7O0dBR0YsR0FDRUMsa0JBQW1CQyxJQUFJLEVBQUU7UUFDdkJaLE9BQU9hLFVBQVUsQ0FBQyxJQUFJLEVBQUVYO1FBRXhCRixPQUFPYyxtQkFBbUIsQ0FBQ0MsV0FBVyxHQUFHO1FBRXpDSCxPQUFPWixPQUFPZ0IsVUFBVSxDQUFDQyxJQUFJLENBQUNMLE1BQU07WUFBRU0sUUFBUTtRQUFNO1FBRXBEO1FBQ0E7UUFDQTFCLGNBQWMsSUFBSSxFQUFFb0IsTUFBTTtJQUM1QjtJQUVBOzs7R0FHRixHQUNFTyxtQkFBb0JQLElBQUksRUFBRTtRQUN4QlosT0FBT2EsVUFBVSxDQUFDLElBQUksRUFBRVg7UUFFeEJGLE9BQU9jLG1CQUFtQixDQUFDQyxXQUFXLEdBQUc7UUFFekNI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QUNUaUMsU0FBU2pDO0lBQ1Q2QixXQUFXN0I7SUFDWCxDQUFDeUMsT0FBT0MsV0FBVyxHQUFHO1FBQ3BCQyxPQUFPO1FBQ1BDLFVBQVU7UUFDVkMsWUFBWTtRQUNaQyxjQUFjO0lBQ2hCO0FBQ0Y7QUFFQVAsT0FBT0MsZ0JBQWdCLENBQUN2QyxZQUFZO0lBQ2xDd0IsT0FBT25DO0lBQ1BvQyxTQUFTcEM7SUFDVHFDLE1BQU1yQztBQUNSO0FBRUF5RCxPQUFPQyxPQUFPLEdBQUc7SUFDZi9DO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tb2NrdXBmbG93Ly4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvd2ViL2ZpbGVhcGkvZmlsZXJlYWRlci5qcz8zZWJkIiwid2VicGFjazovL21vY2t1cGZsb3cvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZmlsZWFwaS9maWxlcmVhZGVyLmpzPzNlYmQqIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7XG4gIHN0YXRpY1Byb3BlcnR5RGVzY3JpcHRvcnMsXG4gIHJlYWRPcGVyYXRpb24sXG4gIGZpcmVBUHJvZ3Jlc3NFdmVudFxufSA9IHJlcXVpcmUoJy4vdXRpbCcpXG5jb25zdCB7XG4gIGtTdGF0ZSxcbiAga0Vycm9yLFxuICBrUmVzdWx0LFxuICBrRXZlbnRzLFxuICBrQWJvcnRlZFxufSA9IHJlcXVpcmUoJy4vc3ltYm9scycpXG5jb25zdCB7IHdlYmlkbCB9ID0gcmVxdWlyZSgnLi4vZmV0Y2gvd2ViaWRsJylcbmNvbnN0IHsga0VudW1lcmFibGVQcm9wZXJ0eSB9ID0gcmVxdWlyZSgnLi4vLi4vY29yZS91dGlsJylcblxuY2xhc3MgRmlsZVJlYWRlciBleHRlbmRzIEV2ZW50VGFyZ2V0IHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHN1cGVyKClcblxuICAgIHRoaXNba1N0YXRlXSA9ICdlbXB0eSdcbiAgICB0aGlzW2tSZXN1bHRdID0gbnVsbFxuICAgIHRoaXNba0Vycm9yXSA9IG51bGxcbiAgICB0aGlzW2tFdmVudHNdID0ge1xuICAgICAgbG9hZGVuZDogbnVsbCxcbiAgICAgIGVycm9yOiBudWxsLFxuICAgICAgYWJvcnQ6IG51bGwsXG4gICAgICBsb2FkOiBudWxsLFxuICAgICAgcHJvZ3Jlc3M6IG51bGwsXG4gICAgICBsb2Fkc3RhcnQ6IG51bGxcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHNlZSBodHRwczovL3czYy5naXRodWIuaW8vRmlsZUFQSS8jZGZuLXJlYWRBc0FycmF5QnVmZmVyXG4gICAqIEBwYXJhbSB7aW1wb3J0KCdidWZmZXInKS5CbG9ifSBibG9iXG4gICAqL1xuICByZWFkQXNBcnJheUJ1ZmZlciAoYmxvYikge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEZpbGVSZWFkZXIpXG5cbiAgICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDEsICdGaWxlUmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyJylcblxuICAgIGJsb2IgPSB3ZWJpZGwuY29udmVydGVycy5CbG9iKGJsb2IsIHsgc3RyaWN0OiBmYWxzZSB9KVxuXG4gICAgLy8gVGhlIHJlYWRBc0FycmF5QnVmZmVyKGJsb2IpIG1ldGhvZCwgd2hlbiBpbnZva2VkLFxuICAgIC8vIG11c3QgaW5pdGlhdGUgYSByZWFkIG9wZXJhdGlvbiBmb3IgYmxvYiB3aXRoIEFycmF5QnVmZmVyLlxuICAgIHJlYWRPcGVyYXRpb24odGhpcywgYmxvYiwgJ0FycmF5QnVmZmVyJylcbiAgfVxuXG4gIC8qKlxuICAgKiBAc2VlIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby9GaWxlQVBJLyNyZWFkQXNCaW5hcnlTdHJpbmdcbiAgICogQHBhcmFtIHtpbXBvcnQoJ2J1ZmZlcicpLkJsb2J9IGJsb2JcbiAgICovXG4gIHJlYWRBc0JpbmFyeVN0cmluZyAoYmxvYikge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEZpbGVSZWFkZXIpXG5cbiAgICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDEsICdGaWxlUmVhZGVyLnJlYWRBc0JpbmFyeVN0cmluZycpXG5cbiAgICBibG9iID0gd2ViaWRsLmNvbnZlcnRlcnMuQmxvYihibG9iLCB7IHN0cmljdDogZmFsc2UgfSlcblxuICAgIC8vIFRoZSByZWFkQXNCaW5hcnlTdHJpbmcoYmxvYikgbWV0aG9kLCB3aGVuIGludm9rZWQsXG4gICAgLy8gbXVzdCBpbml0aWF0ZSBhIHJlYWQgb3BlcmF0aW9uIGZvciBibG9iIHdpdGggQmluYXJ5U3RyaW5nLlxuICAgIHJlYWRPcGVyYXRpb24odGhpcywgYmxvYiwgJ0JpbmFyeVN0cmluZycpXG4gIH1cblxuICAvKipcbiAgICogQHNlZSBodHRwczovL3czYy5naXRodWIuaW8vRmlsZUFQSS8jcmVhZEFzRGF0YVRleHRcbiAgICogQHBhcmFtIHtpbXBvcnQoJ2J1ZmZlcicpLkJsb2J9IGJsb2JcbiAgICogQHBhcmFtIHtzdHJpbmc/fSBlbmNvZGluZ1xuICAgKi9cbiAgcmVhZEFzVGV4dCAoYmxvYiwgZW5jb2RpbmcgPSB1bmRlZmluZWQpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBGaWxlUmVhZGVyKVxuXG4gICAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAxLCAnRmlsZVJlYWRlci5yZWFkQXNUZXh0JylcblxuICAgIGJsb2IgPSB3ZWJpZGwuY29udmVydGVycy5CbG9iKGJsb2IsIHsgc3RyaWN0OiBmYWxzZSB9KVxuXG4gICAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGVuY29kaW5nID0gd2ViaWRsLmNvbnZlcnRlcnMuRE9NU3RyaW5nKGVuY29kaW5nLCAnRmlsZVJlYWRlci5yZWFkQXNUZXh0JywgJ2VuY29kaW5nJylcbiAgICB9XG5cbiAgICAvLyBUaGUgcmVhZEFzVGV4dChibG9iLCBlbmNvZGluZykgbWV0aG9kLCB3aGVuIGludm9rZWQsXG4gICAgLy8gbXVzdCBpbml0aWF0ZSBhIHJlYWQgb3BlcmF0aW9uIGZvciBibG9iIHdpdGggVGV4dCBhbmQgZW5jb2RpbmcuXG4gICAgcmVhZE9wZXJhdGlvbih0aGlzLCBibG9iLCAnVGV4dCcsIGVuY29kaW5nKVxuICB9XG5cbiAgLyoqXG4gICAqIEBzZWUgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL0ZpbGVBUEkvI2Rmbi1yZWFkQXNEYXRhVVJMXG4gICAqIEBwYXJhbSB7aW1wb3J0KCdidWZmZXInKS5CbG9ifSBibG9iXG4gICAqL1xuICByZWFkQXNEYXRhVVJMIChibG9iKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRmlsZVJlYWRlcilcblxuICAgIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMSwgJ0ZpbGVSZWFkZXIucmVhZEFzRGF0YVVSTCcpXG5cbiAgICBibG9iID0gd2ViaWRsLmNvbnZlcnRlcnMuQmxvYihibG9iLCB7IHN0cmljdDogZmFsc2UgfSlcblxuICAgIC8vIFRoZSByZWFkQXNEYXRhVVJMKGJsb2IpIG1ldGhvZCwgd2hlbiBpbnZva2VkLCBtdXN0XG4gICAgLy8gaW5pdGlhdGUgYSByZWFkIG9wZXJhdGlvbiBmb3IgYmxvYiB3aXRoIERhdGFVUkwuXG4gICAgcmVhZE9wZXJhdGlvbih0aGlzLCBibG9iLCAnRGF0YVVSTCcpXG4gIH1cblxuICAvKipcbiAgICogQHNlZSBodHRwczovL3czYy5naXRodWIuaW8vRmlsZUFQSS8jZGZuLWFib3J0XG4gICAqL1xuICBhYm9ydCAoKSB7XG4gICAgLy8gMS4gSWYgdGhpcydzIHN0YXRlIGlzIFwiZW1wdHlcIiBvciBpZiB0aGlzJ3Mgc3RhdGUgaXNcbiAgICAvLyAgICBcImRvbmVcIiBzZXQgdGhpcydzIHJlc3VsdCB0byBudWxsIGFuZCB0ZXJtaW5hdGVcbiAgICAvLyAgICB0aGlzIGFsZ29yaXRobS5cbiAgICBpZiAodGhpc1trU3RhdGVdID09PSAnZW1wdHknIHx8IHRoaXNba1N0YXRlXSA9PT0gJ2RvbmUnKSB7XG4gICAgICB0aGlzW2tSZXN1bHRdID0gbnVsbFxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gMi4gSWYgdGhpcydzIHN0YXRlIGlzIFwibG9hZGluZ1wiIHNldCB0aGlzJ3Mgc3RhdGUgdG9cbiAgICAvLyAgICBcImRvbmVcIiBhbmQgc2V0IHRoaXMncyByZXN1bHQgdG8gbnVsbC5cbiAgICBpZiAodGhpc1trU3RhdGVdID09PSAnbG9hZGluZycpIHtcbiAgICAgIHRoaXNba1N0YXRlXSA9ICdkb25lJ1xuICAgICAgdGhpc1trUmVzdWx0XSA9IG51bGxcbiAgICB9XG5cbiAgICAvLyAzLiBJZiB0aGVyZSBhcmUgYW55IHRhc2tzIGZyb20gdGhpcyBvbiB0aGUgZmlsZSByZWFkaW5nXG4gICAgLy8gICAgdGFzayBzb3VyY2UgaW4gYW4gYWZmaWxpYXRlZCB0YXNrIHF1ZXVlLCB0aGVuIHJlbW92ZVxuICAgIC8vICAgIHRob3NlIHRhc2tzIGZyb20gdGhhdCB0YXNrIHF1ZXVlLlxuICAgIHRoaXNba0Fib3J0ZWRdID0gdHJ1ZVxuXG4gICAgLy8gNC4gVGVybWluYXRlIHRoZSBhbGdvcml0aG0gZm9yIHRoZSByZWFkIG1ldGhvZCBiZWluZyBwcm9jZXNzZWQuXG4gICAgLy8gVE9ET1xuXG4gICAgLy8gNS4gRmlyZSBhIHByb2dyZXNzIGV2ZW50IGNhbGxlZCBhYm9ydCBhdCB0aGlzLlxuICAgIGZpcmVBUHJvZ3Jlc3NFdmVudCgnYWJvcnQnLCB0aGlzKVxuXG4gICAgLy8gNi4gSWYgdGhpcydzIHN0YXRlIGlzIG5vdCBcImxvYWRpbmdcIiwgZmlyZSBhIHByb2dyZXNzXG4gICAgLy8gICAgZXZlbnQgY2FsbGVkIGxvYWRlbmQgYXQgdGhpcy5cbiAgICBpZiAodGhpc1trU3RhdGVdICE9PSAnbG9hZGluZycpIHtcbiAgICAgIGZpcmVBUHJvZ3Jlc3NFdmVudCgnbG9hZGVuZCcsIHRoaXMpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBzZWUgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL0ZpbGVBUEkvI2RvbS1maWxlcmVhZGVyLXJlYWR5c3RhdGVcbiAgICovXG4gIGdldCByZWFkeVN0YXRlICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBGaWxlUmVhZGVyKVxuXG4gICAgc3dpdGNoICh0aGlzW2tTdGF0ZV0pIHtcbiAgICAgIGNhc2UgJ2VtcHR5JzogcmV0dXJuIHRoaXMuRU1QVFlcbiAgICAgIGNhc2UgJ2xvYWRpbmcnOiByZXR1cm4gdGhpcy5MT0FESU5HXG4gICAgICBjYXNlICdkb25lJzogcmV0dXJuIHRoaXMuRE9ORVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAc2VlIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby9GaWxlQVBJLyNkb20tZmlsZXJlYWRlci1yZXN1bHRcbiAgICovXG4gIGdldCByZXN1bHQgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEZpbGVSZWFkZXIpXG5cbiAgICAvLyBUaGUgcmVzdWx0IGF0dHJpYnV0ZeKAmXMgZ2V0dGVyLCB3aGVuIGludm9rZWQsIG11c3QgcmV0dXJuXG4gICAgLy8gdGhpcydzIHJlc3VsdC5cbiAgICByZXR1cm4gdGhpc1trUmVzdWx0XVxuICB9XG5cbiAgLyoqXG4gICAqIEBzZWUgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL0ZpbGVBUEkvI2RvbS1maWxlcmVhZGVyLWVycm9yXG4gICAqL1xuICBnZXQgZXJyb3IgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEZpbGVSZWFkZXIpXG5cbiAgICAvLyBUaGUgZXJyb3IgYXR0cmlidXRl4oCZcyBnZXR0ZXIsIHdoZW4gaW52b2tlZCwgbXVzdCByZXR1cm5cbiAgICAvLyB0aGlzJ3MgZXJyb3IuXG4gICAgcmV0dXJuIHRoaXNba0Vycm9yXVxuICB9XG5cbiAgZ2V0IG9ubG9hZGVuZCAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRmlsZVJlYWRlcilcblxuICAgIHJldHVybiB0aGlzW2tFdmVudHNdLmxvYWRlbmRcbiAgfVxuXG4gIHNldCBvbmxvYWRlbmQgKGZuKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRmlsZVJlYWRlcilcblxuICAgIGlmICh0aGlzW2tFdmVudHNdLmxvYWRlbmQpIHtcbiAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignbG9hZGVuZCcsIHRoaXNba0V2ZW50c10ubG9hZGVuZClcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzW2tFdmVudHNdLmxvYWRlbmQgPSBmblxuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdsb2FkZW5kJywgZm4pXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXNba0V2ZW50c10ubG9hZGVuZCA9IG51bGxcbiAgICB9XG4gIH1cblxuICBnZXQgb25lcnJvciAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRmlsZVJlYWRlcilcblxuICAgIHJldHVybiB0aGlzW2tFdmVudHNdLmVycm9yXG4gIH1cblxuICBzZXQgb25lcnJvciAoZm4pIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBGaWxlUmVhZGVyKVxuXG4gICAgaWYgKHRoaXNba0V2ZW50c10uZXJyb3IpIHtcbiAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCB0aGlzW2tFdmVudHNdLmVycm9yKVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXNba0V2ZW50c10uZXJyb3IgPSBmblxuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGZuKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzW2tFdmVudHNdLmVycm9yID0gbnVsbFxuICAgIH1cbiAgfVxuXG4gIGdldCBvbmxvYWRzdGFydCAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRmlsZVJlYWRlcilcblxuICAgIHJldHVybiB0aGlzW2tFdmVudHNdLmxvYWRzdGFydFxuICB9XG5cbiAgc2V0IG9ubG9hZHN0YXJ0IChmbikge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEZpbGVSZWFkZXIpXG5cbiAgICBpZiAodGhpc1trRXZlbnRzXS5sb2Fkc3RhcnQpIHtcbiAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignbG9hZHN0YXJ0JywgdGhpc1trRXZlbnRzXS5sb2Fkc3RhcnQpXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpc1trRXZlbnRzXS5sb2Fkc3RhcnQgPSBmblxuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdsb2Fkc3RhcnQnLCBmbilcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpc1trRXZlbnRzXS5sb2Fkc3RhcnQgPSBudWxsXG4gICAgfVxuICB9XG5cbiAgZ2V0IG9ucHJvZ3Jlc3MgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEZpbGVSZWFkZXIpXG5cbiAgICByZXR1cm4gdGhpc1trRXZlbnRzXS5wcm9ncmVzc1xuICB9XG5cbiAgc2V0IG9ucHJvZ3Jlc3MgKGZuKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRmlsZVJlYWRlcilcblxuICAgIGlmICh0aGlzW2tFdmVudHNdLnByb2dyZXNzKSB7XG4gICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgdGhpc1trRXZlbnRzXS5wcm9ncmVzcylcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzW2tFdmVudHNdLnByb2dyZXNzID0gZm5cbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCBmbilcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpc1trRXZlbnRzXS5wcm9ncmVzcyA9IG51bGxcbiAgICB9XG4gIH1cblxuICBnZXQgb25sb2FkICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBGaWxlUmVhZGVyKVxuXG4gICAgcmV0dXJuIHRoaXNba0V2ZW50c10ubG9hZFxuICB9XG5cbiAgc2V0IG9ubG9hZCAoZm4pIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBGaWxlUmVhZGVyKVxuXG4gICAgaWYgKHRoaXNba0V2ZW50c10ubG9hZCkge1xuICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdsb2FkJywgdGhpc1trRXZlbnRzXS5sb2FkKVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXNba0V2ZW50c10ubG9hZCA9IGZuXG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBmbilcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpc1trRXZlbnRzXS5sb2FkID0gbnVsbFxuICAgIH1cbiAgfVxuXG4gIGdldCBvbmFib3J0ICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBGaWxlUmVhZGVyKVxuXG4gICAgcmV0dXJuIHRoaXNba0V2ZW50c10uYWJvcnRcbiAgfVxuXG4gIHNldCBvbmFib3J0IChmbikge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEZpbGVSZWFkZXIpXG5cbiAgICBpZiAodGhpc1trRXZlbnRzXS5hYm9ydCkge1xuICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdhYm9ydCcsIHRoaXNba0V2ZW50c10uYWJvcnQpXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpc1trRXZlbnRzXS5hYm9ydCA9IGZuXG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgZm4pXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXNba0V2ZW50c10uYWJvcnQgPSBudWxsXG4gICAgfVxuICB9XG59XG5cbi8vIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby9GaWxlQVBJLyNkb20tZmlsZXJlYWRlci1lbXB0eVxuRmlsZVJlYWRlci5FTVBUWSA9IEZpbGVSZWFkZXIucHJvdG90eXBlLkVNUFRZID0gMFxuLy8gaHR0cHM6Ly93M2MuZ2l0aHViLmlvL0ZpbGVBUEkvI2RvbS1maWxlcmVhZGVyLWxvYWRpbmdcbkZpbGVSZWFkZXIuTE9BRElORyA9IEZpbGVSZWFkZXIucHJvdG90eXBlLkxPQURJTkcgPSAxXG4vLyBodHRwczovL3czYy5naXRodWIuaW8vRmlsZUFQSS8jZG9tLWZpbGVyZWFkZXItZG9uZVxuRmlsZVJlYWRlci5ET05FID0gRmlsZVJlYWRlci5wcm90b3R5cGUuRE9ORSA9IDJcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoRmlsZVJlYWRlci5wcm90b3R5cGUsIHtcbiAgRU1QVFk6IHN0YXRpY1Byb3BlcnR5RGVzY3JpcHRvcnMsXG4gIExPQURJTkc6IHN0YXRpY1Byb3BlcnR5RGVzY3JpcHRvcnMsXG4gIERPTkU6IHN0YXRpY1Byb3BlcnR5RGVzY3JpcHRvcnMsXG4gIHJlYWRBc0FycmF5QnVmZmVyOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICByZWFkQXNCaW5hcnlTdHJpbmc6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIHJlYWRBc1RleHQ6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIHJlYWRBc0RhdGFVUkw6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGFib3J0OiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICByZWFkeVN0YXRlOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICByZXN1bHQ6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGVycm9yOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBvbmxvYWRzdGFydDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgb25wcm9ncmVzczoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgb25sb2FkOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBvbmFib3J0OiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBvbmVycm9yOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBvbmxvYWRlbmQ6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIFtTeW1ib2wudG9TdHJpbmdUYWddOiB7XG4gICAgdmFsdWU6ICdGaWxlUmVhZGVyJyxcbiAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH1cbn0pXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEZpbGVSZWFkZXIsIHtcbiAgRU1QVFk6IHN0YXRpY1Byb3BlcnR5RGVzY3JpcHRvcnMsXG4gIExPQURJTkc6IHN0YXRpY1Byb3BlcnR5RGVzY3JpcHRvcnMsXG4gIERPTkU6IHN0YXRpY1Byb3BlcnR5RGVzY3JpcHRvcnNcbn0pXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBGaWxlUmVhZGVyXG59XG4iXSwibmFtZXMiOlsic3RhdGljUHJvcGVydHlEZXNjcmlwdG9ycyIsInJlYWRPcGVyYXRpb24iLCJmaXJlQVByb2dyZXNzRXZlbnQiLCJyZXF1aXJlIiwia1N0YXRlIiwia0Vycm9yIiwia1Jlc3VsdCIsImtFdmVudHMiLCJrQWJvcnRlZCIsIndlYmlkbCIsImtFbnVtZXJhYmxlUHJvcGVydHkiLCJGaWxlUmVhZGVyIiwiRXZlbnRUYXJnZXQiLCJjb25zdHJ1Y3RvciIsImxvYWRlbmQiLCJlcnJvciIsImFib3J0IiwibG9hZCIsInByb2dyZXNzIiwibG9hZHN0YXJ0IiwicmVhZEFzQXJyYXlCdWZmZXIiLCJibG9iIiwiYnJhbmRDaGVjayIsImFyZ3VtZW50TGVuZ3RoQ2hlY2siLCJhcmd1bWVudHMiLCJjb252ZXJ0ZXJzIiwiQmxvYiIsInN0cmljdCIsInJlYWRBc0JpbmFyeVN0cmluZyIsInJlYWRBc1RleHQiLCJlbmNvZGluZyIsInVuZGVmaW5lZCIsIkRPTVN0cmluZyIsInJlYWRBc0RhdGFVUkwiLCJyZWFkeVN0YXRlIiwiRU1QVFkiLCJMT0FESU5HIiwiRE9ORSIsInJlc3VsdCIsIm9ubG9hZGVuZCIsImZuIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImFkZEV2ZW50TGlzdGVuZXIiLCJvbmVycm9yIiwib25sb2Fkc3RhcnQiLCJvbnByb2dyZXNzIiwib25sb2FkIiwib25hYm9ydCIsInByb3RvdHlwZSIsIk9iamVjdCIsImRlZmluZVByb3BlcnRpZXMiLCJTeW1ib2wiLCJ0b1N0cmluZ1RhZyIsInZhbHVlIiwid3JpdGFibGUiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/fileapi/filereader.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/fileapi/progressevent.js":
/*!**************************************************************!*\
  !*** ./node_modules/undici/lib/web/fileapi/progressevent.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { webidl } = __webpack_require__(/*! ../fetch/webidl */ \"(ssr)/./node_modules/undici/lib/web/fetch/webidl.js\");\nconst kState = Symbol(\"ProgressEvent state\");\n/**\n * @see https://xhr.spec.whatwg.org/#progressevent\n */ class ProgressEvent extends Event {\n    constructor(type, eventInitDict = {}){\n        type = webidl.converters.DOMString(type, \"ProgressEvent constructor\", \"type\");\n        eventInitDict = webidl.converters.ProgressEventInit(eventInitDict ?? {});\n        super(type, eventInitDict);\n        this[kState] = {\n            lengthComputable: eventInitDict.lengthComputable,\n            loaded: eventInitDict.loaded,\n            total: eventInitDict.total\n        };\n    }\n    get lengthComputable() {\n        webidl.brandCheck(this, ProgressEvent);\n        return this[kState].lengthComputable;\n    }\n    get loaded() {\n        webidl.brandCheck(this, ProgressEvent);\n        return this[kState].loaded;\n    }\n    get total() {\n        webidl.brandCheck(this, ProgressEvent);\n        return this[kState].total;\n    }\n}\nwebidl.converters.ProgressEventInit = webidl.dictionaryConverter([\n    {\n        key: \"lengthComputable\",\n        converter: webidl.converters.boolean,\n        defaultValue: ()=>false\n    },\n    {\n        key: \"loaded\",\n        converter: webidl.converters[\"unsigned long long\"],\n        defaultValue: ()=>0\n    },\n    {\n        key: \"total\",\n        converter: webidl.converters[\"unsigned long long\"],\n        defaultValue: ()=>0\n    },\n    {\n        key: \"bubbles\",\n        converter: webidl.converters.boolean,\n        defaultValue: ()=>false\n    },\n    {\n        key: \"cancelable\",\n        converter: webidl.converters.boolean,\n        defaultValue: ()=>false\n    },\n    {\n        key: \"composed\",\n        converter: webidl.converters.boolean,\n        defaultValue: ()=>false\n    }\n]);\nmodule.exports = {\n    ProgressEvent\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZmlsZWFwaS9wcm9ncmVzc2V2ZW50LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTSxFQUFFQSxNQUFBQSxFQUFRLEdBQUdDLG1CQUFPQSxDQUFDO0FBRTNCLE1BQU1DLFNBQVNDLE9BQU87QUFFdEI7O0NBRUEsR0FDQSxNQUFNQyxzQkFBc0JDO0lBQzFCQyxZQUFhQyxJQUFJLEVBQUVDLGdCQUFnQixDQUFDLENBQUMsQ0FBRTtRQUNyQ0QsT0FBT1AsT0FBT1MsVUFBVSxDQUFDQyxTQUFTLENBQUNILE1BQU0sNkJBQTZCO1FBQ3RFQyxnQkFBZ0JSLE9BQU9TLFVBQVUsQ0FBQ0UsaUJBQWlCLENBQUNILGlCQUFpQixDQUFDO1FBRXRFLEtBQUssQ0FBQ0QsTUFBTUM7UUFFWixJQUFJLENBQUNOLE9BQU8sR0FBRztZQUNiVSxrQkFBa0JKLGNBQWNJLGdCQUFnQjtZQUNoREMsUUFBUUwsY0FBY0ssTUFBTTtZQUM1QkMsT0FBT04sY0FBY00sS0FBQUE7UUFDdkI7SUFDRjtJQUVBLElBQUlGLG1CQUFvQjtRQUN0QlosT0FBT2UsVUFBVSxDQUFDLElBQUksRUFBRVg7UUFFeEIsT0FBTyxJQUFJLENBQUNGLE9BQU8sQ0FBQ1UsZ0JBQWdCO0lBQ3RDO0lBRUEsSUFBSUMsU0FBVTtRQUNaYixPQUFPZSxVQUFVLENBQUMsSUFBSSxFQUFFWDtRQUV4QixPQUFPLElBQUksQ0FBQ0YsT0FBTyxDQUFDVyxNQUFNO0lBQzVCO0lBRUEsSUFBSUMsUUFBUztRQUNYZCxPQUFPZSxVQUFVLENBQUMsSUFBSSxFQUFFWDtRQUV4QixPQUFPLElBQUksQ0FBQ0YsT0FBTyxDQUFDWSxLQUFLO0lBQzNCO0FBQ0Y7QUFFQWQsT0FBT1MsVUFBVSxDQUFDRSxpQkFBaUIsR0FBR1gsT0FBT2dCLG1CQUFtQixDQUFDO0lBQy9EO1FBQ0VDLEtBQUs7UUFDTEMsV0FBV2xCLE9BQU9TLFVBQVUsQ0FBQ1UsT0FBTztRQUNwQ0MsY0FBY0EsSUFBTTtJQUN0QjtJQUNBO1FBQ0VILEtBQUs7UUFDTEMsV0FBV2xCLE9BQU9TLFVBQVUsQ0FBQyxxQkFBcUI7UUFDbERXLGNBQWNBLElBQU07SUFDdEI7SUFDQTtRQUNFSCxLQUFLO1FBQ0xDLFdBQVdsQixPQUFPUyxVQUFVLENBQUMscUJBQXFCO1FBQ2xEVyxjQUFjQSxJQUFNO0lBQ3RCO0lBQ0E7UUFDRUgsS0FBSztRQUNMQyxXQUFXbEIsT0FBT1MsVUFBVSxDQUFDVSxPQUFPO1FBQ3BDQyxjQUFjQSxJQUFNO0lBQ3RCO0lBQ0E7UUFDRUgsS0FBSztRQUNMQyxXQUFXbEIsT0FBT1MsVUFBVSxDQUFDVSxPQUFPO1FBQ3BDQyxjQUFjQSxJQUFNO0lBQ3RCO0lBQ0E7UUFDRUgsS0FBSztRQUNMQyxXQUFXbEIsT0FBT1MsVUFBVSxDQUFDVSxPQUFPO1FBQ3BDQyxjQUFjQSxJQUFNO0lBQ3RCO0NBQ0Q7QUFFREMsT0FBT0MsT0FBTyxHQUFHO0lBQ2ZsQjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbW9ja3VwZmxvdy8uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL3dlYi9maWxlYXBpL3Byb2dyZXNzZXZlbnQuanM/NDMyNyIsIndlYnBhY2s6Ly9tb2NrdXBmbG93Ly4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvd2ViL2ZpbGVhcGkvcHJvZ3Jlc3NldmVudC5qcz80MzI3KiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyB3ZWJpZGwgfSA9IHJlcXVpcmUoJy4uL2ZldGNoL3dlYmlkbCcpXG5cbmNvbnN0IGtTdGF0ZSA9IFN5bWJvbCgnUHJvZ3Jlc3NFdmVudCBzdGF0ZScpXG5cbi8qKlxuICogQHNlZSBodHRwczovL3hoci5zcGVjLndoYXR3Zy5vcmcvI3Byb2dyZXNzZXZlbnRcbiAqL1xuY2xhc3MgUHJvZ3Jlc3NFdmVudCBleHRlbmRzIEV2ZW50IHtcbiAgY29uc3RydWN0b3IgKHR5cGUsIGV2ZW50SW5pdERpY3QgPSB7fSkge1xuICAgIHR5cGUgPSB3ZWJpZGwuY29udmVydGVycy5ET01TdHJpbmcodHlwZSwgJ1Byb2dyZXNzRXZlbnQgY29uc3RydWN0b3InLCAndHlwZScpXG4gICAgZXZlbnRJbml0RGljdCA9IHdlYmlkbC5jb252ZXJ0ZXJzLlByb2dyZXNzRXZlbnRJbml0KGV2ZW50SW5pdERpY3QgPz8ge30pXG5cbiAgICBzdXBlcih0eXBlLCBldmVudEluaXREaWN0KVxuXG4gICAgdGhpc1trU3RhdGVdID0ge1xuICAgICAgbGVuZ3RoQ29tcHV0YWJsZTogZXZlbnRJbml0RGljdC5sZW5ndGhDb21wdXRhYmxlLFxuICAgICAgbG9hZGVkOiBldmVudEluaXREaWN0LmxvYWRlZCxcbiAgICAgIHRvdGFsOiBldmVudEluaXREaWN0LnRvdGFsXG4gICAgfVxuICB9XG5cbiAgZ2V0IGxlbmd0aENvbXB1dGFibGUgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFByb2dyZXNzRXZlbnQpXG5cbiAgICByZXR1cm4gdGhpc1trU3RhdGVdLmxlbmd0aENvbXB1dGFibGVcbiAgfVxuXG4gIGdldCBsb2FkZWQgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFByb2dyZXNzRXZlbnQpXG5cbiAgICByZXR1cm4gdGhpc1trU3RhdGVdLmxvYWRlZFxuICB9XG5cbiAgZ2V0IHRvdGFsICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBQcm9ncmVzc0V2ZW50KVxuXG4gICAgcmV0dXJuIHRoaXNba1N0YXRlXS50b3RhbFxuICB9XG59XG5cbndlYmlkbC5jb252ZXJ0ZXJzLlByb2dyZXNzRXZlbnRJbml0ID0gd2ViaWRsLmRpY3Rpb25hcnlDb252ZXJ0ZXIoW1xuICB7XG4gICAga2V5OiAnbGVuZ3RoQ29tcHV0YWJsZScsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5ib29sZWFuLFxuICAgIGRlZmF1bHRWYWx1ZTogKCkgPT4gZmFsc2VcbiAgfSxcbiAge1xuICAgIGtleTogJ2xvYWRlZCcsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVyc1sndW5zaWduZWQgbG9uZyBsb25nJ10sXG4gICAgZGVmYXVsdFZhbHVlOiAoKSA9PiAwXG4gIH0sXG4gIHtcbiAgICBrZXk6ICd0b3RhbCcsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVyc1sndW5zaWduZWQgbG9uZyBsb25nJ10sXG4gICAgZGVmYXVsdFZhbHVlOiAoKSA9PiAwXG4gIH0sXG4gIHtcbiAgICBrZXk6ICdidWJibGVzJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLmJvb2xlYW4sXG4gICAgZGVmYXVsdFZhbHVlOiAoKSA9PiBmYWxzZVxuICB9LFxuICB7XG4gICAga2V5OiAnY2FuY2VsYWJsZScsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5ib29sZWFuLFxuICAgIGRlZmF1bHRWYWx1ZTogKCkgPT4gZmFsc2VcbiAgfSxcbiAge1xuICAgIGtleTogJ2NvbXBvc2VkJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLmJvb2xlYW4sXG4gICAgZGVmYXVsdFZhbHVlOiAoKSA9PiBmYWxzZVxuICB9XG5dKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgUHJvZ3Jlc3NFdmVudFxufVxuIl0sIm5hbWVzIjpbIndlYmlkbCIsInJlcXVpcmUiLCJrU3RhdGUiLCJTeW1ib2wiLCJQcm9ncmVzc0V2ZW50IiwiRXZlbnQiLCJjb25zdHJ1Y3RvciIsInR5cGUiLCJldmVudEluaXREaWN0IiwiY29udmVydGVycyIsIkRPTVN0cmluZyIsIlByb2dyZXNzRXZlbnRJbml0IiwibGVuZ3RoQ29tcHV0YWJsZSIsImxvYWRlZCIsInRvdGFsIiwiYnJhbmRDaGVjayIsImRpY3Rpb25hcnlDb252ZXJ0ZXIiLCJrZXkiLCJjb252ZXJ0ZXIiLCJib29sZWFuIiwiZGVmYXVsdFZhbHVlIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/fileapi/progressevent.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/fileapi/symbols.js":
/*!********************************************************!*\
  !*** ./node_modules/undici/lib/web/fileapi/symbols.js ***!
  \********************************************************/
/***/ ((module) => {

eval("\nmodule.exports = {\n    kState: Symbol(\"FileReader state\"),\n    kResult: Symbol(\"FileReader result\"),\n    kError: Symbol(\"FileReader error\"),\n    kLastProgressEventFired: Symbol(\"FileReader last progress event fired timestamp\"),\n    kEvents: Symbol(\"FileReader events\"),\n    kAborted: Symbol(\"FileReader aborted\")\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZmlsZWFwaS9zeW1ib2xzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUFBLE9BQU9DLE9BQU8sR0FBRztJQUNmQyxRQUFRQyxPQUFPO0lBQ2ZDLFNBQVNELE9BQU87SUFDaEJFLFFBQVFGLE9BQU87SUFDZkcseUJBQXlCSCxPQUFPO0lBQ2hDSSxTQUFTSixPQUFPO0lBQ2hCSyxVQUFVTCxPQUFPO0FBQ25CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbW9ja3VwZmxvdy8uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL3dlYi9maWxlYXBpL3N5bWJvbHMuanM/MTBlNiIsIndlYnBhY2s6Ly9tb2NrdXBmbG93Ly4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvd2ViL2ZpbGVhcGkvc3ltYm9scy5qcz8xMGU2KiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGtTdGF0ZTogU3ltYm9sKCdGaWxlUmVhZGVyIHN0YXRlJyksXG4gIGtSZXN1bHQ6IFN5bWJvbCgnRmlsZVJlYWRlciByZXN1bHQnKSxcbiAga0Vycm9yOiBTeW1ib2woJ0ZpbGVSZWFkZXIgZXJyb3InKSxcbiAga0xhc3RQcm9ncmVzc0V2ZW50RmlyZWQ6IFN5bWJvbCgnRmlsZVJlYWRlciBsYXN0IHByb2dyZXNzIGV2ZW50IGZpcmVkIHRpbWVzdGFtcCcpLFxuICBrRXZlbnRzOiBTeW1ib2woJ0ZpbGVSZWFkZXIgZXZlbnRzJyksXG4gIGtBYm9ydGVkOiBTeW1ib2woJ0ZpbGVSZWFkZXIgYWJvcnRlZCcpXG59XG4iXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsImtTdGF0ZSIsIlN5bWJvbCIsImtSZXN1bHQiLCJrRXJyb3IiLCJrTGFzdFByb2dyZXNzRXZlbnRGaXJlZCIsImtFdmVudHMiLCJrQWJvcnRlZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/fileapi/symbols.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/fileapi/util.js":
/*!*****************************************************!*\
  !*** ./node_modules/undici/lib/web/fileapi/util.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { kState, kError, kResult, kAborted, kLastProgressEventFired } = __webpack_require__(/*! ./symbols */ \"(ssr)/./node_modules/undici/lib/web/fileapi/symbols.js\");\nconst { ProgressEvent } = __webpack_require__(/*! ./progressevent */ \"(ssr)/./node_modules/undici/lib/web/fileapi/progressevent.js\");\nconst { getEncoding } = __webpack_require__(/*! ./encoding */ \"(ssr)/./node_modules/undici/lib/web/fileapi/encoding.js\");\nconst { serializeAMimeType, parseMIMEType } = __webpack_require__(/*! ../fetch/data-url */ \"(ssr)/./node_modules/undici/lib/web/fetch/data-url.js\");\nconst { types } = __webpack_require__(/*! node:util */ \"node:util\");\nconst { StringDecoder } = __webpack_require__(/*! string_decoder */ \"string_decoder\");\nconst { btoa } = __webpack_require__(/*! node:buffer */ \"node:buffer\");\n/** @type {PropertyDescriptor} */ const staticPropertyDescriptors = {\n    enumerable: true,\n    writable: false,\n    configurable: false\n};\n/**\n * @see https://w3c.github.io/FileAPI/#readOperation\n * @param {import('./filereader').FileReader} fr\n * @param {import('buffer').Blob} blob\n * @param {string} type\n * @param {string?} encodingName\n */ function readOperation(fr, blob, type, encodingName) {\n    // 1. If frs state is \"loading\", throw an InvalidStateError\n    //    DOMException.\n    if (fr[kState] === \"loading\") {\n        throw new DOMException(\"Invalid state\", \"InvalidStateError\");\n    }\n    // 2. Set frs state to \"loading\".\n    fr[kState] = \"loading\";\n    // 3. Set frs result to null.\n    fr[kResult] = null;\n    // 4. Set frs error to null.\n    fr[kError] = null;\n    // 5. Let stream be the result of calling get stream on blob.\n    /** @type {import('stream/web').ReadableStream} */ const stream = blob.stream();\n    // 6. Let reader be the result of getting a reader from stream.\n    const reader = stream.getReader();\n    // 7. Let bytes be an empty byte sequence.\n    /** @type {Uint8Array[]} */ const bytes = [];\n    // 8. Let chunkPromise be the result of reading a chunk from\n    //    stream with reader.\n    let chunkPromise = reader.read();\n    // 9. Let isFirstChunk be true.\n    let isFirstChunk = true;\n    (async ()=>{\n        while(!fr[kAborted]){\n            // 1. Wait for chunkPromise to be fulfilled or rejected.\n            try {\n                const { done, value } = await chunkPromise;\n                // 2. If chunkPromise is fulfilled, and isFirstChunk is\n                //    true, queue a task to fire a progress event called\n                //    loadstart at fr.\n                if (isFirstChunk && !fr[kAborted]) {\n                    queueMicrotask(()=>{\n                        fireAProgressEvent(\"loadstart\", fr);\n                    });\n                }\n                // 3. Set isFirstChunk to false.\n                isFirstChunk = false;\n                // 4. If chunkPromise is fulfilled with an object whose\n                //    done property is false and whose value property is\n                //    a Uint8Array object, run these steps:\n                if (!done && types.isUint8Array(value)) {\n                    // 1. Let bs be the byte sequence represented by the\n                    //    Uint8Array object.\n                    // 2. Append bs to bytes.\n                    bytes.push(value);\n                    // 3. If roughly 50ms have passed since these steps\n                    //    were last invoked, queue a task to fire a\n                    //    progress event called progress at fr.\n                    if ((fr[kLastProgressEventFired] === undefined || Date.now() - fr[kLastProgressEventFired] >= 50) && !fr[kAborted]) {\n                        fr[kLastProgressEventFired] = Date.now();\n                        queueMicrotask(()=>{\n                            fireAProgressEvent(\"progress\", fr);\n                        });\n                    }\n                    // 4. Set chunkPromise to the result of reading a\n                    //    chunk from stream with reader.\n                    chunkPromise = reader.read();\n                } else if (done) {\n                    // 5. Otherwise, if chunkPromise is fulfilled with an\n                    //    object whose done property is true, queue a task\n                    //    to run the following steps and abort this algorithm:\n                    queueMicrotask(()=>{\n                        // 1. Set frs state to \"done\".\n                        fr[kState] = \"done\";\n                        // 2. Let result be the result of package data given\n                        //    bytes, type, blobs type, and encodingName.\n                        try {\n                            const result = packageData(bytes, type, blob.type, encodingName);\n                            // 4. Else:\n                            if (fr[kAborted]) {\n                                return;\n                            }\n                            // 1. Set frs result to result.\n                            fr[kResult] = result;\n                            // 2. Fire a progress event called load at the fr.\n                            fireAProgressEvent(\"load\", fr);\n                        } catch (error) {\n                            // 3. If package data threw an exception error:\n                            // 1. Set frs error to error.\n                            fr[kError] = error;\n                            // 2. Fire a progress event called error at fr.\n                            fireAProgressEvent(\"error\", fr);\n                        }\n                        // 5. If frs state is not \"loading\", fire a progress\n                        //    event called loadend at the fr.\n                        if (fr[kState] !== \"loading\") {\n                            fireAProgressEvent(\"loadend\", fr);\n                        }\n                    });\n                    break;\n                }\n            } catch (error) {\n                if (fr[kAborted]) {\n                    return;\n                }\n                // 6. Otherwise, if chunkPromise is rejected with an\n                //    error error, queue a task to run the following\n                //    steps and abort this algorithm:\n                queueMicrotask(()=>{\n                    // 1. Set frs state to \"done\".\n                    fr[kState] = \"done\";\n                    // 2. Set frs error to error.\n                    fr[kError] = error;\n                    // 3. Fire a progress event called error at fr.\n                    fireAProgressEvent(\"error\", fr);\n                    // 4. If frs state is not \"loading\", fire a progress\n                    //    event called loadend at fr.\n                    if (fr[kState] !== \"loading\") {\n                        fireAProgressEvent(\"loadend\", fr);\n                    }\n                });\n                break;\n            }\n        }\n    })();\n}\n/**\n * @see https://w3c.github.io/FileAPI/#fire-a-progress-event\n * @see https://dom.spec.whatwg.org/#concept-event-fire\n * @param {string} e The name of the event\n * @param {import('./filereader').FileReader} reader\n */ function fireAProgressEvent(e, reader) {\n    // The progress event e does not bubble. e.bubbles must be false\n    // The progress event e is NOT cancelable. e.cancelable must be false\n    const event = new ProgressEvent(e, {\n        bubbles: false,\n        cancelable: false\n    });\n    reader.dispatchEvent(event);\n}\n/**\n * @see https://w3c.github.io/FileAPI/#blob-package-data\n * @param {Uint8Array[]} bytes\n * @param {string} type\n * @param {string?} mimeType\n * @param {string?} encodingName\n */ function packageData(bytes, type, mimeType, encodingName) {\n    // 1. A Blob has an associated package data algorithm, given\n    //    bytes, a type, a optional mimeType, and a optional\n    //    encodingName, which switches on type and runs the\n    //    associated steps:\n    switch(type){\n        case \"DataURL\":\n            {\n                // 1. Return bytes as a DataURL [RFC2397] subject to\n                //    the considerations below:\n                //  * Use mimeType as part of the Data URL if it is\n                //    available in keeping with the Data URL\n                //    specification [RFC2397].\n                //  * If mimeType is not available return a Data URL\n                //    without a media-type. [RFC2397].\n                // https://datatracker.ietf.org/doc/html/rfc2397#section-3\n                // dataurl    := \"data:\" [ mediatype ] [ \";base64\" ] \",\" data\n                // mediatype  := [ type \"/\" subtype ] *( \";\" parameter )\n                // data       := *urlchar\n                // parameter  := attribute \"=\" value\n                let dataURL = \"data:\";\n                const parsed = parseMIMEType(mimeType || \"application/octet-stream\");\n                if (parsed !== \"failure\") {\n                    dataURL += serializeAMimeType(parsed);\n                }\n                dataURL += \";base64,\";\n                const decoder = new StringDecoder(\"latin1\");\n                for (const chunk of bytes){\n                    dataURL += btoa(decoder.write(chunk));\n                }\n                dataURL += btoa(decoder.end());\n                return dataURL;\n            }\n        case \"Text\":\n            {\n                // 1. Let encoding be failure\n                let encoding = \"failure\";\n                // 2. If the encodingName is present, set encoding to the\n                //    result of getting an encoding from encodingName.\n                if (encodingName) {\n                    encoding = getEncoding(encodingName);\n                }\n                // 3. If encoding is failure, and mimeType is present:\n                if (encoding === \"failure\" && mimeType) {\n                    // 1. Let type be the result of parse a MIME type\n                    //    given mimeType.\n                    const type = parseMIMEType(mimeType);\n                    // 2. If type is not failure, set encoding to the result\n                    //    of getting an encoding from types parameters[\"charset\"].\n                    if (type !== \"failure\") {\n                        encoding = getEncoding(type.parameters.get(\"charset\"));\n                    }\n                }\n                // 4. If encoding is failure, then set encoding to UTF-8.\n                if (encoding === \"failure\") {\n                    encoding = \"UTF-8\";\n                }\n                // 5. Decode bytes using fallback encoding encoding, and\n                //    return the result.\n                return decode(bytes, encoding);\n            }\n        case \"ArrayBuffer\":\n            {\n                // Return a new ArrayBuffer whose contents are bytes.\n                const sequence = combineByteSequences(bytes);\n                return sequence.buffer;\n            }\n        case \"BinaryString\":\n            {\n                // Return bytes as a binary string, in which every byte\n                //  is represented by a code unit of equal value [0..255].\n                let binaryString = \"\";\n                const decoder = new StringDecoder(\"latin1\");\n                for (const chunk of bytes){\n                    binaryString += decoder.write(chunk);\n                }\n                binaryString += decoder.end();\n                return binaryString;\n            }\n    }\n}\n/**\n * @see https://encoding.spec.whatwg.org/#decode\n * @param {Uint8Array[]} ioQueue\n * @param {string} encoding\n */ function decode(ioQueue, encoding) {\n    const bytes = combineByteSequences(ioQueue);\n    // 1. Let BOMEncoding be the result of BOM sniffing ioQueue.\n    const BOMEncoding = BOMSniffing(bytes);\n    let slice = 0;\n    // 2. If BOMEncoding is non-null:\n    if (BOMEncoding !== null) {\n        // 1. Set encoding to BOMEncoding.\n        encoding = BOMEncoding;\n        // 2. Read three bytes from ioQueue, if BOMEncoding is\n        //    UTF-8; otherwise read two bytes.\n        //    (Do nothing with those bytes.)\n        slice = BOMEncoding === \"UTF-8\" ? 3 : 2;\n    }\n    // 3. Process a queue with an instance of encodings\n    //    decoder, ioQueue, output, and \"replacement\".\n    // 4. Return output.\n    const sliced = bytes.slice(slice);\n    return new TextDecoder(encoding).decode(sliced);\n}\n/**\n * @see https://encoding.spec.whatwg.org/#bom-sniff\n * @param {Uint8Array} ioQueue\n */ function BOMSniffing(ioQueue) {\n    // 1. Let BOM be the result of peeking 3 bytes from ioQueue,\n    //    converted to a byte sequence.\n    const [a, b, c] = ioQueue;\n    // 2. For each of the rows in the table below, starting with\n    //    the first one and going down, if BOM starts with the\n    //    bytes given in the first column, then return the\n    //    encoding given in the cell in the second column of that\n    //    row. Otherwise, return null.\n    if (a === 0xEF && b === 0xBB && c === 0xBF) {\n        return \"UTF-8\";\n    } else if (a === 0xFE && b === 0xFF) {\n        return \"UTF-16BE\";\n    } else if (a === 0xFF && b === 0xFE) {\n        return \"UTF-16LE\";\n    }\n    return null;\n}\n/**\n * @param {Uint8Array[]} sequences\n */ function combineByteSequences(sequences) {\n    const size = sequences.reduce((a, b)=>{\n        return a + b.byteLength;\n    }, 0);\n    let offset = 0;\n    return sequences.reduce((a, b)=>{\n        a.set(b, offset);\n        offset += b.byteLength;\n        return a;\n    }, new Uint8Array(size));\n}\nmodule.exports = {\n    staticPropertyDescriptors,\n    readOperation,\n    fireAProgressEvent\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZmlsZWFwaS91dGlsLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTSxFQUNKQSxNQUFNLEVBQ05DLE1BQU0sRUFDTkMsT0FBTyxFQUNQQyxRQUFRLEVBQ1JDLHVCQUFBQSxFQUNELEdBQUdDLG1CQUFPQSxDQUFDO0FBQ1osTUFBTSxFQUFFQyxhQUFBQSxFQUFlLEdBQUdELG1CQUFPQSxDQUFDO0FBQ2xDLE1BQU0sRUFBRUUsV0FBQUEsRUFBYSxHQUFHRixtQkFBT0EsQ0FBQztBQUNoQyxNQUFNLEVBQUVHLGtCQUFrQixFQUFFQyxhQUFBQSxFQUFlLEdBQUdKLG1CQUFPQSxDQUFDO0FBQ3RELE1BQU0sRUFBRUssS0FBQUEsRUFBTyxHQUFHTCxtQkFBT0EsQ0FBQztBQUMxQixNQUFNLEVBQUVNLGFBQUFBLEVBQWUsR0FBR04sbUJBQU9BLENBQUM7QUFDbEMsTUFBTSxFQUFFTyxJQUFBQSxFQUFNLEdBQUdQLG1CQUFPQSxDQUFDO0FBRXpCLGtDQUNBLE1BQU1RLDRCQUE0QjtJQUNoQ0MsWUFBWTtJQUNaQyxVQUFVO0lBQ1ZDLGNBQWM7QUFDaEI7QUFFQTs7Ozs7O0NBTUEsR0FDQSxTQUFTQyxjQUFlQyxFQUFFLEVBQUVDLElBQUksRUFBRUMsSUFBSSxFQUFFQyxZQUFZO0lBQ2xEO0lBQ0E7SUFDQSxJQUFJSCxFQUFFLENBQUNsQixPQUFPLEtBQUssV0FBVztRQUM1QixNQUFNLElBQUlzQixhQUFhLGlCQUFpQjtJQUMxQztJQUVBO0lBQ0FKLEVBQUUsQ0FBQ2xCLE9BQU8sR0FBRztJQUViO0lBQ0FrQixFQUFFLENBQUNoQixRQUFRLEdBQUc7SUFFZDtJQUNBZ0IsRUFBRSxDQUFDakIsT0FBTyxHQUFHO0lBRWI7SUFDQSxtREFDQSxNQUFNc0IsU0FBU0osS0FBS0ksTUFBTTtJQUUxQjtJQUNBLE1BQU1DLFNBQVNELE9BQU9FLFNBQVM7SUFFL0I7SUFDQSw0QkFDQSxNQUFNQyxRQUFRLEVBQUU7SUFFaEI7SUFDQTtJQUNBLElBQUlDLGVBQWVILE9BQU9JLElBQUk7SUFFOUI7SUFDQSxJQUFJQyxlQUFlO0lBT2pCO1FBQ0EsTUFBTyxDQUFDWCxFQUFFLENBQUNmLFNBQVMsQ0FBRTtZQUNwQjtZQUNBLElBQUk7Z0JBQ0YsTUFBTSxFQUFFMkIsSUFBSSxFQUFFQyxLQUFBQSxFQUFPLEdBQUcsTUFBTUo7Z0JBRTlCO2dCQUNBO2dCQUNBO2dCQUNBLElBQUlFLGdCQUFnQixDQUFDWCxFQUFFLENBQUNmLFNBQVMsRUFBRTtvQkFDakM2QixlQUFlO3dCQUNiQyxtQkFBbUIsYUFBYWY7b0JBQ2xDO2dCQUNGO2dCQUVBO2dCQUNBVyxlQUFlO2dCQUVmO2dCQUNBO2dCQUNBO2dCQUNBLElBQUksQ0FBQ0MsUUFBUXBCLE1BQU13QixZQUFZLENBQUNILFFBQVE7b0JBQ3RDO29CQUNBO29CQUVBO29CQUNBTCxNQUFNUyxJQUFJLENBQUNKO29CQUVYO29CQUNBO29CQUNBO29CQUNBLElBQ0UsQ0FDRWIsRUFBRSxDQUFDZCx3QkFBd0IsS0FBS2dDLGFBQ2hDQyxLQUFLQyxHQUFHLEtBQUtwQixFQUFFLENBQUNkLHdCQUF3QixJQUFJLE9BRTlDLENBQUNjLEVBQUUsQ0FBQ2YsU0FBUyxFQUNiO3dCQUNBZSxFQUFFLENBQUNkLHdCQUF3QixHQUFHaUMsS0FBS0MsR0FBRzt3QkFDdENOLGVBQWU7NEJBQ2JDLG1CQUFtQixZQUFZZjt3QkFDakM7b0JBQ0Y7b0JBRUE7b0JBQ0E7b0JBQ0FTLGVBQWVILE9BQU9JLElBQUk7Z0JBQzVCLE9BQU8sSUFBSUUsTUFBTTtvQkFDZjtvQkFDQTtvQkFDQTtvQkFDQUUsZUFBZTt3QkFDYjt3QkFDQWQsRUFBRSxDQUFDbEIsT0FBTyxHQUFHO3dCQUViO3dCQUNBO3dCQUNBLElBQUk7NEJBQ0YsTUFBTXVDLFNBQVNDLFlBQVlkLE9BQU9OLE1BQU1ELEtBQUtDLElBQUksRUFBRUM7NEJBRW5EOzRCQUVBLElBQUlILEVBQUUsQ0FBQ2YsU0FBUyxFQUFFO2dDQUNoQjs0QkFDRjs0QkFFQTs0QkFDQWUsRUFBRSxDQUFDaEIsUUFBUSxHQUFHcUM7NEJBRWQ7NEJBQ0FOLG1CQUFtQixRQUFRZjt3QkFDN0IsRUFBRSxPQUFPdUIsT0FBTzs0QkFDZDs0QkFFQTs0QkFDQXZCLEVBQUUsQ0FBQ2pCLE9BQU8sR0FBR3dDOzRCQUViOzRCQUNBUixtQkFBbUIsU0FBU2Y7d0JBQzlCO3dCQUVBO3dCQUNBO3dCQUNBLElBQUlBLEVBQUUsQ0FBQ2xCLE9BQU8sS0FBSyxXQUFXOzRCQUM1QmlDLG1CQUFtQixXQUFXZjt3QkFDaEM7b0JBQ0Y7b0JBRUE7Z0JBQ0Y7WUFDRixFQUFFLE9BQU91QixPQUFPO2dCQUNkLElBQUl2QixFQUFFLENBQUNmLFNBQVMsRUFBRTtvQkFDaEI7Z0JBQ0Y7Z0JBRUE7Z0JBQ0E7Z0JBQ0E7Z0JBQ0E2QixlQUFlO29CQUNiO29CQUNBZCxFQUFFLENBQUNsQixPQUFPLEdBQUc7b0JBRWI7b0JBQ0FrQixFQUFFLENBQUNqQixPQUFPLEdBQUd3QztvQkFFYjtvQkFDQVIsbUJBQW1CLFNBQVNmO29CQUU1QjtvQkFDQTtvQkFDQSxJQUFJQSxFQUFFLENBQUNsQixPQUFPLEtBQUssV0FBVzt3QkFDNUJpQyxtQkFBbUIsV0FBV2Y7b0JBQ2hDO2dCQUNGO2dCQUVBO1lBQ0Y7UUFDRjtJQUNGO0FBQ0Y7QUFFQTs7Ozs7Q0FLQSxHQUNBLFNBQVNlLG1CQUFvQlMsQ0FBQyxFQUFFbEIsTUFBTTtJQUNwQztJQUNBO0lBQ0EsTUFBTW1CLFFBQVEsSUFBSXJDLGNBQWNvQyxHQUFHO1FBQ2pDRSxTQUFTO1FBQ1RDLFlBQVk7SUFDZDtJQUVBckIsT0FBT3NCLGFBQWEsQ0FBQ0g7QUFDdkI7QUFFQTs7Ozs7O0NBTUEsR0FDQSxTQUFTSCxZQUFhZCxLQUFLLEVBQUVOLElBQUksRUFBRTJCLFFBQVEsRUFBRTFCLFlBQVk7SUFDdkQ7SUFDQTtJQUNBO0lBQ0E7SUFFQSxPQUFRRDtRQUNOLEtBQUs7WUFBVztnQkFDZDtnQkFDQTtnQkFDQTtnQkFDQTtnQkFDQTtnQkFDQTtnQkFDQTtnQkFFQTtnQkFDQTtnQkFDQTtnQkFDQTtnQkFDQTtnQkFDQSxJQUFJNEIsVUFBVTtnQkFFZCxNQUFNQyxTQUFTeEMsY0FBY3NDLFlBQVk7Z0JBRXpDLElBQUlFLFdBQVcsV0FBVztvQkFDeEJELFdBQVd4QyxtQkFBbUJ5QztnQkFDaEM7Z0JBRUFELFdBQVc7Z0JBRVgsTUFBTUUsVUFBVSxJQUFJdkMsY0FBYztnQkFFbEMsS0FBSyxNQUFNd0MsU0FBU3pCLE1BQU87b0JBQ3pCc0IsV0FBV3BDLEtBQUtzQyxRQUFRRSxLQUFLLENBQUNEO2dCQUNoQztnQkFFQUgsV0FBV3BDLEtBQUtzQyxRQUFRRyxHQUFHO2dCQUUzQixPQUFPTDtZQUNUO1FBQ0EsS0FBSztZQUFRO2dCQUNYO2dCQUNBLElBQUlNLFdBQVc7Z0JBRWY7Z0JBQ0E7Z0JBQ0EsSUFBSWpDLGNBQWM7b0JBQ2hCaUMsV0FBVy9DLFlBQVljO2dCQUN6QjtnQkFFQTtnQkFDQSxJQUFJaUMsYUFBYSxhQUFhUCxVQUFVO29CQUN0QztvQkFDQTtvQkFDQSxNQUFNM0IsT0FBT1gsY0FBY3NDO29CQUUzQjtvQkFDQTtvQkFDQSxJQUFJM0IsU0FBUyxXQUFXO3dCQUN0QmtDLFdBQVcvQyxZQUFZYSxLQUFLbUMsVUFBVSxDQUFDQyxHQUFHLENBQUM7b0JBQzdDO2dCQUNGO2dCQUVBO2dCQUNBLElBQUlGLGFBQWEsV0FBVztvQkFDMUJBLFdBQVc7Z0JBQ2I7Z0JBRUE7Z0JBQ0E7Z0JBQ0EsT0FBT0csT0FBTy9CLE9BQU80QjtZQUN2QjtRQUNBLEtBQUs7WUFBZTtnQkFDbEI7Z0JBQ0EsTUFBTUksV0FBV0MscUJBQXFCakM7Z0JBRXRDLE9BQU9nQyxTQUFTRSxNQUFNO1lBQ3hCO1FBQ0EsS0FBSztZQUFnQjtnQkFDbkI7Z0JBQ0E7Z0JBQ0EsSUFBSUMsZUFBZTtnQkFFbkIsTUFBTVgsVUFBVSxJQUFJdkMsY0FBYztnQkFFbEMsS0FBSyxNQUFNd0MsU0FBU3pCLE1BQU87b0JBQ3pCbUMsZ0JBQWdCWCxRQUFRRSxLQUFLLENBQUNEO2dCQUNoQztnQkFFQVUsZ0JBQWdCWCxRQUFRRyxHQUFHO2dCQUUzQixPQUFPUTtZQUNUO0lBQ0Y7QUFDRjtBQUVBOzs7O0NBSUEsR0FDQSxTQUFTSixPQUFRSyxPQUFPLEVBQUVSLFFBQVE7SUFDaEMsTUFBTTVCLFFBQVFpQyxxQkFBcUJHO0lBRW5DO0lBQ0EsTUFBTUMsY0FBY0MsWUFBWXRDO0lBRWhDLElBQUl1QyxRQUFRO0lBRVo7SUFDQSxJQUFJRixnQkFBZ0IsTUFBTTtRQUN4QjtRQUNBVCxXQUFXUztRQUVYO1FBQ0E7UUFDQTtRQUNBRSxRQUFRRixnQkFBZ0IsVUFBVSxJQUFJO0lBQ3hDO0lBRUE7SUFDQTtJQUVBO0lBRUEsTUFBTUcsU0FBU3hDLE1BQU11QyxLQUFLLENBQUNBO0lBQzNCLE9BQU8sSUFBSUUsWUFBWWIsVUFBVUcsTUFBTSxDQUFDUztBQUMxQztBQUVBOzs7Q0FHQSxHQUNBLFNBQVNGLFlBQWFGLE9BQU87SUFDM0I7SUFDQTtJQUNBLE1BQU0sQ0FBQ00sR0FBR0MsR0FBR0MsRUFBRSxHQUFHUjtJQUVsQjtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsSUFBSU0sTUFBTSxRQUFRQyxNQUFNLFFBQVFDLE1BQU0sTUFBTTtRQUMxQyxPQUFPO0lBQ1QsT0FBTyxJQUFJRixNQUFNLFFBQVFDLE1BQU0sTUFBTTtRQUNuQyxPQUFPO0lBQ1QsT0FBTyxJQUFJRCxNQUFNLFFBQVFDLE1BQU0sTUFBTTtRQUNuQyxPQUFPO0lBQ1Q7SUFFQSxPQUFPO0FBQ1Q7QUFFQTs7Q0FFQSxHQUNBLFNBQVNWLHFCQUFzQlksU0FBUztJQUN0QyxNQUFNQyxPQUFPRCxVQUFVRSxNQUFNLENBQUMsQ0FBQ0wsR0FBR0M7UUFDaEMsT0FBT0QsSUFBSUMsRUFBRUssVUFBVTtJQUN6QixHQUFHO0lBRUgsSUFBSUMsU0FBUztJQUViLE9BQU9KLFVBQVVFLE1BQU0sQ0FBQyxDQUFDTCxHQUFHQztRQUMxQkQsRUFBRVEsR0FBRyxDQUFDUCxHQUFHTTtRQUNUQSxVQUFVTixFQUFFSyxVQUFVO1FBQ3RCLE9BQU9OO0lBQ1QsR0FBRyxJQUFJUyxXQUFXTDtBQUNwQjtBQUVBTSxPQUFPQyxPQUFPLEdBQUc7SUFDZmxFO0lBQ0FJO0lBQ0FnQjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbW9ja3VwZmxvdy8uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL3dlYi9maWxlYXBpL3V0aWwuanM/YTIwOCIsIndlYnBhY2s6Ly9tb2NrdXBmbG93Ly4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvd2ViL2ZpbGVhcGkvdXRpbC5qcz9hMjA4KiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3Qge1xuICBrU3RhdGUsXG4gIGtFcnJvcixcbiAga1Jlc3VsdCxcbiAga0Fib3J0ZWQsXG4gIGtMYXN0UHJvZ3Jlc3NFdmVudEZpcmVkXG59ID0gcmVxdWlyZSgnLi9zeW1ib2xzJylcbmNvbnN0IHsgUHJvZ3Jlc3NFdmVudCB9ID0gcmVxdWlyZSgnLi9wcm9ncmVzc2V2ZW50JylcbmNvbnN0IHsgZ2V0RW5jb2RpbmcgfSA9IHJlcXVpcmUoJy4vZW5jb2RpbmcnKVxuY29uc3QgeyBzZXJpYWxpemVBTWltZVR5cGUsIHBhcnNlTUlNRVR5cGUgfSA9IHJlcXVpcmUoJy4uL2ZldGNoL2RhdGEtdXJsJylcbmNvbnN0IHsgdHlwZXMgfSA9IHJlcXVpcmUoJ25vZGU6dXRpbCcpXG5jb25zdCB7IFN0cmluZ0RlY29kZXIgfSA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyJylcbmNvbnN0IHsgYnRvYSB9ID0gcmVxdWlyZSgnbm9kZTpidWZmZXInKVxuXG4vKiogQHR5cGUge1Byb3BlcnR5RGVzY3JpcHRvcn0gKi9cbmNvbnN0IHN0YXRpY1Byb3BlcnR5RGVzY3JpcHRvcnMgPSB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiBmYWxzZSxcbiAgY29uZmlndXJhYmxlOiBmYWxzZVxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL0ZpbGVBUEkvI3JlYWRPcGVyYXRpb25cbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ZpbGVyZWFkZXInKS5GaWxlUmVhZGVyfSBmclxuICogQHBhcmFtIHtpbXBvcnQoJ2J1ZmZlcicpLkJsb2J9IGJsb2JcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gKiBAcGFyYW0ge3N0cmluZz99IGVuY29kaW5nTmFtZVxuICovXG5mdW5jdGlvbiByZWFkT3BlcmF0aW9uIChmciwgYmxvYiwgdHlwZSwgZW5jb2RpbmdOYW1lKSB7XG4gIC8vIDEuIElmIGZy4oCZcyBzdGF0ZSBpcyBcImxvYWRpbmdcIiwgdGhyb3cgYW4gSW52YWxpZFN0YXRlRXJyb3JcbiAgLy8gICAgRE9NRXhjZXB0aW9uLlxuICBpZiAoZnJba1N0YXRlXSA9PT0gJ2xvYWRpbmcnKSB7XG4gICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbignSW52YWxpZCBzdGF0ZScsICdJbnZhbGlkU3RhdGVFcnJvcicpXG4gIH1cblxuICAvLyAyLiBTZXQgZnLigJlzIHN0YXRlIHRvIFwibG9hZGluZ1wiLlxuICBmcltrU3RhdGVdID0gJ2xvYWRpbmcnXG5cbiAgLy8gMy4gU2V0IGZy4oCZcyByZXN1bHQgdG8gbnVsbC5cbiAgZnJba1Jlc3VsdF0gPSBudWxsXG5cbiAgLy8gNC4gU2V0IGZy4oCZcyBlcnJvciB0byBudWxsLlxuICBmcltrRXJyb3JdID0gbnVsbFxuXG4gIC8vIDUuIExldCBzdHJlYW0gYmUgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGdldCBzdHJlYW0gb24gYmxvYi5cbiAgLyoqIEB0eXBlIHtpbXBvcnQoJ3N0cmVhbS93ZWInKS5SZWFkYWJsZVN0cmVhbX0gKi9cbiAgY29uc3Qgc3RyZWFtID0gYmxvYi5zdHJlYW0oKVxuXG4gIC8vIDYuIExldCByZWFkZXIgYmUgdGhlIHJlc3VsdCBvZiBnZXR0aW5nIGEgcmVhZGVyIGZyb20gc3RyZWFtLlxuICBjb25zdCByZWFkZXIgPSBzdHJlYW0uZ2V0UmVhZGVyKClcblxuICAvLyA3LiBMZXQgYnl0ZXMgYmUgYW4gZW1wdHkgYnl0ZSBzZXF1ZW5jZS5cbiAgLyoqIEB0eXBlIHtVaW50OEFycmF5W119ICovXG4gIGNvbnN0IGJ5dGVzID0gW11cblxuICAvLyA4LiBMZXQgY2h1bmtQcm9taXNlIGJlIHRoZSByZXN1bHQgb2YgcmVhZGluZyBhIGNodW5rIGZyb21cbiAgLy8gICAgc3RyZWFtIHdpdGggcmVhZGVyLlxuICBsZXQgY2h1bmtQcm9taXNlID0gcmVhZGVyLnJlYWQoKVxuXG4gIC8vIDkuIExldCBpc0ZpcnN0Q2h1bmsgYmUgdHJ1ZS5cbiAgbGV0IGlzRmlyc3RDaHVuayA9IHRydWVcblxuICAvLyAxMC4gSW4gcGFyYWxsZWwsIHdoaWxlIHRydWU6XG4gIC8vIE5vdGU6IFwiSW4gcGFyYWxsZWxcIiBqdXN0IG1lYW5zIG5vbi1ibG9ja2luZ1xuICAvLyBOb3RlIDI6IHJlYWRPcGVyYXRpb24gaXRzZWxmIGNhbm5vdCBiZSBhc3luYyBhcyBkb3VibGVcbiAgLy8gcmVhZGluZyB0aGUgYm9keSB3b3VsZCB0aGVuIHJlamVjdCB0aGUgcHJvbWlzZSwgaW5zdGVhZFxuICAvLyBvZiB0aHJvd2luZyBhbiBlcnJvci5cbiAgOyhhc3luYyAoKSA9PiB7XG4gICAgd2hpbGUgKCFmcltrQWJvcnRlZF0pIHtcbiAgICAgIC8vIDEuIFdhaXQgZm9yIGNodW5rUHJvbWlzZSB0byBiZSBmdWxmaWxsZWQgb3IgcmVqZWN0ZWQuXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCBjaHVua1Byb21pc2VcblxuICAgICAgICAvLyAyLiBJZiBjaHVua1Byb21pc2UgaXMgZnVsZmlsbGVkLCBhbmQgaXNGaXJzdENodW5rIGlzXG4gICAgICAgIC8vICAgIHRydWUsIHF1ZXVlIGEgdGFzayB0byBmaXJlIGEgcHJvZ3Jlc3MgZXZlbnQgY2FsbGVkXG4gICAgICAgIC8vICAgIGxvYWRzdGFydCBhdCBmci5cbiAgICAgICAgaWYgKGlzRmlyc3RDaHVuayAmJiAhZnJba0Fib3J0ZWRdKSB7XG4gICAgICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgICAgICAgZmlyZUFQcm9ncmVzc0V2ZW50KCdsb2Fkc3RhcnQnLCBmcilcbiAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gMy4gU2V0IGlzRmlyc3RDaHVuayB0byBmYWxzZS5cbiAgICAgICAgaXNGaXJzdENodW5rID0gZmFsc2VcblxuICAgICAgICAvLyA0LiBJZiBjaHVua1Byb21pc2UgaXMgZnVsZmlsbGVkIHdpdGggYW4gb2JqZWN0IHdob3NlXG4gICAgICAgIC8vICAgIGRvbmUgcHJvcGVydHkgaXMgZmFsc2UgYW5kIHdob3NlIHZhbHVlIHByb3BlcnR5IGlzXG4gICAgICAgIC8vICAgIGEgVWludDhBcnJheSBvYmplY3QsIHJ1biB0aGVzZSBzdGVwczpcbiAgICAgICAgaWYgKCFkb25lICYmIHR5cGVzLmlzVWludDhBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAvLyAxLiBMZXQgYnMgYmUgdGhlIGJ5dGUgc2VxdWVuY2UgcmVwcmVzZW50ZWQgYnkgdGhlXG4gICAgICAgICAgLy8gICAgVWludDhBcnJheSBvYmplY3QuXG5cbiAgICAgICAgICAvLyAyLiBBcHBlbmQgYnMgdG8gYnl0ZXMuXG4gICAgICAgICAgYnl0ZXMucHVzaCh2YWx1ZSlcblxuICAgICAgICAgIC8vIDMuIElmIHJvdWdobHkgNTBtcyBoYXZlIHBhc3NlZCBzaW5jZSB0aGVzZSBzdGVwc1xuICAgICAgICAgIC8vICAgIHdlcmUgbGFzdCBpbnZva2VkLCBxdWV1ZSBhIHRhc2sgdG8gZmlyZSBhXG4gICAgICAgICAgLy8gICAgcHJvZ3Jlc3MgZXZlbnQgY2FsbGVkIHByb2dyZXNzIGF0IGZyLlxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIChcbiAgICAgICAgICAgICAgZnJba0xhc3RQcm9ncmVzc0V2ZW50RmlyZWRdID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICAgRGF0ZS5ub3coKSAtIGZyW2tMYXN0UHJvZ3Jlc3NFdmVudEZpcmVkXSA+PSA1MFxuICAgICAgICAgICAgKSAmJlxuICAgICAgICAgICAgIWZyW2tBYm9ydGVkXVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgZnJba0xhc3RQcm9ncmVzc0V2ZW50RmlyZWRdID0gRGF0ZS5ub3coKVxuICAgICAgICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgICAgICAgICBmaXJlQVByb2dyZXNzRXZlbnQoJ3Byb2dyZXNzJywgZnIpXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIDQuIFNldCBjaHVua1Byb21pc2UgdG8gdGhlIHJlc3VsdCBvZiByZWFkaW5nIGFcbiAgICAgICAgICAvLyAgICBjaHVuayBmcm9tIHN0cmVhbSB3aXRoIHJlYWRlci5cbiAgICAgICAgICBjaHVua1Byb21pc2UgPSByZWFkZXIucmVhZCgpXG4gICAgICAgIH0gZWxzZSBpZiAoZG9uZSkge1xuICAgICAgICAgIC8vIDUuIE90aGVyd2lzZSwgaWYgY2h1bmtQcm9taXNlIGlzIGZ1bGZpbGxlZCB3aXRoIGFuXG4gICAgICAgICAgLy8gICAgb2JqZWN0IHdob3NlIGRvbmUgcHJvcGVydHkgaXMgdHJ1ZSwgcXVldWUgYSB0YXNrXG4gICAgICAgICAgLy8gICAgdG8gcnVuIHRoZSBmb2xsb3dpbmcgc3RlcHMgYW5kIGFib3J0IHRoaXMgYWxnb3JpdGhtOlxuICAgICAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgICAgICAgIC8vIDEuIFNldCBmcuKAmXMgc3RhdGUgdG8gXCJkb25lXCIuXG4gICAgICAgICAgICBmcltrU3RhdGVdID0gJ2RvbmUnXG5cbiAgICAgICAgICAgIC8vIDIuIExldCByZXN1bHQgYmUgdGhlIHJlc3VsdCBvZiBwYWNrYWdlIGRhdGEgZ2l2ZW5cbiAgICAgICAgICAgIC8vICAgIGJ5dGVzLCB0eXBlLCBibG9i4oCZcyB0eXBlLCBhbmQgZW5jb2RpbmdOYW1lLlxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gcGFja2FnZURhdGEoYnl0ZXMsIHR5cGUsIGJsb2IudHlwZSwgZW5jb2RpbmdOYW1lKVxuXG4gICAgICAgICAgICAgIC8vIDQuIEVsc2U6XG5cbiAgICAgICAgICAgICAgaWYgKGZyW2tBYm9ydGVkXSkge1xuICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gMS4gU2V0IGZy4oCZcyByZXN1bHQgdG8gcmVzdWx0LlxuICAgICAgICAgICAgICBmcltrUmVzdWx0XSA9IHJlc3VsdFxuXG4gICAgICAgICAgICAgIC8vIDIuIEZpcmUgYSBwcm9ncmVzcyBldmVudCBjYWxsZWQgbG9hZCBhdCB0aGUgZnIuXG4gICAgICAgICAgICAgIGZpcmVBUHJvZ3Jlc3NFdmVudCgnbG9hZCcsIGZyKVxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgLy8gMy4gSWYgcGFja2FnZSBkYXRhIHRocmV3IGFuIGV4Y2VwdGlvbiBlcnJvcjpcblxuICAgICAgICAgICAgICAvLyAxLiBTZXQgZnLigJlzIGVycm9yIHRvIGVycm9yLlxuICAgICAgICAgICAgICBmcltrRXJyb3JdID0gZXJyb3JcblxuICAgICAgICAgICAgICAvLyAyLiBGaXJlIGEgcHJvZ3Jlc3MgZXZlbnQgY2FsbGVkIGVycm9yIGF0IGZyLlxuICAgICAgICAgICAgICBmaXJlQVByb2dyZXNzRXZlbnQoJ2Vycm9yJywgZnIpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIDUuIElmIGZy4oCZcyBzdGF0ZSBpcyBub3QgXCJsb2FkaW5nXCIsIGZpcmUgYSBwcm9ncmVzc1xuICAgICAgICAgICAgLy8gICAgZXZlbnQgY2FsbGVkIGxvYWRlbmQgYXQgdGhlIGZyLlxuICAgICAgICAgICAgaWYgKGZyW2tTdGF0ZV0gIT09ICdsb2FkaW5nJykge1xuICAgICAgICAgICAgICBmaXJlQVByb2dyZXNzRXZlbnQoJ2xvYWRlbmQnLCBmcilcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKGZyW2tBYm9ydGVkXSkge1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gNi4gT3RoZXJ3aXNlLCBpZiBjaHVua1Byb21pc2UgaXMgcmVqZWN0ZWQgd2l0aCBhblxuICAgICAgICAvLyAgICBlcnJvciBlcnJvciwgcXVldWUgYSB0YXNrIHRvIHJ1biB0aGUgZm9sbG93aW5nXG4gICAgICAgIC8vICAgIHN0ZXBzIGFuZCBhYm9ydCB0aGlzIGFsZ29yaXRobTpcbiAgICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgICAgIC8vIDEuIFNldCBmcuKAmXMgc3RhdGUgdG8gXCJkb25lXCIuXG4gICAgICAgICAgZnJba1N0YXRlXSA9ICdkb25lJ1xuXG4gICAgICAgICAgLy8gMi4gU2V0IGZy4oCZcyBlcnJvciB0byBlcnJvci5cbiAgICAgICAgICBmcltrRXJyb3JdID0gZXJyb3JcblxuICAgICAgICAgIC8vIDMuIEZpcmUgYSBwcm9ncmVzcyBldmVudCBjYWxsZWQgZXJyb3IgYXQgZnIuXG4gICAgICAgICAgZmlyZUFQcm9ncmVzc0V2ZW50KCdlcnJvcicsIGZyKVxuXG4gICAgICAgICAgLy8gNC4gSWYgZnLigJlzIHN0YXRlIGlzIG5vdCBcImxvYWRpbmdcIiwgZmlyZSBhIHByb2dyZXNzXG4gICAgICAgICAgLy8gICAgZXZlbnQgY2FsbGVkIGxvYWRlbmQgYXQgZnIuXG4gICAgICAgICAgaWYgKGZyW2tTdGF0ZV0gIT09ICdsb2FkaW5nJykge1xuICAgICAgICAgICAgZmlyZUFQcm9ncmVzc0V2ZW50KCdsb2FkZW5kJywgZnIpXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICB9KSgpXG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL3czYy5naXRodWIuaW8vRmlsZUFQSS8jZmlyZS1hLXByb2dyZXNzLWV2ZW50XG4gKiBAc2VlIGh0dHBzOi8vZG9tLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1ldmVudC1maXJlXG4gKiBAcGFyYW0ge3N0cmluZ30gZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnRcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ZpbGVyZWFkZXInKS5GaWxlUmVhZGVyfSByZWFkZXJcbiAqL1xuZnVuY3Rpb24gZmlyZUFQcm9ncmVzc0V2ZW50IChlLCByZWFkZXIpIHtcbiAgLy8gVGhlIHByb2dyZXNzIGV2ZW50IGUgZG9lcyBub3QgYnViYmxlLiBlLmJ1YmJsZXMgbXVzdCBiZSBmYWxzZVxuICAvLyBUaGUgcHJvZ3Jlc3MgZXZlbnQgZSBpcyBOT1QgY2FuY2VsYWJsZS4gZS5jYW5jZWxhYmxlIG11c3QgYmUgZmFsc2VcbiAgY29uc3QgZXZlbnQgPSBuZXcgUHJvZ3Jlc3NFdmVudChlLCB7XG4gICAgYnViYmxlczogZmFsc2UsXG4gICAgY2FuY2VsYWJsZTogZmFsc2VcbiAgfSlcblxuICByZWFkZXIuZGlzcGF0Y2hFdmVudChldmVudClcbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby9GaWxlQVBJLyNibG9iLXBhY2thZ2UtZGF0YVxuICogQHBhcmFtIHtVaW50OEFycmF5W119IGJ5dGVzXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICogQHBhcmFtIHtzdHJpbmc/fSBtaW1lVHlwZVxuICogQHBhcmFtIHtzdHJpbmc/fSBlbmNvZGluZ05hbWVcbiAqL1xuZnVuY3Rpb24gcGFja2FnZURhdGEgKGJ5dGVzLCB0eXBlLCBtaW1lVHlwZSwgZW5jb2RpbmdOYW1lKSB7XG4gIC8vIDEuIEEgQmxvYiBoYXMgYW4gYXNzb2NpYXRlZCBwYWNrYWdlIGRhdGEgYWxnb3JpdGhtLCBnaXZlblxuICAvLyAgICBieXRlcywgYSB0eXBlLCBhIG9wdGlvbmFsIG1pbWVUeXBlLCBhbmQgYSBvcHRpb25hbFxuICAvLyAgICBlbmNvZGluZ05hbWUsIHdoaWNoIHN3aXRjaGVzIG9uIHR5cGUgYW5kIHJ1bnMgdGhlXG4gIC8vICAgIGFzc29jaWF0ZWQgc3RlcHM6XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnRGF0YVVSTCc6IHtcbiAgICAgIC8vIDEuIFJldHVybiBieXRlcyBhcyBhIERhdGFVUkwgW1JGQzIzOTddIHN1YmplY3QgdG9cbiAgICAgIC8vICAgIHRoZSBjb25zaWRlcmF0aW9ucyBiZWxvdzpcbiAgICAgIC8vICAqIFVzZSBtaW1lVHlwZSBhcyBwYXJ0IG9mIHRoZSBEYXRhIFVSTCBpZiBpdCBpc1xuICAgICAgLy8gICAgYXZhaWxhYmxlIGluIGtlZXBpbmcgd2l0aCB0aGUgRGF0YSBVUkxcbiAgICAgIC8vICAgIHNwZWNpZmljYXRpb24gW1JGQzIzOTddLlxuICAgICAgLy8gICogSWYgbWltZVR5cGUgaXMgbm90IGF2YWlsYWJsZSByZXR1cm4gYSBEYXRhIFVSTFxuICAgICAgLy8gICAgd2l0aG91dCBhIG1lZGlhLXR5cGUuIFtSRkMyMzk3XS5cblxuICAgICAgLy8gaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9yZmMyMzk3I3NlY3Rpb24tM1xuICAgICAgLy8gZGF0YXVybCAgICA6PSBcImRhdGE6XCIgWyBtZWRpYXR5cGUgXSBbIFwiO2Jhc2U2NFwiIF0gXCIsXCIgZGF0YVxuICAgICAgLy8gbWVkaWF0eXBlICA6PSBbIHR5cGUgXCIvXCIgc3VidHlwZSBdICooIFwiO1wiIHBhcmFtZXRlciApXG4gICAgICAvLyBkYXRhICAgICAgIDo9ICp1cmxjaGFyXG4gICAgICAvLyBwYXJhbWV0ZXIgIDo9IGF0dHJpYnV0ZSBcIj1cIiB2YWx1ZVxuICAgICAgbGV0IGRhdGFVUkwgPSAnZGF0YTonXG5cbiAgICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlTUlNRVR5cGUobWltZVR5cGUgfHwgJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbScpXG5cbiAgICAgIGlmIChwYXJzZWQgIT09ICdmYWlsdXJlJykge1xuICAgICAgICBkYXRhVVJMICs9IHNlcmlhbGl6ZUFNaW1lVHlwZShwYXJzZWQpXG4gICAgICB9XG5cbiAgICAgIGRhdGFVUkwgKz0gJztiYXNlNjQsJ1xuXG4gICAgICBjb25zdCBkZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIoJ2xhdGluMScpXG5cbiAgICAgIGZvciAoY29uc3QgY2h1bmsgb2YgYnl0ZXMpIHtcbiAgICAgICAgZGF0YVVSTCArPSBidG9hKGRlY29kZXIud3JpdGUoY2h1bmspKVxuICAgICAgfVxuXG4gICAgICBkYXRhVVJMICs9IGJ0b2EoZGVjb2Rlci5lbmQoKSlcblxuICAgICAgcmV0dXJuIGRhdGFVUkxcbiAgICB9XG4gICAgY2FzZSAnVGV4dCc6IHtcbiAgICAgIC8vIDEuIExldCBlbmNvZGluZyBiZSBmYWlsdXJlXG4gICAgICBsZXQgZW5jb2RpbmcgPSAnZmFpbHVyZSdcblxuICAgICAgLy8gMi4gSWYgdGhlIGVuY29kaW5nTmFtZSBpcyBwcmVzZW50LCBzZXQgZW5jb2RpbmcgdG8gdGhlXG4gICAgICAvLyAgICByZXN1bHQgb2YgZ2V0dGluZyBhbiBlbmNvZGluZyBmcm9tIGVuY29kaW5nTmFtZS5cbiAgICAgIGlmIChlbmNvZGluZ05hbWUpIHtcbiAgICAgICAgZW5jb2RpbmcgPSBnZXRFbmNvZGluZyhlbmNvZGluZ05hbWUpXG4gICAgICB9XG5cbiAgICAgIC8vIDMuIElmIGVuY29kaW5nIGlzIGZhaWx1cmUsIGFuZCBtaW1lVHlwZSBpcyBwcmVzZW50OlxuICAgICAgaWYgKGVuY29kaW5nID09PSAnZmFpbHVyZScgJiYgbWltZVR5cGUpIHtcbiAgICAgICAgLy8gMS4gTGV0IHR5cGUgYmUgdGhlIHJlc3VsdCBvZiBwYXJzZSBhIE1JTUUgdHlwZVxuICAgICAgICAvLyAgICBnaXZlbiBtaW1lVHlwZS5cbiAgICAgICAgY29uc3QgdHlwZSA9IHBhcnNlTUlNRVR5cGUobWltZVR5cGUpXG5cbiAgICAgICAgLy8gMi4gSWYgdHlwZSBpcyBub3QgZmFpbHVyZSwgc2V0IGVuY29kaW5nIHRvIHRoZSByZXN1bHRcbiAgICAgICAgLy8gICAgb2YgZ2V0dGluZyBhbiBlbmNvZGluZyBmcm9tIHR5cGXigJlzIHBhcmFtZXRlcnNbXCJjaGFyc2V0XCJdLlxuICAgICAgICBpZiAodHlwZSAhPT0gJ2ZhaWx1cmUnKSB7XG4gICAgICAgICAgZW5jb2RpbmcgPSBnZXRFbmNvZGluZyh0eXBlLnBhcmFtZXRlcnMuZ2V0KCdjaGFyc2V0JykpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gNC4gSWYgZW5jb2RpbmcgaXMgZmFpbHVyZSwgdGhlbiBzZXQgZW5jb2RpbmcgdG8gVVRGLTguXG4gICAgICBpZiAoZW5jb2RpbmcgPT09ICdmYWlsdXJlJykge1xuICAgICAgICBlbmNvZGluZyA9ICdVVEYtOCdcbiAgICAgIH1cblxuICAgICAgLy8gNS4gRGVjb2RlIGJ5dGVzIHVzaW5nIGZhbGxiYWNrIGVuY29kaW5nIGVuY29kaW5nLCBhbmRcbiAgICAgIC8vICAgIHJldHVybiB0aGUgcmVzdWx0LlxuICAgICAgcmV0dXJuIGRlY29kZShieXRlcywgZW5jb2RpbmcpXG4gICAgfVxuICAgIGNhc2UgJ0FycmF5QnVmZmVyJzoge1xuICAgICAgLy8gUmV0dXJuIGEgbmV3IEFycmF5QnVmZmVyIHdob3NlIGNvbnRlbnRzIGFyZSBieXRlcy5cbiAgICAgIGNvbnN0IHNlcXVlbmNlID0gY29tYmluZUJ5dGVTZXF1ZW5jZXMoYnl0ZXMpXG5cbiAgICAgIHJldHVybiBzZXF1ZW5jZS5idWZmZXJcbiAgICB9XG4gICAgY2FzZSAnQmluYXJ5U3RyaW5nJzoge1xuICAgICAgLy8gUmV0dXJuIGJ5dGVzIGFzIGEgYmluYXJ5IHN0cmluZywgaW4gd2hpY2ggZXZlcnkgYnl0ZVxuICAgICAgLy8gIGlzIHJlcHJlc2VudGVkIGJ5IGEgY29kZSB1bml0IG9mIGVxdWFsIHZhbHVlIFswLi4yNTVdLlxuICAgICAgbGV0IGJpbmFyeVN0cmluZyA9ICcnXG5cbiAgICAgIGNvbnN0IGRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcignbGF0aW4xJylcblxuICAgICAgZm9yIChjb25zdCBjaHVuayBvZiBieXRlcykge1xuICAgICAgICBiaW5hcnlTdHJpbmcgKz0gZGVjb2Rlci53cml0ZShjaHVuaylcbiAgICAgIH1cblxuICAgICAgYmluYXJ5U3RyaW5nICs9IGRlY29kZXIuZW5kKClcblxuICAgICAgcmV0dXJuIGJpbmFyeVN0cmluZ1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9lbmNvZGluZy5zcGVjLndoYXR3Zy5vcmcvI2RlY29kZVxuICogQHBhcmFtIHtVaW50OEFycmF5W119IGlvUXVldWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBlbmNvZGluZ1xuICovXG5mdW5jdGlvbiBkZWNvZGUgKGlvUXVldWUsIGVuY29kaW5nKSB7XG4gIGNvbnN0IGJ5dGVzID0gY29tYmluZUJ5dGVTZXF1ZW5jZXMoaW9RdWV1ZSlcblxuICAvLyAxLiBMZXQgQk9NRW5jb2RpbmcgYmUgdGhlIHJlc3VsdCBvZiBCT00gc25pZmZpbmcgaW9RdWV1ZS5cbiAgY29uc3QgQk9NRW5jb2RpbmcgPSBCT01TbmlmZmluZyhieXRlcylcblxuICBsZXQgc2xpY2UgPSAwXG5cbiAgLy8gMi4gSWYgQk9NRW5jb2RpbmcgaXMgbm9uLW51bGw6XG4gIGlmIChCT01FbmNvZGluZyAhPT0gbnVsbCkge1xuICAgIC8vIDEuIFNldCBlbmNvZGluZyB0byBCT01FbmNvZGluZy5cbiAgICBlbmNvZGluZyA9IEJPTUVuY29kaW5nXG5cbiAgICAvLyAyLiBSZWFkIHRocmVlIGJ5dGVzIGZyb20gaW9RdWV1ZSwgaWYgQk9NRW5jb2RpbmcgaXNcbiAgICAvLyAgICBVVEYtODsgb3RoZXJ3aXNlIHJlYWQgdHdvIGJ5dGVzLlxuICAgIC8vICAgIChEbyBub3RoaW5nIHdpdGggdGhvc2UgYnl0ZXMuKVxuICAgIHNsaWNlID0gQk9NRW5jb2RpbmcgPT09ICdVVEYtOCcgPyAzIDogMlxuICB9XG5cbiAgLy8gMy4gUHJvY2VzcyBhIHF1ZXVlIHdpdGggYW4gaW5zdGFuY2Ugb2YgZW5jb2RpbmfigJlzXG4gIC8vICAgIGRlY29kZXIsIGlvUXVldWUsIG91dHB1dCwgYW5kIFwicmVwbGFjZW1lbnRcIi5cblxuICAvLyA0LiBSZXR1cm4gb3V0cHV0LlxuXG4gIGNvbnN0IHNsaWNlZCA9IGJ5dGVzLnNsaWNlKHNsaWNlKVxuICByZXR1cm4gbmV3IFRleHREZWNvZGVyKGVuY29kaW5nKS5kZWNvZGUoc2xpY2VkKVxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9lbmNvZGluZy5zcGVjLndoYXR3Zy5vcmcvI2JvbS1zbmlmZlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBpb1F1ZXVlXG4gKi9cbmZ1bmN0aW9uIEJPTVNuaWZmaW5nIChpb1F1ZXVlKSB7XG4gIC8vIDEuIExldCBCT00gYmUgdGhlIHJlc3VsdCBvZiBwZWVraW5nIDMgYnl0ZXMgZnJvbSBpb1F1ZXVlLFxuICAvLyAgICBjb252ZXJ0ZWQgdG8gYSBieXRlIHNlcXVlbmNlLlxuICBjb25zdCBbYSwgYiwgY10gPSBpb1F1ZXVlXG5cbiAgLy8gMi4gRm9yIGVhY2ggb2YgdGhlIHJvd3MgaW4gdGhlIHRhYmxlIGJlbG93LCBzdGFydGluZyB3aXRoXG4gIC8vICAgIHRoZSBmaXJzdCBvbmUgYW5kIGdvaW5nIGRvd24sIGlmIEJPTSBzdGFydHMgd2l0aCB0aGVcbiAgLy8gICAgYnl0ZXMgZ2l2ZW4gaW4gdGhlIGZpcnN0IGNvbHVtbiwgdGhlbiByZXR1cm4gdGhlXG4gIC8vICAgIGVuY29kaW5nIGdpdmVuIGluIHRoZSBjZWxsIGluIHRoZSBzZWNvbmQgY29sdW1uIG9mIHRoYXRcbiAgLy8gICAgcm93LiBPdGhlcndpc2UsIHJldHVybiBudWxsLlxuICBpZiAoYSA9PT0gMHhFRiAmJiBiID09PSAweEJCICYmIGMgPT09IDB4QkYpIHtcbiAgICByZXR1cm4gJ1VURi04J1xuICB9IGVsc2UgaWYgKGEgPT09IDB4RkUgJiYgYiA9PT0gMHhGRikge1xuICAgIHJldHVybiAnVVRGLTE2QkUnXG4gIH0gZWxzZSBpZiAoYSA9PT0gMHhGRiAmJiBiID09PSAweEZFKSB7XG4gICAgcmV0dXJuICdVVEYtMTZMRSdcbiAgfVxuXG4gIHJldHVybiBudWxsXG59XG5cbi8qKlxuICogQHBhcmFtIHtVaW50OEFycmF5W119IHNlcXVlbmNlc1xuICovXG5mdW5jdGlvbiBjb21iaW5lQnl0ZVNlcXVlbmNlcyAoc2VxdWVuY2VzKSB7XG4gIGNvbnN0IHNpemUgPSBzZXF1ZW5jZXMucmVkdWNlKChhLCBiKSA9PiB7XG4gICAgcmV0dXJuIGEgKyBiLmJ5dGVMZW5ndGhcbiAgfSwgMClcblxuICBsZXQgb2Zmc2V0ID0gMFxuXG4gIHJldHVybiBzZXF1ZW5jZXMucmVkdWNlKChhLCBiKSA9PiB7XG4gICAgYS5zZXQoYiwgb2Zmc2V0KVxuICAgIG9mZnNldCArPSBiLmJ5dGVMZW5ndGhcbiAgICByZXR1cm4gYVxuICB9LCBuZXcgVWludDhBcnJheShzaXplKSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHN0YXRpY1Byb3BlcnR5RGVzY3JpcHRvcnMsXG4gIHJlYWRPcGVyYXRpb24sXG4gIGZpcmVBUHJvZ3Jlc3NFdmVudFxufVxuIl0sIm5hbWVzIjpbImtTdGF0ZSIsImtFcnJvciIsImtSZXN1bHQiLCJrQWJvcnRlZCIsImtMYXN0UHJvZ3Jlc3NFdmVudEZpcmVkIiwicmVxdWlyZSIsIlByb2dyZXNzRXZlbnQiLCJnZXRFbmNvZGluZyIsInNlcmlhbGl6ZUFNaW1lVHlwZSIsInBhcnNlTUlNRVR5cGUiLCJ0eXBlcyIsIlN0cmluZ0RlY29kZXIiLCJidG9hIiwic3RhdGljUHJvcGVydHlEZXNjcmlwdG9ycyIsImVudW1lcmFibGUiLCJ3cml0YWJsZSIsImNvbmZpZ3VyYWJsZSIsInJlYWRPcGVyYXRpb24iLCJmciIsImJsb2IiLCJ0eXBlIiwiZW5jb2RpbmdOYW1lIiwiRE9NRXhjZXB0aW9uIiwic3RyZWFtIiwicmVhZGVyIiwiZ2V0UmVhZGVyIiwiYnl0ZXMiLCJjaHVua1Byb21pc2UiLCJyZWFkIiwiaXNGaXJzdENodW5rIiwiZG9uZSIsInZhbHVlIiwicXVldWVNaWNyb3Rhc2siLCJmaXJlQVByb2dyZXNzRXZlbnQiLCJpc1VpbnQ4QXJyYXkiLCJwdXNoIiwidW5kZWZpbmVkIiwiRGF0ZSIsIm5vdyIsInJlc3VsdCIsInBhY2thZ2VEYXRhIiwiZXJyb3IiLCJlIiwiZXZlbnQiLCJidWJibGVzIiwiY2FuY2VsYWJsZSIsImRpc3BhdGNoRXZlbnQiLCJtaW1lVHlwZSIsImRhdGFVUkwiLCJwYXJzZWQiLCJkZWNvZGVyIiwiY2h1bmsiLCJ3cml0ZSIsImVuZCIsImVuY29kaW5nIiwicGFyYW1ldGVycyIsImdldCIsImRlY29kZSIsInNlcXVlbmNlIiwiY29tYmluZUJ5dGVTZXF1ZW5jZXMiLCJidWZmZXIiLCJiaW5hcnlTdHJpbmciLCJpb1F1ZXVlIiwiQk9NRW5jb2RpbmciLCJCT01TbmlmZmluZyIsInNsaWNlIiwic2xpY2VkIiwiVGV4dERlY29kZXIiLCJhIiwiYiIsImMiLCJzZXF1ZW5jZXMiLCJzaXplIiwicmVkdWNlIiwiYnl0ZUxlbmd0aCIsIm9mZnNldCIsInNldCIsIlVpbnQ4QXJyYXkiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/fileapi/util.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/websocket/connection.js":
/*!*************************************************************!*\
  !*** ./node_modules/undici/lib/web/websocket/connection.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { uid, states, sentCloseFrameState, emptyBuffer, opcodes } = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/undici/lib/web/websocket/constants.js\");\nconst { kReadyState, kSentClose, kByteParser, kReceivedClose, kResponse } = __webpack_require__(/*! ./symbols */ \"(ssr)/./node_modules/undici/lib/web/websocket/symbols.js\");\nconst { fireEvent, failWebsocketConnection, isClosing, isClosed, isEstablished, parseExtensions } = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/undici/lib/web/websocket/util.js\");\nconst { channels } = __webpack_require__(/*! ../../core/diagnostics */ \"(ssr)/./node_modules/undici/lib/core/diagnostics.js\");\nconst { CloseEvent } = __webpack_require__(/*! ./events */ \"(ssr)/./node_modules/undici/lib/web/websocket/events.js\");\nconst { makeRequest } = __webpack_require__(/*! ../fetch/request */ \"(ssr)/./node_modules/undici/lib/web/fetch/request.js\");\nconst { fetching } = __webpack_require__(/*! ../fetch/index */ \"(ssr)/./node_modules/undici/lib/web/fetch/index.js\");\nconst { Headers, getHeadersList } = __webpack_require__(/*! ../fetch/headers */ \"(ssr)/./node_modules/undici/lib/web/fetch/headers.js\");\nconst { getDecodeSplit } = __webpack_require__(/*! ../fetch/util */ \"(ssr)/./node_modules/undici/lib/web/fetch/util.js\");\nconst { WebsocketFrameSend } = __webpack_require__(/*! ./frame */ \"(ssr)/./node_modules/undici/lib/web/websocket/frame.js\");\n/** @type {import('crypto')} */ let crypto;\ntry {\n    crypto = __webpack_require__(/*! node:crypto */ \"node:crypto\");\n/* c8 ignore next 3 */ } catch  {}\n/**\n * @see https://websockets.spec.whatwg.org/#concept-websocket-establish\n * @param {URL} url\n * @param {string|string[]} protocols\n * @param {import('./websocket').WebSocket} ws\n * @param {(response: any, extensions: string[] | undefined) => void} onEstablish\n * @param {Partial<import('../../types/websocket').WebSocketInit>} options\n */ function establishWebSocketConnection(url, protocols, client, ws, onEstablish, options) {\n    // 1. Let requestURL be a copy of url, with its scheme set to \"http\", if urls\n    //    scheme is \"ws\", and to \"https\" otherwise.\n    const requestURL = url;\n    requestURL.protocol = url.protocol === \"ws:\" ? \"http:\" : \"https:\";\n    // 2. Let request be a new request, whose URL is requestURL, client is client,\n    //    service-workers mode is \"none\", referrer is \"no-referrer\", mode is\n    //    \"websocket\", credentials mode is \"include\", cache mode is \"no-store\" ,\n    //    and redirect mode is \"error\".\n    const request = makeRequest({\n        urlList: [\n            requestURL\n        ],\n        client,\n        serviceWorkers: \"none\",\n        referrer: \"no-referrer\",\n        mode: \"websocket\",\n        credentials: \"include\",\n        cache: \"no-store\",\n        redirect: \"error\"\n    });\n    // Note: undici extension, allow setting custom headers.\n    if (options.headers) {\n        const headersList = getHeadersList(new Headers(options.headers));\n        request.headersList = headersList;\n    }\n    // 3. Append (`Upgrade`, `websocket`) to requests header list.\n    // 4. Append (`Connection`, `Upgrade`) to requests header list.\n    // Note: both of these are handled by undici currently.\n    // https://github.com/nodejs/undici/blob/68c269c4144c446f3f1220951338daef4a6b5ec4/lib/client.js#L1397\n    // 5. Let keyValue be a nonce consisting of a randomly selected\n    //    16-byte value that has been forgiving-base64-encoded and\n    //    isomorphic encoded.\n    const keyValue = crypto.randomBytes(16).toString(\"base64\");\n    // 6. Append (`Sec-WebSocket-Key`, keyValue) to requests\n    //    header list.\n    request.headersList.append(\"sec-websocket-key\", keyValue);\n    // 7. Append (`Sec-WebSocket-Version`, `13`) to requests\n    //    header list.\n    request.headersList.append(\"sec-websocket-version\", \"13\");\n    // 8. For each protocol in protocols, combine\n    //    (`Sec-WebSocket-Protocol`, protocol) in requests header\n    //    list.\n    for (const protocol of protocols){\n        request.headersList.append(\"sec-websocket-protocol\", protocol);\n    }\n    // 9. Let permessageDeflate be a user-agent defined\n    //    \"permessage-deflate\" extension header value.\n    // https://github.com/mozilla/gecko-dev/blob/ce78234f5e653a5d3916813ff990f053510227bc/netwerk/protocol/websocket/WebSocketChannel.cpp#L2673\n    const permessageDeflate = \"permessage-deflate; client_max_window_bits\";\n    // 10. Append (`Sec-WebSocket-Extensions`, permessageDeflate) to\n    //     requests header list.\n    request.headersList.append(\"sec-websocket-extensions\", permessageDeflate);\n    // 11. Fetch request with useParallelQueue set to true, and\n    //     processResponse given response being these steps:\n    const controller = fetching({\n        request,\n        useParallelQueue: true,\n        dispatcher: options.dispatcher,\n        processResponse (response) {\n            // 1. If response is a network error or its status is not 101,\n            //    fail the WebSocket connection.\n            if (response.type === \"error\" || response.status !== 101) {\n                failWebsocketConnection(ws, \"Received network error or non-101 status code.\");\n                return;\n            }\n            // 2. If protocols is not the empty list and extracting header\n            //    list values given `Sec-WebSocket-Protocol` and responses\n            //    header list results in null, failure, or the empty byte\n            //    sequence, then fail the WebSocket connection.\n            if (protocols.length !== 0 && !response.headersList.get(\"Sec-WebSocket-Protocol\")) {\n                failWebsocketConnection(ws, \"Server did not respond with sent protocols.\");\n                return;\n            }\n            // 3. Follow the requirements stated step 2 to step 6, inclusive,\n            //    of the last set of steps in section 4.1 of The WebSocket\n            //    Protocol to validate response. This either results in fail\n            //    the WebSocket connection or the WebSocket connection is\n            //    established.\n            // 2. If the response lacks an |Upgrade| header field or the |Upgrade|\n            //    header field contains a value that is not an ASCII case-\n            //    insensitive match for the value \"websocket\", the client MUST\n            //    _Fail the WebSocket Connection_.\n            if (response.headersList.get(\"Upgrade\")?.toLowerCase() !== \"websocket\") {\n                failWebsocketConnection(ws, 'Server did not set Upgrade header to \"websocket\".');\n                return;\n            }\n            // 3. If the response lacks a |Connection| header field or the\n            //    |Connection| header field doesn't contain a token that is an\n            //    ASCII case-insensitive match for the value \"Upgrade\", the client\n            //    MUST _Fail the WebSocket Connection_.\n            if (response.headersList.get(\"Connection\")?.toLowerCase() !== \"upgrade\") {\n                failWebsocketConnection(ws, 'Server did not set Connection header to \"upgrade\".');\n                return;\n            }\n            // 4. If the response lacks a |Sec-WebSocket-Accept| header field or\n            //    the |Sec-WebSocket-Accept| contains a value other than the\n            //    base64-encoded SHA-1 of the concatenation of the |Sec-WebSocket-\n            //    Key| (as a string, not base64-decoded) with the string \"258EAFA5-\n            //    E914-47DA-95CA-C5AB0DC85B11\" but ignoring any leading and\n            //    trailing whitespace, the client MUST _Fail the WebSocket\n            //    Connection_.\n            const secWSAccept = response.headersList.get(\"Sec-WebSocket-Accept\");\n            const digest = crypto.createHash(\"sha1\").update(keyValue + uid).digest(\"base64\");\n            if (secWSAccept !== digest) {\n                failWebsocketConnection(ws, \"Incorrect hash received in Sec-WebSocket-Accept header.\");\n                return;\n            }\n            // 5. If the response includes a |Sec-WebSocket-Extensions| header\n            //    field and this header field indicates the use of an extension\n            //    that was not present in the client's handshake (the server has\n            //    indicated an extension not requested by the client), the client\n            //    MUST _Fail the WebSocket Connection_.  (The parsing of this\n            //    header field to determine which extensions are requested is\n            //    discussed in Section 9.1.)\n            const secExtension = response.headersList.get(\"Sec-WebSocket-Extensions\");\n            let extensions;\n            if (secExtension !== null) {\n                extensions = parseExtensions(secExtension);\n                if (!extensions.has(\"permessage-deflate\")) {\n                    failWebsocketConnection(ws, \"Sec-WebSocket-Extensions header does not match.\");\n                    return;\n                }\n            }\n            // 6. If the response includes a |Sec-WebSocket-Protocol| header field\n            //    and this header field indicates the use of a subprotocol that was\n            //    not present in the client's handshake (the server has indicated a\n            //    subprotocol not requested by the client), the client MUST _Fail\n            //    the WebSocket Connection_.\n            const secProtocol = response.headersList.get(\"Sec-WebSocket-Protocol\");\n            if (secProtocol !== null) {\n                const requestProtocols = getDecodeSplit(\"sec-websocket-protocol\", request.headersList);\n                // The client can request that the server use a specific subprotocol by\n                // including the |Sec-WebSocket-Protocol| field in its handshake.  If it\n                // is specified, the server needs to include the same field and one of\n                // the selected subprotocol values in its response for the connection to\n                // be established.\n                if (!requestProtocols.includes(secProtocol)) {\n                    failWebsocketConnection(ws, \"Protocol was not set in the opening handshake.\");\n                    return;\n                }\n            }\n            response.socket.on(\"data\", onSocketData);\n            response.socket.on(\"close\", onSocketClose);\n            response.socket.on(\"error\", onSocketError);\n            if (channels.open.hasSubscribers) {\n                channels.open.publish({\n                    address: response.socket.address(),\n                    protocol: secProtocol,\n                    extensions: secExtension\n                });\n            }\n            onEstablish(response, extensions);\n        }\n    });\n    return controller;\n}\nfunction closeWebSocketConnection(ws, code, reason, reasonByteLength) {\n    if (isClosing(ws) || isClosed(ws)) {\n    // If this's ready state is CLOSING (2) or CLOSED (3)\n    // Do nothing.\n    } else if (!isEstablished(ws)) {\n        // If the WebSocket connection is not yet established\n        // Fail the WebSocket connection and set this's ready state\n        // to CLOSING (2).\n        failWebsocketConnection(ws, \"Connection was closed before it was established.\");\n        ws[kReadyState] = states.CLOSING;\n    } else if (ws[kSentClose] === sentCloseFrameState.NOT_SENT) {\n        // If the WebSocket closing handshake has not yet been started\n        // Start the WebSocket closing handshake and set this's ready\n        // state to CLOSING (2).\n        // - If neither code nor reason is present, the WebSocket Close\n        //   message must not have a body.\n        // - If code is present, then the status code to use in the\n        //   WebSocket Close message must be the integer given by code.\n        // - If reason is also present, then reasonBytes must be\n        //   provided in the Close message after the status code.\n        ws[kSentClose] = sentCloseFrameState.PROCESSING;\n        const frame = new WebsocketFrameSend();\n        // If neither code nor reason is present, the WebSocket Close\n        // message must not have a body.\n        // If code is present, then the status code to use in the\n        // WebSocket Close message must be the integer given by code.\n        if (code !== undefined && reason === undefined) {\n            frame.frameData = Buffer.allocUnsafe(2);\n            frame.frameData.writeUInt16BE(code, 0);\n        } else if (code !== undefined && reason !== undefined) {\n            // If reason is also present, then reasonBytes must be\n            // provided in the Close message after the status code.\n            frame.frameData = Buffer.allocUnsafe(2 + reasonByteLength);\n            frame.frameData.writeUInt16BE(code, 0);\n            // the body MAY contain UTF-8-encoded data with value /reason/\n            frame.frameData.write(reason, 2, \"utf-8\");\n        } else {\n            frame.frameData = emptyBuffer;\n        }\n        /** @type {import('stream').Duplex} */ const socket = ws[kResponse].socket;\n        socket.write(frame.createFrame(opcodes.CLOSE));\n        ws[kSentClose] = sentCloseFrameState.SENT;\n        // Upon either sending or receiving a Close control frame, it is said\n        // that _The WebSocket Closing Handshake is Started_ and that the\n        // WebSocket connection is in the CLOSING state.\n        ws[kReadyState] = states.CLOSING;\n    } else {\n        // Otherwise\n        // Set this's ready state to CLOSING (2).\n        ws[kReadyState] = states.CLOSING;\n    }\n}\n/**\n * @param {Buffer} chunk\n */ function onSocketData(chunk) {\n    if (!this.ws[kByteParser].write(chunk)) {\n        this.pause();\n    }\n}\n/**\n * @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol\n * @see https://datatracker.ietf.org/doc/html/rfc6455#section-7.1.4\n */ function onSocketClose() {\n    const { ws } = this;\n    const { [kResponse]: response } = ws;\n    response.socket.off(\"data\", onSocketData);\n    response.socket.off(\"close\", onSocketClose);\n    response.socket.off(\"error\", onSocketError);\n    // If the TCP connection was closed after the\n    // WebSocket closing handshake was completed, the WebSocket connection\n    // is said to have been closed _cleanly_.\n    const wasClean = ws[kSentClose] === sentCloseFrameState.SENT && ws[kReceivedClose];\n    let code = 1005;\n    let reason = \"\";\n    const result = ws[kByteParser].closingInfo;\n    if (result && !result.error) {\n        code = result.code ?? 1005;\n        reason = result.reason;\n    } else if (!ws[kReceivedClose]) {\n        // If _The WebSocket\n        // Connection is Closed_ and no Close control frame was received by the\n        // endpoint (such as could occur if the underlying transport connection\n        // is lost), _The WebSocket Connection Close Code_ is considered to be\n        // 1006.\n        code = 1006;\n    }\n    // 1. Change the ready state to CLOSED (3).\n    ws[kReadyState] = states.CLOSED;\n    // 2. If the user agent was required to fail the WebSocket\n    //    connection, or if the WebSocket connection was closed\n    //    after being flagged as full, fire an event named error\n    //    at the WebSocket object.\n    // TODO\n    // 3. Fire an event named close at the WebSocket object,\n    //    using CloseEvent, with the wasClean attribute\n    //    initialized to true if the connection closed cleanly\n    //    and false otherwise, the code attribute initialized to\n    //    the WebSocket connection close code, and the reason\n    //    attribute initialized to the result of applying UTF-8\n    //    decode without BOM to the WebSocket connection close\n    //    reason.\n    // TODO: process.nextTick\n    fireEvent(\"close\", ws, (type, init)=>new CloseEvent(type, init), {\n        wasClean,\n        code,\n        reason\n    });\n    if (channels.close.hasSubscribers) {\n        channels.close.publish({\n            websocket: ws,\n            code,\n            reason\n        });\n    }\n}\nfunction onSocketError(error) {\n    const { ws } = this;\n    ws[kReadyState] = states.CLOSING;\n    if (channels.socketError.hasSubscribers) {\n        channels.socketError.publish(error);\n    }\n    this.destroy();\n}\nmodule.exports = {\n    establishWebSocketConnection,\n    closeWebSocketConnection\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvd2Vic29ja2V0L2Nvbm5lY3Rpb24uanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNLEVBQUVBLEdBQUcsRUFBRUMsTUFBTSxFQUFFQyxtQkFBbUIsRUFBRUMsV0FBVyxFQUFFQyxPQUFBQSxFQUFTLEdBQUdDLG1CQUFPQSxDQUFDO0FBQzNFLE1BQU0sRUFDSkMsV0FBVyxFQUNYQyxVQUFVLEVBQ1ZDLFdBQVcsRUFDWEMsY0FBYyxFQUNkQyxTQUFBQSxFQUNELEdBQUdMLG1CQUFPQSxDQUFDO0FBQ1osTUFBTSxFQUFFTSxTQUFTLEVBQUVDLHVCQUF1QixFQUFFQyxTQUFTLEVBQUVDLFFBQVEsRUFBRUMsYUFBYSxFQUFFQyxlQUFBQSxFQUFpQixHQUFHWCxtQkFBT0EsQ0FBQztBQUM1RyxNQUFNLEVBQUVZLFFBQUFBLEVBQVUsR0FBR1osbUJBQU9BLENBQUM7QUFDN0IsTUFBTSxFQUFFYSxVQUFBQSxFQUFZLEdBQUdiLG1CQUFPQSxDQUFDO0FBQy9CLE1BQU0sRUFBRWMsV0FBQUEsRUFBYSxHQUFHZCxtQkFBT0EsQ0FBQztBQUNoQyxNQUFNLEVBQUVlLFFBQUFBLEVBQVUsR0FBR2YsbUJBQU9BLENBQUM7QUFDN0IsTUFBTSxFQUFFZ0IsT0FBTyxFQUFFQyxjQUFBQSxFQUFnQixHQUFHakIsbUJBQU9BLENBQUM7QUFDNUMsTUFBTSxFQUFFa0IsY0FBQUEsRUFBZ0IsR0FBR2xCLG1CQUFPQSxDQUFDO0FBQ25DLE1BQU0sRUFBRW1CLGtCQUFBQSxFQUFvQixHQUFHbkIsbUJBQU9BLENBQUM7QUFFdkMsZ0NBQ0EsSUFBSW9CO0FBQ0osSUFBSTtJQUNGQSxTQUFTcEIsbUJBQU9BLENBQUM7QUFDbkIsdUJBQ0EsRUFBRSxPQUFNLENBRVI7QUFFQTs7Ozs7OztDQU9BLEdBQ0EsU0FBU3FCLDZCQUE4QkMsR0FBRyxFQUFFQyxTQUFTLEVBQUVDLE1BQU0sRUFBRUMsRUFBRSxFQUFFQyxXQUFXLEVBQUVDLE9B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LENBQUN4QixZQUFZLEdBQUdMLE9BQU9rRixPQUFPO0lBRWhDLElBQUlsRSxTQUFTMEYsV0FBVyxDQUFDL0IsY0FBYyxFQUFFO1FBQ3ZDM0QsU0FBUzBGLFdBQVcsQ0FBQzlCLE9BQU8sQ0FBQ3lCO0lBQy9CO0lBRUEsSUFBSSxDQUFDTSxPQUFPO0FBQ2Q7QUFFQUMsT0FBT0MsT0FBTyxHQUFHO0lBQ2ZwRjtJQUNBcUQ7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL21vY2t1cGZsb3cvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvd2Vic29ja2V0L2Nvbm5lY3Rpb24uanM/MmFlOCIsIndlYnBhY2s6Ly9tb2NrdXBmbG93Ly4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvd2ViL3dlYnNvY2tldC9jb25uZWN0aW9uLmpzPzJhZTgqIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IHVpZCwgc3RhdGVzLCBzZW50Q2xvc2VGcmFtZVN0YXRlLCBlbXB0eUJ1ZmZlciwgb3Bjb2RlcyB9ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKVxuY29uc3Qge1xuICBrUmVhZHlTdGF0ZSxcbiAga1NlbnRDbG9zZSxcbiAga0J5dGVQYXJzZXIsXG4gIGtSZWNlaXZlZENsb3NlLFxuICBrUmVzcG9uc2Vcbn0gPSByZXF1aXJlKCcuL3N5bWJvbHMnKVxuY29uc3QgeyBmaXJlRXZlbnQsIGZhaWxXZWJzb2NrZXRDb25uZWN0aW9uLCBpc0Nsb3NpbmcsIGlzQ2xvc2VkLCBpc0VzdGFibGlzaGVkLCBwYXJzZUV4dGVuc2lvbnMgfSA9IHJlcXVpcmUoJy4vdXRpbCcpXG5jb25zdCB7IGNoYW5uZWxzIH0gPSByZXF1aXJlKCcuLi8uLi9jb3JlL2RpYWdub3N0aWNzJylcbmNvbnN0IHsgQ2xvc2VFdmVudCB9ID0gcmVxdWlyZSgnLi9ldmVudHMnKVxuY29uc3QgeyBtYWtlUmVxdWVzdCB9ID0gcmVxdWlyZSgnLi4vZmV0Y2gvcmVxdWVzdCcpXG5jb25zdCB7IGZldGNoaW5nIH0gPSByZXF1aXJlKCcuLi9mZXRjaC9pbmRleCcpXG5jb25zdCB7IEhlYWRlcnMsIGdldEhlYWRlcnNMaXN0IH0gPSByZXF1aXJlKCcuLi9mZXRjaC9oZWFkZXJzJylcbmNvbnN0IHsgZ2V0RGVjb2RlU3BsaXQgfSA9IHJlcXVpcmUoJy4uL2ZldGNoL3V0aWwnKVxuY29uc3QgeyBXZWJzb2NrZXRGcmFtZVNlbmQgfSA9IHJlcXVpcmUoJy4vZnJhbWUnKVxuXG4vKiogQHR5cGUge2ltcG9ydCgnY3J5cHRvJyl9ICovXG5sZXQgY3J5cHRvXG50cnkge1xuICBjcnlwdG8gPSByZXF1aXJlKCdub2RlOmNyeXB0bycpXG4vKiBjOCBpZ25vcmUgbmV4dCAzICovXG59IGNhdGNoIHtcblxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly93ZWJzb2NrZXRzLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC13ZWJzb2NrZXQtZXN0YWJsaXNoXG4gKiBAcGFyYW0ge1VSTH0gdXJsXG4gKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gcHJvdG9jb2xzXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi93ZWJzb2NrZXQnKS5XZWJTb2NrZXR9IHdzXG4gKiBAcGFyYW0geyhyZXNwb25zZTogYW55LCBleHRlbnNpb25zOiBzdHJpbmdbXSB8IHVuZGVmaW5lZCkgPT4gdm9pZH0gb25Fc3RhYmxpc2hcbiAqIEBwYXJhbSB7UGFydGlhbDxpbXBvcnQoJy4uLy4uL3R5cGVzL3dlYnNvY2tldCcpLldlYlNvY2tldEluaXQ+fSBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIGVzdGFibGlzaFdlYlNvY2tldENvbm5lY3Rpb24gKHVybCwgcHJvdG9jb2xzLCBjbGllbnQsIHdzLCBvbkVzdGFibGlzaCwgb3B0aW9ucykge1xuICAvLyAxLiBMZXQgcmVxdWVzdFVSTCBiZSBhIGNvcHkgb2YgdXJsLCB3aXRoIGl0cyBzY2hlbWUgc2V0IHRvIFwiaHR0cFwiLCBpZiB1cmzigJlzXG4gIC8vICAgIHNjaGVtZSBpcyBcIndzXCIsIGFuZCB0byBcImh0dHBzXCIgb3RoZXJ3aXNlLlxuICBjb25zdCByZXF1ZXN0VVJMID0gdXJsXG5cbiAgcmVxdWVzdFVSTC5wcm90b2NvbCA9IHVybC5wcm90b2NvbCA9PT0gJ3dzOicgPyAnaHR0cDonIDogJ2h0dHBzOidcblxuICAvLyAyLiBMZXQgcmVxdWVzdCBiZSBhIG5ldyByZXF1ZXN0LCB3aG9zZSBVUkwgaXMgcmVxdWVzdFVSTCwgY2xpZW50IGlzIGNsaWVudCxcbiAgLy8gICAgc2VydmljZS13b3JrZXJzIG1vZGUgaXMgXCJub25lXCIsIHJlZmVycmVyIGlzIFwibm8tcmVmZXJyZXJcIiwgbW9kZSBpc1xuICAvLyAgICBcIndlYnNvY2tldFwiLCBjcmVkZW50aWFscyBtb2RlIGlzIFwiaW5jbHVkZVwiLCBjYWNoZSBtb2RlIGlzIFwibm8tc3RvcmVcIiAsXG4gIC8vICAgIGFuZCByZWRpcmVjdCBtb2RlIGlzIFwiZXJyb3JcIi5cbiAgY29uc3QgcmVxdWVzdCA9IG1ha2VSZXF1ZXN0KHtcbiAgICB1cmxMaXN0OiBbcmVxdWVzdFVSTF0sXG4gICAgY2xpZW50LFxuICAgIHNlcnZpY2VXb3JrZXJzOiAnbm9uZScsXG4gICAgcmVmZXJyZXI6ICduby1yZWZlcnJlcicsXG4gICAgbW9kZTogJ3dlYnNvY2tldCcsXG4gICAgY3JlZGVudGlhbHM6ICdpbmNsdWRlJyxcbiAgICBjYWNoZTogJ25vLXN0b3JlJyxcbiAgICByZWRpcmVjdDogJ2Vycm9yJ1xuICB9KVxuXG4gIC8vIE5vdGU6IHVuZGljaSBleHRlbnNpb24sIGFsbG93IHNldHRpbmcgY3VzdG9tIGhlYWRlcnMuXG4gIGlmIChvcHRpb25zLmhlYWRlcnMpIHtcbiAgICBjb25zdCBoZWFkZXJzTGlzdCA9IGdldEhlYWRlcnNMaXN0KG5ldyBIZWFkZXJzKG9wdGlvbnMuaGVhZGVycykpXG5cbiAgICByZXF1ZXN0LmhlYWRlcnNMaXN0ID0gaGVhZGVyc0xpc3RcbiAgfVxuXG4gIC8vIDMuIEFwcGVuZCAoYFVwZ3JhZGVgLCBgd2Vic29ja2V0YCkgdG8gcmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QuXG4gIC8vIDQuIEFwcGVuZCAoYENvbm5lY3Rpb25gLCBgVXBncmFkZWApIHRvIHJlcXVlc3TigJlzIGhlYWRlciBsaXN0LlxuICAvLyBOb3RlOiBib3RoIG9mIHRoZXNlIGFyZSBoYW5kbGVkIGJ5IHVuZGljaSBjdXJyZW50bHkuXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvdW5kaWNpL2Jsb2IvNjhjMjY5YzQxNDRjNDQ2ZjNmMTIyMDk1MTMzOGRhZWY0YTZiNWVjNC9saWIvY2xpZW50LmpzI0wxMzk3XG5cbiAgLy8gNS4gTGV0IGtleVZhbHVlIGJlIGEgbm9uY2UgY29uc2lzdGluZyBvZiBhIHJhbmRvbWx5IHNlbGVjdGVkXG4gIC8vICAgIDE2LWJ5dGUgdmFsdWUgdGhhdCBoYXMgYmVlbiBmb3JnaXZpbmctYmFzZTY0LWVuY29kZWQgYW5kXG4gIC8vICAgIGlzb21vcnBoaWMgZW5jb2RlZC5cbiAgY29uc3Qga2V5VmFsdWUgPSBjcnlwdG8ucmFuZG9tQnl0ZXMoMTYpLnRvU3RyaW5nKCdiYXNlNjQnKVxuXG4gIC8vIDYuIEFwcGVuZCAoYFNlYy1XZWJTb2NrZXQtS2V5YCwga2V5VmFsdWUpIHRvIHJlcXVlc3TigJlzXG4gIC8vICAgIGhlYWRlciBsaXN0LlxuICByZXF1ZXN0LmhlYWRlcnNMaXN0LmFwcGVuZCgnc2VjLXdlYnNvY2tldC1rZXknLCBrZXlWYWx1ZSlcblxuICAvLyA3LiBBcHBlbmQgKGBTZWMtV2ViU29ja2V0LVZlcnNpb25gLCBgMTNgKSB0byByZXF1ZXN04oCZc1xuICAvLyAgICBoZWFkZXIgbGlzdC5cbiAgcmVxdWVzdC5oZWFkZXJzTGlzdC5hcHBlbmQoJ3NlYy13ZWJzb2NrZXQtdmVyc2lvbicsICcxMycpXG5cbiAgLy8gOC4gRm9yIGVhY2ggcHJvdG9jb2wgaW4gcHJvdG9jb2xzLCBjb21iaW5lXG4gIC8vICAgIChgU2VjLVdlYlNvY2tldC1Qcm90b2NvbGAsIHByb3RvY29sKSBpbiByZXF1ZXN04oCZcyBoZWFkZXJcbiAgLy8gICAgbGlzdC5cbiAgZm9yIChjb25zdCBwcm90b2NvbCBvZiBwcm90b2NvbHMpIHtcbiAgICByZXF1ZXN0LmhlYWRlcnNMaXN0LmFwcGVuZCgnc2VjLXdlYnNvY2tldC1wcm90b2NvbCcsIHByb3RvY29sKVxuICB9XG5cbiAgLy8gOS4gTGV0IHBlcm1lc3NhZ2VEZWZsYXRlIGJlIGEgdXNlci1hZ2VudCBkZWZpbmVkXG4gIC8vICAgIFwicGVybWVzc2FnZS1kZWZsYXRlXCIgZXh0ZW5zaW9uIGhlYWRlciB2YWx1ZS5cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvZ2Vja28tZGV2L2Jsb2IvY2U3ODIzNGY1ZTY1M2E1ZDM5MTY4MTNmZjk5MGYwNTM1MTAyMjdiYy9uZXR3ZXJrL3Byb3RvY29sL3dlYnNvY2tldC9XZWJTb2NrZXRDaGFubmVsLmNwcCNMMjY3M1xuICBjb25zdCBwZXJtZXNzYWdlRGVmbGF0ZSA9ICdwZXJtZXNzYWdlLWRlZmxhdGU7IGNsaWVudF9tYXhfd2luZG93X2JpdHMnXG5cbiAgLy8gMTAuIEFwcGVuZCAoYFNlYy1XZWJTb2NrZXQtRXh0ZW5zaW9uc2AsIHBlcm1lc3NhZ2VEZWZsYXRlKSB0b1xuICAvLyAgICAgcmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QuXG4gIHJlcXVlc3QuaGVhZGVyc0xpc3QuYXBwZW5kKCdzZWMtd2Vic29ja2V0LWV4dGVuc2lvbnMnLCBwZXJtZXNzYWdlRGVmbGF0ZSlcblxuICAvLyAxMS4gRmV0Y2ggcmVxdWVzdCB3aXRoIHVzZVBhcmFsbGVsUXVldWUgc2V0IHRvIHRydWUsIGFuZFxuICAvLyAgICAgcHJvY2Vzc1Jlc3BvbnNlIGdpdmVuIHJlc3BvbnNlIGJlaW5nIHRoZXNlIHN0ZXBzOlxuICBjb25zdCBjb250cm9sbGVyID0gZmV0Y2hpbmcoe1xuICAgIHJlcXVlc3QsXG4gICAgdXNlUGFyYWxsZWxRdWV1ZTogdHJ1ZSxcbiAgICBkaXNwYXRjaGVyOiBvcHRpb25zLmRpc3BhdGNoZXIsXG4gICAgcHJvY2Vzc1Jlc3BvbnNlIChyZXNwb25zZSkge1xuICAgICAgLy8gMS4gSWYgcmVzcG9uc2UgaXMgYSBuZXR3b3JrIGVycm9yIG9yIGl0cyBzdGF0dXMgaXMgbm90IDEwMSxcbiAgICAgIC8vICAgIGZhaWwgdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uLlxuICAgICAgaWYgKHJlc3BvbnNlLnR5cGUgPT09ICdlcnJvcicgfHwgcmVzcG9uc2Uuc3RhdHVzICE9PSAxMDEpIHtcbiAgICAgICAgZmFpbFdlYnNvY2tldENvbm5lY3Rpb24od3MsICdSZWNlaXZlZCBuZXR3b3JrIGVycm9yIG9yIG5vbi0xMDEgc3RhdHVzIGNvZGUuJylcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIC8vIDIuIElmIHByb3RvY29scyBpcyBub3QgdGhlIGVtcHR5IGxpc3QgYW5kIGV4dHJhY3RpbmcgaGVhZGVyXG4gICAgICAvLyAgICBsaXN0IHZhbHVlcyBnaXZlbiBgU2VjLVdlYlNvY2tldC1Qcm90b2NvbGAgYW5kIHJlc3BvbnNl4oCZc1xuICAgICAgLy8gICAgaGVhZGVyIGxpc3QgcmVzdWx0cyBpbiBudWxsLCBmYWlsdXJlLCBvciB0aGUgZW1wdHkgYnl0ZVxuICAgICAgLy8gICAgc2VxdWVuY2UsIHRoZW4gZmFpbCB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24uXG4gICAgICBpZiAocHJvdG9jb2xzLmxlbmd0aCAhPT0gMCAmJiAhcmVzcG9uc2UuaGVhZGVyc0xpc3QuZ2V0KCdTZWMtV2ViU29ja2V0LVByb3RvY29sJykpIHtcbiAgICAgICAgZmFpbFdlYnNvY2tldENvbm5lY3Rpb24od3MsICdTZXJ2ZXIgZGlkIG5vdCByZXNwb25kIHdpdGggc2VudCBwcm90b2NvbHMuJylcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIC8vIDMuIEZvbGxvdyB0aGUgcmVxdWlyZW1lbnRzIHN0YXRlZCBzdGVwIDIgdG8gc3RlcCA2LCBpbmNsdXNpdmUsXG4gICAgICAvLyAgICBvZiB0aGUgbGFzdCBzZXQgb2Ygc3RlcHMgaW4gc2VjdGlvbiA0LjEgb2YgVGhlIFdlYlNvY2tldFxuICAgICAgLy8gICAgUHJvdG9jb2wgdG8gdmFsaWRhdGUgcmVzcG9uc2UuIFRoaXMgZWl0aGVyIHJlc3VsdHMgaW4gZmFpbFxuICAgICAgLy8gICAgdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uIG9yIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvbiBpc1xuICAgICAgLy8gICAgZXN0YWJsaXNoZWQuXG5cbiAgICAgIC8vIDIuIElmIHRoZSByZXNwb25zZSBsYWNrcyBhbiB8VXBncmFkZXwgaGVhZGVyIGZpZWxkIG9yIHRoZSB8VXBncmFkZXxcbiAgICAgIC8vICAgIGhlYWRlciBmaWVsZCBjb250YWlucyBhIHZhbHVlIHRoYXQgaXMgbm90IGFuIEFTQ0lJIGNhc2UtXG4gICAgICAvLyAgICBpbnNlbnNpdGl2ZSBtYXRjaCBmb3IgdGhlIHZhbHVlIFwid2Vic29ja2V0XCIsIHRoZSBjbGllbnQgTVVTVFxuICAgICAgLy8gICAgX0ZhaWwgdGhlIFdlYlNvY2tldCBDb25uZWN0aW9uXy5cbiAgICAgIGlmIChyZXNwb25zZS5oZWFkZXJzTGlzdC5nZXQoJ1VwZ3JhZGUnKT8udG9Mb3dlckNhc2UoKSAhPT0gJ3dlYnNvY2tldCcpIHtcbiAgICAgICAgZmFpbFdlYnNvY2tldENvbm5lY3Rpb24od3MsICdTZXJ2ZXIgZGlkIG5vdCBzZXQgVXBncmFkZSBoZWFkZXIgdG8gXCJ3ZWJzb2NrZXRcIi4nKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgLy8gMy4gSWYgdGhlIHJlc3BvbnNlIGxhY2tzIGEgfENvbm5lY3Rpb258IGhlYWRlciBmaWVsZCBvciB0aGVcbiAgICAgIC8vICAgIHxDb25uZWN0aW9ufCBoZWFkZXIgZmllbGQgZG9lc24ndCBjb250YWluIGEgdG9rZW4gdGhhdCBpcyBhblxuICAgICAgLy8gICAgQVNDSUkgY2FzZS1pbnNlbnNpdGl2ZSBtYXRjaCBmb3IgdGhlIHZhbHVlIFwiVXBncmFkZVwiLCB0aGUgY2xpZW50XG4gICAgICAvLyAgICBNVVNUIF9GYWlsIHRoZSBXZWJTb2NrZXQgQ29ubmVjdGlvbl8uXG4gICAgICBpZiAocmVzcG9uc2UuaGVhZGVyc0xpc3QuZ2V0KCdDb25uZWN0aW9uJyk/LnRvTG93ZXJDYXNlKCkgIT09ICd1cGdyYWRlJykge1xuICAgICAgICBmYWlsV2Vic29ja2V0Q29ubmVjdGlvbih3cywgJ1NlcnZlciBkaWQgbm90IHNldCBDb25uZWN0aW9uIGhlYWRlciB0byBcInVwZ3JhZGVcIi4nKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgLy8gNC4gSWYgdGhlIHJlc3BvbnNlIGxhY2tzIGEgfFNlYy1XZWJTb2NrZXQtQWNjZXB0fCBoZWFkZXIgZmllbGQgb3JcbiAgICAgIC8vICAgIHRoZSB8U2VjLVdlYlNvY2tldC1BY2NlcHR8IGNvbnRhaW5zIGEgdmFsdWUgb3RoZXIgdGhhbiB0aGVcbiAgICAgIC8vICAgIGJhc2U2NC1lbmNvZGVkIFNIQS0xIG9mIHRoZSBjb25jYXRlbmF0aW9uIG9mIHRoZSB8U2VjLVdlYlNvY2tldC1cbiAgICAgIC8vICAgIEtleXwgKGFzIGEgc3RyaW5nLCBub3QgYmFzZTY0LWRlY29kZWQpIHdpdGggdGhlIHN0cmluZyBcIjI1OEVBRkE1LVxuICAgICAgLy8gICAgRTkxNC00N0RBLTk1Q0EtQzVBQjBEQzg1QjExXCIgYnV0IGlnbm9yaW5nIGFueSBsZWFkaW5nIGFuZFxuICAgICAgLy8gICAgdHJhaWxpbmcgd2hpdGVzcGFjZSwgdGhlIGNsaWVudCBNVVNUIF9GYWlsIHRoZSBXZWJTb2NrZXRcbiAgICAgIC8vICAgIENvbm5lY3Rpb25fLlxuICAgICAgY29uc3Qgc2VjV1NBY2NlcHQgPSByZXNwb25zZS5oZWFkZXJzTGlzdC5nZXQoJ1NlYy1XZWJTb2NrZXQtQWNjZXB0JylcbiAgICAgIGNvbnN0IGRpZ2VzdCA9IGNyeXB0by5jcmVhdGVIYXNoKCdzaGExJykudXBkYXRlKGtleVZhbHVlICsgdWlkKS5kaWdlc3QoJ2Jhc2U2NCcpXG4gICAgICBpZiAoc2VjV1NBY2NlcHQgIT09IGRpZ2VzdCkge1xuICAgICAgICBmYWlsV2Vic29ja2V0Q29ubmVjdGlvbih3cywgJ0luY29ycmVjdCBoYXNoIHJlY2VpdmVkIGluIFNlYy1XZWJTb2NrZXQtQWNjZXB0IGhlYWRlci4nKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgLy8gNS4gSWYgdGhlIHJlc3BvbnNlIGluY2x1ZGVzIGEgfFNlYy1XZWJTb2NrZXQtRXh0ZW5zaW9uc3wgaGVhZGVyXG4gICAgICAvLyAgICBmaWVsZCBhbmQgdGhpcyBoZWFkZXIgZmllbGQgaW5kaWNhdGVzIHRoZSB1c2Ugb2YgYW4gZXh0ZW5zaW9uXG4gICAgICAvLyAgICB0aGF0IHdhcyBub3QgcHJlc2VudCBpbiB0aGUgY2xpZW50J3MgaGFuZHNoYWtlICh0aGUgc2VydmVyIGhhc1xuICAgICAgLy8gICAgaW5kaWNhdGVkIGFuIGV4dGVuc2lvbiBub3QgcmVxdWVzdGVkIGJ5IHRoZSBjbGllbnQpLCB0aGUgY2xpZW50XG4gICAgICAvLyAgICBNVVNUIF9GYWlsIHRoZSBXZWJTb2NrZXQgQ29ubmVjdGlvbl8uICAoVGhlIHBhcnNpbmcgb2YgdGhpc1xuICAgICAgLy8gICAgaGVhZGVyIGZpZWxkIHRvIGRldGVybWluZSB3aGljaCBleHRlbnNpb25zIGFyZSByZXF1ZXN0ZWQgaXNcbiAgICAgIC8vICAgIGRpc2N1c3NlZCBpbiBTZWN0aW9uIDkuMS4pXG4gICAgICBjb25zdCBzZWNFeHRlbnNpb24gPSByZXNwb25zZS5oZWFkZXJzTGlzdC5nZXQoJ1NlYy1XZWJTb2NrZXQtRXh0ZW5zaW9ucycpXG4gICAgICBsZXQgZXh0ZW5zaW9uc1xuXG4gICAgICBpZiAoc2VjRXh0ZW5zaW9uICE9PSBudWxsKSB7XG4gICAgICAgIGV4dGVuc2lvbnMgPSBwYXJzZUV4dGVuc2lvbnMoc2VjRXh0ZW5zaW9uKVxuXG4gICAgICAgIGlmICghZXh0ZW5zaW9ucy5oYXMoJ3Blcm1lc3NhZ2UtZGVmbGF0ZScpKSB7XG4gICAgICAgICAgZmFpbFdlYnNvY2tldENvbm5lY3Rpb24od3MsICdTZWMtV2ViU29ja2V0LUV4dGVuc2lvbnMgaGVhZGVyIGRvZXMgbm90IG1hdGNoLicpXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gNi4gSWYgdGhlIHJlc3BvbnNlIGluY2x1ZGVzIGEgfFNlYy1XZWJTb2NrZXQtUHJvdG9jb2x8IGhlYWRlciBmaWVsZFxuICAgICAgLy8gICAgYW5kIHRoaXMgaGVhZGVyIGZpZWxkIGluZGljYXRlcyB0aGUgdXNlIG9mIGEgc3VicHJvdG9jb2wgdGhhdCB3YXNcbiAgICAgIC8vICAgIG5vdCBwcmVzZW50IGluIHRoZSBjbGllbnQncyBoYW5kc2hha2UgKHRoZSBzZXJ2ZXIgaGFzIGluZGljYXRlZCBhXG4gICAgICAvLyAgICBzdWJwcm90b2NvbCBub3QgcmVxdWVzdGVkIGJ5IHRoZSBjbGllbnQpLCB0aGUgY2xpZW50IE1VU1QgX0ZhaWxcbiAgICAgIC8vICAgIHRoZSBXZWJTb2NrZXQgQ29ubmVjdGlvbl8uXG4gICAgICBjb25zdCBzZWNQcm90b2NvbCA9IHJlc3BvbnNlLmhlYWRlcnNMaXN0LmdldCgnU2VjLVdlYlNvY2tldC1Qcm90b2NvbCcpXG5cbiAgICAgIGlmIChzZWNQcm90b2NvbCAhPT0gbnVsbCkge1xuICAgICAgICBjb25zdCByZXF1ZXN0UHJvdG9jb2xzID0gZ2V0RGVjb2RlU3BsaXQoJ3NlYy13ZWJzb2NrZXQtcHJvdG9jb2wnLCByZXF1ZXN0LmhlYWRlcnNMaXN0KVxuXG4gICAgICAgIC8vIFRoZSBjbGllbnQgY2FuIHJlcXVlc3QgdGhhdCB0aGUgc2VydmVyIHVzZSBhIHNwZWNpZmljIHN1YnByb3RvY29sIGJ5XG4gICAgICAgIC8vIGluY2x1ZGluZyB0aGUgfFNlYy1XZWJTb2NrZXQtUHJvdG9jb2x8IGZpZWxkIGluIGl0cyBoYW5kc2hha2UuICBJZiBpdFxuICAgICAgICAvLyBpcyBzcGVjaWZpZWQsIHRoZSBzZXJ2ZXIgbmVlZHMgdG8gaW5jbHVkZSB0aGUgc2FtZSBmaWVsZCBhbmQgb25lIG9mXG4gICAgICAgIC8vIHRoZSBzZWxlY3RlZCBzdWJwcm90b2NvbCB2YWx1ZXMgaW4gaXRzIHJlc3BvbnNlIGZvciB0aGUgY29ubmVjdGlvbiB0b1xuICAgICAgICAvLyBiZSBlc3RhYmxpc2hlZC5cbiAgICAgICAgaWYgKCFyZXF1ZXN0UHJvdG9jb2xzLmluY2x1ZGVzKHNlY1Byb3RvY29sKSkge1xuICAgICAgICAgIGZhaWxXZWJzb2NrZXRDb25uZWN0aW9uKHdzLCAnUHJvdG9jb2wgd2FzIG5vdCBzZXQgaW4gdGhlIG9wZW5pbmcgaGFuZHNoYWtlLicpXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmVzcG9uc2Uuc29ja2V0Lm9uKCdkYXRhJywgb25Tb2NrZXREYXRhKVxuICAgICAgcmVzcG9uc2Uuc29ja2V0Lm9uKCdjbG9zZScsIG9uU29ja2V0Q2xvc2UpXG4gICAgICByZXNwb25zZS5zb2NrZXQub24oJ2Vycm9yJywgb25Tb2NrZXRFcnJvcilcblxuICAgICAgaWYgKGNoYW5uZWxzLm9wZW4uaGFzU3Vic2NyaWJlcnMpIHtcbiAgICAgICAgY2hhbm5lbHMub3Blbi5wdWJsaXNoKHtcbiAgICAgICAgICBhZGRyZXNzOiByZXNwb25zZS5zb2NrZXQuYWRkcmVzcygpLFxuICAgICAgICAgIHByb3RvY29sOiBzZWNQcm90b2NvbCxcbiAgICAgICAgICBleHRlbnNpb25zOiBzZWNFeHRlbnNpb25cbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAgb25Fc3RhYmxpc2gocmVzcG9uc2UsIGV4dGVuc2lvbnMpXG4gICAgfVxuICB9KVxuXG4gIHJldHVybiBjb250cm9sbGVyXG59XG5cbmZ1bmN0aW9uIGNsb3NlV2ViU29ja2V0Q29ubmVjdGlvbiAod3MsIGNvZGUsIHJlYXNvbiwgcmVhc29uQnl0ZUxlbmd0aCkge1xuICBpZiAoaXNDbG9zaW5nKHdzKSB8fCBpc0Nsb3NlZCh3cykpIHtcbiAgICAvLyBJZiB0aGlzJ3MgcmVhZHkgc3RhdGUgaXMgQ0xPU0lORyAoMikgb3IgQ0xPU0VEICgzKVxuICAgIC8vIERvIG5vdGhpbmcuXG4gIH0gZWxzZSBpZiAoIWlzRXN0YWJsaXNoZWQod3MpKSB7XG4gICAgLy8gSWYgdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uIGlzIG5vdCB5ZXQgZXN0YWJsaXNoZWRcbiAgICAvLyBGYWlsIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvbiBhbmQgc2V0IHRoaXMncyByZWFkeSBzdGF0ZVxuICAgIC8vIHRvIENMT1NJTkcgKDIpLlxuICAgIGZhaWxXZWJzb2NrZXRDb25uZWN0aW9uKHdzLCAnQ29ubmVjdGlvbiB3YXMgY2xvc2VkIGJlZm9yZSBpdCB3YXMgZXN0YWJsaXNoZWQuJylcbiAgICB3c1trUmVhZHlTdGF0ZV0gPSBzdGF0ZXMuQ0xPU0lOR1xuICB9IGVsc2UgaWYgKHdzW2tTZW50Q2xvc2VdID09PSBzZW50Q2xvc2VGcmFtZVN0YXRlLk5PVF9TRU5UKSB7XG4gICAgLy8gSWYgdGhlIFdlYlNvY2tldCBjbG9zaW5nIGhhbmRzaGFrZSBoYXMgbm90IHlldCBiZWVuIHN0YXJ0ZWRcbiAgICAvLyBTdGFydCB0aGUgV2ViU29ja2V0IGNsb3NpbmcgaGFuZHNoYWtlIGFuZCBzZXQgdGhpcydzIHJlYWR5XG4gICAgLy8gc3RhdGUgdG8gQ0xPU0lORyAoMikuXG4gICAgLy8gLSBJZiBuZWl0aGVyIGNvZGUgbm9yIHJlYXNvbiBpcyBwcmVzZW50LCB0aGUgV2ViU29ja2V0IENsb3NlXG4gICAgLy8gICBtZXNzYWdlIG11c3Qgbm90IGhhdmUgYSBib2R5LlxuICAgIC8vIC0gSWYgY29kZSBpcyBwcmVzZW50LCB0aGVuIHRoZSBzdGF0dXMgY29kZSB0byB1c2UgaW4gdGhlXG4gICAgLy8gICBXZWJTb2NrZXQgQ2xvc2UgbWVzc2FnZSBtdXN0IGJlIHRoZSBpbnRlZ2VyIGdpdmVuIGJ5IGNvZGUuXG4gICAgLy8gLSBJZiByZWFzb24gaXMgYWxzbyBwcmVzZW50LCB0aGVuIHJlYXNvbkJ5dGVzIG11c3QgYmVcbiAgICAvLyAgIHByb3ZpZGVkIGluIHRoZSBDbG9zZSBtZXNzYWdlIGFmdGVyIHRoZSBzdGF0dXMgY29kZS5cblxuICAgIHdzW2tTZW50Q2xvc2VdID0gc2VudENsb3NlRnJhbWVTdGF0ZS5QUk9DRVNTSU5HXG5cbiAgICBjb25zdCBmcmFtZSA9IG5ldyBXZWJzb2NrZXRGcmFtZVNlbmQoKVxuXG4gICAgLy8gSWYgbmVpdGhlciBjb2RlIG5vciByZWFzb24gaXMgcHJlc2VudCwgdGhlIFdlYlNvY2tldCBDbG9zZVxuICAgIC8vIG1lc3NhZ2UgbXVzdCBub3QgaGF2ZSBhIGJvZHkuXG5cbiAgICAvLyBJZiBjb2RlIGlzIHByZXNlbnQsIHRoZW4gdGhlIHN0YXR1cyBjb2RlIHRvIHVzZSBpbiB0aGVcbiAgICAvLyBXZWJTb2NrZXQgQ2xvc2UgbWVzc2FnZSBtdXN0IGJlIHRoZSBpbnRlZ2VyIGdpdmVuIGJ5IGNvZGUuXG4gICAgaWYgKGNvZGUgIT09IHVuZGVmaW5lZCAmJiByZWFzb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgZnJhbWUuZnJhbWVEYXRhID0gQnVmZmVyLmFsbG9jVW5zYWZlKDIpXG4gICAgICBmcmFtZS5mcmFtZURhdGEud3JpdGVVSW50MTZCRShjb2RlLCAwKVxuICAgIH0gZWxzZSBpZiAoY29kZSAhPT0gdW5kZWZpbmVkICYmIHJlYXNvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBJZiByZWFzb24gaXMgYWxzbyBwcmVzZW50LCB0aGVuIHJlYXNvbkJ5dGVzIG11c3QgYmVcbiAgICAgIC8vIHByb3ZpZGVkIGluIHRoZSBDbG9zZSBtZXNzYWdlIGFmdGVyIHRoZSBzdGF0dXMgY29kZS5cbiAgICAgIGZyYW1lLmZyYW1lRGF0YSA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgyICsgcmVhc29uQnl0ZUxlbmd0aClcbiAgICAgIGZyYW1lLmZyYW1lRGF0YS53cml0ZVVJbnQxNkJFKGNvZGUsIDApXG4gICAgICAvLyB0aGUgYm9keSBNQVkgY29udGFpbiBVVEYtOC1lbmNvZGVkIGRhdGEgd2l0aCB2YWx1ZSAvcmVhc29uL1xuICAgICAgZnJhbWUuZnJhbWVEYXRhLndyaXRlKHJlYXNvbiwgMiwgJ3V0Zi04JylcbiAgICB9IGVsc2Uge1xuICAgICAgZnJhbWUuZnJhbWVEYXRhID0gZW1wdHlCdWZmZXJcbiAgICB9XG5cbiAgICAvKiogQHR5cGUge2ltcG9ydCgnc3RyZWFtJykuRHVwbGV4fSAqL1xuICAgIGNvbnN0IHNvY2tldCA9IHdzW2tSZXNwb25zZV0uc29ja2V0XG5cbiAgICBzb2NrZXQud3JpdGUoZnJhbWUuY3JlYXRlRnJhbWUob3Bjb2Rlcy5DTE9TRSkpXG5cbiAgICB3c1trU2VudENsb3NlXSA9IHNlbnRDbG9zZUZyYW1lU3RhdGUuU0VOVFxuXG4gICAgLy8gVXBvbiBlaXRoZXIgc2VuZGluZyBvciByZWNlaXZpbmcgYSBDbG9zZSBjb250cm9sIGZyYW1lLCBpdCBpcyBzYWlkXG4gICAgLy8gdGhhdCBfVGhlIFdlYlNvY2tldCBDbG9zaW5nIEhhbmRzaGFrZSBpcyBTdGFydGVkXyBhbmQgdGhhdCB0aGVcbiAgICAvLyBXZWJTb2NrZXQgY29ubmVjdGlvbiBpcyBpbiB0aGUgQ0xPU0lORyBzdGF0ZS5cbiAgICB3c1trUmVhZHlTdGF0ZV0gPSBzdGF0ZXMuQ0xPU0lOR1xuICB9IGVsc2Uge1xuICAgIC8vIE90aGVyd2lzZVxuICAgIC8vIFNldCB0aGlzJ3MgcmVhZHkgc3RhdGUgdG8gQ0xPU0lORyAoMikuXG4gICAgd3Nba1JlYWR5U3RhdGVdID0gc3RhdGVzLkNMT1NJTkdcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7QnVmZmVyfSBjaHVua1xuICovXG5mdW5jdGlvbiBvblNvY2tldERhdGEgKGNodW5rKSB7XG4gIGlmICghdGhpcy53c1trQnl0ZVBhcnNlcl0ud3JpdGUoY2h1bmspKSB7XG4gICAgdGhpcy5wYXVzZSgpXG4gIH1cbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vd2Vic29ja2V0cy5zcGVjLndoYXR3Zy5vcmcvI2ZlZWRiYWNrLWZyb20tdGhlLXByb3RvY29sXG4gKiBAc2VlIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvcmZjNjQ1NSNzZWN0aW9uLTcuMS40XG4gKi9cbmZ1bmN0aW9uIG9uU29ja2V0Q2xvc2UgKCkge1xuICBjb25zdCB7IHdzIH0gPSB0aGlzXG4gIGNvbnN0IHsgW2tSZXNwb25zZV06IHJlc3BvbnNlIH0gPSB3c1xuXG4gIHJlc3BvbnNlLnNvY2tldC5vZmYoJ2RhdGEnLCBvblNvY2tldERhdGEpXG4gIHJlc3BvbnNlLnNvY2tldC5vZmYoJ2Nsb3NlJywgb25Tb2NrZXRDbG9zZSlcbiAgcmVzcG9uc2Uuc29ja2V0Lm9mZignZXJyb3InLCBvblNvY2tldEVycm9yKVxuXG4gIC8vIElmIHRoZSBUQ1AgY29ubmVjdGlvbiB3YXMgY2xvc2VkIGFmdGVyIHRoZVxuICAvLyBXZWJTb2NrZXQgY2xvc2luZyBoYW5kc2hha2Ugd2FzIGNvbXBsZXRlZCwgdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uXG4gIC8vIGlzIHNhaWQgdG8gaGF2ZSBiZWVuIGNsb3NlZCBfY2xlYW5seV8uXG4gIGNvbnN0IHdhc0NsZWFuID0gd3Nba1NlbnRDbG9zZV0gPT09IHNlbnRDbG9zZUZyYW1lU3RhdGUuU0VOVCAmJiB3c1trUmVjZWl2ZWRDbG9zZV1cblxuICBsZXQgY29kZSA9IDEwMDVcbiAgbGV0IHJlYXNvbiA9ICcnXG5cbiAgY29uc3QgcmVzdWx0ID0gd3Nba0J5dGVQYXJzZXJdLmNsb3NpbmdJbmZvXG5cbiAgaWYgKHJlc3VsdCAmJiAhcmVzdWx0LmVycm9yKSB7XG4gICAgY29kZSA9IHJlc3VsdC5jb2RlID8/IDEwMDVcbiAgICByZWFzb24gPSByZXN1bHQucmVhc29uXG4gIH0gZWxzZSBpZiAoIXdzW2tSZWNlaXZlZENsb3NlXSkge1xuICAgIC8vIElmIF9UaGUgV2ViU29ja2V0XG4gICAgLy8gQ29ubmVjdGlvbiBpcyBDbG9zZWRfIGFuZCBubyBDbG9zZSBjb250cm9sIGZyYW1lIHdhcyByZWNlaXZlZCBieSB0aGVcbiAgICAvLyBlbmRwb2ludCAoc3VjaCBhcyBjb3VsZCBvY2N1ciBpZiB0aGUgdW5kZXJseWluZyB0cmFuc3BvcnQgY29ubmVjdGlvblxuICAgIC8vIGlzIGxvc3QpLCBfVGhlIFdlYlNvY2tldCBDb25uZWN0aW9uIENsb3NlIENvZGVfIGlzIGNvbnNpZGVyZWQgdG8gYmVcbiAgICAvLyAxMDA2LlxuICAgIGNvZGUgPSAxMDA2XG4gIH1cblxuICAvLyAxLiBDaGFuZ2UgdGhlIHJlYWR5IHN0YXRlIHRvIENMT1NFRCAoMykuXG4gIHdzW2tSZWFkeVN0YXRlXSA9IHN0YXRlcy5DTE9TRURcblxuICAvLyAyLiBJZiB0aGUgdXNlciBhZ2VudCB3YXMgcmVxdWlyZWQgdG8gZmFpbCB0aGUgV2ViU29ja2V0XG4gIC8vICAgIGNvbm5lY3Rpb24sIG9yIGlmIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvbiB3YXMgY2xvc2VkXG4gIC8vICAgIGFmdGVyIGJlaW5nIGZsYWdnZWQgYXMgZnVsbCwgZmlyZSBhbiBldmVudCBuYW1lZCBlcnJvclxuICAvLyAgICBhdCB0aGUgV2ViU29ja2V0IG9iamVjdC5cbiAgLy8gVE9ET1xuXG4gIC8vIDMuIEZpcmUgYW4gZXZlbnQgbmFtZWQgY2xvc2UgYXQgdGhlIFdlYlNvY2tldCBvYmplY3QsXG4gIC8vICAgIHVzaW5nIENsb3NlRXZlbnQsIHdpdGggdGhlIHdhc0NsZWFuIGF0dHJpYnV0ZVxuICAvLyAgICBpbml0aWFsaXplZCB0byB0cnVlIGlmIHRoZSBjb25uZWN0aW9uIGNsb3NlZCBjbGVhbmx5XG4gIC8vICAgIGFuZCBmYWxzZSBvdGhlcndpc2UsIHRoZSBjb2RlIGF0dHJpYnV0ZSBpbml0aWFsaXplZCB0b1xuICAvLyAgICB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24gY2xvc2UgY29kZSwgYW5kIHRoZSByZWFzb25cbiAgLy8gICAgYXR0cmlidXRlIGluaXRpYWxpemVkIHRvIHRoZSByZXN1bHQgb2YgYXBwbHlpbmcgVVRGLThcbiAgLy8gICAgZGVjb2RlIHdpdGhvdXQgQk9NIHRvIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvbiBjbG9zZVxuICAvLyAgICByZWFzb24uXG4gIC8vIFRPRE86IHByb2Nlc3MubmV4dFRpY2tcbiAgZmlyZUV2ZW50KCdjbG9zZScsIHdzLCAodHlwZSwgaW5pdCkgPT4gbmV3IENsb3NlRXZlbnQodHlwZSwgaW5pdCksIHtcbiAgICB3YXNDbGVhbiwgY29kZSwgcmVhc29uXG4gIH0pXG5cbiAgaWYgKGNoYW5uZWxzLmNsb3NlLmhhc1N1YnNjcmliZXJzKSB7XG4gICAgY2hhbm5lbHMuY2xvc2UucHVibGlzaCh7XG4gICAgICB3ZWJzb2NrZXQ6IHdzLFxuICAgICAgY29kZSxcbiAgICAgIHJlYXNvblxuICAgIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gb25Tb2NrZXRFcnJvciAoZXJyb3IpIHtcbiAgY29uc3QgeyB3cyB9ID0gdGhpc1xuXG4gIHdzW2tSZWFkeVN0YXRlXSA9IHN0YXRlcy5DTE9TSU5HXG5cbiAgaWYgKGNoYW5uZWxzLnNvY2tldEVycm9yLmhhc1N1YnNjcmliZXJzKSB7XG4gICAgY2hhbm5lbHMuc29ja2V0RXJyb3IucHVibGlzaChlcnJvcilcbiAgfVxuXG4gIHRoaXMuZGVzdHJveSgpXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBlc3RhYmxpc2hXZWJTb2NrZXRDb25uZWN0aW9uLFxuICBjbG9zZVdlYlNvY2tldENvbm5lY3Rpb25cbn1cbiJdLCJuYW1lcyI6WyJ1aWQiLCJzdGF0ZXMiLCJzZW50Q2xvc2VGcmFtZVN0YXRlIiwiZW1wdHlCdWZmZXIiLCJvcGNvZGVzIiwicmVxdWlyZSIsImtSZWFkeVN0YXRlIiwia1NlbnRDbG9zZSIsImtCeXRlUGFyc2VyIiwia1JlY2VpdmVkQ2xvc2UiLCJrUmVzcG9uc2UiLCJmaXJlRXZlbnQiLCJmYWlsV2Vic29ja2V0Q29ubmVjdGlvbiIsImlzQ2xvc2luZyIsImlzQ2xvc2VkIiwiaXNFc3RhYmxpc2hlZCIsInBhcnNlRXh0ZW5zaW9ucyIsImNoYW5uZWxzIiwiQ2xvc2VFdmVudCIsIm1ha2VSZXF1ZXN0IiwiZmV0Y2hpbmciLCJIZWFkZXJzIiwiZ2V0SGVhZGVyc0xpc3QiLCJnZXREZWNvZGVTcGxpdCIsIldlYnNvY2tldEZyYW1lU2VuZCIsImNyeXB0byIsImVzdGFibGlzaFdlYlNvY2tldENvbm5lY3Rpb24iLCJ1cmwiLCJwcm90b2NvbHMiLCJjbGllbnQiLCJ3cyIsIm9uRXN0YWJsaXNoIiwib3B0aW9ucyIsInJlcXVlc3RVUkwiLCJwcm90b2NvbCIsInJlcXVlc3QiLCJ1cmxMaXN0Iiwic2VydmljZVdvcmtlcnMiLCJyZWZlcnJlciIsIm1vZGUiLCJjcmVkZW50aWFscyIsImNhY2hlIiwicmVkaXJlY3QiLCJoZWFkZXJzIiwiaGVhZGVyc0xpc3QiLCJrZXlWYWx1ZSIsInJhbmRvbUJ5dGVzIiwidG9TdHJpbmciLCJhcHBlbmQiLCJwZXJtZXNzYWdlRGVmbGF0ZSIsImNvbnRyb2xsZXIiLCJ1c2VQYXJhbGxlbFF1ZXVlIiwiZGlzcGF0Y2hlciIsInByb2Nlc3NSZXNwb25zZSIsInJlc3BvbnNlIiwidHlwZSIsInN0YXR1cyIsImxlbmd0aCIsImdldCIsInRvTG93ZXJDYXNlIiwic2VjV1NBY2NlcHQiLCJkaWdlc3QiLCJjcmVhdGVIYXNoIiwidXBkYXRlIiwic2VjRXh0ZW5zaW9uIiwiZXh0ZW5zaW9ucyIsImhhcyIsInNlY1Byb3RvY29sIiwicmVxdWVzdFByb3RvY29scyIsImluY2x1ZGVzIiwic29ja2V0Iiwib24iLCJvblNvY2tldERhdGEiLCJvblNvY2tldENsb3NlIiwib25Tb2NrZXRFcnJvciIsIm9wZW4iLCJoYXNTdWJzY3JpYmVycyIsInB1Ymxpc2giLCJhZGRyZXNzIiwiY2xvc2VXZWJTb2NrZXRDb25uZWN0aW9uIiwiY29kZSIsInJlYXNvbiIsInJlYXNvbkJ5dGVMZW5ndGgiLCJDTE9TSU5HIiwiTk9UX1NFTlQiLCJQUk9DRVNTSU5HIiwiZnJhbWUiLCJ1bmRlZmluZWQiLCJmcmFtZURhdGEiLCJCdWZmZXIiLCJhbGxvY1Vuc2FmZSIsIndyaXRlVUludDE2QkUiLCJ3cml0ZSIsImNyZWF0ZUZyYW1lIiwiQ0xPU0UiLCJTRU5UIiwiY2h1bmsiLCJwYXVzZSIsIm9mZiIsIndhc0NsZWFuIiwicmVzdWx0IiwiY2xvc2luZ0luZm8iLCJlcnJvciIsIkNMT1NFRCIsImluaXQiLCJjbG9zZSIsIndlYnNvY2tldCIsInNvY2tldEVycm9yIiwiZGVzdHJveSIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/websocket/connection.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/websocket/constants.js":
/*!************************************************************!*\
  !*** ./node_modules/undici/lib/web/websocket/constants.js ***!
  \************************************************************/
/***/ ((module) => {

eval("\n// This is a Globally Unique Identifier unique used\n// to validate that the endpoint accepts websocket\n// connections.\n// See https://www.rfc-editor.org/rfc/rfc6455.html#section-1.3\nconst uid = \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\";\n/** @type {PropertyDescriptor} */ const staticPropertyDescriptors = {\n    enumerable: true,\n    writable: false,\n    configurable: false\n};\nconst states = {\n    CONNECTING: 0,\n    OPEN: 1,\n    CLOSING: 2,\n    CLOSED: 3\n};\nconst sentCloseFrameState = {\n    NOT_SENT: 0,\n    PROCESSING: 1,\n    SENT: 2\n};\nconst opcodes = {\n    CONTINUATION: 0x0,\n    TEXT: 0x1,\n    BINARY: 0x2,\n    CLOSE: 0x8,\n    PING: 0x9,\n    PONG: 0xA\n};\nconst maxUnsigned16Bit = 2 ** 16 - 1; // 65535\nconst parserStates = {\n    INFO: 0,\n    PAYLOADLENGTH_16: 2,\n    PAYLOADLENGTH_64: 3,\n    READ_DATA: 4\n};\nconst emptyBuffer = Buffer.allocUnsafe(0);\nconst sendHints = {\n    string: 1,\n    typedArray: 2,\n    arrayBuffer: 3,\n    blob: 4\n};\nmodule.exports = {\n    uid,\n    sentCloseFrameState,\n    staticPropertyDescriptors,\n    states,\n    opcodes,\n    maxUnsigned16Bit,\n    parserStates,\n    emptyBuffer,\n    sendHints\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvd2Vic29ja2V0L2NvbnN0YW50cy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTUEsTUFBTTtBQUVaLGtDQUNBLE1BQU1DLDRCQUE0QjtJQUNoQ0MsWUFBWTtJQUNaQyxVQUFVO0lBQ1ZDLGNBQWM7QUFDaEI7QUFFQSxNQUFNQyxTQUFTO0lBQ2JDLFlBQVk7SUFDWkMsTUFBTTtJQUNOQyxTQUFTO0lBQ1RDLFFBQVE7QUFDVjtBQUVBLE1BQU1DLHNCQUFzQjtJQUMxQkMsVUFBVTtJQUNWQyxZQUFZO0lBQ1pDLE1BQU07QUFDUjtBQUVBLE1BQU1DLFVBQVU7SUFDZEMsY0FBYztJQUNkQyxNQUFNO0lBQ05DLFFBQVE7SUFDUkMsT0FBTztJQUNQQyxNQUFNO0lBQ05DLE1BQU07QUFDUjtBQUVBLE1BQU1DLG1CQUFtQixLQUFLLEtBQUssR0FBRTtBQUVyQyxNQUFNQyxlQUFlO0lBQ25CQyxNQUFNO0lBQ05DLGtCQUFrQjtJQUNsQkMsa0JBQWtCO0lBQ2xCQyxXQUFXO0FBQ2I7QUFFQSxNQUFNQyxjQUFjQyxPQUFPQyxXQUFXLENBQUM7QUFFdkMsTUFBTUMsWUFBWTtJQUNoQkMsUUFBUTtJQUNSQyxZQUFZO0lBQ1pDLGFBQWE7SUFDYkMsTUFBTTtBQUNSO0FBRUFDLE9BQU9DLE9BQU8sR0FBRztJQUNmcEM7SUFDQVU7SUFDQVQ7SUFDQUk7SUFDQVM7SUFDQU87SUFDQUM7SUFDQUs7SUFDQUc7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL21vY2t1cGZsb3cvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvd2Vic29ja2V0L2NvbnN0YW50cy5qcz8wNjk0Iiwid2VicGFjazovL21vY2t1cGZsb3cvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvd2Vic29ja2V0L2NvbnN0YW50cy5qcz8wNjk0KiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuLy8gVGhpcyBpcyBhIEdsb2JhbGx5IFVuaXF1ZSBJZGVudGlmaWVyIHVuaXF1ZSB1c2VkXG4vLyB0byB2YWxpZGF0ZSB0aGF0IHRoZSBlbmRwb2ludCBhY2NlcHRzIHdlYnNvY2tldFxuLy8gY29ubmVjdGlvbnMuXG4vLyBTZWUgaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzY0NTUuaHRtbCNzZWN0aW9uLTEuM1xuY29uc3QgdWlkID0gJzI1OEVBRkE1LUU5MTQtNDdEQS05NUNBLUM1QUIwREM4NUIxMSdcblxuLyoqIEB0eXBlIHtQcm9wZXJ0eURlc2NyaXB0b3J9ICovXG5jb25zdCBzdGF0aWNQcm9wZXJ0eURlc2NyaXB0b3JzID0ge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogZmFsc2UsXG4gIGNvbmZpZ3VyYWJsZTogZmFsc2Vcbn1cblxuY29uc3Qgc3RhdGVzID0ge1xuICBDT05ORUNUSU5HOiAwLFxuICBPUEVOOiAxLFxuICBDTE9TSU5HOiAyLFxuICBDTE9TRUQ6IDNcbn1cblxuY29uc3Qgc2VudENsb3NlRnJhbWVTdGF0ZSA9IHtcbiAgTk9UX1NFTlQ6IDAsXG4gIFBST0NFU1NJTkc6IDEsXG4gIFNFTlQ6IDJcbn1cblxuY29uc3Qgb3Bjb2RlcyA9IHtcbiAgQ09OVElOVUFUSU9OOiAweDAsXG4gIFRFWFQ6IDB4MSxcbiAgQklOQVJZOiAweDIsXG4gIENMT1NFOiAweDgsXG4gIFBJTkc6IDB4OSxcbiAgUE9ORzogMHhBXG59XG5cbmNvbnN0IG1heFVuc2lnbmVkMTZCaXQgPSAyICoqIDE2IC0gMSAvLyA2NTUzNVxuXG5jb25zdCBwYXJzZXJTdGF0ZXMgPSB7XG4gIElORk86IDAsXG4gIFBBWUxPQURMRU5HVEhfMTY6IDIsXG4gIFBBWUxPQURMRU5HVEhfNjQ6IDMsXG4gIFJFQURfREFUQTogNFxufVxuXG5jb25zdCBlbXB0eUJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgwKVxuXG5jb25zdCBzZW5kSGludHMgPSB7XG4gIHN0cmluZzogMSxcbiAgdHlwZWRBcnJheTogMixcbiAgYXJyYXlCdWZmZXI6IDMsXG4gIGJsb2I6IDRcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHVpZCxcbiAgc2VudENsb3NlRnJhbWVTdGF0ZSxcbiAgc3RhdGljUHJvcGVydHlEZXNjcmlwdG9ycyxcbiAgc3RhdGVzLFxuICBvcGNvZGVzLFxuICBtYXhVbnNpZ25lZDE2Qml0LFxuICBwYXJzZXJTdGF0ZXMsXG4gIGVtcHR5QnVmZmVyLFxuICBzZW5kSGludHNcbn1cbiJdLCJuYW1lcyI6WyJ1aWQiLCJzdGF0aWNQcm9wZXJ0eURlc2NyaXB0b3JzIiwiZW51bWVyYWJsZSIsIndyaXRhYmxlIiwiY29uZmlndXJhYmxlIiwic3RhdGVzIiwiQ09OTkVDVElORyIsIk9QRU4iLCJDTE9TSU5HIiwiQ0xPU0VEIiwic2VudENsb3NlRnJhbWVTdGF0ZSIsIk5PVF9TRU5UIiwiUFJPQ0VTU0lORyIsIlNFTlQiLCJvcGNvZGVzIiwiQ09OVElOVUFUSU9OIiwiVEVYVCIsIkJJTkFSWSIsIkNMT1NFIiwiUElORyIsIlBPTkciLCJtYXhVbnNpZ25lZDE2Qml0IiwicGFyc2VyU3RhdGVzIiwiSU5GTyIsIlBBWUxPQURMRU5HVEhfMTYiLCJQQVlMT0FETEVOR1RIXzY0IiwiUkVBRF9EQVRBIiwiZW1wdHlCdWZmZXIiLCJCdWZmZXIiLCJhbGxvY1Vuc2FmZSIsInNlbmRIaW50cyIsInN0cmluZyIsInR5cGVkQXJyYXkiLCJhcnJheUJ1ZmZlciIsImJsb2IiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/websocket/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/websocket/events.js":
/*!*********************************************************!*\
  !*** ./node_modules/undici/lib/web/websocket/events.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { webidl } = __webpack_require__(/*! ../fetch/webidl */ \"(ssr)/./node_modules/undici/lib/web/fetch/webidl.js\");\nconst { kEnumerableProperty } = __webpack_require__(/*! ../../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\");\nconst { kConstruct } = __webpack_require__(/*! ../../core/symbols */ \"(ssr)/./node_modules/undici/lib/core/symbols.js\");\nconst { MessagePort } = __webpack_require__(/*! node:worker_threads */ \"node:worker_threads\");\n/**\n * @see https://html.spec.whatwg.org/multipage/comms.html#messageevent\n */ class MessageEvent extends Event {\n    #eventInit;\n    constructor(type, eventInitDict = {}){\n        if (type === kConstruct) {\n            super(arguments[1], arguments[2]);\n            return;\n        }\n        const prefix = \"MessageEvent constructor\";\n        webidl.argumentLengthCheck(arguments, 1, prefix);\n        type = webidl.converters.DOMString(type, prefix, \"type\");\n        eventInitDict = webidl.converters.MessageEventInit(eventInitDict, prefix, \"eventInitDict\");\n        super(type, eventInitDict);\n        this.#eventInit = eventInitDict;\n    }\n    get data() {\n        webidl.brandCheck(this, MessageEvent);\n        return this.#eventInit.data;\n    }\n    get origin() {\n        webidl.brandCheck(this, MessageEvent);\n        return this.#eventInit.origin;\n    }\n    get lastEventId() {\n        webidl.brandCheck(this, MessageEvent);\n        return this.#eventInit.lastEventId;\n    }\n    get source() {\n        webidl.brandCheck(this, MessageEvent);\n        return this.#eventInit.source;\n    }\n    get ports() {\n        webidl.brandCheck(this, MessageEvent);\n        if (!Object.isFrozen(this.#eventInit.ports)) {\n            Object.freeze(this.#eventInit.ports);\n        }\n        return this.#eventInit.ports;\n    }\n    initMessageEvent(type, bubbles = false, cancelable = false, data = null, origin = \"\", lastEventId = \"\", source = null, ports = []) {\n        webidl.brandCheck(this, MessageEvent);\n        webidl.argumentLengthCheck(arguments, 1, \"MessageEvent.initMessageEvent\");\n        return new MessageEvent(type, {\n            bubbles,\n            cancelable,\n            data,\n            origin,\n            lastEventId,\n            source,\n            ports\n        });\n    }\n    static createFastMessageEvent(type, init) {\n        const messageEvent = new MessageEvent(kConstruct, type, init);\n        messageEvent.#eventInit = init;\n        messageEvent.#eventInit.data ??= null;\n        messageEvent.#eventInit.origin ??= \"\";\n        messageEvent.#eventInit.lastEventId ??= \"\";\n        messageEvent.#eventInit.source ??= null;\n        messageEvent.#eventInit.ports ??= [];\n        return messageEvent;\n    }\n}\nconst { createFastMessageEvent } = MessageEvent;\ndelete MessageEvent.createFastMessageEvent;\n/**\n * @see https://websockets.spec.whatwg.org/#the-closeevent-interface\n */ class CloseEvent extends Event {\n    #eventInit;\n    constructor(type, eventInitDict = {}){\n        const prefix = \"CloseEvent constructor\";\n        webidl.argumentLengthCheck(arguments, 1, prefix);\n        type = webidl.converters.DOMString(type, prefix, \"type\");\n        eventInitDict = webidl.converters.CloseEventInit(eventInitDict);\n        super(type, eventInitDict);\n        this.#eventInit = eventInitDict;\n    }\n    get wasClean() {\n        webidl.brandCheck(this, CloseEvent);\n        return this.#eventInit.wasClean;\n    }\n    get code() {\n        webidl.brandCheck(this, CloseEvent);\n        return this.#eventInit.code;\n    }\n    get reason() {\n        webidl.brandCheck(this, CloseEvent);\n        return this.#eventInit.reason;\n    }\n}\n// https://html.spec.whatwg.org/multipage/webappapis.html#the-errorevent-interface\nclass ErrorEvent extends Event {\n    #eventInit;\n    constructor(type, eventInitDict){\n        const prefix = \"ErrorEvent constructor\";\n        webidl.argumentLengthCheck(arguments, 1, prefix);\n        super(type, eventInitDict);\n        type = webidl.converters.DOMString(type, prefix, \"type\");\n        eventInitDict = webidl.converters.ErrorEventInit(eventInitDict ?? {});\n        this.#eventInit = eventInitDict;\n    }\n    get message() {\n        webidl.brandCheck(this, ErrorEvent);\n        return this.#eventInit.message;\n    }\n    get filename() {\n        webidl.brandCheck(this, ErrorEvent);\n        return this.#eventInit.filename;\n    }\n    get lineno() {\n        webidl.brandCheck(this, ErrorEvent);\n        return this.#eventInit.lineno;\n    }\n    get colno() {\n        webidl.brandCheck(this, ErrorEvent);\n        return this.#eventInit.colno;\n    }\n    get error() {\n        webidl.brandCheck(this, ErrorEvent);\n        return this.#eventInit.error;\n    }\n}\nObject.defineProperties(MessageEvent.prototype, {\n    [Symbol.toStringTag]: {\n        value: \"MessageEvent\",\n        configurable: true\n    },\n    data: kEnumerableProperty,\n    origin: kEnumerableProperty,\n    lastEventId: kEnumerableProperty,\n    source: kEnumerableProperty,\n    ports: kEnumerableProperty,\n    initMessageEvent: kEnumerableProperty\n});\nObject.defineProperties(CloseEvent.prototype, {\n    [Symbol.toStringTag]: {\n        value: \"CloseEvent\",\n        configurable: true\n    },\n    reason: kEnumerableProperty,\n    code: kEnumerableProperty,\n    wasClean: kEnumerableProperty\n});\nObject.defineProperties(ErrorEvent.prototype, {\n    [Symbol.toStringTag]: {\n        value: \"ErrorEvent\",\n        configurable: true\n    },\n    message: kEnumerableProperty,\n    filename: kEnumerableProperty,\n    lineno: kEnumerableProperty,\n    colno: kEnumerableProperty,\n    error: kEnumerableProperty\n});\nwebidl.converters.MessagePort = webidl.interfaceConverter(MessagePort);\nwebidl.converters[\"sequence<MessagePort>\"] = webidl.sequenceConverter(webidl.converters.MessagePort);\nconst eventInit = [\n    {\n        key: \"bubbles\",\n        converter: webidl.converters.boolean,\n        defaultValue: ()=>false\n    },\n    {\n        key: \"cancelable\",\n        converter: webidl.converters.boolean,\n        defaultValue: ()=>false\n    },\n    {\n        key: \"composed\",\n        converter: webidl.converters.boolean,\n        defaultValue: ()=>false\n    }\n];\nwebidl.converters.MessageEventInit = webidl.dictionaryConverter([\n    ...eventInit,\n    {\n        key: \"data\",\n        converter: webidl.converters.any,\n        defaultValue: ()=>null\n    },\n    {\n        key: \"origin\",\n        converter: webidl.converters.USVString,\n        defaultValue: ()=>\"\"\n    },\n    {\n        key: \"lastEventId\",\n        converter: webidl.converters.DOMString,\n        defaultValue: ()=>\"\"\n    },\n    {\n        key: \"source\",\n        // Node doesn't implement WindowProxy or ServiceWorker, so the only\n        // valid value for source is a MessagePort.\n        converter: webidl.nullableConverter(webidl.converters.MessagePort),\n        defaultValue: ()=>null\n    },\n    {\n        key: \"ports\",\n        converter: webidl.converters[\"sequence<MessagePort>\"],\n        defaultValue: ()=>new Array(0)\n    }\n]);\nwebidl.converters.CloseEventInit = webidl.dictionaryConverter([\n    ...eventInit,\n    {\n        key: \"wasClean\",\n        converter: webidl.converters.boolean,\n        defaultValue: ()=>false\n    },\n    {\n        key: \"code\",\n        converter: webidl.converters[\"unsigned short\"],\n        defaultValue: ()=>0\n    },\n    {\n        key: \"reason\",\n        converter: webidl.converters.USVString,\n        defaultValue: ()=>\"\"\n    }\n]);\nwebidl.converters.ErrorEventInit = webidl.dictionaryConverter([\n    ...eventInit,\n    {\n        key: \"message\",\n        converter: webidl.converters.DOMString,\n        defaultValue: ()=>\"\"\n    },\n    {\n        key: \"filename\",\n        converter: webidl.converters.USVString,\n        defaultValue: ()=>\"\"\n    },\n    {\n        key: \"lineno\",\n        converter: webidl.converters[\"unsigned long\"],\n        defaultValue: ()=>0\n    },\n    {\n        key: \"colno\",\n        converter: webidl.converters[\"unsigned long\"],\n        defaultValue: ()=>0\n    },\n    {\n        key: \"error\",\n        converter: webidl.converters.any\n    }\n]);\nmodule.exports = {\n    MessageEvent,\n    CloseEvent,\n    ErrorEvent,\n    createFastMessageEvent\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvd2Vic29ja2V0L2V2ZW50cy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU0sRUFBRUEsTUFBQUEsRUFBUSxHQUFHQyxtQkFBT0EsQ0FBQztBQUMzQixNQUFNLEVBQUVDLG1CQUFBQSxFQUFxQixHQUFHRCxtQkFBT0EsQ0FBQztBQUN4QyxNQUFNLEVBQUVFLFVBQUFBLEVBQVksR0FBR0YsbUJBQU9BLENBQUM7QUFDL0IsTUFBTSxFQUFFRyxXQUFBQSxFQUFhLEdBQUdILG1CQUFPQSxDQUFDO0FBRWhDOztDQUVBLEdBQ0EsTUFBTUkscUJBQXFCQztJQUN6QixDQUFDQyxTQUFTO0lBRVZDLFlBQWFDLElBQUksRUFBRUMsZ0JBQWdCLENBQUMsQ0FBQyxDQUFFO1FBQ3JDLElBQUlELFNBQVNOLFlBQVk7WUFDdkIsS0FBSyxDQUFDUSxTQUFTLENBQUMsRUFBRSxFQUFFQSxTQUFTLENBQUMsRUFBRTtZQUNoQztRQUNGO1FBRUEsTUFBTUMsU0FBUztRQUNmWixPQUFPYSxtQkFBbUIsQ0FBQ0YsV0FBVyxHQUFHQztRQUV6Q0gsT0FBT1QsT0FBT2MsVUFBVSxDQUFDQyxTQUFTLENBQUNOLE1BQU1HLFFBQVE7UUFDakRGLGdCQUFnQlYsT0FBT2MsVUFBVSxDQUFDRSxnQkFBZ0IsQ0FBQ04sZUFBZUUsUUFBUTtRQUUxRSxLQUFLLENBQUNILE1BQU1DO1FBRVosSUFBSSxDQUFDLENBQUNILFNBQVMsR0FBR0c7SUFDcEI7SUFFQSxJQUFJTyxPQUFRO1FBQ1ZqQixPQUFPa0IsVUFBVSxDQUFDLElBQUksRUFBRWI7UUFFeEIsT0FBTyxJQUFJLENBQUMsQ0FBQ0UsU0FBUyxDQUFDVSxJQUFJO0lBQzdCO0lBRUEsSUFBSUUsU0FBVTtRQUNabkIsT0FBT2tCLFVBQVUsQ0FBQyxJQUFJLEVBQUViO1FBRXhCLE9BQU8sSUFBSSxDQUFDLENBQUNFLFNBQVMsQ0FBQ1ksTUFBTTtJQUMvQjtJQUVBLElBQUlDLGNBQWU7UUFD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QUFDLGdCQUFnQjtRQUM3Q3lDLGNBQWNBLElBQU07SUFDdEI7SUFDQTtRQUNFSCxLQUFLO1FBQ0xDLFdBQVdyRCxPQUFPYyxVQUFVLENBQUMsZ0JBQWdCO1FBQzdDeUMsY0FBY0EsSUFBTTtJQUN0QjtJQUNBO1FBQ0VILEtBQUs7UUFDTEMsV0FBV3JELE9BQU9jLFVBQVUsQ0FBQzJDLEdBQUFBO0lBQy9CO0NBQ0Q7QUFFREksT0FBT0MsT0FBTyxHQUFHO0lBQ2Z6RDtJQUNBMkI7SUFDQUs7SUFDQVI7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL21vY2t1cGZsb3cvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvd2Vic29ja2V0L2V2ZW50cy5qcz9lMTQ5Iiwid2VicGFjazovL21vY2t1cGZsb3cvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvd2Vic29ja2V0L2V2ZW50cy5qcz9lMTQ5KiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyB3ZWJpZGwgfSA9IHJlcXVpcmUoJy4uL2ZldGNoL3dlYmlkbCcpXG5jb25zdCB7IGtFbnVtZXJhYmxlUHJvcGVydHkgfSA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvdXRpbCcpXG5jb25zdCB7IGtDb25zdHJ1Y3QgfSA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvc3ltYm9scycpXG5jb25zdCB7IE1lc3NhZ2VQb3J0IH0gPSByZXF1aXJlKCdub2RlOndvcmtlcl90aHJlYWRzJylcblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2NvbW1zLmh0bWwjbWVzc2FnZWV2ZW50XG4gKi9cbmNsYXNzIE1lc3NhZ2VFdmVudCBleHRlbmRzIEV2ZW50IHtcbiAgI2V2ZW50SW5pdFxuXG4gIGNvbnN0cnVjdG9yICh0eXBlLCBldmVudEluaXREaWN0ID0ge30pIHtcbiAgICBpZiAodHlwZSA9PT0ga0NvbnN0cnVjdCkge1xuICAgICAgc3VwZXIoYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0pXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCBwcmVmaXggPSAnTWVzc2FnZUV2ZW50IGNvbnN0cnVjdG9yJ1xuICAgIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMSwgcHJlZml4KVxuXG4gICAgdHlwZSA9IHdlYmlkbC5jb252ZXJ0ZXJzLkRPTVN0cmluZyh0eXBlLCBwcmVmaXgsICd0eXBlJylcbiAgICBldmVudEluaXREaWN0ID0gd2ViaWRsLmNvbnZlcnRlcnMuTWVzc2FnZUV2ZW50SW5pdChldmVudEluaXREaWN0LCBwcmVmaXgsICdldmVudEluaXREaWN0JylcblxuICAgIHN1cGVyKHR5cGUsIGV2ZW50SW5pdERpY3QpXG5cbiAgICB0aGlzLiNldmVudEluaXQgPSBldmVudEluaXREaWN0XG4gIH1cblxuICBnZXQgZGF0YSAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgTWVzc2FnZUV2ZW50KVxuXG4gICAgcmV0dXJuIHRoaXMuI2V2ZW50SW5pdC5kYXRhXG4gIH1cblxuICBnZXQgb3JpZ2luICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBNZXNzYWdlRXZlbnQpXG5cbiAgICByZXR1cm4gdGhpcy4jZXZlbnRJbml0Lm9yaWdpblxuICB9XG5cbiAgZ2V0IGxhc3RFdmVudElkICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBNZXNzYWdlRXZlbnQpXG5cbiAgICByZXR1cm4gdGhpcy4jZXZlbnRJbml0Lmxhc3RFdmVudElkXG4gIH1cblxuICBnZXQgc291cmNlICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBNZXNzYWdlRXZlbnQpXG5cbiAgICByZXR1cm4gdGhpcy4jZXZlbnRJbml0LnNvdXJjZVxuICB9XG5cbiAgZ2V0IHBvcnRzICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBNZXNzYWdlRXZlbnQpXG5cbiAgICBpZiAoIU9iamVjdC5pc0Zyb3plbih0aGlzLiNldmVudEluaXQucG9ydHMpKSB7XG4gICAgICBPYmplY3QuZnJlZXplKHRoaXMuI2V2ZW50SW5pdC5wb3J0cylcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy4jZXZlbnRJbml0LnBvcnRzXG4gIH1cblxuICBpbml0TWVzc2FnZUV2ZW50IChcbiAgICB0eXBlLFxuICAgIGJ1YmJsZXMgPSBmYWxzZSxcbiAgICBjYW5jZWxhYmxlID0gZmFsc2UsXG4gICAgZGF0YSA9IG51bGwsXG4gICAgb3JpZ2luID0gJycsXG4gICAgbGFzdEV2ZW50SWQgPSAnJyxcbiAgICBzb3VyY2UgPSBudWxsLFxuICAgIHBvcnRzID0gW11cbiAgKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgTWVzc2FnZUV2ZW50KVxuXG4gICAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAxLCAnTWVzc2FnZUV2ZW50LmluaXRNZXNzYWdlRXZlbnQnKVxuXG4gICAgcmV0dXJuIG5ldyBNZXNzYWdlRXZlbnQodHlwZSwge1xuICAgICAgYnViYmxlcywgY2FuY2VsYWJsZSwgZGF0YSwgb3JpZ2luLCBsYXN0RXZlbnRJZCwgc291cmNlLCBwb3J0c1xuICAgIH0pXG4gIH1cblxuICBzdGF0aWMgY3JlYXRlRmFzdE1lc3NhZ2VFdmVudCAodHlwZSwgaW5pdCkge1xuICAgIGNvbnN0IG1lc3NhZ2VFdmVudCA9IG5ldyBNZXNzYWdlRXZlbnQoa0NvbnN0cnVjdCwgdHlwZSwgaW5pdClcbiAgICBtZXNzYWdlRXZlbnQuI2V2ZW50SW5pdCA9IGluaXRcbiAgICBtZXNzYWdlRXZlbnQuI2V2ZW50SW5pdC5kYXRhID8/PSBudWxsXG4gICAgbWVzc2FnZUV2ZW50LiNldmVudEluaXQub3JpZ2luID8/PSAnJ1xuICAgIG1lc3NhZ2VFdmVudC4jZXZlbnRJbml0Lmxhc3RFdmVudElkID8/PSAnJ1xuICAgIG1lc3NhZ2VFdmVudC4jZXZlbnRJbml0LnNvdXJjZSA/Pz0gbnVsbFxuICAgIG1lc3NhZ2VFdmVudC4jZXZlbnRJbml0LnBvcnRzID8/PSBbXVxuICAgIHJldHVybiBtZXNzYWdlRXZlbnRcbiAgfVxufVxuXG5jb25zdCB7IGNyZWF0ZUZhc3RNZXNzYWdlRXZlbnQgfSA9IE1lc3NhZ2VFdmVudFxuZGVsZXRlIE1lc3NhZ2VFdmVudC5jcmVhdGVGYXN0TWVzc2FnZUV2ZW50XG5cbi8qKlxuICogQHNlZSBodHRwczovL3dlYnNvY2tldHMuc3BlYy53aGF0d2cub3JnLyN0aGUtY2xvc2VldmVudC1pbnRlcmZhY2VcbiAqL1xuY2xhc3MgQ2xvc2VFdmVudCBleHRlbmRzIEV2ZW50IHtcbiAgI2V2ZW50SW5pdFxuXG4gIGNvbnN0cnVjdG9yICh0eXBlLCBldmVudEluaXREaWN0ID0ge30pIHtcbiAgICBjb25zdCBwcmVmaXggPSAnQ2xvc2VFdmVudCBjb25zdHJ1Y3RvcidcbiAgICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDEsIHByZWZpeClcblxuICAgIHR5cGUgPSB3ZWJpZGwuY29udmVydGVycy5ET01TdHJpbmcodHlwZSwgcHJlZml4LCAndHlwZScpXG4gICAgZXZlbnRJbml0RGljdCA9IHdlYmlkbC5jb252ZXJ0ZXJzLkNsb3NlRXZlbnRJbml0KGV2ZW50SW5pdERpY3QpXG5cbiAgICBzdXBlcih0eXBlLCBldmVudEluaXREaWN0KVxuXG4gICAgdGhpcy4jZXZlbnRJbml0ID0gZXZlbnRJbml0RGljdFxuICB9XG5cbiAgZ2V0IHdhc0NsZWFuICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBDbG9zZUV2ZW50KVxuXG4gICAgcmV0dXJuIHRoaXMuI2V2ZW50SW5pdC53YXNDbGVhblxuICB9XG5cbiAgZ2V0IGNvZGUgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIENsb3NlRXZlbnQpXG5cbiAgICByZXR1cm4gdGhpcy4jZXZlbnRJbml0LmNvZGVcbiAgfVxuXG4gIGdldCByZWFzb24gKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIENsb3NlRXZlbnQpXG5cbiAgICByZXR1cm4gdGhpcy4jZXZlbnRJbml0LnJlYXNvblxuICB9XG59XG5cbi8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3dlYmFwcGFwaXMuaHRtbCN0aGUtZXJyb3JldmVudC1pbnRlcmZhY2VcbmNsYXNzIEVycm9yRXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gICNldmVudEluaXRcblxuICBjb25zdHJ1Y3RvciAodHlwZSwgZXZlbnRJbml0RGljdCkge1xuICAgIGNvbnN0IHByZWZpeCA9ICdFcnJvckV2ZW50IGNvbnN0cnVjdG9yJ1xuICAgIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMSwgcHJlZml4KVxuXG4gICAgc3VwZXIodHlwZSwgZXZlbnRJbml0RGljdClcblxuICAgIHR5cGUgPSB3ZWJpZGwuY29udmVydGVycy5ET01TdHJpbmcodHlwZSwgcHJlZml4LCAndHlwZScpXG4gICAgZXZlbnRJbml0RGljdCA9IHdlYmlkbC5jb252ZXJ0ZXJzLkVycm9yRXZlbnRJbml0KGV2ZW50SW5pdERpY3QgPz8ge30pXG5cbiAgICB0aGlzLiNldmVudEluaXQgPSBldmVudEluaXREaWN0XG4gIH1cblxuICBnZXQgbWVzc2FnZSAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRXJyb3JFdmVudClcblxuICAgIHJldHVybiB0aGlzLiNldmVudEluaXQubWVzc2FnZVxuICB9XG5cbiAgZ2V0IGZpbGVuYW1lICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBFcnJvckV2ZW50KVxuXG4gICAgcmV0dXJuIHRoaXMuI2V2ZW50SW5pdC5maWxlbmFtZVxuICB9XG5cbiAgZ2V0IGxpbmVubyAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRXJyb3JFdmVudClcblxuICAgIHJldHVybiB0aGlzLiNldmVudEluaXQubGluZW5vXG4gIH1cblxuICBnZXQgY29sbm8gKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEVycm9yRXZlbnQpXG5cbiAgICByZXR1cm4gdGhpcy4jZXZlbnRJbml0LmNvbG5vXG4gIH1cblxuICBnZXQgZXJyb3IgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEVycm9yRXZlbnQpXG5cbiAgICByZXR1cm4gdGhpcy4jZXZlbnRJbml0LmVycm9yXG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoTWVzc2FnZUV2ZW50LnByb3RvdHlwZSwge1xuICBbU3ltYm9sLnRvU3RyaW5nVGFnXToge1xuICAgIHZhbHVlOiAnTWVzc2FnZUV2ZW50JyxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSxcbiAgZGF0YToga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgb3JpZ2luOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBsYXN0RXZlbnRJZDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgc291cmNlOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBwb3J0czoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgaW5pdE1lc3NhZ2VFdmVudDoga0VudW1lcmFibGVQcm9wZXJ0eVxufSlcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoQ2xvc2VFdmVudC5wcm90b3R5cGUsIHtcbiAgW1N5bWJvbC50b1N0cmluZ1RhZ106IHtcbiAgICB2YWx1ZTogJ0Nsb3NlRXZlbnQnLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9LFxuICByZWFzb246IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGNvZGU6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIHdhc0NsZWFuOiBrRW51bWVyYWJsZVByb3BlcnR5XG59KVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhFcnJvckV2ZW50LnByb3RvdHlwZSwge1xuICBbU3ltYm9sLnRvU3RyaW5nVGFnXToge1xuICAgIHZhbHVlOiAnRXJyb3JFdmVudCcsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0sXG4gIG1lc3NhZ2U6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGZpbGVuYW1lOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBsaW5lbm86IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGNvbG5vOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBlcnJvcjoga0VudW1lcmFibGVQcm9wZXJ0eVxufSlcblxud2ViaWRsLmNvbnZlcnRlcnMuTWVzc2FnZVBvcnQgPSB3ZWJpZGwuaW50ZXJmYWNlQ29udmVydGVyKE1lc3NhZ2VQb3J0KVxuXG53ZWJpZGwuY29udmVydGVyc1snc2VxdWVuY2U8TWVzc2FnZVBvcnQ+J10gPSB3ZWJpZGwuc2VxdWVuY2VDb252ZXJ0ZXIoXG4gIHdlYmlkbC5jb252ZXJ0ZXJzLk1lc3NhZ2VQb3J0XG4pXG5cbmNvbnN0IGV2ZW50SW5pdCA9IFtcbiAge1xuICAgIGtleTogJ2J1YmJsZXMnLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuYm9vbGVhbixcbiAgICBkZWZhdWx0VmFsdWU6ICgpID0+IGZhbHNlXG4gIH0sXG4gIHtcbiAgICBrZXk6ICdjYW5jZWxhYmxlJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLmJvb2xlYW4sXG4gICAgZGVmYXVsdFZhbHVlOiAoKSA9PiBmYWxzZVxuICB9LFxuICB7XG4gICAga2V5OiAnY29tcG9zZWQnLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuYm9vbGVhbixcbiAgICBkZWZhdWx0VmFsdWU6ICgpID0+IGZhbHNlXG4gIH1cbl1cblxud2ViaWRsLmNvbnZlcnRlcnMuTWVzc2FnZUV2ZW50SW5pdCA9IHdlYmlkbC5kaWN0aW9uYXJ5Q29udmVydGVyKFtcbiAgLi4uZXZlbnRJbml0LFxuICB7XG4gICAga2V5OiAnZGF0YScsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5hbnksXG4gICAgZGVmYXVsdFZhbHVlOiAoKSA9PiBudWxsXG4gIH0sXG4gIHtcbiAgICBrZXk6ICdvcmlnaW4nLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuVVNWU3RyaW5nLFxuICAgIGRlZmF1bHRWYWx1ZTogKCkgPT4gJydcbiAgfSxcbiAge1xuICAgIGtleTogJ2xhc3RFdmVudElkJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLkRPTVN0cmluZyxcbiAgICBkZWZhdWx0VmFsdWU6ICgpID0+ICcnXG4gIH0sXG4gIHtcbiAgICBrZXk6ICdzb3VyY2UnLFxuICAgIC8vIE5vZGUgZG9lc24ndCBpbXBsZW1lbnQgV2luZG93UHJveHkgb3IgU2VydmljZVdvcmtlciwgc28gdGhlIG9ubHlcbiAgICAvLyB2YWxpZCB2YWx1ZSBmb3Igc291cmNlIGlzIGEgTWVzc2FnZVBvcnQuXG4gICAgY29udmVydGVyOiB3ZWJpZGwubnVsbGFibGVDb252ZXJ0ZXIod2ViaWRsLmNvbnZlcnRlcnMuTWVzc2FnZVBvcnQpLFxuICAgIGRlZmF1bHRWYWx1ZTogKCkgPT4gbnVsbFxuICB9LFxuICB7XG4gICAga2V5OiAncG9ydHMnLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnNbJ3NlcXVlbmNlPE1lc3NhZ2VQb3J0PiddLFxuICAgIGRlZmF1bHRWYWx1ZTogKCkgPT4gbmV3IEFycmF5KDApXG4gIH1cbl0pXG5cbndlYmlkbC5jb252ZXJ0ZXJzLkNsb3NlRXZlbnRJbml0ID0gd2ViaWRsLmRpY3Rpb25hcnlDb252ZXJ0ZXIoW1xuICAuLi5ldmVudEluaXQsXG4gIHtcbiAgICBrZXk6ICd3YXNDbGVhbicsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5ib29sZWFuLFxuICAgIGRlZmF1bHRWYWx1ZTogKCkgPT4gZmFsc2VcbiAgfSxcbiAge1xuICAgIGtleTogJ2NvZGUnLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnNbJ3Vuc2lnbmVkIHNob3J0J10sXG4gICAgZGVmYXVsdFZhbHVlOiAoKSA9PiAwXG4gIH0sXG4gIHtcbiAgICBrZXk6ICdyZWFzb24nLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuVVNWU3RyaW5nLFxuICAgIGRlZmF1bHRWYWx1ZTogKCkgPT4gJydcbiAgfVxuXSlcblxud2ViaWRsLmNvbnZlcnRlcnMuRXJyb3JFdmVudEluaXQgPSB3ZWJpZGwuZGljdGlvbmFyeUNvbnZlcnRlcihbXG4gIC4uLmV2ZW50SW5pdCxcbiAge1xuICAgIGtleTogJ21lc3NhZ2UnLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuRE9NU3RyaW5nLFxuICAgIGRlZmF1bHRWYWx1ZTogKCkgPT4gJydcbiAgfSxcbiAge1xuICAgIGtleTogJ2ZpbGVuYW1lJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLlVTVlN0cmluZyxcbiAgICBkZWZhdWx0VmFsdWU6ICgpID0+ICcnXG4gIH0sXG4gIHtcbiAgICBrZXk6ICdsaW5lbm8nLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnNbJ3Vuc2lnbmVkIGxvbmcnXSxcbiAgICBkZWZhdWx0VmFsdWU6ICgpID0+IDBcbiAgfSxcbiAge1xuICAgIGtleTogJ2NvbG5vJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzWyd1bnNpZ25lZCBsb25nJ10sXG4gICAgZGVmYXVsdFZhbHVlOiAoKSA9PiAwXG4gIH0sXG4gIHtcbiAgICBrZXk6ICdlcnJvcicsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5hbnlcbiAgfVxuXSlcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIE1lc3NhZ2VFdmVudCxcbiAgQ2xvc2VFdmVudCxcbiAgRXJyb3JFdmVudCxcbiAgY3JlYXRlRmFzdE1lc3NhZ2VFdmVudFxufVxuIl0sIm5hbWVzIjpbIndlYmlkbCIsInJlcXVpcmUiLCJrRW51bWVyYWJsZVByb3BlcnR5Iiwia0NvbnN0cnVjdCIsIk1lc3NhZ2VQb3J0IiwiTWVzc2FnZUV2ZW50IiwiRXZlbnQiLCJldmVudEluaXQiLCJjb25zdHJ1Y3RvciIsInR5cGUiLCJldmVudEluaXREaWN0IiwiYXJndW1lbnRzIiwicHJlZml4IiwiYXJndW1lbnRMZW5ndGhDaGVjayIsImNvbnZlcnRlcnMiLCJET01TdHJpbmciLCJNZXNzYWdlRXZlbnRJbml0IiwiZGF0YSIsImJyYW5kQ2hlY2siLCJvcmlnaW4iLCJsYXN0RXZlbnRJZCIsInNvdXJjZSIsInBvcnRzIiwiT2JqZWN0IiwiaXNGcm96ZW4iLCJmcmVlemUiLCJpbml0TWVzc2FnZUV2ZW50IiwiYnViYmxlcyIsImNhbmNlbGFibGUiLCJjcmVhdGVGYXN0TWVzc2FnZUV2ZW50IiwiaW5pdCIsIm1lc3NhZ2VFdmVudCIsIkNsb3NlRXZlbnQiLCJDbG9zZUV2ZW50SW5pdCIsIndhc0NsZWFuIiwiY29kZSIsInJlYXNvbiIsIkVycm9yRXZlbnQiLCJFcnJvckV2ZW50SW5pdCIsIm1lc3NhZ2UiLCJmaWxlbmFtZSIsImxpbmVubyIsImNvbG5vIiwiZXJyb3IiLCJkZWZpbmVQcm9wZXJ0aWVzIiwicHJvdG90eXBlIiwiU3ltYm9sIiwidG9TdHJpbmdUYWciLCJ2YWx1ZSIsImNvbmZpZ3VyYWJsZSIsImludGVyZmFjZUNvbnZlcnRlciIsInNlcXVlbmNlQ29udmVydGVyIiwia2V5IiwiY29udmVydGVyIiwiYm9vbGVhbiIsImRlZmF1bHRWYWx1ZSIsImRpY3Rpb25hcnlDb252ZXJ0ZXIiLCJhbnkiLCJVU1ZTdHJpbmciLCJudWxsYWJsZUNvbnZlcnRlciIsIkFycmF5IiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/websocket/events.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/websocket/frame.js":
/*!********************************************************!*\
  !*** ./node_modules/undici/lib/web/websocket/frame.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { maxUnsigned16Bit } = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/undici/lib/web/websocket/constants.js\");\nconst BUFFER_SIZE = 16386;\n/** @type {import('crypto')} */ let crypto;\nlet buffer = null;\nlet bufIdx = BUFFER_SIZE;\ntry {\n    crypto = __webpack_require__(/*! node:crypto */ \"node:crypto\");\n/* c8 ignore next 3 */ } catch  {\n    crypto = {\n        // not full compatibility, but minimum.\n        randomFillSync: function randomFillSync(buffer, _offset, _size) {\n            for(let i = 0; i < buffer.length; ++i){\n                buffer[i] = Math.random() * 255 | 0;\n            }\n            return buffer;\n        }\n    };\n}\nfunction generateMask() {\n    if (bufIdx === BUFFER_SIZE) {\n        bufIdx = 0;\n        crypto.randomFillSync(buffer ??= Buffer.allocUnsafe(BUFFER_SIZE), 0, BUFFER_SIZE);\n    }\n    return [\n        buffer[bufIdx++],\n        buffer[bufIdx++],\n        buffer[bufIdx++],\n        buffer[bufIdx++]\n    ];\n}\nclass WebsocketFrameSend {\n    /**\n   * @param {Buffer|undefined} data\n   */ constructor(data){\n        this.frameData = data;\n    }\n    createFrame(opcode) {\n        const frameData = this.frameData;\n        const maskKey = generateMask();\n        const bodyLength = frameData?.byteLength ?? 0;\n        /** @type {number} */ let payloadLength = bodyLength; // 0-125\n        let offset = 6;\n        if (bodyLength > maxUnsigned16Bit) {\n            offset += 8; // payload length is next 8 bytes\n            payloadLength = 127;\n        } else if (bodyLength > 125) {\n            offset += 2; // payload length is next 2 bytes\n            payloadLength = 126;\n        }\n        const buffer = Buffer.allocUnsafe(bodyLength + offset);\n        // Clear first 2 bytes, everything else is overwritten\n        buffer[0] = buffer[1] = 0;\n        buffer[0] |= 0x80; // FIN\n        buffer[0] = (buffer[0] & 0xF0) + opcode; // opcode\n        /*! ws. MIT License. Einar Otto Stangvik <einaros@gmail.com> */ buffer[offset - 4] = maskKey[0];\n        buffer[offset - 3] = maskKey[1];\n        buffer[offset - 2] = maskKey[2];\n        buffer[offset - 1] = maskKey[3];\n        buffer[1] = payloadLength;\n        if (payloadLength === 126) {\n            buffer.writeUInt16BE(bodyLength, 2);\n        } else if (payloadLength === 127) {\n            // Clear extended payload length\n            buffer[2] = buffer[3] = 0;\n            buffer.writeUIntBE(bodyLength, 4, 6);\n        }\n        buffer[1] |= 0x80; // MASK\n        // mask body\n        for(let i = 0; i < bodyLength; ++i){\n            buffer[offset + i] = frameData[i] ^ maskKey[i & 3];\n        }\n        return buffer;\n    }\n}\nmodule.exports = {\n    WebsocketFrameSend\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvd2Vic29ja2V0L2ZyYW1lLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTSxFQUFFQSxnQkFBQUEsRUFBa0IsR0FBR0MsbUJBQU9BLENBQUM7QUFFckMsTUFBTUMsY0FBYztBQUVwQixnQ0FDQSxJQUFJQztBQUNKLElBQUlDLFNBQVM7QUFDYixJQUFJQyxTQUFTSDtBQUViLElBQUk7SUFDRkMsU0FBU0YsbUJBQU9BLENBQUM7QUFDbkIsdUJBQ0EsRUFBRSxPQUFNO0lBQ05FLFNBQVM7UUFDUDtRQUNBRyxnQkFBZ0IsU0FBU0EsZUFBZ0JGLE1BQU0sRUFBRUcsT0FBTyxFQUFFQyxLQUFLO1lBQzdELElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJTCxPQUFPTSxNQUFNLEVBQUUsRUFBRUQsRUFBRztnQkFDdENMLE1BQU0sQ0FBQ0ssRUFBRSxHQUFHRSxLQUFLQyxNQUFNLEtBQUssTUFBTTtZQUNwQztZQUNBLE9BQU9SO1FBQ1Q7SUFDRjtBQUNGO0FBRUEsU0FBU1M7SUFDUCxJQUFJUixXQUFXSCxhQUFhO1FBQzFCRyxTQUFTO1FBQ1RGLE9BQU9HLGNBQWMsQ0FBRUYsV0FBV1UsT0FBT0MsV0FBVyxDQUFDYixjQUFlLEdBQUdBO0lBQ3pFO0lBQ0EsT0FBTztRQUFDRSxNQUFNLENBQUNDLFNBQVM7UUFBRUQsTUFBTSxDQUFDQyxTQUFTO1FBQUVELE1BQU0sQ0FBQ0MsU0FBUztRQUFFRCxNQUFNLENBQUNDLFNBQVM7S0FBQztBQUNqRjtBQUVBLE1BQU1XO0lBQ0o7O0dBRUYsR0FDRUMsWUFBYUMsSUFBSSxDQUFFO1FBQ2pCLElBQUksQ0FBQ0MsU0FBUyxHQUFHRDtJQUNuQjtJQUVBRSxZQUFhQyxNQUFNLEVBQUU7UUFDbkIsTUFBTUYsWUFBWSxJQUFJLENBQUNBLFNBQVM7UUFDaEMsTUFBTUcsVUFBVVQ7UUFDaEIsTUFBTVUsYUFBYUosV0FBV0ssY0FBYztRQUU1QyxzQkFDQSxJQUFJQyxnQkFBZ0JGLFlBQVc7UUFDL0IsSUFBSUcsU0FBUztRQUViLElBQUlILGFBQWF2QixrQkFBa0I7WUFDakMwQixVQUFVLEdBQUU7WUFDWkQsZ0JBQWdCO1FBQ2xCLE9BQU8sSUFBSUYsYUFBYSxLQUFLO1lBQzNCRyxVQUFVLEdBQUU7WUFDWkQsZ0JBQWdCO1FBQ2xCO1FBRUEsTUFBTXJCLFNBQVNVLE9BQU9DLFdBQVcsQ0FBQ1EsYUFBYUc7UUFFL0M7UUFDQXRCLE1BQU0sQ0FBQyxFQUFFLEdBQUdBLE1BQU0sQ0FBQyxFQUFFLEdBQUc7UUFDeEJBLE1BQU0sQ0FBQyxFQUFFLElBQUksTUFBSztRQUNsQkEsTUFBTSxDQUFDLEVBQUUsR0FBRyxDQUFDQSxNQUFNLENBQUMsRUFBRSxHQUFHLFFBQVFpQixRQUFPO1FBRXhDLGdFQUNBakIsTUFBTSxDQUFDc0IsU0FBUyxFQUFFLEdBQUdKLE9BQU8sQ0FBQyxFQUFFO1FBQy9CbEIsTUFBTSxDQUFDc0IsU0FBUyxFQUFFLEdBQUdKLE9BQU8sQ0FBQyxFQUFFO1FBQy9CbEIsTUFBTSxDQUFDc0IsU0FBUyxFQUFFLEdBQUdKLE9BQU8sQ0FBQyxFQUFFO1FBQy9CbEIsTUFBTSxDQUFDc0IsU0FBUyxFQUFFLEdBQUdKLE9BQU8sQ0FBQyxFQUFFO1FBRS9CbEIsTUFBTSxDQUFDLEVBQUUsR0FBR3FCO1FBRVosSUFBSUEsa0JBQWtCLEtBQUs7WUFDekJyQixPQUFPdUIsYUFBYSxDQUFDSixZQUFZO1FBQ25DLE9BQU8sSUFBSUUsa0JBQWtCLEtBQUs7WUFDaEM7WUFDQXJCLE1BQU0sQ0FBQyxFQUFFLEdBQUdBLE1BQU0sQ0FBQyxFQUFFLEdBQUc7WUFDeEJBLE9BQU93QixXQUFXLENBQUNMLFlBQVksR0FBRztRQUNwQztRQUVBbkIsTUFBTSxDQUFDLEVBQUUsSUFBSSxNQUFLO1FBRWxCO1FBQ0EsSUFBSyxJQUFJSyxJQUFJLEdBQUdBLElBQUljLFlBQVksRUFBRWQsRUFBRztZQUNuQ0wsTUFBTSxDQUFDc0IsU0FBU2pCLEVBQUUsR0FBR1UsU0FBUyxDQUFDVixFQUFFLEdBQUdhLE9BQU8sQ0FBQ2IsSUFBSSxFQUFFO1FBQ3BEO1FBRUEsT0FBT0w7SUFDVDtBQUNGO0FBRUF5QixPQUFPQyxPQUFPLEdBQUc7SUFDZmQ7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL21vY2t1cGZsb3cvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvd2Vic29ja2V0L2ZyYW1lLmpzPzlmYjgiLCJ3ZWJwYWNrOi8vbW9ja3VwZmxvdy8uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL3dlYi93ZWJzb2NrZXQvZnJhbWUuanM/OWZiOCoiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgbWF4VW5zaWduZWQxNkJpdCB9ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKVxuXG5jb25zdCBCVUZGRVJfU0laRSA9IDE2Mzg2XG5cbi8qKiBAdHlwZSB7aW1wb3J0KCdjcnlwdG8nKX0gKi9cbmxldCBjcnlwdG9cbmxldCBidWZmZXIgPSBudWxsXG5sZXQgYnVmSWR4ID0gQlVGRkVSX1NJWkVcblxudHJ5IHtcbiAgY3J5cHRvID0gcmVxdWlyZSgnbm9kZTpjcnlwdG8nKVxuLyogYzggaWdub3JlIG5leHQgMyAqL1xufSBjYXRjaCB7XG4gIGNyeXB0byA9IHtcbiAgICAvLyBub3QgZnVsbCBjb21wYXRpYmlsaXR5LCBidXQgbWluaW11bS5cbiAgICByYW5kb21GaWxsU3luYzogZnVuY3Rpb24gcmFuZG9tRmlsbFN5bmMgKGJ1ZmZlciwgX29mZnNldCwgX3NpemUpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnVmZmVyLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGJ1ZmZlcltpXSA9IE1hdGgucmFuZG9tKCkgKiAyNTUgfCAwXG4gICAgICB9XG4gICAgICByZXR1cm4gYnVmZmVyXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlTWFzayAoKSB7XG4gIGlmIChidWZJZHggPT09IEJVRkZFUl9TSVpFKSB7XG4gICAgYnVmSWR4ID0gMFxuICAgIGNyeXB0by5yYW5kb21GaWxsU3luYygoYnVmZmVyID8/PSBCdWZmZXIuYWxsb2NVbnNhZmUoQlVGRkVSX1NJWkUpKSwgMCwgQlVGRkVSX1NJWkUpXG4gIH1cbiAgcmV0dXJuIFtidWZmZXJbYnVmSWR4KytdLCBidWZmZXJbYnVmSWR4KytdLCBidWZmZXJbYnVmSWR4KytdLCBidWZmZXJbYnVmSWR4KytdXVxufVxuXG5jbGFzcyBXZWJzb2NrZXRGcmFtZVNlbmQge1xuICAvKipcbiAgICogQHBhcmFtIHtCdWZmZXJ8dW5kZWZpbmVkfSBkYXRhXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoZGF0YSkge1xuICAgIHRoaXMuZnJhbWVEYXRhID0gZGF0YVxuICB9XG5cbiAgY3JlYXRlRnJhbWUgKG9wY29kZSkge1xuICAgIGNvbnN0IGZyYW1lRGF0YSA9IHRoaXMuZnJhbWVEYXRhXG4gICAgY29uc3QgbWFza0tleSA9IGdlbmVyYXRlTWFzaygpXG4gICAgY29uc3QgYm9keUxlbmd0aCA9IGZyYW1lRGF0YT8uYnl0ZUxlbmd0aCA/PyAwXG5cbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICBsZXQgcGF5bG9hZExlbmd0aCA9IGJvZHlMZW5ndGggLy8gMC0xMjVcbiAgICBsZXQgb2Zmc2V0ID0gNlxuXG4gICAgaWYgKGJvZHlMZW5ndGggPiBtYXhVbnNpZ25lZDE2Qml0KSB7XG4gICAgICBvZmZzZXQgKz0gOCAvLyBwYXlsb2FkIGxlbmd0aCBpcyBuZXh0IDggYnl0ZXNcbiAgICAgIHBheWxvYWRMZW5ndGggPSAxMjdcbiAgICB9IGVsc2UgaWYgKGJvZHlMZW5ndGggPiAxMjUpIHtcbiAgICAgIG9mZnNldCArPSAyIC8vIHBheWxvYWQgbGVuZ3RoIGlzIG5leHQgMiBieXRlc1xuICAgICAgcGF5bG9hZExlbmd0aCA9IDEyNlxuICAgIH1cblxuICAgIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShib2R5TGVuZ3RoICsgb2Zmc2V0KVxuXG4gICAgLy8gQ2xlYXIgZmlyc3QgMiBieXRlcywgZXZlcnl0aGluZyBlbHNlIGlzIG92ZXJ3cml0dGVuXG4gICAgYnVmZmVyWzBdID0gYnVmZmVyWzFdID0gMFxuICAgIGJ1ZmZlclswXSB8PSAweDgwIC8vIEZJTlxuICAgIGJ1ZmZlclswXSA9IChidWZmZXJbMF0gJiAweEYwKSArIG9wY29kZSAvLyBvcGNvZGVcblxuICAgIC8qISB3cy4gTUlUIExpY2Vuc2UuIEVpbmFyIE90dG8gU3Rhbmd2aWsgPGVpbmFyb3NAZ21haWwuY29tPiAqL1xuICAgIGJ1ZmZlcltvZmZzZXQgLSA0XSA9IG1hc2tLZXlbMF1cbiAgICBidWZmZXJbb2Zmc2V0IC0gM10gPSBtYXNrS2V5WzFdXG4gICAgYnVmZmVyW29mZnNldCAtIDJdID0gbWFza0tleVsyXVxuICAgIGJ1ZmZlcltvZmZzZXQgLSAxXSA9IG1hc2tLZXlbM11cblxuICAgIGJ1ZmZlclsxXSA9IHBheWxvYWRMZW5ndGhcblxuICAgIGlmIChwYXlsb2FkTGVuZ3RoID09PSAxMjYpIHtcbiAgICAgIGJ1ZmZlci53cml0ZVVJbnQxNkJFKGJvZHlMZW5ndGgsIDIpXG4gICAgfSBlbHNlIGlmIChwYXlsb2FkTGVuZ3RoID09PSAxMjcpIHtcbiAgICAgIC8vIENsZWFyIGV4dGVuZGVkIHBheWxvYWQgbGVuZ3RoXG4gICAgICBidWZmZXJbMl0gPSBidWZmZXJbM10gPSAwXG4gICAgICBidWZmZXIud3JpdGVVSW50QkUoYm9keUxlbmd0aCwgNCwgNilcbiAgICB9XG5cbiAgICBidWZmZXJbMV0gfD0gMHg4MCAvLyBNQVNLXG5cbiAgICAvLyBtYXNrIGJvZHlcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJvZHlMZW5ndGg7ICsraSkge1xuICAgICAgYnVmZmVyW29mZnNldCArIGldID0gZnJhbWVEYXRhW2ldIF4gbWFza0tleVtpICYgM11cbiAgICB9XG5cbiAgICByZXR1cm4gYnVmZmVyXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdlYnNvY2tldEZyYW1lU2VuZFxufVxuIl0sIm5hbWVzIjpbIm1heFVuc2lnbmVkMTZCaXQiLCJyZXF1aXJlIiwiQlVGRkVSX1NJWkUiLCJjcnlwdG8iLCJidWZmZXIiLCJidWZJZHgiLCJyYW5kb21GaWxsU3luYyIsIl9vZmZzZXQiLCJfc2l6ZSIsImkiLCJsZW5ndGgiLCJNYXRoIiwicmFuZG9tIiwiZ2VuZXJhdGVNYXNrIiwiQnVmZmVyIiwiYWxsb2NVbnNhZmUiLCJXZWJzb2NrZXRGcmFtZVNlbmQiLCJjb25zdHJ1Y3RvciIsImRhdGEiLCJmcmFtZURhdGEiLCJjcmVhdGVGcmFtZSIsIm9wY29kZSIsIm1hc2tLZXkiLCJib2R5TGVuZ3RoIiwiYnl0ZUxlbmd0aCIsInBheWxvYWRMZW5ndGgiLCJvZmZzZXQiLCJ3cml0ZVVJbnQxNkJFIiwid3JpdGVVSW50QkUiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/websocket/frame.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/websocket/permessage-deflate.js":
/*!*********************************************************************!*\
  !*** ./node_modules/undici/lib/web/websocket/permessage-deflate.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { createInflateRaw, Z_DEFAULT_WINDOWBITS } = __webpack_require__(/*! node:zlib */ \"node:zlib\");\nconst { isValidClientWindowBits } = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/undici/lib/web/websocket/util.js\");\nconst tail = Buffer.from([\n    0x00,\n    0x00,\n    0xff,\n    0xff\n]);\nconst kBuffer = Symbol(\"kBuffer\");\nconst kLength = Symbol(\"kLength\");\nclass PerMessageDeflate {\n    /** @type {import('node:zlib').InflateRaw} */ #inflate;\n    #options;\n    constructor(extensions){\n        this.#options = {};\n        this.#options.serverNoContextTakeover = extensions.has(\"server_no_context_takeover\");\n        this.#options.serverMaxWindowBits = extensions.get(\"server_max_window_bits\");\n    }\n    decompress(chunk, fin, callback) {\n        // An endpoint uses the following algorithm to decompress a message.\n        // 1.  Append 4 octets of 0x00 0x00 0xff 0xff to the tail end of the\n        //     payload of the message.\n        // 2.  Decompress the resulting data using DEFLATE.\n        if (!this.#inflate) {\n            let windowBits = Z_DEFAULT_WINDOWBITS;\n            if (this.#options.serverMaxWindowBits) {\n                // empty values default to Z_DEFAULT_WINDOWBITS\n                if (!isValidClientWindowBits(this.#options.serverMaxWindowBits)) {\n                    callback(new Error(\"Invalid server_max_window_bits\"));\n                    return;\n                }\n                windowBits = Number.parseInt(this.#options.serverMaxWindowBits);\n            }\n            this.#inflate = createInflateRaw({\n                windowBits\n            });\n            this.#inflate[kBuffer] = [];\n            this.#inflate[kLength] = 0;\n            this.#inflate.on(\"data\", (data)=>{\n                this.#inflate[kBuffer].push(data);\n                this.#inflate[kLength] += data.length;\n            });\n            this.#inflate.on(\"error\", (err)=>{\n                this.#inflate = null;\n                callback(err);\n            });\n        }\n        this.#inflate.write(chunk);\n        if (fin) {\n            this.#inflate.write(tail);\n        }\n        this.#inflate.flush(()=>{\n            const full = Buffer.concat(this.#inflate[kBuffer], this.#inflate[kLength]);\n            this.#inflate[kBuffer].length = 0;\n            this.#inflate[kLength] = 0;\n            callback(null, full);\n        });\n    }\n}\nmodule.exports = {\n    PerMessageDeflate\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvd2Vic29ja2V0L3Blcm1lc3NhZ2UtZGVmbGF0ZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU0sRUFBRUEsZ0JBQWdCLEVBQUVDLG9CQUFBQSxFQUFzQixHQUFHQyxtQkFBT0EsQ0FBQztBQUMzRCxNQUFNLEVBQUVDLHVCQUFBQSxFQUF5QixHQUFHRCxtQkFBT0EsQ0FBQztBQUU1QyxNQUFNRSxPQUFPQyxPQUFPQyxJQUFJLENBQUM7SUFBQztJQUFNO0lBQU07SUFBTTtDQUFLO0FBQ2pELE1BQU1DLFVBQVVDLE9BQU87QUFDdkIsTUFBTUMsVUFBVUQsT0FBTztBQUV2QixNQUFNRTtJQUNKLDhDQUNBLENBQUNDLE9BQU87SUFFUixDQUFDQyxPQUFPLENBQUs7SUFFYkMsWUFBYUMsVUFBVSxDQUFFO2FBRnpCLENBQUNGLE9BQU8sR0FBRyxDQUFDO1FBR1YsSUFBSSxDQUFDLENBQUNBLE9BQU8sQ0FBQ0csdUJBQXVCLEdBQUdELFdBQVdFLEdBQUcsQ0FBQztRQUN2RCxJQUFJLENBQUMsQ0FBQ0osT0FBTyxDQUFDSyxtQkFBbUIsR0FBR0gsV0FBV0ksR0FBRyxDQUFDO0lBQ3JEO0lBRUFDLFdBQVlDLEtBQUssRUFBRUMsR0FBRyxFQUFFQyxRQUFRLEVBQUU7UUFDaEM7UUFDQTtRQUNBO1FBQ0E7UUFFQSxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUNYLE9BQU8sRUFBRTtZQUNsQixJQUFJWSxhQUFhdEI7WUFFakIsSUFBSSxJQUFJLENBQUMsQ0FBQ1csT0FBTyxDQUFDSyxtQkFBbUIsRUFBRTtnQkFBRTtnQkFDdkMsSUFBSSxDQUFDZCx3QkFBd0IsSUFBSSxDQUFDLENBQUNTLE9BQU8sQ0FBQ0ssbUJBQW1CLEdBQUc7b0JBQy9ESyxTQUFTLElBQUlFLE1BQU07b0JBQ25CO2dCQUNGO2dCQUVBRCxhQUFhRSxPQUFPQyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUNkLE9BQU8sQ0FBQ0ssbUJBQW1CO1lBQ2hFO1lBRUEsSUFBSSxDQUFDLENBQUNOLE9BQU8sR0FBR1gsaUJBQWlCO2dCQUFFdUI7WUFBVztZQUM5QyxJQUFJLENBQUMsQ0FBQ1osT0FBTyxDQUFDSixRQUFRLEdBQUcsRUFBRTtZQUMzQixJQUFJLENBQUMsQ0FBQ0ksT0FBTyxDQUFDRixRQUFRLEdBQUc7WUFFekIsSUFBSSxDQUFDLENBQUNFLE9BQU8sQ0FBQ2dCLEVBQUUsQ0FBQyxRQUFTQyxDQUFBQTtnQkFDeEIsSUFBSSxDQUFDLENBQUNqQixPQUFPLENBQUNKLFFBQVEsQ0FBQ3NCLElBQUksQ0FBQ0Q7Z0JBQzVCLElBQUksQ0FBQyxDQUFDakIsT0FBTyxDQUFDRixRQUFRLElBQUltQixLQUFLRSxNQUFNO1lBQ3ZDO1lBRUEsSUFBSSxDQUFDLENBQUNuQixPQUFPLENBQUNnQixFQUFFLENBQUMsU0FBVUksQ0FBQUE7Z0JBQ3pCLElBQUksQ0FBQyxDQUFDcEIsT0FBTyxHQUFHO2dCQUNoQlcsU0FBU1M7WUFDWDtRQUNGO1FBRUEsSUFBSSxDQUFDLENBQUNwQixPQUFPLENBQUNxQixLQUFLLENBQUNaO1FBQ3BCLElBQUlDLEtBQUs7WUFDUCxJQUFJLENBQUMsQ0FBQ1YsT0FBTyxDQUFDcUIsS0FBSyxDQUFDNUI7UUFDdEI7UUFFQSxJQUFJLENBQUMsQ0FBQ08sT0FBTyxDQUFDc0IsS0FBSyxDQUFDO1lBQ2xCLE1BQU1DLE9BQU83QixPQUFPOEIsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDeEIsT0FBTyxDQUFDSixRQUFRLEVBQUUsSUFBSSxDQUFDLENBQUNJLE9BQU8sQ0FBQ0YsUUFBUTtZQUV6RSxJQUFJLENBQUMsQ0FBQ0UsT0FBTyxDQUFDSixRQUFRLENBQUN1QixNQUFNLEdBQUc7WUFDaEMsSUFBSSxDQUFDLENBQUNuQixPQUFPLENBQUNGLFFBQVEsR0FBRztZQUV6QmEsU0FBUyxNQUFNWTtRQUNqQjtJQUNGO0FBQ0Y7QUFFQUUsT0FBT0MsT0FBTyxHQUFHO0lBQUUzQjtBQUFrQiIsInNvdXJjZXMiOlsid2VicGFjazovL21vY2t1cGZsb3cvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvd2Vic29ja2V0L3Blcm1lc3NhZ2UtZGVmbGF0ZS5qcz9mNDFmIiwid2VicGFjazovL21vY2t1cGZsb3cvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvd2Vic29ja2V0L3Blcm1lc3NhZ2UtZGVmbGF0ZS5qcz9mNDFmKiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyBjcmVhdGVJbmZsYXRlUmF3LCBaX0RFRkFVTFRfV0lORE9XQklUUyB9ID0gcmVxdWlyZSgnbm9kZTp6bGliJylcbmNvbnN0IHsgaXNWYWxpZENsaWVudFdpbmRvd0JpdHMgfSA9IHJlcXVpcmUoJy4vdXRpbCcpXG5cbmNvbnN0IHRhaWwgPSBCdWZmZXIuZnJvbShbMHgwMCwgMHgwMCwgMHhmZiwgMHhmZl0pXG5jb25zdCBrQnVmZmVyID0gU3ltYm9sKCdrQnVmZmVyJylcbmNvbnN0IGtMZW5ndGggPSBTeW1ib2woJ2tMZW5ndGgnKVxuXG5jbGFzcyBQZXJNZXNzYWdlRGVmbGF0ZSB7XG4gIC8qKiBAdHlwZSB7aW1wb3J0KCdub2RlOnpsaWInKS5JbmZsYXRlUmF3fSAqL1xuICAjaW5mbGF0ZVxuXG4gICNvcHRpb25zID0ge31cblxuICBjb25zdHJ1Y3RvciAoZXh0ZW5zaW9ucykge1xuICAgIHRoaXMuI29wdGlvbnMuc2VydmVyTm9Db250ZXh0VGFrZW92ZXIgPSBleHRlbnNpb25zLmhhcygnc2VydmVyX25vX2NvbnRleHRfdGFrZW92ZXInKVxuICAgIHRoaXMuI29wdGlvbnMuc2VydmVyTWF4V2luZG93Qml0cyA9IGV4dGVuc2lvbnMuZ2V0KCdzZXJ2ZXJfbWF4X3dpbmRvd19iaXRzJylcbiAgfVxuXG4gIGRlY29tcHJlc3MgKGNodW5rLCBmaW4sIGNhbGxiYWNrKSB7XG4gICAgLy8gQW4gZW5kcG9pbnQgdXNlcyB0aGUgZm9sbG93aW5nIGFsZ29yaXRobSB0byBkZWNvbXByZXNzIGEgbWVzc2FnZS5cbiAgICAvLyAxLiAgQXBwZW5kIDQgb2N0ZXRzIG9mIDB4MDAgMHgwMCAweGZmIDB4ZmYgdG8gdGhlIHRhaWwgZW5kIG9mIHRoZVxuICAgIC8vICAgICBwYXlsb2FkIG9mIHRoZSBtZXNzYWdlLlxuICAgIC8vIDIuICBEZWNvbXByZXNzIHRoZSByZXN1bHRpbmcgZGF0YSB1c2luZyBERUZMQVRFLlxuXG4gICAgaWYgKCF0aGlzLiNpbmZsYXRlKSB7XG4gICAgICBsZXQgd2luZG93Qml0cyA9IFpfREVGQVVMVF9XSU5ET1dCSVRTXG5cbiAgICAgIGlmICh0aGlzLiNvcHRpb25zLnNlcnZlck1heFdpbmRvd0JpdHMpIHsgLy8gZW1wdHkgdmFsdWVzIGRlZmF1bHQgdG8gWl9ERUZBVUxUX1dJTkRPV0JJVFNcbiAgICAgICAgaWYgKCFpc1ZhbGlkQ2xpZW50V2luZG93Qml0cyh0aGlzLiNvcHRpb25zLnNlcnZlck1heFdpbmRvd0JpdHMpKSB7XG4gICAgICAgICAgY2FsbGJhY2sobmV3IEVycm9yKCdJbnZhbGlkIHNlcnZlcl9tYXhfd2luZG93X2JpdHMnKSlcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIHdpbmRvd0JpdHMgPSBOdW1iZXIucGFyc2VJbnQodGhpcy4jb3B0aW9ucy5zZXJ2ZXJNYXhXaW5kb3dCaXRzKVxuICAgICAgfVxuXG4gICAgICB0aGlzLiNpbmZsYXRlID0gY3JlYXRlSW5mbGF0ZVJhdyh7IHdpbmRvd0JpdHMgfSlcbiAgICAgIHRoaXMuI2luZmxhdGVba0J1ZmZlcl0gPSBbXVxuICAgICAgdGhpcy4jaW5mbGF0ZVtrTGVuZ3RoXSA9IDBcblxuICAgICAgdGhpcy4jaW5mbGF0ZS5vbignZGF0YScsIChkYXRhKSA9PiB7XG4gICAgICAgIHRoaXMuI2luZmxhdGVba0J1ZmZlcl0ucHVzaChkYXRhKVxuICAgICAgICB0aGlzLiNpbmZsYXRlW2tMZW5ndGhdICs9IGRhdGEubGVuZ3RoXG4gICAgICB9KVxuXG4gICAgICB0aGlzLiNpbmZsYXRlLm9uKCdlcnJvcicsIChlcnIpID0+IHtcbiAgICAgICAgdGhpcy4jaW5mbGF0ZSA9IG51bGxcbiAgICAgICAgY2FsbGJhY2soZXJyKVxuICAgICAgfSlcbiAgICB9XG5cbiAgICB0aGlzLiNpbmZsYXRlLndyaXRlKGNodW5rKVxuICAgIGlmIChmaW4pIHtcbiAgICAgIHRoaXMuI2luZmxhdGUud3JpdGUodGFpbClcbiAgICB9XG5cbiAgICB0aGlzLiNpbmZsYXRlLmZsdXNoKCgpID0+IHtcbiAgICAgIGNvbnN0IGZ1bGwgPSBCdWZmZXIuY29uY2F0KHRoaXMuI2luZmxhdGVba0J1ZmZlcl0sIHRoaXMuI2luZmxhdGVba0xlbmd0aF0pXG5cbiAgICAgIHRoaXMuI2luZmxhdGVba0J1ZmZlcl0ubGVuZ3RoID0gMFxuICAgICAgdGhpcy4jaW5mbGF0ZVtrTGVuZ3RoXSA9IDBcblxuICAgICAgY2FsbGJhY2sobnVsbCwgZnVsbClcbiAgICB9KVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0geyBQZXJNZXNzYWdlRGVmbGF0ZSB9XG4iXSwibmFtZXMiOlsiY3JlYXRlSW5mbGF0ZVJhdyIsIlpfREVGQVVMVF9XSU5ET1dCSVRTIiwicmVxdWlyZSIsImlzVmFsaWRDbGllbnRXaW5kb3dCaXRzIiwidGFpbCIsIkJ1ZmZlciIsImZyb20iLCJrQnVmZmVyIiwiU3ltYm9sIiwia0xlbmd0aCIsIlBlck1lc3NhZ2VEZWZsYXRlIiwiaW5mbGF0ZSIsIm9wdGlvbnMiLCJjb25zdHJ1Y3RvciIsImV4dGVuc2lvbnMiLCJzZXJ2ZXJOb0NvbnRleHRUYWtlb3ZlciIsImhhcyIsInNlcnZlck1heFdpbmRvd0JpdHMiLCJnZXQiLCJkZWNvbXByZXNzIiwiY2h1bmsiLCJmaW4iLCJjYWxsYmFjayIsIndpbmRvd0JpdHMiLCJFcnJvciIsIk51bWJlciIsInBhcnNlSW50Iiwib24iLCJkYXRhIiwicHVzaCIsImxlbmd0aCIsImVyciIsIndyaXRlIiwiZmx1c2giLCJmdWxsIiwiY29uY2F0IiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/websocket/permessage-deflate.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/websocket/receiver.js":
/*!***********************************************************!*\
  !*** ./node_modules/undici/lib/web/websocket/receiver.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { Writable } = __webpack_require__(/*! node:stream */ \"node:stream\");\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\");\nconst { parserStates, opcodes, states, emptyBuffer, sentCloseFrameState } = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/undici/lib/web/websocket/constants.js\");\nconst { kReadyState, kSentClose, kResponse, kReceivedClose } = __webpack_require__(/*! ./symbols */ \"(ssr)/./node_modules/undici/lib/web/websocket/symbols.js\");\nconst { channels } = __webpack_require__(/*! ../../core/diagnostics */ \"(ssr)/./node_modules/undici/lib/core/diagnostics.js\");\nconst { isValidStatusCode, isValidOpcode, failWebsocketConnection, websocketMessageReceived, utf8Decode, isControlFrame, isTextBinaryFrame, isContinuationFrame } = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/undici/lib/web/websocket/util.js\");\nconst { WebsocketFrameSend } = __webpack_require__(/*! ./frame */ \"(ssr)/./node_modules/undici/lib/web/websocket/frame.js\");\nconst { closeWebSocketConnection } = __webpack_require__(/*! ./connection */ \"(ssr)/./node_modules/undici/lib/web/websocket/connection.js\");\nconst { PerMessageDeflate } = __webpack_require__(/*! ./permessage-deflate */ \"(ssr)/./node_modules/undici/lib/web/websocket/permessage-deflate.js\");\n// This code was influenced by ws released under the MIT license.\n// Copyright (c) 2011 Einar Otto Stangvik <einaros@gmail.com>\n// Copyright (c) 2013 Arnout Kazemier and contributors\n// Copyright (c) 2016 Luigi Pinca and contributors\nclass ByteParser extends Writable {\n    #buffers;\n    #byteOffset;\n    #loop;\n    #state;\n    #info;\n    #fragments;\n    /** @type {Map<string, PerMessageDeflate>} */ #extensions;\n    constructor(ws, extensions){\n        super();\n        this.#buffers = [];\n        this.#byteOffset = 0;\n        this.#loop = false;\n        this.#state = parserStates.INFO;\n        this.#info = {};\n        this.#fragments = [];\n        this.ws = ws;\n        this.#extensions = extensions == null ? new Map() : extensions;\n        if (this.#extensions.has(\"permessage-deflate\")) {\n            this.#extensions.set(\"permessage-deflate\", new PerMessageDeflate(extensions));\n        }\n    }\n    /**\n   * @param {Buffer} chunk\n   * @param {() => void} callback\n   */ _write(chunk, _, callback) {\n        this.#buffers.push(chunk);\n        this.#byteOffset += chunk.length;\n        this.#loop = true;\n        this.run(callback);\n    }\n    /**\n   * Runs whenever a new chunk is received.\n   * Callback is called whenever there are no more chunks buffering,\n   * or not enough bytes are buffered to parse.\n   */ run(callback) {\n        while(this.#loop){\n            if (this.#state === parserStates.INFO) {\n                // If there aren't enough bytes to parse the payload length, etc.\n                if (this.#byteOffset < 2) {\n                    return callback();\n                }\n                const buffer = this.consume(2);\n                const fin = (buffer[0] & 0x80) !== 0;\n                const opcode = buffer[0] & 0x0F;\n                const masked = (buffer[1] & 0x80) === 0x80;\n                const fragmented = !fin && opcode !== opcodes.CONTINUATION;\n                const payloadLength = buffer[1] & 0x7F;\n                const rsv1 = buffer[0] & 0x40;\n                const rsv2 = buffer[0] & 0x20;\n                const rsv3 = buffer[0] & 0x10;\n                if (!isValidOpcode(opcode)) {\n                    failWebsocketConnection(this.ws, \"Invalid opcode received\");\n                    return callback();\n                }\n                if (masked) {\n                    failWebsocketConnection(this.ws, \"Frame cannot be masked\");\n                    return callback();\n                }\n                // MUST be 0 unless an extension is negotiated that defines meanings\n                // for non-zero values.  If a nonzero value is received and none of\n                // the negotiated extensions defines the meaning of such a nonzero\n                // value, the receiving endpoint MUST _Fail the WebSocket\n                // Connection_.\n                // This document allocates the RSV1 bit of the WebSocket header for\n                // PMCEs and calls the bit the \"Per-Message Compressed\" bit.  On a\n                // WebSocket connection where a PMCE is in use, this bit indicates\n                // whether a message is compressed or not.\n                if (rsv1 !== 0 && !this.#extensions.has(\"permessage-deflate\")) {\n                    failWebsocketConnection(this.ws, \"Expected RSV1 to be clear.\");\n                    return;\n                }\n                if (rsv2 !== 0 || rsv3 !== 0) {\n                    failWebsocketConnection(this.ws, \"RSV1, RSV2, RSV3 must be clear\");\n                    return;\n                }\n                if (fragmented && !isTextBinaryFrame(opcode)) {\n                    // Only text and binary frames can be fragmented\n                    failWebsocketConnection(this.ws, \"Invalid frame type was fragmented.\");\n                    return;\n                }\n                // If we are already parsing a text/binary frame and do not receive either\n                // a continuation frame or close frame, fail the connection.\n                if (isTextBinaryFrame(opcode) && this.#fragments.length > 0) {\n                    failWebsocketConnection(this.ws, \"Expected continuation frame\");\n                    return;\n                }\n                if (this.#info.fragmented && fragmented) {\n                    // A fragmented frame can't be fragmented itself\n                    failWebsocketConnection(this.ws, \"Fragmented frame exceeded 125 bytes.\");\n                    return;\n                }\n                // \"All control frames MUST have a payload length of 125 bytes or less\n                // and MUST NOT be fragmented.\"\n                if ((payloadLength > 125 || fragmented) && isControlFrame(opcode)) {\n                    failWebsocketConnection(this.ws, \"Control frame either too large or fragmented\");\n                    return;\n                }\n                if (isContinuationFrame(opcode) && this.#fragments.length === 0 && !this.#info.compressed) {\n                    failWebsocketConnection(this.ws, \"Unexpected continuation frame\");\n                    return;\n                }\n                if (payloadLength <= 125) {\n                    this.#info.payloadLength = payloadLength;\n                    this.#state = parserStates.READ_DATA;\n                } else if (payloadLength === 126) {\n                    this.#state = parserStates.PAYLOADLENGTH_16;\n                } else if (payloadLength === 127) {\n                    this.#state = parserStates.PAYLOADLENGTH_64;\n                }\n                if (isTextBinaryFrame(opcode)) {\n                    this.#info.binaryType = opcode;\n                    this.#info.compressed = rsv1 !== 0;\n                }\n                this.#info.opcode = opcode;\n                this.#info.masked = masked;\n                this.#info.fin = fin;\n                this.#info.fragmented = fragmented;\n            } else if (this.#state === parserStates.PAYLOADLENGTH_16) {\n                if (this.#byteOffset < 2) {\n                    return callback();\n                }\n                const buffer = this.consume(2);\n                this.#info.payloadLength = buffer.readUInt16BE(0);\n                this.#state = parserStates.READ_DATA;\n            } else if (this.#state === parserStates.PAYLOADLENGTH_64) {\n                if (this.#byteOffset < 8) {\n                    return callback();\n                }\n                const buffer = this.consume(8);\n                const upper = buffer.readUInt32BE(0);\n                // 2^31 is the maximum bytes an arraybuffer can contain\n                // on 32-bit systems. Although, on 64-bit systems, this is\n                // 2^53-1 bytes.\n                // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Invalid_array_length\n                // https://source.chromium.org/chromium/chromium/src/+/main:v8/src/common/globals.h;drc=1946212ac0100668f14eb9e2843bdd846e510a1e;bpv=1;bpt=1;l=1275\n                // https://source.chromium.org/chromium/chromium/src/+/main:v8/src/objects/js-array-buffer.h;l=34;drc=1946212ac0100668f14eb9e2843bdd846e510a1e\n                if (upper > 2 ** 31 - 1) {\n                    failWebsocketConnection(this.ws, \"Received payload length > 2^31 bytes.\");\n                    return;\n                }\n                const lower = buffer.readUInt32BE(4);\n                this.#info.payloadLength = (upper << 8) + lower;\n                this.#state = parserStates.READ_DATA;\n            } else if (this.#state === parserStates.READ_DATA) {\n                if (this.#byteOffset < this.#info.payloadLength) {\n                    return callback();\n                }\n                const body = this.consume(this.#info.payloadLength);\n                if (isControlFrame(this.#info.opcode)) {\n                    this.#loop = this.parseControlFrame(body);\n                    this.#state = parserStates.INFO;\n                } else {\n                    if (!this.#info.compressed) {\n                        this.#fragments.push(body);\n                        // If the frame is not fragmented, a message has been received.\n                        // If the frame is fragmented, it will terminate with a fin bit set\n                        // and an opcode of 0 (continuation), therefore we handle that when\n                        // parsing continuation frames, not here.\n                        if (!this.#info.fragmented && this.#info.fin) {\n                            const fullMessage = Buffer.concat(this.#fragments);\n                            websocketMessageReceived(this.ws, this.#info.binaryType, fullMessage);\n                            this.#fragments.length = 0;\n                        }\n                        this.#state = parserStates.INFO;\n                    } else {\n                        this.#extensions.get(\"permessage-deflate\").decompress(body, this.#info.fin, (error, data)=>{\n                            if (error) {\n                                closeWebSocketConnection(this.ws, 1007, error.message, error.message.length);\n                                return;\n                            }\n                            this.#fragments.push(data);\n                            if (!this.#info.fin) {\n                                this.#state = parserStates.INFO;\n                                this.#loop = true;\n                                this.run(callback);\n                                return;\n                            }\n                            websocketMessageReceived(this.ws, this.#info.binaryType, Buffer.concat(this.#fragments));\n                            this.#loop = true;\n                            this.#state = parserStates.INFO;\n                            this.#fragments.length = 0;\n                            this.run(callback);\n                        });\n                        this.#loop = false;\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    /**\n   * Take n bytes from the buffered Buffers\n   * @param {number} n\n   * @returns {Buffer}\n   */ consume(n) {\n        if (n > this.#byteOffset) {\n            throw new Error(\"Called consume() before buffers satiated.\");\n        } else if (n === 0) {\n            return emptyBuffer;\n        }\n        if (this.#buffers[0].length === n) {\n            this.#byteOffset -= this.#buffers[0].length;\n            return this.#buffers.shift();\n        }\n        const buffer = Buffer.allocUnsafe(n);\n        let offset = 0;\n        while(offset !== n){\n            const next = this.#buffers[0];\n            const { length } = next;\n            if (length + offset === n) {\n                buffer.set(this.#buffers.shift(), offset);\n                break;\n            } else if (length + offset > n) {\n                buffer.set(next.subarray(0, n - offset), offset);\n                this.#buffers[0] = next.subarray(n - offset);\n                break;\n            } else {\n                buffer.set(this.#buffers.shift(), offset);\n                offset += next.length;\n            }\n        }\n        this.#byteOffset -= n;\n        return buffer;\n    }\n    parseCloseBody(data) {\n        assert(data.length !== 1);\n        // https://datatracker.ietf.org/doc/html/rfc6455#section-7.1.5\n        /** @type {number|undefined} */ let code;\n        if (data.length >= 2) {\n            // _The WebSocket Connection Close Code_ is\n            // defined as the status code (Section 7.4) contained in the first Close\n            // control frame received by the application\n            code = data.readUInt16BE(0);\n        }\n        if (code !== undefined && !isValidStatusCode(code)) {\n            return {\n                code: 1002,\n                reason: \"Invalid status code\",\n                error: true\n            };\n        }\n        // https://datatracker.ietf.org/doc/html/rfc6455#section-7.1.6\n        /** @type {Buffer} */ let reason = data.subarray(2);\n        // Remove BOM\n        if (reason[0] === 0xEF && reason[1] === 0xBB && reason[2] === 0xBF) {\n            reason = reason.subarray(3);\n        }\n        try {\n            reason = utf8Decode(reason);\n        } catch  {\n            return {\n                code: 1007,\n                reason: \"Invalid UTF-8\",\n                error: true\n            };\n        }\n        return {\n            code,\n            reason,\n            error: false\n        };\n    }\n    /**\n   * Parses control frames.\n   * @param {Buffer} body\n   */ parseControlFrame(body) {\n        const { opcode, payloadLength } = this.#info;\n        if (opcode === opcodes.CLOSE) {\n            if (payloadLength === 1) {\n                failWebsocketConnection(this.ws, \"Received close frame with a 1-byte body.\");\n                return false;\n            }\n            this.#info.closeInfo = this.parseCloseBody(body);\n            if (this.#info.closeInfo.error) {\n                const { code, reason } = this.#info.closeInfo;\n                closeWebSocketConnection(this.ws, code, reason, reason.length);\n                failWebsocketConnection(this.ws, reason);\n                return false;\n            }\n            if (this.ws[kSentClose] !== sentCloseFrameState.SENT) {\n                // If an endpoint receives a Close frame and did not previously send a\n                // Close frame, the endpoint MUST send a Close frame in response.  (When\n                // sending a Close frame in response, the endpoint typically echos the\n                // status code it received.)\n                let body = emptyBuffer;\n                if (this.#info.closeInfo.code) {\n                    body = Buffer.allocUnsafe(2);\n                    body.writeUInt16BE(this.#info.closeInfo.code, 0);\n                }\n                const closeFrame = new WebsocketFrameSend(body);\n                this.ws[kResponse].socket.write(closeFrame.createFrame(opcodes.CLOSE), (err)=>{\n                    if (!err) {\n                        this.ws[kSentClose] = sentCloseFrameState.SENT;\n                    }\n                });\n            }\n            // Upon either sending or receiving a Close control frame, it is said\n            // that _The WebSocket Closing Handshake is Started_ and that the\n            // WebSocket connection is in the CLOSING state.\n            this.ws[kReadyState] = states.CLOSING;\n            this.ws[kReceivedClose] = true;\n            return false;\n        } else if (opcode === opcodes.PING) {\n            // Upon receipt of a Ping frame, an endpoint MUST send a Pong frame in\n            // response, unless it already received a Close frame.\n            // A Pong frame sent in response to a Ping frame must have identical\n            // \"Application data\"\n            if (!this.ws[kReceivedClose]) {\n                const frame = new WebsocketFrameSend(body);\n                this.ws[kResponse].socket.write(frame.createFrame(opcodes.PONG));\n                if (channels.ping.hasSubscribers) {\n                    channels.ping.publish({\n                        payload: body\n                    });\n                }\n            }\n        } else if (opcode === opcodes.PONG) {\n            // A Pong frame MAY be sent unsolicited.  This serves as a\n            // unidirectional heartbeat.  A response to an unsolicited Pong frame is\n            // not expected.\n            if (channels.pong.hasSubscribers) {\n                channels.pong.publish({\n                    payload: body\n                });\n            }\n        }\n        return true;\n    }\n    get closingInfo() {\n        return this.#info.closeInfo;\n    }\n}\nmodule.exports = {\n    ByteParser\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvd2Vic29ja2V0L3JlY2VpdmVyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTSxFQUFFQSxRQUFBQSxFQUFVLEdBQUdDLG1CQUFPQSxDQUFDO0FBQzdCLE1BQU1DLFNBQVNELG1CQUFPQSxDQUFDO0FBQ3ZCLE1BQU0sRUFBRUUsWUFBWSxFQUFFQyxPQUFPLEVBQUVDLE1BQU0sRUFBRUMsV0FBVyxFQUFFQyxtQkFBQUEsRUFBcUIsR0FBR04sbUJBQU9BLENBQUM7QUFDcEYsTUFBTSxFQUFFTyxXQUFXLEVBQUVDLFVBQVUsRUFBRUMsU0FBUyxFQUFFQyxjQUFBQSxFQUFnQixHQUFHVixtQkFBT0EsQ0FBQztBQUN2RSxNQUFNLEVBQUVXLFFBQUFBLEVBQVUsR0FBR1gsbUJBQU9BLENBQUM7QUFDN0IsTUFBTSxFQUNKWSxpQkFBaUIsRUFDakJDLGFBQWEsRUFDYkMsdUJBQXVCLEVBQ3ZCQyx3QkFBd0IsRUFDeEJDLFVBQVUsRUFDVkMsY0FBYyxFQUNkQyxpQkFBaUIsRUFDakJDLG1CQUFBQSxFQUNELEdBQUduQixtQkFBT0EsQ0FBQztBQUNaLE1BQU0sRUFBRW9CLGtCQUFBQSxFQUFvQixHQUFHcEIsbUJBQU9BLENBQUM7QUFDdkMsTUFBTSxFQUFFcUIsd0JBQUFBLEVBQTBCLEdBQUdyQixtQkFBT0EsQ0FBQztBQUM3QyxNQUFNLEVBQUVzQixpQkFBQUEsRUFBbUIsR0FBR3RCLG1CQUFPQSxDQUFDO0FBRXRDO0FBQ0E7QUFDQTtBQUNBO0FBRUEsTUFBTXVCLG1CQUFtQnhCO0lBQ3ZCLENBQUN5QixPQUFPLENBQUs7SUFDYixDQUFDQyxVQUFVLENBQUk7SUFDZixDQUFDQyxJQUFJLENBQVE7SUFFYixDQUFDQyxLQUFLLENBQW9CO0lBRTFCLENBQUNDLElBQUksQ0FBSztJQUNWLENBQUNDLFNBQVMsQ0FBSztJQUVmLDhDQUNBLENBQUNDLFVBQVU7SUFFWEMsWUFBYUMsRUFBRSxFQUFFRixVQUFVLENB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QUksQ0FBQ2hDLEVBQUUsQ0FBQ3ZCLFVBQVUsQ0FBQ2lGLE1BQU0sQ0FBQ0MsS0FBSyxDQUFDSyxNQUFNSixXQUFXLENBQUN6RixRQUFROEYsSUFBSTtnQkFFOUQsSUFBSXRGLFNBQVN1RixJQUFJLENBQUNDLGNBQWMsRUFBRTtvQkFDaEN4RixTQUFTdUYsSUFBSSxDQUFDRSxPQUFPLENBQUM7d0JBQ3BCQyxTQUFTckM7b0JBQ1g7Z0JBQ0Y7WUFDRjtRQUNGLE9BQU8sSUFBSWpCLFdBQVc1QyxRQUFROEYsSUFBSSxFQUFFO1lBQ2xDO1lBQ0E7WUFDQTtZQUVBLElBQUl0RixTQUFTMkYsSUFBSSxDQUFDSCxjQUFjLEVBQUU7Z0JBQ2hDeEYsU0FBUzJGLElBQUksQ0FBQ0YsT0FBTyxDQUFDO29CQUNwQkMsU0FBU3JDO2dCQUNYO1lBQ0Y7UUFDRjtRQUVBLE9BQU87SUFDVDtJQUVBLElBQUl1QyxjQUFlO1FBQ2pCLE9BQU8sSUFBSSxDQUFDLENBQUMzRSxJQUFJLENBQUMwRCxTQUFTO0lBQzdCO0FBQ0Y7QUFFQWtCLE9BQU9DLE9BQU8sR0FBRztJQUNmbEY7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL21vY2t1cGZsb3cvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvd2Vic29ja2V0L3JlY2VpdmVyLmpzPzczZjkiLCJ3ZWJwYWNrOi8vbW9ja3VwZmxvdy8uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL3dlYi93ZWJzb2NrZXQvcmVjZWl2ZXIuanM/NzNmOSoiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgV3JpdGFibGUgfSA9IHJlcXVpcmUoJ25vZGU6c3RyZWFtJylcbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ25vZGU6YXNzZXJ0JylcbmNvbnN0IHsgcGFyc2VyU3RhdGVzLCBvcGNvZGVzLCBzdGF0ZXMsIGVtcHR5QnVmZmVyLCBzZW50Q2xvc2VGcmFtZVN0YXRlIH0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpXG5jb25zdCB7IGtSZWFkeVN0YXRlLCBrU2VudENsb3NlLCBrUmVzcG9uc2UsIGtSZWNlaXZlZENsb3NlIH0gPSByZXF1aXJlKCcuL3N5bWJvbHMnKVxuY29uc3QgeyBjaGFubmVscyB9ID0gcmVxdWlyZSgnLi4vLi4vY29yZS9kaWFnbm9zdGljcycpXG5jb25zdCB7XG4gIGlzVmFsaWRTdGF0dXNDb2RlLFxuICBpc1ZhbGlkT3Bjb2RlLFxuICBmYWlsV2Vic29ja2V0Q29ubmVjdGlvbixcbiAgd2Vic29ja2V0TWVzc2FnZVJlY2VpdmVkLFxuICB1dGY4RGVjb2RlLFxuICBpc0NvbnRyb2xGcmFtZSxcbiAgaXNUZXh0QmluYXJ5RnJhbWUsXG4gIGlzQ29udGludWF0aW9uRnJhbWVcbn0gPSByZXF1aXJlKCcuL3V0aWwnKVxuY29uc3QgeyBXZWJzb2NrZXRGcmFtZVNlbmQgfSA9IHJlcXVpcmUoJy4vZnJhbWUnKVxuY29uc3QgeyBjbG9zZVdlYlNvY2tldENvbm5lY3Rpb24gfSA9IHJlcXVpcmUoJy4vY29ubmVjdGlvbicpXG5jb25zdCB7IFBlck1lc3NhZ2VEZWZsYXRlIH0gPSByZXF1aXJlKCcuL3Blcm1lc3NhZ2UtZGVmbGF0ZScpXG5cbi8vIFRoaXMgY29kZSB3YXMgaW5mbHVlbmNlZCBieSB3cyByZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTEgRWluYXIgT3R0byBTdGFuZ3ZpayA8ZWluYXJvc0BnbWFpbC5jb20+XG4vLyBDb3B5cmlnaHQgKGMpIDIwMTMgQXJub3V0IEthemVtaWVyIGFuZCBjb250cmlidXRvcnNcbi8vIENvcHlyaWdodCAoYykgMjAxNiBMdWlnaSBQaW5jYSBhbmQgY29udHJpYnV0b3JzXG5cbmNsYXNzIEJ5dGVQYXJzZXIgZXh0ZW5kcyBXcml0YWJsZSB7XG4gICNidWZmZXJzID0gW11cbiAgI2J5dGVPZmZzZXQgPSAwXG4gICNsb29wID0gZmFsc2VcblxuICAjc3RhdGUgPSBwYXJzZXJTdGF0ZXMuSU5GT1xuXG4gICNpbmZvID0ge31cbiAgI2ZyYWdtZW50cyA9IFtdXG5cbiAgLyoqIEB0eXBlIHtNYXA8c3RyaW5nLCBQZXJNZXNzYWdlRGVmbGF0ZT59ICovXG4gICNleHRlbnNpb25zXG5cbiAgY29uc3RydWN0b3IgKHdzLCBleHRlbnNpb25zKSB7XG4gICAgc3VwZXIoKVxuXG4gICAgdGhpcy53cyA9IHdzXG4gICAgdGhpcy4jZXh0ZW5zaW9ucyA9IGV4dGVuc2lvbnMgPT0gbnVsbCA/IG5ldyBNYXAoKSA6IGV4dGVuc2lvbnNcblxuICAgIGlmICh0aGlzLiNleHRlbnNpb25zLmhhcygncGVybWVzc2FnZS1kZWZsYXRlJykpIHtcbiAgICAgIHRoaXMuI2V4dGVuc2lvbnMuc2V0KCdwZXJtZXNzYWdlLWRlZmxhdGUnLCBuZXcgUGVyTWVzc2FnZURlZmxhdGUoZXh0ZW5zaW9ucykpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBjaHVua1xuICAgKiBAcGFyYW0geygpID0+IHZvaWR9IGNhbGxiYWNrXG4gICAqL1xuICBfd3JpdGUgKGNodW5rLCBfLCBjYWxsYmFjaykge1xuICAgIHRoaXMuI2J1ZmZlcnMucHVzaChjaHVuaylcbiAgICB0aGlzLiNieXRlT2Zmc2V0ICs9IGNodW5rLmxlbmd0aFxuICAgIHRoaXMuI2xvb3AgPSB0cnVlXG5cbiAgICB0aGlzLnJ1bihjYWxsYmFjaylcbiAgfVxuXG4gIC8qKlxuICAgKiBSdW5zIHdoZW5ldmVyIGEgbmV3IGNodW5rIGlzIHJlY2VpdmVkLlxuICAgKiBDYWxsYmFjayBpcyBjYWxsZWQgd2hlbmV2ZXIgdGhlcmUgYXJlIG5vIG1vcmUgY2h1bmtzIGJ1ZmZlcmluZyxcbiAgICogb3Igbm90IGVub3VnaCBieXRlcyBhcmUgYnVmZmVyZWQgdG8gcGFyc2UuXG4gICAqL1xuICBydW4gKGNhbGxiYWNrKSB7XG4gICAgd2hpbGUgKHRoaXMuI2xvb3ApIHtcbiAgICAgIGlmICh0aGlzLiNzdGF0ZSA9PT0gcGFyc2VyU3RhdGVzLklORk8pIHtcbiAgICAgICAgLy8gSWYgdGhlcmUgYXJlbid0IGVub3VnaCBieXRlcyB0byBwYXJzZSB0aGUgcGF5bG9hZCBsZW5ndGgsIGV0Yy5cbiAgICAgICAgaWYgKHRoaXMuI2J5dGVPZmZzZXQgPCAyKSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKClcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IHRoaXMuY29uc3VtZSgyKVxuICAgICAgICBjb25zdCBmaW4gPSAoYnVmZmVyWzBdICYgMHg4MCkgIT09IDBcbiAgICAgICAgY29uc3Qgb3Bjb2RlID0gYnVmZmVyWzBdICYgMHgwRlxuICAgICAgICBjb25zdCBtYXNrZWQgPSAoYnVmZmVyWzFdICYgMHg4MCkgPT09IDB4ODBcblxuICAgICAgICBjb25zdCBmcmFnbWVudGVkID0gIWZpbiAmJiBvcGNvZGUgIT09IG9wY29kZXMuQ09OVElOVUFUSU9OXG4gICAgICAgIGNvbnN0IHBheWxvYWRMZW5ndGggPSBidWZmZXJbMV0gJiAweDdGXG5cbiAgICAgICAgY29uc3QgcnN2MSA9IGJ1ZmZlclswXSAmIDB4NDBcbiAgICAgICAgY29uc3QgcnN2MiA9IGJ1ZmZlclswXSAmIDB4MjBcbiAgICAgICAgY29uc3QgcnN2MyA9IGJ1ZmZlclswXSAmIDB4MTBcblxuICAgICAgICBpZiAoIWlzVmFsaWRPcGNvZGUob3Bjb2RlKSkge1xuICAgICAgICAgIGZhaWxXZWJzb2NrZXRDb25uZWN0aW9uKHRoaXMud3MsICdJbnZhbGlkIG9wY29kZSByZWNlaXZlZCcpXG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKClcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtYXNrZWQpIHtcbiAgICAgICAgICBmYWlsV2Vic29ja2V0Q29ubmVjdGlvbih0aGlzLndzLCAnRnJhbWUgY2Fubm90IGJlIG1hc2tlZCcpXG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKClcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE1VU1QgYmUgMCB1bmxlc3MgYW4gZXh0ZW5zaW9uIGlzIG5lZ290aWF0ZWQgdGhhdCBkZWZpbmVzIG1lYW5pbmdzXG4gICAgICAgIC8vIGZvciBub24temVybyB2YWx1ZXMuICBJZiBhIG5vbnplcm8gdmFsdWUgaXMgcmVjZWl2ZWQgYW5kIG5vbmUgb2ZcbiAgICAgICAgLy8gdGhlIG5lZ290aWF0ZWQgZXh0ZW5zaW9ucyBkZWZpbmVzIHRoZSBtZWFuaW5nIG9mIHN1Y2ggYSBub256ZXJvXG4gICAgICAgIC8vIHZhbHVlLCB0aGUgcmVjZWl2aW5nIGVuZHBvaW50IE1VU1QgX0ZhaWwgdGhlIFdlYlNvY2tldFxuICAgICAgICAvLyBDb25uZWN0aW9uXy5cbiAgICAgICAgLy8gVGhpcyBkb2N1bWVudCBhbGxvY2F0ZXMgdGhlIFJTVjEgYml0IG9mIHRoZSBXZWJTb2NrZXQgaGVhZGVyIGZvclxuICAgICAgICAvLyBQTUNFcyBhbmQgY2FsbHMgdGhlIGJpdCB0aGUgXCJQZXItTWVzc2FnZSBDb21wcmVzc2VkXCIgYml0LiAgT24gYVxuICAgICAgICAvLyBXZWJTb2NrZXQgY29ubmVjdGlvbiB3aGVyZSBhIFBNQ0UgaXMgaW4gdXNlLCB0aGlzIGJpdCBpbmRpY2F0ZXNcbiAgICAgICAgLy8gd2hldGhlciBhIG1lc3NhZ2UgaXMgY29tcHJlc3NlZCBvciBub3QuXG4gICAgICAgIGlmIChyc3YxICE9PSAwICYmICF0aGlzLiNleHRlbnNpb25zLmhhcygncGVybWVzc2FnZS1kZWZsYXRlJykpIHtcbiAgICAgICAgICBmYWlsV2Vic29ja2V0Q29ubmVjdGlvbih0aGlzLndzLCAnRXhwZWN0ZWQgUlNWMSB0byBiZSBjbGVhci4nKVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJzdjIgIT09IDAgfHwgcnN2MyAhPT0gMCkge1xuICAgICAgICAgIGZhaWxXZWJzb2NrZXRDb25uZWN0aW9uKHRoaXMud3MsICdSU1YxLCBSU1YyLCBSU1YzIG11c3QgYmUgY2xlYXInKVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZyYWdtZW50ZWQgJiYgIWlzVGV4dEJpbmFyeUZyYW1lKG9wY29kZSkpIHtcbiAgICAgICAgICAvLyBPbmx5IHRleHQgYW5kIGJpbmFyeSBmcmFtZXMgY2FuIGJlIGZyYWdtZW50ZWRcbiAgICAgICAgICBmYWlsV2Vic29ja2V0Q29ubmVjdGlvbih0aGlzLndzLCAnSW52YWxpZCBmcmFtZSB0eXBlIHdhcyBmcmFnbWVudGVkLicpXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB3ZSBhcmUgYWxyZWFkeSBwYXJzaW5nIGEgdGV4dC9iaW5hcnkgZnJhbWUgYW5kIGRvIG5vdCByZWNlaXZlIGVpdGhlclxuICAgICAgICAvLyBhIGNvbnRpbnVhdGlvbiBmcmFtZSBvciBjbG9zZSBmcmFtZSwgZmFpbCB0aGUgY29ubmVjdGlvbi5cbiAgICAgICAgaWYgKGlzVGV4dEJpbmFyeUZyYW1lKG9wY29kZSkgJiYgdGhpcy4jZnJhZ21lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBmYWlsV2Vic29ja2V0Q29ubmVjdGlvbih0aGlzLndzLCAnRXhwZWN0ZWQgY29udGludWF0aW9uIGZyYW1lJylcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLiNpbmZvLmZyYWdtZW50ZWQgJiYgZnJhZ21lbnRlZCkge1xuICAgICAgICAgIC8vIEEgZnJhZ21lbnRlZCBmcmFtZSBjYW4ndCBiZSBmcmFnbWVudGVkIGl0c2VsZlxuICAgICAgICAgIGZhaWxXZWJzb2NrZXRDb25uZWN0aW9uKHRoaXMud3MsICdGcmFnbWVudGVkIGZyYW1lIGV4Y2VlZGVkIDEyNSBieXRlcy4nKVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gXCJBbGwgY29udHJvbCBmcmFtZXMgTVVTVCBoYXZlIGEgcGF5bG9hZCBsZW5ndGggb2YgMTI1IGJ5dGVzIG9yIGxlc3NcbiAgICAgICAgLy8gYW5kIE1VU1QgTk9UIGJlIGZyYWdtZW50ZWQuXCJcbiAgICAgICAgaWYgKChwYXlsb2FkTGVuZ3RoID4gMTI1IHx8IGZyYWdtZW50ZWQpICYmIGlzQ29udHJvbEZyYW1lKG9wY29kZSkpIHtcbiAgICAgICAgICBmYWlsV2Vic29ja2V0Q29ubmVjdGlvbih0aGlzLndzLCAnQ29udHJvbCBmcmFtZSBlaXRoZXIgdG9vIGxhcmdlIG9yIGZyYWdtZW50ZWQnKVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzQ29udGludWF0aW9uRnJhbWUob3Bjb2RlKSAmJiB0aGlzLiNmcmFnbWVudHMubGVuZ3RoID09PSAwICYmICF0aGlzLiNpbmZvLmNvbXByZXNzZWQpIHtcbiAgICAgICAgICBmYWlsV2Vic29ja2V0Q29ubmVjdGlvbih0aGlzLndzLCAnVW5leHBlY3RlZCBjb250aW51YXRpb24gZnJhbWUnKVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBheWxvYWRMZW5ndGggPD0gMTI1KSB7XG4gICAgICAgICAgdGhpcy4jaW5mby5wYXlsb2FkTGVuZ3RoID0gcGF5bG9hZExlbmd0aFxuICAgICAgICAgIHRoaXMuI3N0YXRlID0gcGFyc2VyU3RhdGVzLlJFQURfREFUQVxuICAgICAgICB9IGVsc2UgaWYgKHBheWxvYWRMZW5ndGggPT09IDEyNikge1xuICAgICAgICAgIHRoaXMuI3N0YXRlID0gcGFyc2VyU3RhdGVzLlBBWUxPQURMRU5HVEhfMTZcbiAgICAgICAgfSBlbHNlIGlmIChwYXlsb2FkTGVuZ3RoID09PSAxMjcpIHtcbiAgICAgICAgICB0aGlzLiNzdGF0ZSA9IHBhcnNlclN0YXRlcy5QQVlMT0FETEVOR1RIXzY0XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNUZXh0QmluYXJ5RnJhbWUob3Bjb2RlKSkge1xuICAgICAgICAgIHRoaXMuI2luZm8uYmluYXJ5VHlwZSA9IG9wY29kZVxuICAgICAgICAgIHRoaXMuI2luZm8uY29tcHJlc3NlZCA9IHJzdjEgIT09IDBcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuI2luZm8ub3Bjb2RlID0gb3Bjb2RlXG4gICAgICAgIHRoaXMuI2luZm8ubWFza2VkID0gbWFza2VkXG4gICAgICAgIHRoaXMuI2luZm8uZmluID0gZmluXG4gICAgICAgIHRoaXMuI2luZm8uZnJhZ21lbnRlZCA9IGZyYWdtZW50ZWRcbiAgICAgIH0gZWxzZSBpZiAodGhpcy4jc3RhdGUgPT09IHBhcnNlclN0YXRlcy5QQVlMT0FETEVOR1RIXzE2KSB7XG4gICAgICAgIGlmICh0aGlzLiNieXRlT2Zmc2V0IDwgMikge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjaygpXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBidWZmZXIgPSB0aGlzLmNvbnN1bWUoMilcblxuICAgICAgICB0aGlzLiNpbmZvLnBheWxvYWRMZW5ndGggPSBidWZmZXIucmVhZFVJbnQxNkJFKDApXG4gICAgICAgIHRoaXMuI3N0YXRlID0gcGFyc2VyU3RhdGVzLlJFQURfREFUQVxuICAgICAgfSBlbHNlIGlmICh0aGlzLiNzdGF0ZSA9PT0gcGFyc2VyU3RhdGVzLlBBWUxPQURMRU5HVEhfNjQpIHtcbiAgICAgICAgaWYgKHRoaXMuI2J5dGVPZmZzZXQgPCA4KSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKClcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IHRoaXMuY29uc3VtZSg4KVxuICAgICAgICBjb25zdCB1cHBlciA9IGJ1ZmZlci5yZWFkVUludDMyQkUoMClcblxuICAgICAgICAvLyAyXjMxIGlzIHRoZSBtYXhpbXVtIGJ5dGVzIGFuIGFycmF5YnVmZmVyIGNhbiBjb250YWluXG4gICAgICAgIC8vIG9uIDMyLWJpdCBzeXN0ZW1zLiBBbHRob3VnaCwgb24gNjQtYml0IHN5c3RlbXMsIHRoaXMgaXNcbiAgICAgICAgLy8gMl41My0xIGJ5dGVzLlxuICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9FcnJvcnMvSW52YWxpZF9hcnJheV9sZW5ndGhcbiAgICAgICAgLy8gaHR0cHM6Ly9zb3VyY2UuY2hyb21pdW0ub3JnL2Nocm9taXVtL2Nocm9taXVtL3NyYy8rL21haW46djgvc3JjL2NvbW1vbi9nbG9iYWxzLmg7ZHJjPTE5NDYyMTJhYzAxMDA2NjhmMTRlYjllMjg0M2JkZDg0NmU1MTBhMWU7YnB2PTE7YnB0PTE7bD0xMjc1XG4gICAgICAgIC8vIGh0dHBzOi8vc291cmNlLmNocm9taXVtLm9yZy9jaHJvbWl1bS9jaHJvbWl1bS9zcmMvKy9tYWluOnY4L3NyYy9vYmplY3RzL2pzLWFycmF5LWJ1ZmZlci5oO2w9MzQ7ZHJjPTE5NDYyMTJhYzAxMDA2NjhmMTRlYjllMjg0M2JkZDg0NmU1MTBhMWVcbiAgICAgICAgaWYgKHVwcGVyID4gMiAqKiAzMSAtIDEpIHtcbiAgICAgICAgICBmYWlsV2Vic29ja2V0Q29ubmVjdGlvbih0aGlzLndzLCAnUmVjZWl2ZWQgcGF5bG9hZCBsZW5ndGggPiAyXjMxIGJ5dGVzLicpXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBsb3dlciA9IGJ1ZmZlci5yZWFkVUludDMyQkUoNClcblxuICAgICAgICB0aGlzLiNpbmZvLnBheWxvYWRMZW5ndGggPSAodXBwZXIgPDwgOCkgKyBsb3dlclxuICAgICAgICB0aGlzLiNzdGF0ZSA9IHBhcnNlclN0YXRlcy5SRUFEX0RBVEFcbiAgICAgIH0gZWxzZSBpZiAodGhpcy4jc3RhdGUgPT09IHBhcnNlclN0YXRlcy5SRUFEX0RBVEEpIHtcbiAgICAgICAgaWYgKHRoaXMuI2J5dGVPZmZzZXQgPCB0aGlzLiNpbmZvLnBheWxvYWRMZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soKVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYm9keSA9IHRoaXMuY29uc3VtZSh0aGlzLiNpbmZvLnBheWxvYWRMZW5ndGgpXG5cbiAgICAgICAgaWYgKGlzQ29udHJvbEZyYW1lKHRoaXMuI2luZm8ub3Bjb2RlKSkge1xuICAgICAgICAgIHRoaXMuI2xvb3AgPSB0aGlzLnBhcnNlQ29udHJvbEZyYW1lKGJvZHkpXG4gICAgICAgICAgdGhpcy4jc3RhdGUgPSBwYXJzZXJTdGF0ZXMuSU5GT1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICghdGhpcy4jaW5mby5jb21wcmVzc2VkKSB7XG4gICAgICAgICAgICB0aGlzLiNmcmFnbWVudHMucHVzaChib2R5KVxuXG4gICAgICAgICAgICAvLyBJZiB0aGUgZnJhbWUgaXMgbm90IGZyYWdtZW50ZWQsIGEgbWVzc2FnZSBoYXMgYmVlbiByZWNlaXZlZC5cbiAgICAgICAgICAgIC8vIElmIHRoZSBmcmFtZSBpcyBmcmFnbWVudGVkLCBpdCB3aWxsIHRlcm1pbmF0ZSB3aXRoIGEgZmluIGJpdCBzZXRcbiAgICAgICAgICAgIC8vIGFuZCBhbiBvcGNvZGUgb2YgMCAoY29udGludWF0aW9uKSwgdGhlcmVmb3JlIHdlIGhhbmRsZSB0aGF0IHdoZW5cbiAgICAgICAgICAgIC8vIHBhcnNpbmcgY29udGludWF0aW9uIGZyYW1lcywgbm90IGhlcmUuXG4gICAgICAgICAgICBpZiAoIXRoaXMuI2luZm8uZnJhZ21lbnRlZCAmJiB0aGlzLiNpbmZvLmZpbikge1xuICAgICAgICAgICAgICBjb25zdCBmdWxsTWVzc2FnZSA9IEJ1ZmZlci5jb25jYXQodGhpcy4jZnJhZ21lbnRzKVxuICAgICAgICAgICAgICB3ZWJzb2NrZXRNZXNzYWdlUmVjZWl2ZWQodGhpcy53cywgdGhpcy4jaW5mby5iaW5hcnlUeXBlLCBmdWxsTWVzc2FnZSlcbiAgICAgICAgICAgICAgdGhpcy4jZnJhZ21lbnRzLmxlbmd0aCA9IDBcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy4jc3RhdGUgPSBwYXJzZXJTdGF0ZXMuSU5GT1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLiNleHRlbnNpb25zLmdldCgncGVybWVzc2FnZS1kZWZsYXRlJykuZGVjb21wcmVzcyhib2R5LCB0aGlzLiNpbmZvLmZpbiwgKGVycm9yLCBkYXRhKSA9PiB7XG4gICAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGNsb3NlV2ViU29ja2V0Q29ubmVjdGlvbih0aGlzLndzLCAxMDA3LCBlcnJvci5tZXNzYWdlLCBlcnJvci5tZXNzYWdlLmxlbmd0aClcbiAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHRoaXMuI2ZyYWdtZW50cy5wdXNoKGRhdGEpXG5cbiAgICAgICAgICAgICAgaWYgKCF0aGlzLiNpbmZvLmZpbikge1xuICAgICAgICAgICAgICAgIHRoaXMuI3N0YXRlID0gcGFyc2VyU3RhdGVzLklORk9cbiAgICAgICAgICAgICAgICB0aGlzLiNsb29wID0gdHJ1ZVxuICAgICAgICAgICAgICAgIHRoaXMucnVuKGNhbGxiYWNrKVxuICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgd2Vic29ja2V0TWVzc2FnZVJlY2VpdmVkKHRoaXMud3MsIHRoaXMuI2luZm8uYmluYXJ5VHlwZSwgQnVmZmVyLmNvbmNhdCh0aGlzLiNmcmFnbWVudHMpKVxuXG4gICAgICAgICAgICAgIHRoaXMuI2xvb3AgPSB0cnVlXG4gICAgICAgICAgICAgIHRoaXMuI3N0YXRlID0gcGFyc2VyU3RhdGVzLklORk9cbiAgICAgICAgICAgICAgdGhpcy4jZnJhZ21lbnRzLmxlbmd0aCA9IDBcbiAgICAgICAgICAgICAgdGhpcy5ydW4oY2FsbGJhY2spXG4gICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICB0aGlzLiNsb29wID0gZmFsc2VcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRha2UgbiBieXRlcyBmcm9tIHRoZSBidWZmZXJlZCBCdWZmZXJzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBuXG4gICAqIEByZXR1cm5zIHtCdWZmZXJ9XG4gICAqL1xuICBjb25zdW1lIChuKSB7XG4gICAgaWYgKG4gPiB0aGlzLiNieXRlT2Zmc2V0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbGxlZCBjb25zdW1lKCkgYmVmb3JlIGJ1ZmZlcnMgc2F0aWF0ZWQuJylcbiAgICB9IGVsc2UgaWYgKG4gPT09IDApIHtcbiAgICAgIHJldHVybiBlbXB0eUJ1ZmZlclxuICAgIH1cblxuICAgIGlmICh0aGlzLiNidWZmZXJzWzBdLmxlbmd0aCA9PT0gbikge1xuICAgICAgdGhpcy4jYnl0ZU9mZnNldCAtPSB0aGlzLiNidWZmZXJzWzBdLmxlbmd0aFxuICAgICAgcmV0dXJuIHRoaXMuI2J1ZmZlcnMuc2hpZnQoKVxuICAgIH1cblxuICAgIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuKVxuICAgIGxldCBvZmZzZXQgPSAwXG5cbiAgICB3aGlsZSAob2Zmc2V0ICE9PSBuKSB7XG4gICAgICBjb25zdCBuZXh0ID0gdGhpcy4jYnVmZmVyc1swXVxuICAgICAgY29uc3QgeyBsZW5ndGggfSA9IG5leHRcblxuICAgICAgaWYgKGxlbmd0aCArIG9mZnNldCA9PT0gbikge1xuICAgICAgICBidWZmZXIuc2V0KHRoaXMuI2J1ZmZlcnMuc2hpZnQoKSwgb2Zmc2V0KVxuICAgICAgICBicmVha1xuICAgICAgfSBlbHNlIGlmIChsZW5ndGggKyBvZmZzZXQgPiBuKSB7XG4gICAgICAgIGJ1ZmZlci5zZXQobmV4dC5zdWJhcnJheSgwLCBuIC0gb2Zmc2V0KSwgb2Zmc2V0KVxuICAgICAgICB0aGlzLiNidWZmZXJzWzBdID0gbmV4dC5zdWJhcnJheShuIC0gb2Zmc2V0KVxuICAgICAgICBicmVha1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnVmZmVyLnNldCh0aGlzLiNidWZmZXJzLnNoaWZ0KCksIG9mZnNldClcbiAgICAgICAgb2Zmc2V0ICs9IG5leHQubGVuZ3RoXG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy4jYnl0ZU9mZnNldCAtPSBuXG5cbiAgICByZXR1cm4gYnVmZmVyXG4gIH1cblxuICBwYXJzZUNsb3NlQm9keSAoZGF0YSkge1xuICAgIGFzc2VydChkYXRhLmxlbmd0aCAhPT0gMSlcblxuICAgIC8vIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvcmZjNjQ1NSNzZWN0aW9uLTcuMS41XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfSAqL1xuICAgIGxldCBjb2RlXG5cbiAgICBpZiAoZGF0YS5sZW5ndGggPj0gMikge1xuICAgICAgLy8gX1RoZSBXZWJTb2NrZXQgQ29ubmVjdGlvbiBDbG9zZSBDb2RlXyBpc1xuICAgICAgLy8gZGVmaW5lZCBhcyB0aGUgc3RhdHVzIGNvZGUgKFNlY3Rpb24gNy40KSBjb250YWluZWQgaW4gdGhlIGZpcnN0IENsb3NlXG4gICAgICAvLyBjb250cm9sIGZyYW1lIHJlY2VpdmVkIGJ5IHRoZSBhcHBsaWNhdGlvblxuICAgICAgY29kZSA9IGRhdGEucmVhZFVJbnQxNkJFKDApXG4gICAgfVxuXG4gICAgaWYgKGNvZGUgIT09IHVuZGVmaW5lZCAmJiAhaXNWYWxpZFN0YXR1c0NvZGUoY29kZSkpIHtcbiAgICAgIHJldHVybiB7IGNvZGU6IDEwMDIsIHJlYXNvbjogJ0ludmFsaWQgc3RhdHVzIGNvZGUnLCBlcnJvcjogdHJ1ZSB9XG4gICAgfVxuXG4gICAgLy8gaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9yZmM2NDU1I3NlY3Rpb24tNy4xLjZcbiAgICAvKiogQHR5cGUge0J1ZmZlcn0gKi9cbiAgICBsZXQgcmVhc29uID0gZGF0YS5zdWJhcnJheSgyKVxuXG4gICAgLy8gUmVtb3ZlIEJPTVxuICAgIGlmIChyZWFzb25bMF0gPT09IDB4RUYgJiYgcmVhc29uWzFdID09PSAweEJCICYmIHJlYXNvblsyXSA9PT0gMHhCRikge1xuICAgICAgcmVhc29uID0gcmVhc29uLnN1YmFycmF5KDMpXG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHJlYXNvbiA9IHV0ZjhEZWNvZGUocmVhc29uKVxuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuIHsgY29kZTogMTAwNywgcmVhc29uOiAnSW52YWxpZCBVVEYtOCcsIGVycm9yOiB0cnVlIH1cbiAgICB9XG5cbiAgICByZXR1cm4geyBjb2RlLCByZWFzb24sIGVycm9yOiBmYWxzZSB9XG4gIH1cblxuICAvKipcbiAgICogUGFyc2VzIGNvbnRyb2wgZnJhbWVzLlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gYm9keVxuICAgKi9cbiAgcGFyc2VDb250cm9sRnJhbWUgKGJvZHkpIHtcbiAgICBjb25zdCB7IG9wY29kZSwgcGF5bG9hZExlbmd0aCB9ID0gdGhpcy4jaW5mb1xuXG4gICAgaWYgKG9wY29kZSA9PT0gb3Bjb2Rlcy5DTE9TRSkge1xuICAgICAgaWYgKHBheWxvYWRMZW5ndGggPT09IDEpIHtcbiAgICAgICAgZmFpbFdlYnNvY2tldENvbm5lY3Rpb24odGhpcy53cywgJ1JlY2VpdmVkIGNsb3NlIGZyYW1lIHdpdGggYSAxLWJ5dGUgYm9keS4nKVxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cblxuICAgICAgdGhpcy4jaW5mby5jbG9zZUluZm8gPSB0aGlzLnBhcnNlQ2xvc2VCb2R5KGJvZHkpXG5cbiAgICAgIGlmICh0aGlzLiNpbmZvLmNsb3NlSW5mby5lcnJvcikge1xuICAgICAgICBjb25zdCB7IGNvZGUsIHJlYXNvbiB9ID0gdGhpcy4jaW5mby5jbG9zZUluZm9cblxuICAgICAgICBjbG9zZVdlYlNvY2tldENvbm5lY3Rpb24odGhpcy53cywgY29kZSwgcmVhc29uLCByZWFzb24ubGVuZ3RoKVxuICAgICAgICBmYWlsV2Vic29ja2V0Q29ubmVjdGlvbih0aGlzLndzLCByZWFzb24pXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy53c1trU2VudENsb3NlXSAhPT0gc2VudENsb3NlRnJhbWVTdGF0ZS5TRU5UKSB7XG4gICAgICAgIC8vIElmIGFuIGVuZHBvaW50IHJlY2VpdmVzIGEgQ2xvc2UgZnJhbWUgYW5kIGRpZCBub3QgcHJldmlvdXNseSBzZW5kIGFcbiAgICAgICAgLy8gQ2xvc2UgZnJhbWUsIHRoZSBlbmRwb2ludCBNVVNUIHNlbmQgYSBDbG9zZSBmcmFtZSBpbiByZXNwb25zZS4gIChXaGVuXG4gICAgICAgIC8vIHNlbmRpbmcgYSBDbG9zZSBmcmFtZSBpbiByZXNwb25zZSwgdGhlIGVuZHBvaW50IHR5cGljYWxseSBlY2hvcyB0aGVcbiAgICAgICAgLy8gc3RhdHVzIGNvZGUgaXQgcmVjZWl2ZWQuKVxuICAgICAgICBsZXQgYm9keSA9IGVtcHR5QnVmZmVyXG4gICAgICAgIGlmICh0aGlzLiNpbmZvLmNsb3NlSW5mby5jb2RlKSB7XG4gICAgICAgICAgYm9keSA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgyKVxuICAgICAgICAgIGJvZHkud3JpdGVVSW50MTZCRSh0aGlzLiNpbmZvLmNsb3NlSW5mby5jb2RlLCAwKVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNsb3NlRnJhbWUgPSBuZXcgV2Vic29ja2V0RnJhbWVTZW5kKGJvZHkpXG5cbiAgICAgICAgdGhpcy53c1trUmVzcG9uc2VdLnNvY2tldC53cml0ZShcbiAgICAgICAgICBjbG9zZUZyYW1lLmNyZWF0ZUZyYW1lKG9wY29kZXMuQ0xPU0UpLFxuICAgICAgICAgIChlcnIpID0+IHtcbiAgICAgICAgICAgIGlmICghZXJyKSB7XG4gICAgICAgICAgICAgIHRoaXMud3Nba1NlbnRDbG9zZV0gPSBzZW50Q2xvc2VGcmFtZVN0YXRlLlNFTlRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgLy8gVXBvbiBlaXRoZXIgc2VuZGluZyBvciByZWNlaXZpbmcgYSBDbG9zZSBjb250cm9sIGZyYW1lLCBpdCBpcyBzYWlkXG4gICAgICAvLyB0aGF0IF9UaGUgV2ViU29ja2V0IENsb3NpbmcgSGFuZHNoYWtlIGlzIFN0YXJ0ZWRfIGFuZCB0aGF0IHRoZVxuICAgICAgLy8gV2ViU29ja2V0IGNvbm5lY3Rpb24gaXMgaW4gdGhlIENMT1NJTkcgc3RhdGUuXG4gICAgICB0aGlzLndzW2tSZWFkeVN0YXRlXSA9IHN0YXRlcy5DTE9TSU5HXG4gICAgICB0aGlzLndzW2tSZWNlaXZlZENsb3NlXSA9IHRydWVcblxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfSBlbHNlIGlmIChvcGNvZGUgPT09IG9wY29kZXMuUElORykge1xuICAgICAgLy8gVXBvbiByZWNlaXB0IG9mIGEgUGluZyBmcmFtZSwgYW4gZW5kcG9pbnQgTVVTVCBzZW5kIGEgUG9uZyBmcmFtZSBpblxuICAgICAgLy8gcmVzcG9uc2UsIHVubGVzcyBpdCBhbHJlYWR5IHJlY2VpdmVkIGEgQ2xvc2UgZnJhbWUuXG4gICAgICAvLyBBIFBvbmcgZnJhbWUgc2VudCBpbiByZXNwb25zZSB0byBhIFBpbmcgZnJhbWUgbXVzdCBoYXZlIGlkZW50aWNhbFxuICAgICAgLy8gXCJBcHBsaWNhdGlvbiBkYXRhXCJcblxuICAgICAgaWYgKCF0aGlzLndzW2tSZWNlaXZlZENsb3NlXSkge1xuICAgICAgICBjb25zdCBmcmFtZSA9IG5ldyBXZWJzb2NrZXRGcmFtZVNlbmQoYm9keSlcblxuICAgICAgICB0aGlzLndzW2tSZXNwb25zZV0uc29ja2V0LndyaXRlKGZyYW1lLmNyZWF0ZUZyYW1lKG9wY29kZXMuUE9ORykpXG5cbiAgICAgICAgaWYgKGNoYW5uZWxzLnBpbmcuaGFzU3Vic2NyaWJlcnMpIHtcbiAgICAgICAgICBjaGFubmVscy5waW5nLnB1Ymxpc2goe1xuICAgICAgICAgICAgcGF5bG9hZDogYm9keVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9wY29kZSA9PT0gb3Bjb2Rlcy5QT05HKSB7XG4gICAgICAvLyBBIFBvbmcgZnJhbWUgTUFZIGJlIHNlbnQgdW5zb2xpY2l0ZWQuICBUaGlzIHNlcnZlcyBhcyBhXG4gICAgICAvLyB1bmlkaXJlY3Rpb25hbCBoZWFydGJlYXQuICBBIHJlc3BvbnNlIHRvIGFuIHVuc29saWNpdGVkIFBvbmcgZnJhbWUgaXNcbiAgICAgIC8vIG5vdCBleHBlY3RlZC5cblxuICAgICAgaWYgKGNoYW5uZWxzLnBvbmcuaGFzU3Vic2NyaWJlcnMpIHtcbiAgICAgICAgY2hhbm5lbHMucG9uZy5wdWJsaXNoKHtcbiAgICAgICAgICBwYXlsb2FkOiBib2R5XG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGdldCBjbG9zaW5nSW5mbyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2luZm8uY2xvc2VJbmZvXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEJ5dGVQYXJzZXJcbn1cbiJdLCJuYW1lcyI6WyJXcml0YWJsZSIsInJlcXVpcmUiLCJhc3NlcnQiLCJwYXJzZXJTdGF0ZXMiLCJvcGNvZGVzIiwic3RhdGVzIiwiZW1wdHlCdWZmZXIiLCJzZW50Q2xvc2VGcmFtZVN0YXRlIiwia1JlYWR5U3RhdGUiLCJrU2VudENsb3NlIiwia1Jlc3BvbnNlIiwia1JlY2VpdmVkQ2xvc2UiLCJjaGFubmVscyIsImlzVmFsaWRTdGF0dXNDb2RlIiwiaXNWYWxpZE9wY29kZSIsImZhaWxXZWJzb2NrZXRDb25uZWN0aW9uIiwid2Vic29ja2V0TWVzc2FnZVJlY2VpdmVkIiwidXRmOERlY29kZSIsImlzQ29udHJvbEZyYW1lIiwiaXNUZXh0QmluYXJ5RnJhbWUiLCJpc0NvbnRpbnVhdGlvbkZyYW1lIiwiV2Vic29ja2V0RnJhbWVTZW5kIiwiY2xvc2VXZWJTb2NrZXRDb25uZWN0aW9uIiwiUGVyTWVzc2FnZURlZmxhdGUiLCJCeXRlUGFyc2VyIiwiYnVmZmVycyIsImJ5dGVPZmZzZXQiLCJsb29wIiwic3RhdGUiLCJpbmZvIiwiZnJhZ21lbnRzIiwiZXh0ZW5zaW9ucyIsImNvbnN0cnVjdG9yIiwid3MiLCJJTkZPIiwiTWFwIiwiaGFzIiwic2V0IiwiX3dyaXRlIiwiY2h1bmsiLCJfIiwiY2FsbGJhY2siLCJwdXNoIiwibGVuZ3RoIiwicnVuIiwiYnVmZmVyIiwiY29uc3VtZSIsImZpbiIsIm9wY29kZSIsIm1hc2tlZCIsImZyYWdtZW50ZWQiLCJDT05USU5VQVRJT04iLCJwYXlsb2FkTGVuZ3RoIiwicnN2MSIsInJzdjIiLCJyc3YzIiwiY29tcHJlc3NlZCIsIlJFQURfREFUQSIsIlBBWUxPQURMRU5HVEhfMTYiLCJQQVlMT0FETEVOR1RIXzY0IiwiYmluYXJ5VHlwZSIsInJlYWRVSW50MTZCRSIsInVwcGVyIiwicmVhZFVJbnQzMkJFIiwibG93ZXIiLCJib2R5IiwicGFyc2VDb250cm9sRnJhbWUiLCJmdWxsTWVzc2FnZSIsIkJ1ZmZlciIsImNvbmNhdCIsImdldCIsImRlY29tcHJlc3MiLCJlcnJvciIsImRhdGEiLCJtZXNzYWdlIiwibiIsIkVycm9yIiwic2hpZnQiLCJhbGxvY1Vuc2FmZSIsIm9mZnNldCIsIm5leHQiLCJzdWJhcnJheSIsInBhcnNlQ2xvc2VCb2R5IiwiY29kZSIsInVuZGVmaW5lZCIsInJlYXNvbiIsIkNMT1NFIiwiY2xvc2VJbmZvIiwiU0VOVCIsIndyaXRlVUludDE2QkUiLCJjbG9zZUZyYW1lIiwic29ja2V0Iiwid3JpdGUiLCJjcmVhdGVGcmFtZSIsImVyciIsIkNMT1NJTkciLCJQSU5HIiwiZnJhbWUiLCJQT05HIiwicGluZyIsImhhc1N1YnNjcmliZXJzIiwicHVibGlzaCIsInBheWxvYWQiLCJwb25nIiwiY2xvc2luZ0luZm8iLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/websocket/receiver.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/websocket/sender.js":
/*!*********************************************************!*\
  !*** ./node_modules/undici/lib/web/websocket/sender.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { WebsocketFrameSend } = __webpack_require__(/*! ./frame */ \"(ssr)/./node_modules/undici/lib/web/websocket/frame.js\");\nconst { opcodes, sendHints } = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/undici/lib/web/websocket/constants.js\");\nconst FixedQueue = __webpack_require__(/*! ../../dispatcher/fixed-queue */ \"(ssr)/./node_modules/undici/lib/dispatcher/fixed-queue.js\");\n/** @type {typeof Uint8Array} */ const FastBuffer = Buffer[Symbol.species];\n/**\n * @typedef {object} SendQueueNode\n * @property {Promise<void> | null} promise\n * @property {((...args: any[]) => any)} callback\n * @property {Buffer | null} frame\n */ class SendQueue {\n    /**\n   * @type {FixedQueue}\n   */ #queue;\n    /**\n   * @type {boolean}\n   */ #running;\n    /** @type {import('node:net').Socket} */ #socket;\n    constructor(socket){\n        this.#queue = new FixedQueue();\n        this.#running = false;\n        this.#socket = socket;\n    }\n    add(item, cb, hint) {\n        if (hint !== sendHints.blob) {\n            const frame = createFrame(item, hint);\n            if (!this.#running) {\n                // fast-path\n                this.#socket.write(frame, cb);\n            } else {\n                /** @type {SendQueueNode} */ const node = {\n                    promise: null,\n                    callback: cb,\n                    frame\n                };\n                this.#queue.push(node);\n            }\n            return;\n        }\n        /** @type {SendQueueNode} */ const node = {\n            promise: item.arrayBuffer().then((ab)=>{\n                node.promise = null;\n                node.frame = createFrame(ab, hint);\n            }),\n            callback: cb,\n            frame: null\n        };\n        this.#queue.push(node);\n        if (!this.#running) {\n            this.#run();\n        }\n    }\n    async #run() {\n        this.#running = true;\n        const queue = this.#queue;\n        while(!queue.isEmpty()){\n            const node = queue.shift();\n            // wait pending promise\n            if (node.promise !== null) {\n                await node.promise;\n            }\n            // write\n            this.#socket.write(node.frame, node.callback);\n            // cleanup\n            node.callback = node.frame = null;\n        }\n        this.#running = false;\n    }\n}\nfunction createFrame(data, hint) {\n    return new WebsocketFrameSend(toBuffer(data, hint)).createFrame(hint === sendHints.string ? opcodes.TEXT : opcodes.BINARY);\n}\nfunction toBuffer(data, hint) {\n    switch(hint){\n        case sendHints.string:\n            return Buffer.from(data);\n        case sendHints.arrayBuffer:\n        case sendHints.blob:\n            return new FastBuffer(data);\n        case sendHints.typedArray:\n            return new FastBuffer(data.buffer, data.byteOffset, data.byteLength);\n    }\n}\nmodule.exports = {\n    SendQueue\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvd2Vic29ja2V0L3NlbmRlci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU0sRUFBRUEsa0JBQUFBLEVBQW9CLEdBQUdDLG1CQUFPQSxDQUFDO0FBQ3ZDLE1BQU0sRUFBRUMsT0FBTyxFQUFFQyxTQUFBQSxFQUFXLEdBQUdGLG1CQUFPQSxDQUFDO0FBQ3ZDLE1BQU1HLGFBQWFILG1CQUFPQSxDQUFDO0FBRTNCLGlDQUNBLE1BQU1JLGFBQWFDLE1BQU0sQ0FBQ0MsT0FBT0MsT0FBTyxDQUFDO0FBRXpDOzs7OztDQUtBLEdBRUEsTUFBTUM7SUFDSjs7R0FFRixHQUNFLENBQUNDLEtBQUssQ0FBbUI7SUFFekI7O0dBRUYsR0FDRSxDQUFDQyxPQUFPLENBQVE7SUFFaEIseUNBQ0EsQ0FBQ0MsTUFBTTtJQUVQQyxZQUFhRCxNQUFNLENBQUU7YUFWckIsQ0FBQ0YsS0FBSyxHQUFHLElBQUlOO2FBS2IsQ0FBQ08sT0FBTyxHQUFHO1FBTVQsSUFBSSxDQUFDLENBQUNDLE1BQU0sR0FBR0E7SUFDakI7SUFFQUUsSUFBS0MsSUFBSSxFQUFFQyxFQUFFLEVBQUVDLElBQUksRUFBRTtRQUNuQixJQUFJQSxTQUFTZCxVQUFVZSxJQUFJLEVBQUU7WUFDM0IsTUFBTUMsUUFBUUMsWUFBWUwsTUFBTUU7WUFDaEMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDTixPQUFPLEVBQUU7Z0JBQ2xCO2dCQUNBLElBQUksQ0FBQyxDQUFDQyxNQUFNLENBQUNTLEtBQUssQ0FBQ0YsT0FBT0g7WUFDNUIsT0FBTztnQkFDTCw2QkFDQSxNQUFNTSxPQUFPO29CQUNYQyxTQUFTO29CQUNUQyxVQUFVUjtvQkFDVkc7Z0JBQ0Y7Z0JBQ0EsSUFBSSxDQUFDLENBQUNULEtBQUssQ0FBQ2UsSUFBSSxDQUFDSDtZQUNuQjtZQUNBO1FBQ0Y7UUFFQSw2QkFDQSxNQUFNQSxPQUFPO1lBQ1hDLFNBQVNSLEtBQUtXLFdBQVcsR0FBR0MsSUFBSSxDQUFFQyxDQUFBQTtnQkFDaENOLEtBQUtDLE9BQU8sR0FBRztnQkFDZkQsS0FBS0gsS0FBSyxHQUFHQyxZQUFZUSxJQUFJWDtZQUMvQjtZQUNBTyxVQUFVUjtZQUNWRyxPQUFPO1FBQ1Q7UUFFQSxJQUFJLENBQUMsQ0FBQ1QsS0FBSyxDQUFDZSxJQUFJLENBQUNIO1FBRWpCLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQ1gsT0FBTyxFQUFFO1lBQ2xCLElBQUksQ0FBQyxDQUFDa0IsR0FBRztRQUNYO0lBQ0Y7SUFFQSxNQUFNLENBQUNBLEdBQUdDO1FBQ1IsSUFBSSxDQUFDLENBQUNuQixPQUFPLEdBQUc7UUFDaEIsTUFBTUQsUUFBUSxJQUFJLENBQUMsQ0FBQ0EsS0FBSztRQUN6QixNQUFPLENBQUNBLE1BQU1xQixPQUFPLEdBQUk7WUFDdkIsTUFBTVQsT0FBT1osTUFBTXNCLEtBQUs7WUFDeEI7WUFDQSxJQUFJVixLQUFLQyxPQUFPLEtBQUssTUFBTTtnQkFDekIsTUFBTUQsS0FBS0MsT0FBTztZQUNwQjtZQUNBO1lBQ0EsSUFBSSxDQUFDLENBQUNYLE1BQU0sQ0FBQ1MsS0FBSyxDQUFDQyxLQUFLSCxLQUFLLEVBQUVHLEtBQUtFLFFBQVE7WUFDNUM7WUFDQUYsS0FBS0UsUUFBUSxHQUFHRixLQUFLSCxLQUFLLEdBQUc7UUFDL0I7UUFDQSxJQUFJLENBQUMsQ0FBQ1IsT0FBTyxHQUFHO0lBQ2xCO0FBQ0Y7QUFFQSxTQUFTUyxZQUFhYSxJQUFJLEVBQUVoQixJQUFJO0lBQzlCLE9BQU8sSUFBSWpCLG1CQUFtQmtDLFNBQVNELE1BQU1oQixPQUFPRyxXQUFXLENBQUNILFNBQVNkLFVBQVVnQyxNQUFNLEdBQUdqQyxRQUFRa0MsSUFBSSxHQUFHbEMsUUFBUW1DLE1BQU07QUFDM0g7QUFFQSxTQUFTSCxTQUFVRCxJQUFJLEVBQUVoQixJQUFJO0lBQzNCLE9BQVFBO1FBQ04sS0FBS2QsVUFBVWdDLE1BQU07WUFDbkIsT0FBTzdCLE9BQU9nQyxJQUFJLENBQUNMO1FBQ3JCLEtBQUs5QixVQUFVdUIsV0FBVztRQUMxQixLQUFLdkIsVUFBVWUsSUFBSTtZQUNqQixPQUFPLElBQUliLFdBQVc0QjtRQUN4QixLQUFLOUIsVUFBVW9DLFVBQVU7WUFDdkIsT0FBTyxJQUFJbEMsV0FBVzRCLEtBQUtPLE1BQU0sRUFBRVAsS0FBS1EsVUFBVSxFQUFFUixLQUFLUyxVQUFVO0lBQ3ZFO0FBQ0Y7QUFFQUMsT0FBT0MsT0FBTyxHQUFHO0lBQUVuQztBQUFVIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbW9ja3VwZmxvdy8uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL3dlYi93ZWJzb2NrZXQvc2VuZGVyLmpzPzg2NTgiLCJ3ZWJwYWNrOi8vbW9ja3VwZmxvdy8uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL3dlYi93ZWJzb2NrZXQvc2VuZGVyLmpzPzg2NTgqIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IFdlYnNvY2tldEZyYW1lU2VuZCB9ID0gcmVxdWlyZSgnLi9mcmFtZScpXG5jb25zdCB7IG9wY29kZXMsIHNlbmRIaW50cyB9ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKVxuY29uc3QgRml4ZWRRdWV1ZSA9IHJlcXVpcmUoJy4uLy4uL2Rpc3BhdGNoZXIvZml4ZWQtcXVldWUnKVxuXG4vKiogQHR5cGUge3R5cGVvZiBVaW50OEFycmF5fSAqL1xuY29uc3QgRmFzdEJ1ZmZlciA9IEJ1ZmZlcltTeW1ib2wuc3BlY2llc11cblxuLyoqXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBTZW5kUXVldWVOb2RlXG4gKiBAcHJvcGVydHkge1Byb21pc2U8dm9pZD4gfCBudWxsfSBwcm9taXNlXG4gKiBAcHJvcGVydHkgeygoLi4uYXJnczogYW55W10pID0+IGFueSl9IGNhbGxiYWNrXG4gKiBAcHJvcGVydHkge0J1ZmZlciB8IG51bGx9IGZyYW1lXG4gKi9cblxuY2xhc3MgU2VuZFF1ZXVlIHtcbiAgLyoqXG4gICAqIEB0eXBlIHtGaXhlZFF1ZXVlfVxuICAgKi9cbiAgI3F1ZXVlID0gbmV3IEZpeGVkUXVldWUoKVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gICNydW5uaW5nID0gZmFsc2VcblxuICAvKiogQHR5cGUge2ltcG9ydCgnbm9kZTpuZXQnKS5Tb2NrZXR9ICovXG4gICNzb2NrZXRcblxuICBjb25zdHJ1Y3RvciAoc29ja2V0KSB7XG4gICAgdGhpcy4jc29ja2V0ID0gc29ja2V0XG4gIH1cblxuICBhZGQgKGl0ZW0sIGNiLCBoaW50KSB7XG4gICAgaWYgKGhpbnQgIT09IHNlbmRIaW50cy5ibG9iKSB7XG4gICAgICBjb25zdCBmcmFtZSA9IGNyZWF0ZUZyYW1lKGl0ZW0sIGhpbnQpXG4gICAgICBpZiAoIXRoaXMuI3J1bm5pbmcpIHtcbiAgICAgICAgLy8gZmFzdC1wYXRoXG4gICAgICAgIHRoaXMuI3NvY2tldC53cml0ZShmcmFtZSwgY2IpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvKiogQHR5cGUge1NlbmRRdWV1ZU5vZGV9ICovXG4gICAgICAgIGNvbnN0IG5vZGUgPSB7XG4gICAgICAgICAgcHJvbWlzZTogbnVsbCxcbiAgICAgICAgICBjYWxsYmFjazogY2IsXG4gICAgICAgICAgZnJhbWVcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNxdWV1ZS5wdXNoKG5vZGUpXG4gICAgICB9XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvKiogQHR5cGUge1NlbmRRdWV1ZU5vZGV9ICovXG4gICAgY29uc3Qgbm9kZSA9IHtcbiAgICAgIHByb21pc2U6IGl0ZW0uYXJyYXlCdWZmZXIoKS50aGVuKChhYikgPT4ge1xuICAgICAgICBub2RlLnByb21pc2UgPSBudWxsXG4gICAgICAgIG5vZGUuZnJhbWUgPSBjcmVhdGVGcmFtZShhYiwgaGludClcbiAgICAgIH0pLFxuICAgICAgY2FsbGJhY2s6IGNiLFxuICAgICAgZnJhbWU6IG51bGxcbiAgICB9XG5cbiAgICB0aGlzLiNxdWV1ZS5wdXNoKG5vZGUpXG5cbiAgICBpZiAoIXRoaXMuI3J1bm5pbmcpIHtcbiAgICAgIHRoaXMuI3J1bigpXG4gICAgfVxuICB9XG5cbiAgYXN5bmMgI3J1biAoKSB7XG4gICAgdGhpcy4jcnVubmluZyA9IHRydWVcbiAgICBjb25zdCBxdWV1ZSA9IHRoaXMuI3F1ZXVlXG4gICAgd2hpbGUgKCFxdWV1ZS5pc0VtcHR5KCkpIHtcbiAgICAgIGNvbnN0IG5vZGUgPSBxdWV1ZS5zaGlmdCgpXG4gICAgICAvLyB3YWl0IHBlbmRpbmcgcHJvbWlzZVxuICAgICAgaWYgKG5vZGUucHJvbWlzZSAhPT0gbnVsbCkge1xuICAgICAgICBhd2FpdCBub2RlLnByb21pc2VcbiAgICAgIH1cbiAgICAgIC8vIHdyaXRlXG4gICAgICB0aGlzLiNzb2NrZXQud3JpdGUobm9kZS5mcmFtZSwgbm9kZS5jYWxsYmFjaylcbiAgICAgIC8vIGNsZWFudXBcbiAgICAgIG5vZGUuY2FsbGJhY2sgPSBub2RlLmZyYW1lID0gbnVsbFxuICAgIH1cbiAgICB0aGlzLiNydW5uaW5nID0gZmFsc2VcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVGcmFtZSAoZGF0YSwgaGludCkge1xuICByZXR1cm4gbmV3IFdlYnNvY2tldEZyYW1lU2VuZCh0b0J1ZmZlcihkYXRhLCBoaW50KSkuY3JlYXRlRnJhbWUoaGludCA9PT0gc2VuZEhpbnRzLnN0cmluZyA/IG9wY29kZXMuVEVYVCA6IG9wY29kZXMuQklOQVJZKVxufVxuXG5mdW5jdGlvbiB0b0J1ZmZlciAoZGF0YSwgaGludCkge1xuICBzd2l0Y2ggKGhpbnQpIHtcbiAgICBjYXNlIHNlbmRIaW50cy5zdHJpbmc6XG4gICAgICByZXR1cm4gQnVmZmVyLmZyb20oZGF0YSlcbiAgICBjYXNlIHNlbmRIaW50cy5hcnJheUJ1ZmZlcjpcbiAgICBjYXNlIHNlbmRIaW50cy5ibG9iOlxuICAgICAgcmV0dXJuIG5ldyBGYXN0QnVmZmVyKGRhdGEpXG4gICAgY2FzZSBzZW5kSGludHMudHlwZWRBcnJheTpcbiAgICAgIHJldHVybiBuZXcgRmFzdEJ1ZmZlcihkYXRhLmJ1ZmZlciwgZGF0YS5ieXRlT2Zmc2V0LCBkYXRhLmJ5dGVMZW5ndGgpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7IFNlbmRRdWV1ZSB9XG4iXSwibmFtZXMiOlsiV2Vic29ja2V0RnJhbWVTZW5kIiwicmVxdWlyZSIsIm9wY29kZXMiLCJzZW5kSGludHMiLCJGaXhlZFF1ZXVlIiwiRmFzdEJ1ZmZlciIsIkJ1ZmZlciIsIlN5bWJvbCIsInNwZWNpZXMiLCJTZW5kUXVldWUiLCJxdWV1ZSIsInJ1bm5pbmciLCJzb2NrZXQiLCJjb25zdHJ1Y3RvciIsImFkZCIsIml0ZW0iLCJjYiIsImhpbnQiLCJibG9iIiwiZnJhbWUiLCJjcmVhdGVGcmFtZSIsIndyaXRlIiwibm9kZSIsInByb21pc2UiLCJjYWxsYmFjayIsInB1c2giLCJhcnJheUJ1ZmZlciIsInRoZW4iLCJhYiIsInJ1biIsIiNydW4iLCJpc0VtcHR5Iiwic2hpZnQiLCJkYXRhIiwidG9CdWZmZXIiLCJzdHJpbmciLCJURVhUIiwiQklOQVJZIiwiZnJvbSIsInR5cGVkQXJyYXkiLCJidWZmZXIiLCJieXRlT2Zmc2V0IiwiYnl0ZUxlbmd0aCIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/websocket/sender.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/websocket/symbols.js":
/*!**********************************************************!*\
  !*** ./node_modules/undici/lib/web/websocket/symbols.js ***!
  \**********************************************************/
/***/ ((module) => {

eval("\nmodule.exports = {\n    kWebSocketURL: Symbol(\"url\"),\n    kReadyState: Symbol(\"ready state\"),\n    kController: Symbol(\"controller\"),\n    kResponse: Symbol(\"response\"),\n    kBinaryType: Symbol(\"binary type\"),\n    kSentClose: Symbol(\"sent close\"),\n    kReceivedClose: Symbol(\"received close\"),\n    kByteParser: Symbol(\"byte parser\")\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvd2Vic29ja2V0L3N5bWJvbHMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQUEsT0FBT0MsT0FBTyxHQUFHO0lBQ2ZDLGVBQWVDLE9BQU87SUFDdEJDLGFBQWFELE9BQU87SUFDcEJFLGFBQWFGLE9BQU87SUFDcEJHLFdBQVdILE9BQU87SUFDbEJJLGFBQWFKLE9BQU87SUFDcEJLLFlBQVlMLE9BQU87SUFDbkJNLGdCQUFnQk4sT0FBTztJQUN2Qk8sYUFBYVAsT0FBTztBQUN0QiIsInNvdXJjZXMiOlsid2VicGFjazovL21vY2t1cGZsb3cvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvd2Vic29ja2V0L3N5bWJvbHMuanM/MjRlYyIsIndlYnBhY2s6Ly9tb2NrdXBmbG93Ly4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvd2ViL3dlYnNvY2tldC9zeW1ib2xzLmpzPzI0ZWMqIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAga1dlYlNvY2tldFVSTDogU3ltYm9sKCd1cmwnKSxcbiAga1JlYWR5U3RhdGU6IFN5bWJvbCgncmVhZHkgc3RhdGUnKSxcbiAga0NvbnRyb2xsZXI6IFN5bWJvbCgnY29udHJvbGxlcicpLFxuICBrUmVzcG9uc2U6IFN5bWJvbCgncmVzcG9uc2UnKSxcbiAga0JpbmFyeVR5cGU6IFN5bWJvbCgnYmluYXJ5IHR5cGUnKSxcbiAga1NlbnRDbG9zZTogU3ltYm9sKCdzZW50IGNsb3NlJyksXG4gIGtSZWNlaXZlZENsb3NlOiBTeW1ib2woJ3JlY2VpdmVkIGNsb3NlJyksXG4gIGtCeXRlUGFyc2VyOiBTeW1ib2woJ2J5dGUgcGFyc2VyJylcbn1cbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwia1dlYlNvY2tldFVSTCIsIlN5bWJvbCIsImtSZWFkeVN0YXRlIiwia0NvbnRyb2xsZXIiLCJrUmVzcG9uc2UiLCJrQmluYXJ5VHlwZSIsImtTZW50Q2xvc2UiLCJrUmVjZWl2ZWRDbG9zZSIsImtCeXRlUGFyc2VyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/websocket/symbols.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/websocket/util.js":
/*!*******************************************************!*\
  !*** ./node_modules/undici/lib/web/websocket/util.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { kReadyState, kController, kResponse, kBinaryType, kWebSocketURL } = __webpack_require__(/*! ./symbols */ \"(ssr)/./node_modules/undici/lib/web/websocket/symbols.js\");\nconst { states, opcodes } = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/undici/lib/web/websocket/constants.js\");\nconst { ErrorEvent, createFastMessageEvent } = __webpack_require__(/*! ./events */ \"(ssr)/./node_modules/undici/lib/web/websocket/events.js\");\nconst { isUtf8 } = __webpack_require__(/*! node:buffer */ \"node:buffer\");\nconst { collectASequenceOfCodePointsFast, removeHTTPWhitespace } = __webpack_require__(/*! ../fetch/data-url */ \"(ssr)/./node_modules/undici/lib/web/fetch/data-url.js\");\n/* globals Blob */ /**\n * @param {import('./websocket').WebSocket} ws\n * @returns {boolean}\n */ function isConnecting(ws) {\n    // If the WebSocket connection is not yet established, and the connection\n    // is not yet closed, then the WebSocket connection is in the CONNECTING state.\n    return ws[kReadyState] === states.CONNECTING;\n}\n/**\n * @param {import('./websocket').WebSocket} ws\n * @returns {boolean}\n */ function isEstablished(ws) {\n    // If the server's response is validated as provided for above, it is\n    // said that _The WebSocket Connection is Established_ and that the\n    // WebSocket Connection is in the OPEN state.\n    return ws[kReadyState] === states.OPEN;\n}\n/**\n * @param {import('./websocket').WebSocket} ws\n * @returns {boolean}\n */ function isClosing(ws) {\n    // Upon either sending or receiving a Close control frame, it is said\n    // that _The WebSocket Closing Handshake is Started_ and that the\n    // WebSocket connection is in the CLOSING state.\n    return ws[kReadyState] === states.CLOSING;\n}\n/**\n * @param {import('./websocket').WebSocket} ws\n * @returns {boolean}\n */ function isClosed(ws) {\n    return ws[kReadyState] === states.CLOSED;\n}\n/**\n * @see https://dom.spec.whatwg.org/#concept-event-fire\n * @param {string} e\n * @param {EventTarget} target\n * @param {(...args: ConstructorParameters<typeof Event>) => Event} eventFactory\n * @param {EventInit | undefined} eventInitDict\n */ function fireEvent(e, target, eventFactory = (type, init)=>new Event(type, init), eventInitDict = {}) {\n    // 1. If eventConstructor is not given, then let eventConstructor be Event.\n    // 2. Let event be the result of creating an event given eventConstructor,\n    //    in the relevant realm of target.\n    // 3. Initialize events type attribute to e.\n    const event = eventFactory(e, eventInitDict);\n    // 4. Initialize any other IDL attributes of event as described in the\n    //    invocation of this algorithm.\n    // 5. Return the result of dispatching event at target, with legacy target\n    //    override flag set if set.\n    target.dispatchEvent(event);\n}\n/**\n * @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol\n * @param {import('./websocket').WebSocket} ws\n * @param {number} type Opcode\n * @param {Buffer} data application data\n */ function websocketMessageReceived(ws, type, data) {\n    // 1. If ready state is not OPEN (1), then return.\n    if (ws[kReadyState] !== states.OPEN) {\n        return;\n    }\n    // 2. Let dataForEvent be determined by switching on type and binary type:\n    let dataForEvent;\n    if (type === opcodes.TEXT) {\n        // -> type indicates that the data is Text\n        //      a new DOMString containing data\n        try {\n            dataForEvent = utf8Decode(data);\n        } catch  {\n            failWebsocketConnection(ws, \"Received invalid UTF-8 in text frame.\");\n            return;\n        }\n    } else if (type === opcodes.BINARY) {\n        if (ws[kBinaryType] === \"blob\") {\n            // -> type indicates that the data is Binary and binary type is \"blob\"\n            //      a new Blob object, created in the relevant Realm of the WebSocket\n            //      object, that represents data as its raw data\n            dataForEvent = new Blob([\n                data\n            ]);\n        } else {\n            // -> type indicates that the data is Binary and binary type is \"arraybuffer\"\n            //      a new ArrayBuffer object, created in the relevant Realm of the\n            //      WebSocket object, whose contents are data\n            dataForEvent = toArrayBuffer(data);\n        }\n    }\n    // 3. Fire an event named message at the WebSocket object, using MessageEvent,\n    //    with the origin attribute initialized to the serialization of the WebSocket\n    //    objects url's origin, and the data attribute initialized to dataForEvent.\n    fireEvent(\"message\", ws, createFastMessageEvent, {\n        origin: ws[kWebSocketURL].origin,\n        data: dataForEvent\n    });\n}\nfunction toArrayBuffer(buffer) {\n    if (buffer.byteLength === buffer.buffer.byteLength) {\n        return buffer.buffer;\n    }\n    return buffer.buffer.slice(buffer.byteOffset, buffer.byteOffset + buffer.byteLength);\n}\n/**\n * @see https://datatracker.ietf.org/doc/html/rfc6455\n * @see https://datatracker.ietf.org/doc/html/rfc2616\n * @see https://bugs.chromium.org/p/chromium/issues/detail?id=398407\n * @param {string} protocol\n */ function isValidSubprotocol(protocol) {\n    // If present, this value indicates one\n    // or more comma-separated subprotocol the client wishes to speak,\n    // ordered by preference.  The elements that comprise this value\n    // MUST be non-empty strings with characters in the range U+0021 to\n    // U+007E not including separator characters as defined in\n    // [RFC2616] and MUST all be unique strings.\n    if (protocol.length === 0) {\n        return false;\n    }\n    for(let i = 0; i < protocol.length; ++i){\n        const code = protocol.charCodeAt(i);\n        if (code < 0x21 || // CTL, contains SP (0x20) and HT (0x09)\n        code > 0x7E || code === 0x22 || // \"\n        code === 0x28 || // (\n        code === 0x29 || // )\n        code === 0x2C || // ,\n        code === 0x2F || // /\n        code === 0x3A || // :\n        code === 0x3B || // ;\n        code === 0x3C || // <\n        code === 0x3D || // =\n        code === 0x3E || // >\n        code === 0x3F || // ?\n        code === 0x40 || // @\n        code === 0x5B || // [\n        code === 0x5C || // \\\n        code === 0x5D || // ]\n        code === 0x7B || // {\n        code === 0x7D // }\n        ) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * @see https://datatracker.ietf.org/doc/html/rfc6455#section-7-4\n * @param {number} code\n */ function isValidStatusCode(code) {\n    if (code >= 1000 && code < 1015) {\n        return code !== 1004 && // reserved\n        code !== 1005 && // \"MUST NOT be set as a status code\"\n        code !== 1006 // \"MUST NOT be set as a status code\"\n        ;\n    }\n    return code >= 3000 && code <= 4999;\n}\n/**\n * @param {import('./websocket').WebSocket} ws\n * @param {string|undefined} reason\n */ function failWebsocketConnection(ws, reason) {\n    const { [kController]: controller, [kResponse]: response } = ws;\n    controller.abort();\n    if (response?.socket && !response.socket.destroyed) {\n        response.socket.destroy();\n    }\n    if (reason) {\n        // TODO: process.nextTick\n        fireEvent(\"error\", ws, (type, init)=>new ErrorEvent(type, init), {\n            error: new Error(reason),\n            message: reason\n        });\n    }\n}\n/**\n * @see https://datatracker.ietf.org/doc/html/rfc6455#section-5.5\n * @param {number} opcode\n */ function isControlFrame(opcode) {\n    return opcode === opcodes.CLOSE || opcode === opcodes.PING || opcode === opcodes.PONG;\n}\nfunction isContinuationFrame(opcode) {\n    return opcode === opcodes.CONTINUATION;\n}\nfunction isTextBinaryFrame(opcode) {\n    return opcode === opcodes.TEXT || opcode === opcodes.BINARY;\n}\nfunction isValidOpcode(opcode) {\n    return isTextBinaryFrame(opcode) || isContinuationFrame(opcode) || isControlFrame(opcode);\n}\n/**\n * Parses a Sec-WebSocket-Extensions header value.\n * @param {string} extensions\n * @returns {Map<string, string>}\n */ // TODO(@Uzlopak, @KhafraDev): make compliant https://datatracker.ietf.org/doc/html/rfc6455#section-9.1\nfunction parseExtensions(extensions) {\n    const position = {\n        position: 0\n    };\n    const extensionList = new Map();\n    while(position.position < extensions.length){\n        const pair = collectASequenceOfCodePointsFast(\";\", extensions, position);\n        const [name, value = \"\"] = pair.split(\"=\");\n        extensionList.set(removeHTTPWhitespace(name, true, false), removeHTTPWhitespace(value, false, true));\n        position.position++;\n    }\n    return extensionList;\n}\n/**\n * @see https://www.rfc-editor.org/rfc/rfc7692#section-7.1.2.2\n * @description \"client-max-window-bits = 1*DIGIT\"\n * @param {string} value\n */ function isValidClientWindowBits(value) {\n    for(let i = 0; i < value.length; i++){\n        const byte = value.charCodeAt(i);\n        if (byte < 0x30 || byte > 0x39) {\n            return false;\n        }\n    }\n    return true;\n}\n// https://nodejs.org/api/intl.html#detecting-internationalization-support\nconst hasIntl = typeof process.versions.icu === \"string\";\nconst fatalDecoder = hasIntl ? new TextDecoder(\"utf-8\", {\n    fatal: true\n}) : undefined;\n/**\n * Converts a Buffer to utf-8, even on platforms without icu.\n * @param {Buffer} buffer\n */ const utf8Decode = hasIntl ? fatalDecoder.decode.bind(fatalDecoder) : function(buffer) {\n    if (isUtf8(buffer)) {\n        return buffer.toString(\"utf-8\");\n    }\n    throw new TypeError(\"Invalid utf-8 received.\");\n};\nmodule.exports = {\n    isConnecting,\n    isEstablished,\n    isClosing,\n    isClosed,\n    fireEvent,\n    isValidSubprotocol,\n    isValidStatusCode,\n    failWebsocketConnection,\n    websocketMessageReceived,\n    utf8Decode,\n    isControlFrame,\n    isContinuationFrame,\n    isTextBinaryFrame,\n    isValidOpcode,\n    parseExtensions,\n    isValidClientWindowBits\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvd2Vic29ja2V0L3V0aWwuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNLEVBQUVBLFdBQVcsRUFBRUMsV0FBVyxFQUFFQyxTQUFTLEVBQUVDLFdBQVcsRUFBRUMsYUFBQUEsRUFBZSxHQUFHQyxtQkFBT0EsQ0FBQztBQUNwRixNQUFNLEVBQUVDLE1BQU0sRUFBRUMsT0FBQUEsRUFBUyxHQUFHRixtQkFBT0EsQ0FBQztBQUNwQyxNQUFNLEVBQUVHLFVBQVUsRUFBRUMsc0JBQUFBLEVBQXdCLEdBQUdKLG1CQUFPQSxDQUFDO0FBQ3ZELE1BQU0sRUFBRUssTUFBQUEsRUFBUSxHQUFHTCxtQkFBT0EsQ0FBQztBQUMzQixNQUFNLEVBQUVNLGdDQUFnQyxFQUFFQyxvQkFBQUEsRUFBc0IsR0FBR1AsbUJBQU9BLENBQUM7QUFFM0UsbUJBRUE7OztDQUdBLEdBQ0EsU0FBU1EsYUFBY0MsRUFBRTtJQUN2QjtJQUNBO0lBQ0EsT0FBT0EsRUFBRSxDQUFDZCxZQUFZLEtBQUtNLE9BQU9TLFVBQVU7QUFDOUM7QUFFQTs7O0NBR0EsR0FDQSxTQUFTQyxjQUFlRixFQUFFO0lBQ3hCO0lBQ0E7SUFDQTtJQUNBLE9BQU9BLEVBQUUsQ0FBQ2QsWUFBWSxLQUFLTSxPQUFPVyxJQUFJO0FBQ3hDO0FBRUE7OztDQUdBLEdBQ0EsU0FBU0MsVUFBV0osRUFBRTtJQUNwQjtJQUNBO0lBQ0E7SUFDQSxPQUFPQSxFQUFFLENBQUNkLFlBQVksS0FBS00sT0FBT2EsT0FBTztBQUMzQztBQUVBOzs7Q0FHQSxHQUNBLFNBQVNDLFNBQVVOLEVBQUU7SUFDbkIsT0FBT0EsRUFBRSxDQUFDZCxZQUFZLEtBQUtNLE9BQU9lLE1BQU07QUFDMUM7QUFFQTs7Ozs7O0NBTUEsR0FDQSxTQUFTQyxVQUFXQyxDQUFDLEVBQUVDLE1BQU0sRUFBRUMsZUFBZUEsQ0FBQ0MsTUFBTUMsT0FBUyxJQUFJQyxNQUFNRixNQUFNQyxLQUFLLEVBQUVFLGdCQUFnQixDQUFDLENBQUM7SUFDckc7SUFFQTtJQUNBO0lBQ0E7SUFDQSxNQUFNQyxRQUFRTCxhQUFhRixHQUFHTTtJQUU5QjtJQUNBO0lBRUE7SUFDQTtJQUNBTCxPQUFPTyxhQUFhLENBQUNEO0FBQ3ZCO0FBRUE7Ozs7O0NBS0EsR0FDQSxTQUFTRSx5QkFBMEJsQixFQUFFLEVBQUVZLElBQUksRUFBRU8sSUFBSTtJQUMvQztJQUNBLElBQUluQixFQUFFLENBQUNkLFlBQVksS0FBS00sT0FBT1csSUFBSSxFQUFFO1FBQ25DO0lBQ0Y7SUFFQTtJQUNBLElBQUlpQjtJQUVKLElBQUlSLFNBQVNuQixRQUFRNEIsSUFBSSxFQUFFO1FBQ3pCO1FBQ0E7UUFDQSxJQUFJO1lBQ0ZELGVBQWVFLFdBQVdIO1FBQzVCLEVBQUUsT0FBTTtZQUNOSSx3QkFBd0J2QixJQUFJO1lBQzVCO1FBQ0Y7SUFDRixPQUFPLElBQUlZLFNBQVNuQixRQUFRK0IsTUFBTSxFQUFFO1FBQ2xDLElBQUl4QixFQUFFLENBQUNYLFlBQVksS0FBSyxRQUFRO1lBQzlCO1lBQ0E7WUFDQTtZQUNBK0IsZUFBZSxJQUFJSyxLQUFLO2dCQUFDTjthQUFLO1FBQ2hDLE9BQU87WUFDTDtZQUNBO1lBQ0E7WUFDQUMsZUFBZU0sY0FBY1A7UUFDL0I7SUFDRjtJQUVBO0lBQ0E7SUFDQTtJQUNBWCxVQUFVLFdBQVdSLElBQUlMLHdCQUF3QjtRQUMvQ2dDLFFBQVEzQixFQUFFLENBQUNWLGNBQWMsQ0FBQ3FDLE1BQU07UUFDaENSLE1BQU1DO0lBQ1I7QUFDRjtBQUVBLFNBQVNNLGNBQWVFLE1BQU07SUFDNUIsSUFBSUEsT0FBT0MsVUFBVSxLQUFLRCxPQUFPQSxNQUFNLENBQUNDLFVBQVUsRUFBRTtRQUNsRCxPQUFPRCxPQUFPQSxNQUFNO0lBQ3RCO0lBQ0EsT0FBT0EsT0FBT0EsTUFBTSxDQUFDRSxLQUFLLENBQUNGLE9BQU9HLFVBQVUsRUFBRUgsT0FBT0csVUFBVSxHQUFHSCxPQUFPQyxVQUFVO0FBQ3JGO0FBRUE7Ozs7O0NBS0EsR0FDQSxTQUFTRyxtQkFBb0JDLFFBQVE7SUFDbkM7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsSUFBSUEsU0FBU0MsTUFBTSxLQUFLLEdBQUc7UUFDekIsT0FBTztJQUNUO0lBRUEsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlGLFNBQVNDLE1BQU0sRUFBRSxFQUFFQyxFQUFHO1FBQ3hDLE1BQU1DLE9BQU9ILFNBQVNJLFVBQVUsQ0FBQ0Y7UUFFakMsSUFDRUMsT0FBTyxRQUFRO1FBQ2ZBLE9BQU8sUUFDUEEsU0FBUyxRQUFRO1FBQ2pCQSxTQUFTLFFBQVE7UUFDakJBLFNBQVMsUUFBUTtRQUNqQkEsU0FBUyxRQUFRO1FBQ2pCQSxTQUFTLFFBQVE7UUFDakJBLFNBQVMsUUFBUTtRQUNqQkEsU0FBUyxRQUFRO1FBQ2pCQSxTQUFTLFFBQVE7UUFDakJBLFNBQVMsUUFBUTtRQUNqQkEsU0FBUyxRQUFRO1FBQ2pCQSxTQUFTLFFBQVE7UUFDakJBLFNBQVMsUUFBUTtRQUNqQkEsU0FBUyxRQUFRO1FBQ2pCQSxTQUFTLFFBQVE7UUFDakJBLFNBQVMsUUFBUTtRQUNqQkEsU0FBUyxRQUFRO1FBQ2pCQSxTQUFTLEtBQUs7VUFDZDtZQUNBLE9BQU87UUFDVDtJQUNGO0lBRUEsT0FBTztBQUNUO0FBRUE7OztDQUdBLEdBQ0EsU0FBU0Usa0JBQW1CRixJQUFJO0lBQzlCLElBQUlBLFFBQVEsUUFBUUEsT0FBTyxNQUFNO1FBQy9CLE9BQ0VBLFNBQVMsUUFBUTtRQUNqQkEsU0FBUyxRQUFRO1FBQ2pCQSxTQUFTLEtBQUs7O0lBRWxCO0lBRUEsT0FBT0EsUUFBUSxRQUFRQSxRQUFRO0FBQ2pDO0FBRUE7OztDQUdBLEdBQ0EsU0FBU2Isd0JBQXlCdkIsRUFBRSxFQUFFdUMsTUFBTTtJQUMxQyxNQUFNLEVBQUUsQ0FBQ3BELFlBQVcsRUFBR3FELFVBQVUsRUFBRSxDQUFDcEQsVUFBUyxFQUFHcUQsUUFBQUEsRUFBVSxHQUFHekM7SUFFN0R3QyxXQUFXRSxLQUFLO0lBRWhCLElBQUlELFVBQVVFLFVBQVUsQ0FBQ0YsU0FBU0UsTUFBTSxDQUFDQyxTQUFTLEVBQUU7UUFDbERILFNBQVNFLE1BQU0sQ0FBQ0UsT0FBTztJQUN6QjtJQUVBLElBQUlOLFFBQVE7UUFDVjtRQUNBL0IsVUFBVSxTQUFTUixJQUFJLENBQUNZLE1BQU1DLE9BQVMsSUFBSW5CLFdBQVdrQixNQUFNQyxPQUFPO1lBQ2pFaUMsT0FBTyxJQUFJQyxNQUFNUjtZQUNqQlMsU0FBU1Q7UUFDWDtJQUNGO0FBQ0Y7QUFFQTs7O0NBR0EsR0FDQSxTQUFTVSxlQUFnQkMsTUFBTTtJQUM3QixPQUNFQSxXQUFXekQsUUFBUTBELEtBQUssSUFDeEJELFdBQVd6RCxRQUFRMkQsSUFBSSxJQUN2QkYsV0FBV3pELFFBQVE0RCxJQUFJO0FBRTNCO0FBRUEsU0FBU0Msb0JBQXFCSixNQUFNO0lBQ2xDLE9BQU9BLFdBQVd6RCxRQUFROEQsWUFBWTtBQUN4QztBQUVBLFNBQVNDLGtCQUFtQk4sTUFBTTtJQUNoQyxPQUFPQSxXQUFXekQsUUFBUTRCLElBQUksSUFBSTZCLFdBQVd6RCxRQUFRK0IsTUFBTTtBQUM3RDtBQUVBLFNBQVNpQyxjQUFlUCxNQUFNO0lBQzVCLE9BQU9NLGtCQUFrQk4sV0FBV0ksb0JBQW9CSixXQUFXRCxlQUFlQztBQUNwRjtBQUVBOzs7O0NBSUEsR0FDQTtBQUNBLFNBQVNRLGdCQUFpQkMsVUFBVTtJQUNsQyxNQUFNQyxXQUFXO1FBQUVBLFVBQVU7SUFBRTtJQUMvQixNQUFNQyxnQkFBZ0IsSUFBSUM7SUFFMUIsTUFBT0YsU0FBU0EsUUFBUSxHQUFHRCxXQUFXekIsTUFBTSxDQUFFO1FBQzVDLE1BQU02QixPQUFPbEUsaUNBQWlDLEtBQUs4RCxZQUFZQztRQUMvRCxNQUFNLENBQUNJLE1BQU1DLFFBQVEsRUFBRSxDQUFDLEdBQUdGLEtBQUtHLEtBQUssQ0FBQztRQUV0Q0wsY0FBY00sR0FBRyxDQUNmckUscUJBQXFCa0UsTUFBTSxNQUFNLFFBQ2pDbEUscUJBQXFCbUUsT0FBTyxPQUFPO1FBR3JDTCxTQUFTQSxRQUFRO0lBQ25CO0lBRUEsT0FBT0M7QUFDVDtBQUVBOzs7O0NBSUEsR0FDQSxTQUFTTyx3QkFBeUJILEtBQUs7SUFDckMsSUFBSyxJQUFJOUIsSUFBSSxHQUFHQSxJQUFJOEIsTUFBTS9CLE1BQU0sRUFBRUMsSUFBSztRQUNyQyxNQUFNa0MsT0FBT0osTUFBTTVCLFVBQVUsQ0FBQ0Y7UUFFOUIsSUFBSWtDLE9BQU8sUUFBUUEsT0FBTyxNQUFNO1lBQzlCLE9BQU87UUFDVDtJQUNGO0lBRUEsT0FBTztBQUNUO0FBRUE7QUFDQSxNQUFNQyxVQUFVLE9BQU9DLFFBQVFDLFFBQVEsQ0FBQ0MsR0FBRyxLQUFLO0FBQ2hELE1BQU1DLGVBQWVKLFVBQVUsSUFBSUssWUFBWSxTQUFTO0lBQUVDLE9BQU87QUFBSyxLQUFLQztBQUUzRTs7O0NBR0EsR0FDQSxNQUFNdkQsYUFBYWdELFVBQ2ZJLGFBQWFJLE1BQU0sQ0FBQ0MsSUFBSSxDQUFDTCxnQkFDekIsU0FBVTlDLE1BQU07SUFDaEIsSUFBSWhDLE9BQU9nQyxTQUFTO1FBQ2xCLE9BQU9BLE9BQU9vRCxRQUFRLENBQUM7SUFDekI7SUFDQSxNQUFNLElBQUlDLFVBQVU7QUFDdEI7QUFFRkMsT0FBT0MsT0FBTyxHQUFHO0lBQ2ZwRjtJQUNBRztJQUNBRTtJQUNBRTtJQUNBRTtJQUNBd0I7SUFDQU07SUFDQWY7SUFDQUw7SUFDQUk7SUFDQTJCO0lBQ0FLO0lBQ0FFO0lBQ0FDO0lBQ0FDO0lBQ0FVO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tb2NrdXBmbG93Ly4vbm9kZV9tb2R1bGVzL3VuZGljaS9saWIvd2ViL3dlYnNvY2tldC91dGlsLmpzPzQ5OGQiLCJ3ZWJwYWNrOi8vbW9ja3VwZmxvdy8uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL3dlYi93ZWJzb2NrZXQvdXRpbC5qcz80OThkKiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyBrUmVhZHlTdGF0ZSwga0NvbnRyb2xsZXIsIGtSZXNwb25zZSwga0JpbmFyeVR5cGUsIGtXZWJTb2NrZXRVUkwgfSA9IHJlcXVpcmUoJy4vc3ltYm9scycpXG5jb25zdCB7IHN0YXRlcywgb3Bjb2RlcyB9ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKVxuY29uc3QgeyBFcnJvckV2ZW50LCBjcmVhdGVGYXN0TWVzc2FnZUV2ZW50IH0gPSByZXF1aXJlKCcuL2V2ZW50cycpXG5jb25zdCB7IGlzVXRmOCB9ID0gcmVxdWlyZSgnbm9kZTpidWZmZXInKVxuY29uc3QgeyBjb2xsZWN0QVNlcXVlbmNlT2ZDb2RlUG9pbnRzRmFzdCwgcmVtb3ZlSFRUUFdoaXRlc3BhY2UgfSA9IHJlcXVpcmUoJy4uL2ZldGNoL2RhdGEtdXJsJylcblxuLyogZ2xvYmFscyBCbG9iICovXG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJy4vd2Vic29ja2V0JykuV2ViU29ja2V0fSB3c1xuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzQ29ubmVjdGluZyAod3MpIHtcbiAgLy8gSWYgdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uIGlzIG5vdCB5ZXQgZXN0YWJsaXNoZWQsIGFuZCB0aGUgY29ubmVjdGlvblxuICAvLyBpcyBub3QgeWV0IGNsb3NlZCwgdGhlbiB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24gaXMgaW4gdGhlIENPTk5FQ1RJTkcgc3RhdGUuXG4gIHJldHVybiB3c1trUmVhZHlTdGF0ZV0gPT09IHN0YXRlcy5DT05ORUNUSU5HXG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJy4vd2Vic29ja2V0JykuV2ViU29ja2V0fSB3c1xuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzRXN0YWJsaXNoZWQgKHdzKSB7XG4gIC8vIElmIHRoZSBzZXJ2ZXIncyByZXNwb25zZSBpcyB2YWxpZGF0ZWQgYXMgcHJvdmlkZWQgZm9yIGFib3ZlLCBpdCBpc1xuICAvLyBzYWlkIHRoYXQgX1RoZSBXZWJTb2NrZXQgQ29ubmVjdGlvbiBpcyBFc3RhYmxpc2hlZF8gYW5kIHRoYXQgdGhlXG4gIC8vIFdlYlNvY2tldCBDb25uZWN0aW9uIGlzIGluIHRoZSBPUEVOIHN0YXRlLlxuICByZXR1cm4gd3Nba1JlYWR5U3RhdGVdID09PSBzdGF0ZXMuT1BFTlxufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL3dlYnNvY2tldCcpLldlYlNvY2tldH0gd3NcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0Nsb3NpbmcgKHdzKSB7XG4gIC8vIFVwb24gZWl0aGVyIHNlbmRpbmcgb3IgcmVjZWl2aW5nIGEgQ2xvc2UgY29udHJvbCBmcmFtZSwgaXQgaXMgc2FpZFxuICAvLyB0aGF0IF9UaGUgV2ViU29ja2V0IENsb3NpbmcgSGFuZHNoYWtlIGlzIFN0YXJ0ZWRfIGFuZCB0aGF0IHRoZVxuICAvLyBXZWJTb2NrZXQgY29ubmVjdGlvbiBpcyBpbiB0aGUgQ0xPU0lORyBzdGF0ZS5cbiAgcmV0dXJuIHdzW2tSZWFkeVN0YXRlXSA9PT0gc3RhdGVzLkNMT1NJTkdcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi93ZWJzb2NrZXQnKS5XZWJTb2NrZXR9IHdzXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNDbG9zZWQgKHdzKSB7XG4gIHJldHVybiB3c1trUmVhZHlTdGF0ZV0gPT09IHN0YXRlcy5DTE9TRURcbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZG9tLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1ldmVudC1maXJlXG4gKiBAcGFyYW0ge3N0cmluZ30gZVxuICogQHBhcmFtIHtFdmVudFRhcmdldH0gdGFyZ2V0XG4gKiBAcGFyYW0geyguLi5hcmdzOiBDb25zdHJ1Y3RvclBhcmFtZXRlcnM8dHlwZW9mIEV2ZW50PikgPT4gRXZlbnR9IGV2ZW50RmFjdG9yeVxuICogQHBhcmFtIHtFdmVudEluaXQgfCB1bmRlZmluZWR9IGV2ZW50SW5pdERpY3RcbiAqL1xuZnVuY3Rpb24gZmlyZUV2ZW50IChlLCB0YXJnZXQsIGV2ZW50RmFjdG9yeSA9ICh0eXBlLCBpbml0KSA9PiBuZXcgRXZlbnQodHlwZSwgaW5pdCksIGV2ZW50SW5pdERpY3QgPSB7fSkge1xuICAvLyAxLiBJZiBldmVudENvbnN0cnVjdG9yIGlzIG5vdCBnaXZlbiwgdGhlbiBsZXQgZXZlbnRDb25zdHJ1Y3RvciBiZSBFdmVudC5cblxuICAvLyAyLiBMZXQgZXZlbnQgYmUgdGhlIHJlc3VsdCBvZiBjcmVhdGluZyBhbiBldmVudCBnaXZlbiBldmVudENvbnN0cnVjdG9yLFxuICAvLyAgICBpbiB0aGUgcmVsZXZhbnQgcmVhbG0gb2YgdGFyZ2V0LlxuICAvLyAzLiBJbml0aWFsaXplIGV2ZW504oCZcyB0eXBlIGF0dHJpYnV0ZSB0byBlLlxuICBjb25zdCBldmVudCA9IGV2ZW50RmFjdG9yeShlLCBldmVudEluaXREaWN0KVxuXG4gIC8vIDQuIEluaXRpYWxpemUgYW55IG90aGVyIElETCBhdHRyaWJ1dGVzIG9mIGV2ZW50IGFzIGRlc2NyaWJlZCBpbiB0aGVcbiAgLy8gICAgaW52b2NhdGlvbiBvZiB0aGlzIGFsZ29yaXRobS5cblxuICAvLyA1LiBSZXR1cm4gdGhlIHJlc3VsdCBvZiBkaXNwYXRjaGluZyBldmVudCBhdCB0YXJnZXQsIHdpdGggbGVnYWN5IHRhcmdldFxuICAvLyAgICBvdmVycmlkZSBmbGFnIHNldCBpZiBzZXQuXG4gIHRhcmdldC5kaXNwYXRjaEV2ZW50KGV2ZW50KVxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly93ZWJzb2NrZXRzLnNwZWMud2hhdHdnLm9yZy8jZmVlZGJhY2stZnJvbS10aGUtcHJvdG9jb2xcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL3dlYnNvY2tldCcpLldlYlNvY2tldH0gd3NcbiAqIEBwYXJhbSB7bnVtYmVyfSB0eXBlIE9wY29kZVxuICogQHBhcmFtIHtCdWZmZXJ9IGRhdGEgYXBwbGljYXRpb24gZGF0YVxuICovXG5mdW5jdGlvbiB3ZWJzb2NrZXRNZXNzYWdlUmVjZWl2ZWQgKHdzLCB0eXBlLCBkYXRhKSB7XG4gIC8vIDEuIElmIHJlYWR5IHN0YXRlIGlzIG5vdCBPUEVOICgxKSwgdGhlbiByZXR1cm4uXG4gIGlmICh3c1trUmVhZHlTdGF0ZV0gIT09IHN0YXRlcy5PUEVOKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvLyAyLiBMZXQgZGF0YUZvckV2ZW50IGJlIGRldGVybWluZWQgYnkgc3dpdGNoaW5nIG9uIHR5cGUgYW5kIGJpbmFyeSB0eXBlOlxuICBsZXQgZGF0YUZvckV2ZW50XG5cbiAgaWYgKHR5cGUgPT09IG9wY29kZXMuVEVYVCkge1xuICAgIC8vIC0+IHR5cGUgaW5kaWNhdGVzIHRoYXQgdGhlIGRhdGEgaXMgVGV4dFxuICAgIC8vICAgICAgYSBuZXcgRE9NU3RyaW5nIGNvbnRhaW5pbmcgZGF0YVxuICAgIHRyeSB7XG4gICAgICBkYXRhRm9yRXZlbnQgPSB1dGY4RGVjb2RlKGRhdGEpXG4gICAgfSBjYXRjaCB7XG4gICAgICBmYWlsV2Vic29ja2V0Q29ubmVjdGlvbih3cywgJ1JlY2VpdmVkIGludmFsaWQgVVRGLTggaW4gdGV4dCBmcmFtZS4nKVxuICAgICAgcmV0dXJuXG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGUgPT09IG9wY29kZXMuQklOQVJZKSB7XG4gICAgaWYgKHdzW2tCaW5hcnlUeXBlXSA9PT0gJ2Jsb2InKSB7XG4gICAgICAvLyAtPiB0eXBlIGluZGljYXRlcyB0aGF0IHRoZSBkYXRhIGlzIEJpbmFyeSBhbmQgYmluYXJ5IHR5cGUgaXMgXCJibG9iXCJcbiAgICAgIC8vICAgICAgYSBuZXcgQmxvYiBvYmplY3QsIGNyZWF0ZWQgaW4gdGhlIHJlbGV2YW50IFJlYWxtIG9mIHRoZSBXZWJTb2NrZXRcbiAgICAgIC8vICAgICAgb2JqZWN0LCB0aGF0IHJlcHJlc2VudHMgZGF0YSBhcyBpdHMgcmF3IGRhdGFcbiAgICAgIGRhdGFGb3JFdmVudCA9IG5ldyBCbG9iKFtkYXRhXSlcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gLT4gdHlwZSBpbmRpY2F0ZXMgdGhhdCB0aGUgZGF0YSBpcyBCaW5hcnkgYW5kIGJpbmFyeSB0eXBlIGlzIFwiYXJyYXlidWZmZXJcIlxuICAgICAgLy8gICAgICBhIG5ldyBBcnJheUJ1ZmZlciBvYmplY3QsIGNyZWF0ZWQgaW4gdGhlIHJlbGV2YW50IFJlYWxtIG9mIHRoZVxuICAgICAgLy8gICAgICBXZWJTb2NrZXQgb2JqZWN0LCB3aG9zZSBjb250ZW50cyBhcmUgZGF0YVxuICAgICAgZGF0YUZvckV2ZW50ID0gdG9BcnJheUJ1ZmZlcihkYXRhKVxuICAgIH1cbiAgfVxuXG4gIC8vIDMuIEZpcmUgYW4gZXZlbnQgbmFtZWQgbWVzc2FnZSBhdCB0aGUgV2ViU29ja2V0IG9iamVjdCwgdXNpbmcgTWVzc2FnZUV2ZW50LFxuICAvLyAgICB3aXRoIHRoZSBvcmlnaW4gYXR0cmlidXRlIGluaXRpYWxpemVkIHRvIHRoZSBzZXJpYWxpemF0aW9uIG9mIHRoZSBXZWJTb2NrZXRcbiAgLy8gICAgb2JqZWN04oCZcyB1cmwncyBvcmlnaW4sIGFuZCB0aGUgZGF0YSBhdHRyaWJ1dGUgaW5pdGlhbGl6ZWQgdG8gZGF0YUZvckV2ZW50LlxuICBmaXJlRXZlbnQoJ21lc3NhZ2UnLCB3cywgY3JlYXRlRmFzdE1lc3NhZ2VFdmVudCwge1xuICAgIG9yaWdpbjogd3Nba1dlYlNvY2tldFVSTF0ub3JpZ2luLFxuICAgIGRhdGE6IGRhdGFGb3JFdmVudFxuICB9KVxufVxuXG5mdW5jdGlvbiB0b0FycmF5QnVmZmVyIChidWZmZXIpIHtcbiAgaWYgKGJ1ZmZlci5ieXRlTGVuZ3RoID09PSBidWZmZXIuYnVmZmVyLmJ5dGVMZW5ndGgpIHtcbiAgICByZXR1cm4gYnVmZmVyLmJ1ZmZlclxuICB9XG4gIHJldHVybiBidWZmZXIuYnVmZmVyLnNsaWNlKGJ1ZmZlci5ieXRlT2Zmc2V0LCBidWZmZXIuYnl0ZU9mZnNldCArIGJ1ZmZlci5ieXRlTGVuZ3RoKVxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9yZmM2NDU1XG4gKiBAc2VlIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvcmZjMjYxNlxuICogQHNlZSBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0zOTg0MDdcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm90b2NvbFxuICovXG5mdW5jdGlvbiBpc1ZhbGlkU3VicHJvdG9jb2wgKHByb3RvY29sKSB7XG4gIC8vIElmIHByZXNlbnQsIHRoaXMgdmFsdWUgaW5kaWNhdGVzIG9uZVxuICAvLyBvciBtb3JlIGNvbW1hLXNlcGFyYXRlZCBzdWJwcm90b2NvbCB0aGUgY2xpZW50IHdpc2hlcyB0byBzcGVhayxcbiAgLy8gb3JkZXJlZCBieSBwcmVmZXJlbmNlLiAgVGhlIGVsZW1lbnRzIHRoYXQgY29tcHJpc2UgdGhpcyB2YWx1ZVxuICAvLyBNVVNUIGJlIG5vbi1lbXB0eSBzdHJpbmdzIHdpdGggY2hhcmFjdGVycyBpbiB0aGUgcmFuZ2UgVSswMDIxIHRvXG4gIC8vIFUrMDA3RSBub3QgaW5jbHVkaW5nIHNlcGFyYXRvciBjaGFyYWN0ZXJzIGFzIGRlZmluZWQgaW5cbiAgLy8gW1JGQzI2MTZdIGFuZCBNVVNUIGFsbCBiZSB1bmlxdWUgc3RyaW5ncy5cbiAgaWYgKHByb3RvY29sLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcm90b2NvbC5sZW5ndGg7ICsraSkge1xuICAgIGNvbnN0IGNvZGUgPSBwcm90b2NvbC5jaGFyQ29kZUF0KGkpXG5cbiAgICBpZiAoXG4gICAgICBjb2RlIDwgMHgyMSB8fCAvLyBDVEwsIGNvbnRhaW5zIFNQICgweDIwKSBhbmQgSFQgKDB4MDkpXG4gICAgICBjb2RlID4gMHg3RSB8fFxuICAgICAgY29kZSA9PT0gMHgyMiB8fCAvLyBcIlxuICAgICAgY29kZSA9PT0gMHgyOCB8fCAvLyAoXG4gICAgICBjb2RlID09PSAweDI5IHx8IC8vIClcbiAgICAgIGNvZGUgPT09IDB4MkMgfHwgLy8gLFxuICAgICAgY29kZSA9PT0gMHgyRiB8fCAvLyAvXG4gICAgICBjb2RlID09PSAweDNBIHx8IC8vIDpcbiAgICAgIGNvZGUgPT09IDB4M0IgfHwgLy8gO1xuICAgICAgY29kZSA9PT0gMHgzQyB8fCAvLyA8XG4gICAgICBjb2RlID09PSAweDNEIHx8IC8vID1cbiAgICAgIGNvZGUgPT09IDB4M0UgfHwgLy8gPlxuICAgICAgY29kZSA9PT0gMHgzRiB8fCAvLyA/XG4gICAgICBjb2RlID09PSAweDQwIHx8IC8vIEBcbiAgICAgIGNvZGUgPT09IDB4NUIgfHwgLy8gW1xuICAgICAgY29kZSA9PT0gMHg1QyB8fCAvLyBcXFxuICAgICAgY29kZSA9PT0gMHg1RCB8fCAvLyBdXG4gICAgICBjb2RlID09PSAweDdCIHx8IC8vIHtcbiAgICAgIGNvZGUgPT09IDB4N0QgLy8gfVxuICAgICkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvcmZjNjQ1NSNzZWN0aW9uLTctNFxuICogQHBhcmFtIHtudW1iZXJ9IGNvZGVcbiAqL1xuZnVuY3Rpb24gaXNWYWxpZFN0YXR1c0NvZGUgKGNvZGUpIHtcbiAgaWYgKGNvZGUgPj0gMTAwMCAmJiBjb2RlIDwgMTAxNSkge1xuICAgIHJldHVybiAoXG4gICAgICBjb2RlICE9PSAxMDA0ICYmIC8vIHJlc2VydmVkXG4gICAgICBjb2RlICE9PSAxMDA1ICYmIC8vIFwiTVVTVCBOT1QgYmUgc2V0IGFzIGEgc3RhdHVzIGNvZGVcIlxuICAgICAgY29kZSAhPT0gMTAwNiAvLyBcIk1VU1QgTk9UIGJlIHNldCBhcyBhIHN0YXR1cyBjb2RlXCJcbiAgICApXG4gIH1cblxuICByZXR1cm4gY29kZSA+PSAzMDAwICYmIGNvZGUgPD0gNDk5OVxufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL3dlYnNvY2tldCcpLldlYlNvY2tldH0gd3NcbiAqIEBwYXJhbSB7c3RyaW5nfHVuZGVmaW5lZH0gcmVhc29uXG4gKi9cbmZ1bmN0aW9uIGZhaWxXZWJzb2NrZXRDb25uZWN0aW9uICh3cywgcmVhc29uKSB7XG4gIGNvbnN0IHsgW2tDb250cm9sbGVyXTogY29udHJvbGxlciwgW2tSZXNwb25zZV06IHJlc3BvbnNlIH0gPSB3c1xuXG4gIGNvbnRyb2xsZXIuYWJvcnQoKVxuXG4gIGlmIChyZXNwb25zZT8uc29ja2V0ICYmICFyZXNwb25zZS5zb2NrZXQuZGVzdHJveWVkKSB7XG4gICAgcmVzcG9uc2Uuc29ja2V0LmRlc3Ryb3koKVxuICB9XG5cbiAgaWYgKHJlYXNvbikge1xuICAgIC8vIFRPRE86IHByb2Nlc3MubmV4dFRpY2tcbiAgICBmaXJlRXZlbnQoJ2Vycm9yJywgd3MsICh0eXBlLCBpbml0KSA9PiBuZXcgRXJyb3JFdmVudCh0eXBlLCBpbml0KSwge1xuICAgICAgZXJyb3I6IG5ldyBFcnJvcihyZWFzb24pLFxuICAgICAgbWVzc2FnZTogcmVhc29uXG4gICAgfSlcbiAgfVxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9yZmM2NDU1I3NlY3Rpb24tNS41XG4gKiBAcGFyYW0ge251bWJlcn0gb3Bjb2RlXG4gKi9cbmZ1bmN0aW9uIGlzQ29udHJvbEZyYW1lIChvcGNvZGUpIHtcbiAgcmV0dXJuIChcbiAgICBvcGNvZGUgPT09IG9wY29kZXMuQ0xPU0UgfHxcbiAgICBvcGNvZGUgPT09IG9wY29kZXMuUElORyB8fFxuICAgIG9wY29kZSA9PT0gb3Bjb2Rlcy5QT05HXG4gIClcbn1cblxuZnVuY3Rpb24gaXNDb250aW51YXRpb25GcmFtZSAob3Bjb2RlKSB7XG4gIHJldHVybiBvcGNvZGUgPT09IG9wY29kZXMuQ09OVElOVUFUSU9OXG59XG5cbmZ1bmN0aW9uIGlzVGV4dEJpbmFyeUZyYW1lIChvcGNvZGUpIHtcbiAgcmV0dXJuIG9wY29kZSA9PT0gb3Bjb2Rlcy5URVhUIHx8IG9wY29kZSA9PT0gb3Bjb2Rlcy5CSU5BUllcbn1cblxuZnVuY3Rpb24gaXNWYWxpZE9wY29kZSAob3Bjb2RlKSB7XG4gIHJldHVybiBpc1RleHRCaW5hcnlGcmFtZShvcGNvZGUpIHx8IGlzQ29udGludWF0aW9uRnJhbWUob3Bjb2RlKSB8fCBpc0NvbnRyb2xGcmFtZShvcGNvZGUpXG59XG5cbi8qKlxuICogUGFyc2VzIGEgU2VjLVdlYlNvY2tldC1FeHRlbnNpb25zIGhlYWRlciB2YWx1ZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBleHRlbnNpb25zXG4gKiBAcmV0dXJucyB7TWFwPHN0cmluZywgc3RyaW5nPn1cbiAqL1xuLy8gVE9ETyhAVXpsb3BhaywgQEtoYWZyYURldik6IG1ha2UgY29tcGxpYW50IGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvcmZjNjQ1NSNzZWN0aW9uLTkuMVxuZnVuY3Rpb24gcGFyc2VFeHRlbnNpb25zIChleHRlbnNpb25zKSB7XG4gIGNvbnN0IHBvc2l0aW9uID0geyBwb3NpdGlvbjogMCB9XG4gIGNvbnN0IGV4dGVuc2lvbkxpc3QgPSBuZXcgTWFwKClcblxuICB3aGlsZSAocG9zaXRpb24ucG9zaXRpb24gPCBleHRlbnNpb25zLmxlbmd0aCkge1xuICAgIGNvbnN0IHBhaXIgPSBjb2xsZWN0QVNlcXVlbmNlT2ZDb2RlUG9pbnRzRmFzdCgnOycsIGV4dGVuc2lvbnMsIHBvc2l0aW9uKVxuICAgIGNvbnN0IFtuYW1lLCB2YWx1ZSA9ICcnXSA9IHBhaXIuc3BsaXQoJz0nKVxuXG4gICAgZXh0ZW5zaW9uTGlzdC5zZXQoXG4gICAgICByZW1vdmVIVFRQV2hpdGVzcGFjZShuYW1lLCB0cnVlLCBmYWxzZSksXG4gICAgICByZW1vdmVIVFRQV2hpdGVzcGFjZSh2YWx1ZSwgZmFsc2UsIHRydWUpXG4gICAgKVxuXG4gICAgcG9zaXRpb24ucG9zaXRpb24rK1xuICB9XG5cbiAgcmV0dXJuIGV4dGVuc2lvbkxpc3Rcbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM3NjkyI3NlY3Rpb24tNy4xLjIuMlxuICogQGRlc2NyaXB0aW9uIFwiY2xpZW50LW1heC13aW5kb3ctYml0cyA9IDEqRElHSVRcIlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRDbGllbnRXaW5kb3dCaXRzICh2YWx1ZSkge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgYnl0ZSA9IHZhbHVlLmNoYXJDb2RlQXQoaSlcblxuICAgIGlmIChieXRlIDwgMHgzMCB8fCBieXRlID4gMHgzOSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cblxuLy8gaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9pbnRsLmh0bWwjZGV0ZWN0aW5nLWludGVybmF0aW9uYWxpemF0aW9uLXN1cHBvcnRcbmNvbnN0IGhhc0ludGwgPSB0eXBlb2YgcHJvY2Vzcy52ZXJzaW9ucy5pY3UgPT09ICdzdHJpbmcnXG5jb25zdCBmYXRhbERlY29kZXIgPSBoYXNJbnRsID8gbmV3IFRleHREZWNvZGVyKCd1dGYtOCcsIHsgZmF0YWw6IHRydWUgfSkgOiB1bmRlZmluZWRcblxuLyoqXG4gKiBDb252ZXJ0cyBhIEJ1ZmZlciB0byB1dGYtOCwgZXZlbiBvbiBwbGF0Zm9ybXMgd2l0aG91dCBpY3UuXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmZmVyXG4gKi9cbmNvbnN0IHV0ZjhEZWNvZGUgPSBoYXNJbnRsXG4gID8gZmF0YWxEZWNvZGVyLmRlY29kZS5iaW5kKGZhdGFsRGVjb2RlcilcbiAgOiBmdW5jdGlvbiAoYnVmZmVyKSB7XG4gICAgaWYgKGlzVXRmOChidWZmZXIpKSB7XG4gICAgICByZXR1cm4gYnVmZmVyLnRvU3RyaW5nKCd1dGYtOCcpXG4gICAgfVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgdXRmLTggcmVjZWl2ZWQuJylcbiAgfVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaXNDb25uZWN0aW5nLFxuICBpc0VzdGFibGlzaGVkLFxuICBpc0Nsb3NpbmcsXG4gIGlzQ2xvc2VkLFxuICBmaXJlRXZlbnQsXG4gIGlzVmFsaWRTdWJwcm90b2NvbCxcbiAgaXNWYWxpZFN0YXR1c0NvZGUsXG4gIGZhaWxXZWJzb2NrZXRDb25uZWN0aW9uLFxuICB3ZWJzb2NrZXRNZXNzYWdlUmVjZWl2ZWQsXG4gIHV0ZjhEZWNvZGUsXG4gIGlzQ29udHJvbEZyYW1lLFxuICBpc0NvbnRpbnVhdGlvbkZyYW1lLFxuICBpc1RleHRCaW5hcnlGcmFtZSxcbiAgaXNWYWxpZE9wY29kZSxcbiAgcGFyc2VFeHRlbnNpb25zLFxuICBpc1ZhbGlkQ2xpZW50V2luZG93Qml0c1xufVxuIl0sIm5hbWVzIjpbImtSZWFkeVN0YXRlIiwia0NvbnRyb2xsZXIiLCJrUmVzcG9uc2UiLCJrQmluYXJ5VHlwZSIsImtXZWJTb2NrZXRVUkwiLCJyZXF1aXJlIiwic3RhdGVzIiwib3Bjb2RlcyIsIkVycm9yRXZlbnQiLCJjcmVhdGVGYXN0TWVzc2FnZUV2ZW50IiwiaXNVdGY4IiwiY29sbGVjdEFTZXF1ZW5jZU9mQ29kZVBvaW50c0Zhc3QiLCJyZW1vdmVIVFRQV2hpdGVzcGFjZSIsImlzQ29ubmVjdGluZyIsIndzIiwiQ09OTkVDVElORyIsImlzRXN0YWJsaXNoZWQiLCJPUEVOIiwiaXNDbG9zaW5nIiwiQ0xPU0lORyIsImlzQ2xvc2VkIiwiQ0xPU0VEIiwiZmlyZUV2ZW50IiwiZSIsInRhcmdldCIsImV2ZW50RmFjdG9yeSIsInR5cGUiLCJpbml0IiwiRXZlbnQiLCJldmVudEluaXREaWN0IiwiZXZlbnQiLCJkaXNwYXRjaEV2ZW50Iiwid2Vic29ja2V0TWVzc2FnZVJlY2VpdmVkIiwiZGF0YSIsImRhdGFGb3JFdmVudCIsIlRFWFQiLCJ1dGY4RGVjb2RlIiwiZmFpbFdlYnNvY2tldENvbm5lY3Rpb24iLCJCSU5BUlkiLCJCbG9iIiwidG9BcnJheUJ1ZmZlciIsIm9yaWdpbiIsImJ1ZmZlciIsImJ5dGVMZW5ndGgiLCJzbGljZSIsImJ5dGVPZmZzZXQiLCJpc1ZhbGlkU3VicHJvdG9jb2wiLCJwcm90b2NvbCIsImxlbmd0aCIsImkiLCJjb2RlIiwiY2hhckNvZGVBdCIsImlzVmFsaWRTdGF0dXNDb2RlIiwicmVhc29uIiwiY29udHJvbGxlciIsInJlc3BvbnNlIiwiYWJvcnQiLCJzb2NrZXQiLCJkZXN0cm95ZWQiLCJkZXN0cm95IiwiZXJyb3IiLCJFcnJvciIsIm1lc3NhZ2UiLCJpc0NvbnRyb2xGcmFtZSIsIm9wY29kZSIsIkNMT1NFIiwiUElORyIsIlBPTkciLCJpc0NvbnRpbnVhdGlvbkZyYW1lIiwiQ09OVElOVUFUSU9OIiwiaXNUZXh0QmluYXJ5RnJhbWUiLCJpc1ZhbGlkT3Bjb2RlIiwicGFyc2VFeHRlbnNpb25zIiwiZXh0ZW5zaW9ucyIsInBvc2l0aW9uIiwiZXh0ZW5zaW9uTGlzdCIsIk1hcCIsInBhaXIiLCJuYW1lIiwidmFsdWUiLCJzcGxpdCIsInNldCIsImlzVmFsaWRDbGllbnRXaW5kb3dCaXRzIiwiYnl0ZSIsImhhc0ludGwiLCJwcm9jZXNzIiwidmVyc2lvbnMiLCJpY3UiLCJmYXRhbERlY29kZXIiLCJUZXh0RGVjb2RlciIsImZhdGFsIiwidW5kZWZpbmVkIiwiZGVjb2RlIiwiYmluZCIsInRvU3RyaW5nIiwiVHlwZUVycm9yIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/websocket/util.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/websocket/websocket.js":
/*!************************************************************!*\
  !*** ./node_modules/undici/lib/web/websocket/websocket.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { webidl } = __webpack_require__(/*! ../fetch/webidl */ \"(ssr)/./node_modules/undici/lib/web/fetch/webidl.js\");\nconst { URLSerializer } = __webpack_require__(/*! ../fetch/data-url */ \"(ssr)/./node_modules/undici/lib/web/fetch/data-url.js\");\nconst { environmentSettingsObject } = __webpack_require__(/*! ../fetch/util */ \"(ssr)/./node_modules/undici/lib/web/fetch/util.js\");\nconst { staticPropertyDescriptors, states, sentCloseFrameState, sendHints } = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/undici/lib/web/websocket/constants.js\");\nconst { kWebSocketURL, kReadyState, kController, kBinaryType, kResponse, kSentClose, kByteParser } = __webpack_require__(/*! ./symbols */ \"(ssr)/./node_modules/undici/lib/web/websocket/symbols.js\");\nconst { isConnecting, isEstablished, isClosing, isValidSubprotocol, fireEvent } = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/undici/lib/web/websocket/util.js\");\nconst { establishWebSocketConnection, closeWebSocketConnection } = __webpack_require__(/*! ./connection */ \"(ssr)/./node_modules/undici/lib/web/websocket/connection.js\");\nconst { ByteParser } = __webpack_require__(/*! ./receiver */ \"(ssr)/./node_modules/undici/lib/web/websocket/receiver.js\");\nconst { kEnumerableProperty, isBlobLike } = __webpack_require__(/*! ../../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\");\nconst { getGlobalDispatcher } = __webpack_require__(/*! ../../global */ \"(ssr)/./node_modules/undici/lib/global.js\");\nconst { types } = __webpack_require__(/*! node:util */ \"node:util\");\nconst { ErrorEvent, CloseEvent } = __webpack_require__(/*! ./events */ \"(ssr)/./node_modules/undici/lib/web/websocket/events.js\");\nconst { SendQueue } = __webpack_require__(/*! ./sender */ \"(ssr)/./node_modules/undici/lib/web/websocket/sender.js\");\n// https://websockets.spec.whatwg.org/#interface-definition\nclass WebSocket extends EventTarget {\n    #events;\n    #bufferedAmount;\n    #protocol;\n    #extensions;\n    /** @type {SendQueue} */ #sendQueue;\n    /**\n   * @param {string} url\n   * @param {string|string[]} protocols\n   */ constructor(url, protocols = []){\n        super();\n        this.#events = {\n            open: null,\n            error: null,\n            close: null,\n            message: null\n        };\n        this.#bufferedAmount = 0;\n        this.#protocol = \"\";\n        this.#extensions = \"\";\n        const prefix = \"WebSocket constructor\";\n        webidl.argumentLengthCheck(arguments, 1, prefix);\n        const options = webidl.converters[\"DOMString or sequence<DOMString> or WebSocketInit\"](protocols, prefix, \"options\");\n        url = webidl.converters.USVString(url, prefix, \"url\");\n        protocols = options.protocols;\n        // 1. Let baseURL be this's relevant settings object's API base URL.\n        const baseURL = environmentSettingsObject.settingsObject.baseUrl;\n        // 1. Let urlRecord be the result of applying the URL parser to url with baseURL.\n        let urlRecord;\n        try {\n            urlRecord = new URL(url, baseURL);\n        } catch (e) {\n            // 3. If urlRecord is failure, then throw a \"SyntaxError\" DOMException.\n            throw new DOMException(e, \"SyntaxError\");\n        }\n        // 4. If urlRecords scheme is \"http\", then set urlRecords scheme to \"ws\".\n        if (urlRecord.protocol === \"http:\") {\n            urlRecord.protocol = \"ws:\";\n        } else if (urlRecord.protocol === \"https:\") {\n            // 5. Otherwise, if urlRecords scheme is \"https\", set urlRecords scheme to \"wss\".\n            urlRecord.protocol = \"wss:\";\n        }\n        // 6. If urlRecords scheme is not \"ws\" or \"wss\", then throw a \"SyntaxError\" DOMException.\n        if (urlRecord.protocol !== \"ws:\" && urlRecord.protocol !== \"wss:\") {\n            throw new DOMException(`Expected a ws: or wss: protocol, got ${urlRecord.protocol}`, \"SyntaxError\");\n        }\n        // 7. If urlRecords fragment is non-null, then throw a \"SyntaxError\"\n        //    DOMException.\n        if (urlRecord.hash || urlRecord.href.endsWith(\"#\")) {\n            throw new DOMException(\"Got fragment\", \"SyntaxError\");\n        }\n        // 8. If protocols is a string, set protocols to a sequence consisting\n        //    of just that string.\n        if (typeof protocols === \"string\") {\n            protocols = [\n                protocols\n            ];\n        }\n        // 9. If any of the values in protocols occur more than once or otherwise\n        //    fail to match the requirements for elements that comprise the value\n        //    of `Sec-WebSocket-Protocol` fields as defined by The WebSocket\n        //    protocol, then throw a \"SyntaxError\" DOMException.\n        if (protocols.length !== new Set(protocols.map((p)=>p.toLowerCase())).size) {\n            throw new DOMException(\"Invalid Sec-WebSocket-Protocol value\", \"SyntaxError\");\n        }\n        if (protocols.length > 0 && !protocols.every((p)=>isValidSubprotocol(p))) {\n            throw new DOMException(\"Invalid Sec-WebSocket-Protocol value\", \"SyntaxError\");\n        }\n        // 10. Set this's url to urlRecord.\n        this[kWebSocketURL] = new URL(urlRecord.href);\n        // 11. Let client be this's relevant settings object.\n        const client = environmentSettingsObject.settingsObject;\n        // 12. Run this step in parallel:\n        //    1. Establish a WebSocket connection given urlRecord, protocols,\n        //       and client.\n        this[kController] = establishWebSocketConnection(urlRecord, protocols, client, this, (response, extensions)=>this.#onConnectionEstablished(response, extensions), options);\n        // Each WebSocket object has an associated ready state, which is a\n        // number representing the state of the connection. Initially it must\n        // be CONNECTING (0).\n        this[kReadyState] = WebSocket.CONNECTING;\n        this[kSentClose] = sentCloseFrameState.NOT_SENT;\n        // The extensions attribute must initially return the empty string.\n        // The protocol attribute must initially return the empty string.\n        // Each WebSocket object has an associated binary type, which is a\n        // BinaryType. Initially it must be \"blob\".\n        this[kBinaryType] = \"blob\";\n    }\n    /**\n   * @see https://websockets.spec.whatwg.org/#dom-websocket-close\n   * @param {number|undefined} code\n   * @param {string|undefined} reason\n   */ close(code = undefined, reason = undefined) {\n        webidl.brandCheck(this, WebSocket);\n        const prefix = \"WebSocket.close\";\n        if (code !== undefined) {\n            code = webidl.converters[\"unsigned short\"](code, prefix, \"code\", {\n                clamp: true\n            });\n        }\n        if (reason !== undefined) {\n            reason = webidl.converters.USVString(reason, prefix, \"reason\");\n        }\n        // 1. If code is present, but is neither an integer equal to 1000 nor an\n        //    integer in the range 3000 to 4999, inclusive, throw an\n        //    \"InvalidAccessError\" DOMException.\n        if (code !== undefined) {\n            if (code !== 1000 && (code < 3000 || code > 4999)) {\n                throw new DOMException(\"invalid code\", \"InvalidAccessError\");\n            }\n        }\n        let reasonByteLength = 0;\n        // 2. If reason is present, then run these substeps:\n        if (reason !== undefined) {\n            // 1. Let reasonBytes be the result of encoding reason.\n            // 2. If reasonBytes is longer than 123 bytes, then throw a\n            //    \"SyntaxError\" DOMException.\n            reasonByteLength = Buffer.byteLength(reason);\n            if (reasonByteLength > 123) {\n                throw new DOMException(`Reason must be less than 123 bytes; received ${reasonByteLength}`, \"SyntaxError\");\n            }\n        }\n        // 3. Run the first matching steps from the following list:\n        closeWebSocketConnection(this, code, reason, reasonByteLength);\n    }\n    /**\n   * @see https://websockets.spec.whatwg.org/#dom-websocket-send\n   * @param {NodeJS.TypedArray|ArrayBuffer|Blob|string} data\n   */ send(data) {\n        webidl.brandCheck(this, WebSocket);\n        const prefix = \"WebSocket.send\";\n        webidl.argumentLengthCheck(arguments, 1, prefix);\n        data = webidl.converters.WebSocketSendData(data, prefix, \"data\");\n        // 1. If this's ready state is CONNECTING, then throw an\n        //    \"InvalidStateError\" DOMException.\n        if (isConnecting(this)) {\n            throw new DOMException(\"Sent before connected.\", \"InvalidStateError\");\n        }\n        // 2. Run the appropriate set of steps from the following list:\n        // https://datatracker.ietf.org/doc/html/rfc6455#section-6.1\n        // https://datatracker.ietf.org/doc/html/rfc6455#section-5.2\n        if (!isEstablished(this) || isClosing(this)) {\n            return;\n        }\n        // If data is a string\n        if (typeof data === \"string\") {\n            // If the WebSocket connection is established and the WebSocket\n            // closing handshake has not yet started, then the user agent\n            // must send a WebSocket Message comprised of the data argument\n            // using a text frame opcode; if the data cannot be sent, e.g.\n            // because it would need to be buffered but the buffer is full,\n            // the user agent must flag the WebSocket as full and then close\n            // the WebSocket connection. Any invocation of this method with a\n            // string argument that does not throw an exception must increase\n            // the bufferedAmount attribute by the number of bytes needed to\n            // express the argument as UTF-8.\n            const length = Buffer.byteLength(data);\n            this.#bufferedAmount += length;\n            this.#sendQueue.add(data, ()=>{\n                this.#bufferedAmount -= length;\n            }, sendHints.string);\n        } else if (types.isArrayBuffer(data)) {\n            // If the WebSocket connection is established, and the WebSocket\n            // closing handshake has not yet started, then the user agent must\n            // send a WebSocket Message comprised of data using a binary frame\n            // opcode; if the data cannot be sent, e.g. because it would need\n            // to be buffered but the buffer is full, the user agent must flag\n            // the WebSocket as full and then close the WebSocket connection.\n            // The data to be sent is the data stored in the buffer described\n            // by the ArrayBuffer object. Any invocation of this method with an\n            // ArrayBuffer argument that does not throw an exception must\n            // increase the bufferedAmount attribute by the length of the\n            // ArrayBuffer in bytes.\n            this.#bufferedAmount += data.byteLength;\n            this.#sendQueue.add(data, ()=>{\n                this.#bufferedAmount -= data.byteLength;\n            }, sendHints.arrayBuffer);\n        } else if (ArrayBuffer.isView(data)) {\n            // If the WebSocket connection is established, and the WebSocket\n            // closing handshake has not yet started, then the user agent must\n            // send a WebSocket Message comprised of data using a binary frame\n            // opcode; if the data cannot be sent, e.g. because it would need to\n            // be buffered but the buffer is full, the user agent must flag the\n            // WebSocket as full and then close the WebSocket connection. The\n            // data to be sent is the data stored in the section of the buffer\n            // described by the ArrayBuffer object that data references. Any\n            // invocation of this method with this kind of argument that does\n            // not throw an exception must increase the bufferedAmount attribute\n            // by the length of datas buffer in bytes.\n            this.#bufferedAmount += data.byteLength;\n            this.#sendQueue.add(data, ()=>{\n                this.#bufferedAmount -= data.byteLength;\n            }, sendHints.typedArray);\n        } else if (isBlobLike(data)) {\n            // If the WebSocket connection is established, and the WebSocket\n            // closing handshake has not yet started, then the user agent must\n            // send a WebSocket Message comprised of data using a binary frame\n            // opcode; if the data cannot be sent, e.g. because it would need to\n            // be buffered but the buffer is full, the user agent must flag the\n            // WebSocket as full and then close the WebSocket connection. The data\n            // to be sent is the raw data represented by the Blob object. Any\n            // invocation of this method with a Blob argument that does not throw\n            // an exception must increase the bufferedAmount attribute by the size\n            // of the Blob objects raw data, in bytes.\n            this.#bufferedAmount += data.size;\n            this.#sendQueue.add(data, ()=>{\n                this.#bufferedAmount -= data.size;\n            }, sendHints.blob);\n        }\n    }\n    get readyState() {\n        webidl.brandCheck(this, WebSocket);\n        // The readyState getter steps are to return this's ready state.\n        return this[kReadyState];\n    }\n    get bufferedAmount() {\n        webidl.brandCheck(this, WebSocket);\n        return this.#bufferedAmount;\n    }\n    get url() {\n        webidl.brandCheck(this, WebSocket);\n        // The url getter steps are to return this's url, serialized.\n        return URLSerializer(this[kWebSocketURL]);\n    }\n    get extensions() {\n        webidl.brandCheck(this, WebSocket);\n        return this.#extensions;\n    }\n    get protocol() {\n        webidl.brandCheck(this, WebSocket);\n        return this.#protocol;\n    }\n    get onopen() {\n        webidl.brandCheck(this, WebSocket);\n        return this.#events.open;\n    }\n    set onopen(fn) {\n        webidl.brandCheck(this, WebSocket);\n        if (this.#events.open) {\n            this.removeEventListener(\"open\", this.#events.open);\n        }\n        if (typeof fn === \"function\") {\n            this.#events.open = fn;\n            this.addEventListener(\"open\", fn);\n        } else {\n            this.#events.open = null;\n        }\n    }\n    get onerror() {\n        webidl.brandCheck(this, WebSocket);\n        return this.#events.error;\n    }\n    set onerror(fn) {\n        webidl.brandCheck(this, WebSocket);\n        if (this.#events.error) {\n            this.removeEventListener(\"error\", this.#events.error);\n        }\n        if (typeof fn === \"function\") {\n            this.#events.error = fn;\n            this.addEventListener(\"error\", fn);\n        } else {\n            this.#events.error = null;\n        }\n    }\n    get onclose() {\n        webidl.brandCheck(this, WebSocket);\n        return this.#events.close;\n    }\n    set onclose(fn) {\n        webidl.brandCheck(this, WebSocket);\n        if (this.#events.close) {\n            this.removeEventListener(\"close\", this.#events.close);\n        }\n        if (typeof fn === \"function\") {\n            this.#events.close = fn;\n            this.addEventListener(\"close\", fn);\n        } else {\n            this.#events.close = null;\n        }\n    }\n    get onmessage() {\n        webidl.brandCheck(this, WebSocket);\n        return this.#events.message;\n    }\n    set onmessage(fn) {\n        webidl.brandCheck(this, WebSocket);\n        if (this.#events.message) {\n            this.removeEventListener(\"message\", this.#events.message);\n        }\n        if (typeof fn === \"function\") {\n            this.#events.message = fn;\n            this.addEventListener(\"message\", fn);\n        } else {\n            this.#events.message = null;\n        }\n    }\n    get binaryType() {\n        webidl.brandCheck(this, WebSocket);\n        return this[kBinaryType];\n    }\n    set binaryType(type) {\n        webidl.brandCheck(this, WebSocket);\n        if (type !== \"blob\" && type !== \"arraybuffer\") {\n            this[kBinaryType] = \"blob\";\n        } else {\n            this[kBinaryType] = type;\n        }\n    }\n    /**\n   * @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol\n   */ #onConnectionEstablished(response, parsedExtensions) {\n        // processResponse is called when the \"responses header list has been received and initialized.\"\n        // once this happens, the connection is open\n        this[kResponse] = response;\n        const parser = new ByteParser(this, parsedExtensions);\n        parser.on(\"drain\", onParserDrain);\n        parser.on(\"error\", onParserError.bind(this));\n        response.socket.ws = this;\n        this[kByteParser] = parser;\n        this.#sendQueue = new SendQueue(response.socket);\n        // 1. Change the ready state to OPEN (1).\n        this[kReadyState] = states.OPEN;\n        // 2. Change the extensions attributes value to the extensions in use, if\n        //    it is not the null value.\n        // https://datatracker.ietf.org/doc/html/rfc6455#section-9.1\n        const extensions = response.headersList.get(\"sec-websocket-extensions\");\n        if (extensions !== null) {\n            this.#extensions = extensions;\n        }\n        // 3. Change the protocol attributes value to the subprotocol in use, if\n        //    it is not the null value.\n        // https://datatracker.ietf.org/doc/html/rfc6455#section-1.9\n        const protocol = response.headersList.get(\"sec-websocket-protocol\");\n        if (protocol !== null) {\n            this.#protocol = protocol;\n        }\n        // 4. Fire an event named open at the WebSocket object.\n        fireEvent(\"open\", this);\n    }\n}\n// https://websockets.spec.whatwg.org/#dom-websocket-connecting\nWebSocket.CONNECTING = WebSocket.prototype.CONNECTING = states.CONNECTING;\n// https://websockets.spec.whatwg.org/#dom-websocket-open\nWebSocket.OPEN = WebSocket.prototype.OPEN = states.OPEN;\n// https://websockets.spec.whatwg.org/#dom-websocket-closing\nWebSocket.CLOSING = WebSocket.prototype.CLOSING = states.CLOSING;\n// https://websockets.spec.whatwg.org/#dom-websocket-closed\nWebSocket.CLOSED = WebSocket.prototype.CLOSED = states.CLOSED;\nObject.defineProperties(WebSocket.prototype, {\n    CONNECTING: staticPropertyDescriptors,\n    OPEN: staticPropertyDescriptors,\n    CLOSING: staticPropertyDescriptors,\n    CLOSED: staticPropertyDescriptors,\n    url: kEnumerableProperty,\n    readyState: kEnumerableProperty,\n    bufferedAmount: kEnumerableProperty,\n    onopen: kEnumerableProperty,\n    onerror: kEnumerableProperty,\n    onclose: kEnumerableProperty,\n    close: kEnumerableProperty,\n    onmessage: kEnumerableProperty,\n    binaryType: kEnumerableProperty,\n    send: kEnumerableProperty,\n    extensions: kEnumerableProperty,\n    protocol: kEnumerableProperty,\n    [Symbol.toStringTag]: {\n        value: \"WebSocket\",\n        writable: false,\n        enumerable: false,\n        configurable: true\n    }\n});\nObject.defineProperties(WebSocket, {\n    CONNECTING: staticPropertyDescriptors,\n    OPEN: staticPropertyDescriptors,\n    CLOSING: staticPropertyDescriptors,\n    CLOSED: staticPropertyDescriptors\n});\nwebidl.converters[\"sequence<DOMString>\"] = webidl.sequenceConverter(webidl.converters.DOMString);\nwebidl.converters[\"DOMString or sequence<DOMString>\"] = function(V, prefix, argument) {\n    if (webidl.util.Type(V) === \"Object\" && Symbol.iterator in V) {\n        return webidl.converters[\"sequence<DOMString>\"](V);\n    }\n    return webidl.converters.DOMString(V, prefix, argument);\n};\n// This implements the proposal made in https://github.com/whatwg/websockets/issues/42\nwebidl.converters.WebSocketInit = webidl.dictionaryConverter([\n    {\n        key: \"protocols\",\n        converter: webidl.converters[\"DOMString or sequence<DOMString>\"],\n        defaultValue: ()=>new Array(0)\n    },\n    {\n        key: \"dispatcher\",\n        converter: webidl.converters.any,\n        defaultValue: ()=>getGlobalDispatcher()\n    },\n    {\n        key: \"headers\",\n        converter: webidl.nullableConverter(webidl.converters.HeadersInit)\n    }\n]);\nwebidl.converters[\"DOMString or sequence<DOMString> or WebSocketInit\"] = function(V) {\n    if (webidl.util.Type(V) === \"Object\" && !(Symbol.iterator in V)) {\n        return webidl.converters.WebSocketInit(V);\n    }\n    return {\n        protocols: webidl.converters[\"DOMString or sequence<DOMString>\"](V)\n    };\n};\nwebidl.converters.WebSocketSendData = function(V) {\n    if (webidl.util.Type(V) === \"Object\") {\n        if (isBlobLike(V)) {\n            return webidl.converters.Blob(V, {\n                strict: false\n            });\n        }\n        if (ArrayBuffer.isView(V) || types.isArrayBuffer(V)) {\n            return webidl.converters.BufferSource(V);\n        }\n    }\n    return webidl.converters.USVString(V);\n};\nfunction onParserDrain() {\n    this.ws[kResponse].socket.resume();\n}\nfunction onParserError(err) {\n    let message;\n    let code;\n    if (err instanceof CloseEvent) {\n        message = err.reason;\n        code = err.code;\n    } else {\n        message = err.message;\n    }\n    fireEvent(\"error\", this, ()=>new ErrorEvent(\"error\", {\n            error: err,\n            message\n        }));\n    closeWebSocketConnection(this, code);\n}\nmodule.exports = {\n    WebSocket\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvd2Vic29ja2V0L3dlYnNvY2tldC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU0sRUFBRUEsTUFBQUEsRUFBUSxHQUFHQyxtQkFBT0EsQ0FBQztBQUMzQixNQUFNLEVBQUVDLGFBQUFBLEVBQWUsR0FBR0QsbUJBQU9BLENBQUM7QUFDbEMsTUFBTSxFQUFFRSx5QkFBQUEsRUFBMkIsR0FBR0YsbUJBQU9BLENBQUM7QUFDOUMsTUFBTSxFQUFFRyx5QkFBeUIsRUFBRUMsTUFBTSxFQUFFQyxtQkFBbUIsRUFBRUMsU0FBQUEsRUFBVyxHQUFHTixtQkFBT0EsQ0FBQztBQUN0RixNQUFNLEVBQ0pPLGFBQWEsRUFDYkMsV0FBVyxFQUNYQyxXQUFXLEVBQ1hDLFdBQVcsRUFDWEMsU0FBUyxFQUNUQyxVQUFVLEVBQ1ZDLFdBQUFBLEVBQ0QsR0FBR2IsbUJBQU9BLENBQUM7QUFDWixNQUFNLEVBQ0pjLFlBQVksRUFDWkMsYUFBYSxFQUNiQyxTQUFTLEVBQ1RDLGtCQUFrQixFQUNsQkMsU0FBQUEsRUFDRCxHQUFHbEIsbUJBQU9BLENBQUM7QUFDWixNQUFNLEVBQUVtQiw0QkFBNEIsRUFBRUMsd0JBQUFBLEVBQTBCLEdBQUdwQixtQkFBT0EsQ0FBQztBQUMzRSxNQUFNLEVBQUVxQixVQUFBQSxFQUFZLEdBQUdyQixtQkFBT0EsQ0FBQztBQUMvQixNQUFNLEVBQUVzQixtQkFBbUIsRUFBRUMsVUFBQUEsRUFBWSxHQUFHdkIsbUJBQU9BLENBQUM7QUFDcEQsTUFBTSxFQUFFd0IsbUJBQUFBLEVBQXFCLEdBQUd4QixtQkFBT0EsQ0FBQztBQUN4QyxNQUFNLEVBQUV5QixLQUFBQSxFQUFPLEdBQUd6QixtQkFBT0EsQ0FBQztBQUMxQixNQUFNLEVBQUUwQixVQUFVLEVBQUVDLFVBQUFBLEVBQVksR0FBRzNCLG1CQUFPQSxDQUFDO0FBQzNDLE1BQU0sRUFBRTRCLFNBQUFBLEVBQVcsR0FBRzVCLG1CQUFPQSxDQUFD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LElBQUk7WUFDbkQsT0FBTzlILE9BQU9nRCxVQUFVLENBQUM4RixZQUFZLENBQUNoQjtRQUN4QztJQUNGO0lBRUEsT0FBTzlILE9BQU9nRCxVQUFVLENBQUNDLFNBQVMsQ0FBQzZFO0FBQ3JDO0FBRUEsU0FBU3JCO0lBQ1AsSUFBSSxDQUFDSSxFQUFFLENBQUNqRyxVQUFVLENBQUNnRyxNQUFNLENBQUNtQyxNQUFNO0FBQ2xDO0FBRUEsU0FBU3JDLGNBQWVzQyxHQUFHO0lBQ3pCLElBQUlyRztJQUNKLElBQUk2QjtJQUVKLElBQUl3RSxlQUFlcEgsWUFBWTtRQUM3QmUsVUFBVXFHLElBQUl0RSxNQUFNO1FBQ3BCRixPQUFPd0UsSUFBSXhFLElBQUk7SUFDakIsT0FBTztRQUNMN0IsVUFBVXFHLElBQUlyRyxPQUFPO0lBQ3ZCO0lBRUF4QixVQUFVLFNBQVMsSUFBSSxFQUFFLElBQU0sSUFBSVEsV0FBVyxTQUFTO1lBQUVjLE9BQU91RztZQUFLckc7UUFBUTtJQUU3RXRCLHlCQUF5QixJQUFJLEVBQUVtRDtBQUNqQztBQUVBeUUsT0FBT0MsT0FBTyxHQUFHO0lBQ2ZwSDtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbW9ja3VwZmxvdy8uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL3dlYi93ZWJzb2NrZXQvd2Vic29ja2V0LmpzPzMyOTgiLCJ3ZWJwYWNrOi8vbW9ja3VwZmxvdy8uL25vZGVfbW9kdWxlcy91bmRpY2kvbGliL3dlYi93ZWJzb2NrZXQvd2Vic29ja2V0LmpzPzMyOTgqIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IHdlYmlkbCB9ID0gcmVxdWlyZSgnLi4vZmV0Y2gvd2ViaWRsJylcbmNvbnN0IHsgVVJMU2VyaWFsaXplciB9ID0gcmVxdWlyZSgnLi4vZmV0Y2gvZGF0YS11cmwnKVxuY29uc3QgeyBlbnZpcm9ubWVudFNldHRpbmdzT2JqZWN0IH0gPSByZXF1aXJlKCcuLi9mZXRjaC91dGlsJylcbmNvbnN0IHsgc3RhdGljUHJvcGVydHlEZXNjcmlwdG9ycywgc3RhdGVzLCBzZW50Q2xvc2VGcmFtZVN0YXRlLCBzZW5kSGludHMgfSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJylcbmNvbnN0IHtcbiAga1dlYlNvY2tldFVSTCxcbiAga1JlYWR5U3RhdGUsXG4gIGtDb250cm9sbGVyLFxuICBrQmluYXJ5VHlwZSxcbiAga1Jlc3BvbnNlLFxuICBrU2VudENsb3NlLFxuICBrQnl0ZVBhcnNlclxufSA9IHJlcXVpcmUoJy4vc3ltYm9scycpXG5jb25zdCB7XG4gIGlzQ29ubmVjdGluZyxcbiAgaXNFc3RhYmxpc2hlZCxcbiAgaXNDbG9zaW5nLFxuICBpc1ZhbGlkU3VicHJvdG9jb2wsXG4gIGZpcmVFdmVudFxufSA9IHJlcXVpcmUoJy4vdXRpbCcpXG5jb25zdCB7IGVzdGFibGlzaFdlYlNvY2tldENvbm5lY3Rpb24sIGNsb3NlV2ViU29ja2V0Q29ubmVjdGlvbiB9ID0gcmVxdWlyZSgnLi9jb25uZWN0aW9uJylcbmNvbnN0IHsgQnl0ZVBhcnNlciB9ID0gcmVxdWlyZSgnLi9yZWNlaXZlcicpXG5jb25zdCB7IGtFbnVtZXJhYmxlUHJvcGVydHksIGlzQmxvYkxpa2UgfSA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvdXRpbCcpXG5jb25zdCB7IGdldEdsb2JhbERpc3BhdGNoZXIgfSA9IHJlcXVpcmUoJy4uLy4uL2dsb2JhbCcpXG5jb25zdCB7IHR5cGVzIH0gPSByZXF1aXJlKCdub2RlOnV0aWwnKVxuY29uc3QgeyBFcnJvckV2ZW50LCBDbG9zZUV2ZW50IH0gPSByZXF1aXJlKCcuL2V2ZW50cycpXG5jb25zdCB7IFNlbmRRdWV1ZSB9ID0gcmVxdWlyZSgnLi9zZW5kZXInKVxuXG4vLyBodHRwczovL3dlYnNvY2tldHMuc3BlYy53aGF0d2cub3JnLyNpbnRlcmZhY2UtZGVmaW5pdGlvblxuY2xhc3MgV2ViU29ja2V0IGV4dGVuZHMgRXZlbnRUYXJnZXQge1xuICAjZXZlbnRzID0ge1xuICAgIG9wZW46IG51bGwsXG4gICAgZXJyb3I6IG51bGwsXG4gICAgY2xvc2U6IG51bGwsXG4gICAgbWVzc2FnZTogbnVsbFxuICB9XG5cbiAgI2J1ZmZlcmVkQW1vdW50ID0gMFxuICAjcHJvdG9jb2wgPSAnJ1xuICAjZXh0ZW5zaW9ucyA9ICcnXG5cbiAgLyoqIEB0eXBlIHtTZW5kUXVldWV9ICovXG4gICNzZW5kUXVldWVcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHVybFxuICAgKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gcHJvdG9jb2xzXG4gICAqL1xuICBjb25zdHJ1Y3RvciAodXJsLCBwcm90b2NvbHMgPSBbXSkge1xuICAgIHN1cGVyKClcblxuICAgIGNvbnN0IHByZWZpeCA9ICdXZWJTb2NrZXQgY29uc3RydWN0b3InXG4gICAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAxLCBwcmVmaXgpXG5cbiAgICBjb25zdCBvcHRpb25zID0gd2ViaWRsLmNvbnZlcnRlcnNbJ0RPTVN0cmluZyBvciBzZXF1ZW5jZTxET01TdHJpbmc+IG9yIFdlYlNvY2tldEluaXQnXShwcm90b2NvbHMsIHByZWZpeCwgJ29wdGlvbnMnKVxuXG4gICAgdXJsID0gd2ViaWRsLmNvbnZlcnRlcnMuVVNWU3RyaW5nKHVybCwgcHJlZml4LCAndXJsJylcbiAgICBwcm90b2NvbHMgPSBvcHRpb25zLnByb3RvY29sc1xuXG4gICAgLy8gMS4gTGV0IGJhc2VVUkwgYmUgdGhpcydzIHJlbGV2YW50IHNldHRpbmdzIG9iamVjdCdzIEFQSSBiYXNlIFVSTC5cbiAgICBjb25zdCBiYXNlVVJMID0gZW52aXJvbm1lbnRTZXR0aW5nc09iamVjdC5zZXR0aW5nc09iamVjdC5iYXNlVXJsXG5cbiAgICAvLyAxLiBMZXQgdXJsUmVjb3JkIGJlIHRoZSByZXN1bHQgb2YgYXBwbHlpbmcgdGhlIFVSTCBwYXJzZXIgdG8gdXJsIHdpdGggYmFzZVVSTC5cbiAgICBsZXQgdXJsUmVjb3JkXG5cbiAgICB0cnkge1xuICAgICAgdXJsUmVjb3JkID0gbmV3IFVSTCh1cmwsIGJhc2VVUkwpXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gMy4gSWYgdXJsUmVjb3JkIGlzIGZhaWx1cmUsIHRoZW4gdGhyb3cgYSBcIlN5bnRheEVycm9yXCIgRE9NRXhjZXB0aW9uLlxuICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbihlLCAnU3ludGF4RXJyb3InKVxuICAgIH1cblxuICAgIC8vIDQuIElmIHVybFJlY29yZOKAmXMgc2NoZW1lIGlzIFwiaHR0cFwiLCB0aGVuIHNldCB1cmxSZWNvcmTigJlzIHNjaGVtZSB0byBcIndzXCIuXG4gICAgaWYgKHVybFJlY29yZC5wcm90b2NvbCA9PT0gJ2h0dHA6Jykge1xuICAgICAgdXJsUmVjb3JkLnByb3RvY29sID0gJ3dzOidcbiAgICB9IGVsc2UgaWYgKHVybFJlY29yZC5wcm90b2NvbCA9PT0gJ2h0dHBzOicpIHtcbiAgICAgIC8vIDUuIE90aGVyd2lzZSwgaWYgdXJsUmVjb3Jk4oCZcyBzY2hlbWUgaXMgXCJodHRwc1wiLCBzZXQgdXJsUmVjb3Jk4oCZcyBzY2hlbWUgdG8gXCJ3c3NcIi5cbiAgICAgIHVybFJlY29yZC5wcm90b2NvbCA9ICd3c3M6J1xuICAgIH1cblxuICAgIC8vIDYuIElmIHVybFJlY29yZOKAmXMgc2NoZW1lIGlzIG5vdCBcIndzXCIgb3IgXCJ3c3NcIiwgdGhlbiB0aHJvdyBhIFwiU3ludGF4RXJyb3JcIiBET01FeGNlcHRpb24uXG4gICAgaWYgKHVybFJlY29yZC5wcm90b2NvbCAhPT0gJ3dzOicgJiYgdXJsUmVjb3JkLnByb3RvY29sICE9PSAnd3NzOicpIHtcbiAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oXG4gICAgICAgIGBFeHBlY3RlZCBhIHdzOiBvciB3c3M6IHByb3RvY29sLCBnb3QgJHt1cmxSZWNvcmQucHJvdG9jb2x9YCxcbiAgICAgICAgJ1N5bnRheEVycm9yJ1xuICAgICAgKVxuICAgIH1cblxuICAgIC8vIDcuIElmIHVybFJlY29yZOKAmXMgZnJhZ21lbnQgaXMgbm9uLW51bGwsIHRoZW4gdGhyb3cgYSBcIlN5bnRheEVycm9yXCJcbiAgICAvLyAgICBET01FeGNlcHRpb24uXG4gICAgaWYgKHVybFJlY29yZC5oYXNoIHx8IHVybFJlY29yZC5ocmVmLmVuZHNXaXRoKCcjJykpIHtcbiAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oJ0dvdCBmcmFnbWVudCcsICdTeW50YXhFcnJvcicpXG4gICAgfVxuXG4gICAgLy8gOC4gSWYgcHJvdG9jb2xzIGlzIGEgc3RyaW5nLCBzZXQgcHJvdG9jb2xzIHRvIGEgc2VxdWVuY2UgY29uc2lzdGluZ1xuICAgIC8vICAgIG9mIGp1c3QgdGhhdCBzdHJpbmcuXG4gICAgaWYgKHR5cGVvZiBwcm90b2NvbHMgPT09ICdzdHJpbmcnKSB7XG4gICAgICBwcm90b2NvbHMgPSBbcHJvdG9jb2xzXVxuICAgIH1cblxuICAgIC8vIDkuIElmIGFueSBvZiB0aGUgdmFsdWVzIGluIHByb3RvY29scyBvY2N1ciBtb3JlIHRoYW4gb25jZSBvciBvdGhlcndpc2VcbiAgICAvLyAgICBmYWlsIHRvIG1hdGNoIHRoZSByZXF1aXJlbWVudHMgZm9yIGVsZW1lbnRzIHRoYXQgY29tcHJpc2UgdGhlIHZhbHVlXG4gICAgLy8gICAgb2YgYFNlYy1XZWJTb2NrZXQtUHJvdG9jb2xgIGZpZWxkcyBhcyBkZWZpbmVkIGJ5IFRoZSBXZWJTb2NrZXRcbiAgICAvLyAgICBwcm90b2NvbCwgdGhlbiB0aHJvdyBhIFwiU3ludGF4RXJyb3JcIiBET01FeGNlcHRpb24uXG4gICAgaWYgKHByb3RvY29scy5sZW5ndGggIT09IG5ldyBTZXQocHJvdG9jb2xzLm1hcChwID0+IHAudG9Mb3dlckNhc2UoKSkpLnNpemUpIHtcbiAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oJ0ludmFsaWQgU2VjLVdlYlNvY2tldC1Qcm90b2NvbCB2YWx1ZScsICdTeW50YXhFcnJvcicpXG4gICAgfVxuXG4gICAgaWYgKHByb3RvY29scy5sZW5ndGggPiAwICYmICFwcm90b2NvbHMuZXZlcnkocCA9PiBpc1ZhbGlkU3VicHJvdG9jb2wocCkpKSB7XG4gICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKCdJbnZhbGlkIFNlYy1XZWJTb2NrZXQtUHJvdG9jb2wgdmFsdWUnLCAnU3ludGF4RXJyb3InKVxuICAgIH1cblxuICAgIC8vIDEwLiBTZXQgdGhpcydzIHVybCB0byB1cmxSZWNvcmQuXG4gICAgdGhpc1trV2ViU29ja2V0VVJMXSA9IG5ldyBVUkwodXJsUmVjb3JkLmhyZWYpXG5cbiAgICAvLyAxMS4gTGV0IGNsaWVudCBiZSB0aGlzJ3MgcmVsZXZhbnQgc2V0dGluZ3Mgb2JqZWN0LlxuICAgIGNvbnN0IGNsaWVudCA9IGVudmlyb25tZW50U2V0dGluZ3NPYmplY3Quc2V0dGluZ3NPYmplY3RcblxuICAgIC8vIDEyLiBSdW4gdGhpcyBzdGVwIGluIHBhcmFsbGVsOlxuXG4gICAgLy8gICAgMS4gRXN0YWJsaXNoIGEgV2ViU29ja2V0IGNvbm5lY3Rpb24gZ2l2ZW4gdXJsUmVjb3JkLCBwcm90b2NvbHMsXG4gICAgLy8gICAgICAgYW5kIGNsaWVudC5cbiAgICB0aGlzW2tDb250cm9sbGVyXSA9IGVzdGFibGlzaFdlYlNvY2tldENvbm5lY3Rpb24oXG4gICAgICB1cmxSZWNvcmQsXG4gICAgICBwcm90b2NvbHMsXG4gICAgICBjbGllbnQsXG4gICAgICB0aGlzLFxuICAgICAgKHJlc3BvbnNlLCBleHRlbnNpb25zKSA9PiB0aGlzLiNvbkNvbm5lY3Rpb25Fc3RhYmxpc2hlZChyZXNwb25zZSwgZXh0ZW5zaW9ucyksXG4gICAgICBvcHRpb25zXG4gICAgKVxuXG4gICAgLy8gRWFjaCBXZWJTb2NrZXQgb2JqZWN0IGhhcyBhbiBhc3NvY2lhdGVkIHJlYWR5IHN0YXRlLCB3aGljaCBpcyBhXG4gICAgLy8gbnVtYmVyIHJlcHJlc2VudGluZyB0aGUgc3RhdGUgb2YgdGhlIGNvbm5lY3Rpb24uIEluaXRpYWxseSBpdCBtdXN0XG4gICAgLy8gYmUgQ09OTkVDVElORyAoMCkuXG4gICAgdGhpc1trUmVhZHlTdGF0ZV0gPSBXZWJTb2NrZXQuQ09OTkVDVElOR1xuXG4gICAgdGhpc1trU2VudENsb3NlXSA9IHNlbnRDbG9zZUZyYW1lU3RhdGUuTk9UX1NFTlRcblxuICAgIC8vIFRoZSBleHRlbnNpb25zIGF0dHJpYnV0ZSBtdXN0IGluaXRpYWxseSByZXR1cm4gdGhlIGVtcHR5IHN0cmluZy5cblxuICAgIC8vIFRoZSBwcm90b2NvbCBhdHRyaWJ1dGUgbXVzdCBpbml0aWFsbHkgcmV0dXJuIHRoZSBlbXB0eSBzdHJpbmcuXG5cbiAgICAvLyBFYWNoIFdlYlNvY2tldCBvYmplY3QgaGFzIGFuIGFzc29jaWF0ZWQgYmluYXJ5IHR5cGUsIHdoaWNoIGlzIGFcbiAgICAvLyBCaW5hcnlUeXBlLiBJbml0aWFsbHkgaXQgbXVzdCBiZSBcImJsb2JcIi5cbiAgICB0aGlzW2tCaW5hcnlUeXBlXSA9ICdibG9iJ1xuICB9XG5cbiAgLyoqXG4gICAqIEBzZWUgaHR0cHM6Ly93ZWJzb2NrZXRzLnNwZWMud2hhdHdnLm9yZy8jZG9tLXdlYnNvY2tldC1jbG9zZVxuICAgKiBAcGFyYW0ge251bWJlcnx1bmRlZmluZWR9IGNvZGVcbiAgICogQHBhcmFtIHtzdHJpbmd8dW5kZWZpbmVkfSByZWFzb25cbiAgICovXG4gIGNsb3NlIChjb2RlID0gdW5kZWZpbmVkLCByZWFzb24gPSB1bmRlZmluZWQpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBXZWJTb2NrZXQpXG5cbiAgICBjb25zdCBwcmVmaXggPSAnV2ViU29ja2V0LmNsb3NlJ1xuXG4gICAgaWYgKGNvZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY29kZSA9IHdlYmlkbC5jb252ZXJ0ZXJzWyd1bnNpZ25lZCBzaG9ydCddKGNvZGUsIHByZWZpeCwgJ2NvZGUnLCB7IGNsYW1wOiB0cnVlIH0pXG4gICAgfVxuXG4gICAgaWYgKHJlYXNvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZWFzb24gPSB3ZWJpZGwuY29udmVydGVycy5VU1ZTdHJpbmcocmVhc29uLCBwcmVmaXgsICdyZWFzb24nKVxuICAgIH1cblxuICAgIC8vIDEuIElmIGNvZGUgaXMgcHJlc2VudCwgYnV0IGlzIG5laXRoZXIgYW4gaW50ZWdlciBlcXVhbCB0byAxMDAwIG5vciBhblxuICAgIC8vICAgIGludGVnZXIgaW4gdGhlIHJhbmdlIDMwMDAgdG8gNDk5OSwgaW5jbHVzaXZlLCB0aHJvdyBhblxuICAgIC8vICAgIFwiSW52YWxpZEFjY2Vzc0Vycm9yXCIgRE9NRXhjZXB0aW9uLlxuICAgIGlmIChjb2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChjb2RlICE9PSAxMDAwICYmIChjb2RlIDwgMzAwMCB8fCBjb2RlID4gNDk5OSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbignaW52YWxpZCBjb2RlJywgJ0ludmFsaWRBY2Nlc3NFcnJvcicpXG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IHJlYXNvbkJ5dGVMZW5ndGggPSAwXG5cbiAgICAvLyAyLiBJZiByZWFzb24gaXMgcHJlc2VudCwgdGhlbiBydW4gdGhlc2Ugc3Vic3RlcHM6XG4gICAgaWYgKHJlYXNvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyAxLiBMZXQgcmVhc29uQnl0ZXMgYmUgdGhlIHJlc3VsdCBvZiBlbmNvZGluZyByZWFzb24uXG4gICAgICAvLyAyLiBJZiByZWFzb25CeXRlcyBpcyBsb25nZXIgdGhhbiAxMjMgYnl0ZXMsIHRoZW4gdGhyb3cgYVxuICAgICAgLy8gICAgXCJTeW50YXhFcnJvclwiIERPTUV4Y2VwdGlvbi5cbiAgICAgIHJlYXNvbkJ5dGVMZW5ndGggPSBCdWZmZXIuYnl0ZUxlbmd0aChyZWFzb24pXG5cbiAgICAgIGlmIChyZWFzb25CeXRlTGVuZ3RoID4gMTIzKSB7XG4gICAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oXG4gICAgICAgICAgYFJlYXNvbiBtdXN0IGJlIGxlc3MgdGhhbiAxMjMgYnl0ZXM7IHJlY2VpdmVkICR7cmVhc29uQnl0ZUxlbmd0aH1gLFxuICAgICAgICAgICdTeW50YXhFcnJvcidcbiAgICAgICAgKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIDMuIFJ1biB0aGUgZmlyc3QgbWF0Y2hpbmcgc3RlcHMgZnJvbSB0aGUgZm9sbG93aW5nIGxpc3Q6XG4gICAgY2xvc2VXZWJTb2NrZXRDb25uZWN0aW9uKHRoaXMsIGNvZGUsIHJlYXNvbiwgcmVhc29uQnl0ZUxlbmd0aClcbiAgfVxuXG4gIC8qKlxuICAgKiBAc2VlIGh0dHBzOi8vd2Vic29ja2V0cy5zcGVjLndoYXR3Zy5vcmcvI2RvbS13ZWJzb2NrZXQtc2VuZFxuICAgKiBAcGFyYW0ge05vZGVKUy5UeXBlZEFycmF5fEFycmF5QnVmZmVyfEJsb2J8c3RyaW5nfSBkYXRhXG4gICAqL1xuICBzZW5kIChkYXRhKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgV2ViU29ja2V0KVxuXG4gICAgY29uc3QgcHJlZml4ID0gJ1dlYlNvY2tldC5zZW5kJ1xuICAgIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMSwgcHJlZml4KVxuXG4gICAgZGF0YSA9IHdlYmlkbC5jb252ZXJ0ZXJzLldlYlNvY2tldFNlbmREYXRhKGRhdGEsIHByZWZpeCwgJ2RhdGEnKVxuXG4gICAgLy8gMS4gSWYgdGhpcydzIHJlYWR5IHN0YXRlIGlzIENPTk5FQ1RJTkcsIHRoZW4gdGhyb3cgYW5cbiAgICAvLyAgICBcIkludmFsaWRTdGF0ZUVycm9yXCIgRE9NRXhjZXB0aW9uLlxuICAgIGlmIChpc0Nvbm5lY3RpbmcodGhpcykpIHtcbiAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oJ1NlbnQgYmVmb3JlIGNvbm5lY3RlZC4nLCAnSW52YWxpZFN0YXRlRXJyb3InKVxuICAgIH1cblxuICAgIC8vIDIuIFJ1biB0aGUgYXBwcm9wcmlhdGUgc2V0IG9mIHN0ZXBzIGZyb20gdGhlIGZvbGxvd2luZyBsaXN0OlxuICAgIC8vIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvcmZjNjQ1NSNzZWN0aW9uLTYuMVxuICAgIC8vIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvcmZjNjQ1NSNzZWN0aW9uLTUuMlxuXG4gICAgaWYgKCFpc0VzdGFibGlzaGVkKHRoaXMpIHx8IGlzQ2xvc2luZyh0aGlzKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gSWYgZGF0YSBpcyBhIHN0cmluZ1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIElmIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvbiBpcyBlc3RhYmxpc2hlZCBhbmQgdGhlIFdlYlNvY2tldFxuICAgICAgLy8gY2xvc2luZyBoYW5kc2hha2UgaGFzIG5vdCB5ZXQgc3RhcnRlZCwgdGhlbiB0aGUgdXNlciBhZ2VudFxuICAgICAgLy8gbXVzdCBzZW5kIGEgV2ViU29ja2V0IE1lc3NhZ2UgY29tcHJpc2VkIG9mIHRoZSBkYXRhIGFyZ3VtZW50XG4gICAgICAvLyB1c2luZyBhIHRleHQgZnJhbWUgb3Bjb2RlOyBpZiB0aGUgZGF0YSBjYW5ub3QgYmUgc2VudCwgZS5nLlxuICAgICAgLy8gYmVjYXVzZSBpdCB3b3VsZCBuZWVkIHRvIGJlIGJ1ZmZlcmVkIGJ1dCB0aGUgYnVmZmVyIGlzIGZ1bGwsXG4gICAgICAvLyB0aGUgdXNlciBhZ2VudCBtdXN0IGZsYWcgdGhlIFdlYlNvY2tldCBhcyBmdWxsIGFuZCB0aGVuIGNsb3NlXG4gICAgICAvLyB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24uIEFueSBpbnZvY2F0aW9uIG9mIHRoaXMgbWV0aG9kIHdpdGggYVxuICAgICAgLy8gc3RyaW5nIGFyZ3VtZW50IHRoYXQgZG9lcyBub3QgdGhyb3cgYW4gZXhjZXB0aW9uIG11c3QgaW5jcmVhc2VcbiAgICAgIC8vIHRoZSBidWZmZXJlZEFtb3VudCBhdHRyaWJ1dGUgYnkgdGhlIG51bWJlciBvZiBieXRlcyBuZWVkZWQgdG9cbiAgICAgIC8vIGV4cHJlc3MgdGhlIGFyZ3VtZW50IGFzIFVURi04LlxuXG4gICAgICBjb25zdCBsZW5ndGggPSBCdWZmZXIuYnl0ZUxlbmd0aChkYXRhKVxuXG4gICAgICB0aGlzLiNidWZmZXJlZEFtb3VudCArPSBsZW5ndGhcbiAgICAgIHRoaXMuI3NlbmRRdWV1ZS5hZGQoZGF0YSwgKCkgPT4ge1xuICAgICAgICB0aGlzLiNidWZmZXJlZEFtb3VudCAtPSBsZW5ndGhcbiAgICAgIH0sIHNlbmRIaW50cy5zdHJpbmcpXG4gICAgfSBlbHNlIGlmICh0eXBlcy5pc0FycmF5QnVmZmVyKGRhdGEpKSB7XG4gICAgICAvLyBJZiB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24gaXMgZXN0YWJsaXNoZWQsIGFuZCB0aGUgV2ViU29ja2V0XG4gICAgICAvLyBjbG9zaW5nIGhhbmRzaGFrZSBoYXMgbm90IHlldCBzdGFydGVkLCB0aGVuIHRoZSB1c2VyIGFnZW50IG11c3RcbiAgICAgIC8vIHNlbmQgYSBXZWJTb2NrZXQgTWVzc2FnZSBjb21wcmlzZWQgb2YgZGF0YSB1c2luZyBhIGJpbmFyeSBmcmFtZVxuICAgICAgLy8gb3Bjb2RlOyBpZiB0aGUgZGF0YSBjYW5ub3QgYmUgc2VudCwgZS5nLiBiZWNhdXNlIGl0IHdvdWxkIG5lZWRcbiAgICAgIC8vIHRvIGJlIGJ1ZmZlcmVkIGJ1dCB0aGUgYnVmZmVyIGlzIGZ1bGwsIHRoZSB1c2VyIGFnZW50IG11c3QgZmxhZ1xuICAgICAgLy8gdGhlIFdlYlNvY2tldCBhcyBmdWxsIGFuZCB0aGVuIGNsb3NlIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvbi5cbiAgICAgIC8vIFRoZSBkYXRhIHRvIGJlIHNlbnQgaXMgdGhlIGRhdGEgc3RvcmVkIGluIHRoZSBidWZmZXIgZGVzY3JpYmVkXG4gICAgICAvLyBieSB0aGUgQXJyYXlCdWZmZXIgb2JqZWN0LiBBbnkgaW52b2NhdGlvbiBvZiB0aGlzIG1ldGhvZCB3aXRoIGFuXG4gICAgICAvLyBBcnJheUJ1ZmZlciBhcmd1bWVudCB0aGF0IGRvZXMgbm90IHRocm93IGFuIGV4Y2VwdGlvbiBtdXN0XG4gICAgICAvLyBpbmNyZWFzZSB0aGUgYnVmZmVyZWRBbW91bnQgYXR0cmlidXRlIGJ5IHRoZSBsZW5ndGggb2YgdGhlXG4gICAgICAvLyBBcnJheUJ1ZmZlciBpbiBieXRlcy5cblxuICAgICAgdGhpcy4jYnVmZmVyZWRBbW91bnQgKz0gZGF0YS5ieXRlTGVuZ3RoXG4gICAgICB0aGlzLiNzZW5kUXVldWUuYWRkKGRhdGEsICgpID0+IHtcbiAgICAgICAgdGhpcy4jYnVmZmVyZWRBbW91bnQgLT0gZGF0YS5ieXRlTGVuZ3RoXG4gICAgICB9LCBzZW5kSGludHMuYXJyYXlCdWZmZXIpXG4gICAgfSBlbHNlIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoZGF0YSkpIHtcbiAgICAgIC8vIElmIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvbiBpcyBlc3RhYmxpc2hlZCwgYW5kIHRoZSBXZWJTb2NrZXRcbiAgICAgIC8vIGNsb3NpbmcgaGFuZHNoYWtlIGhhcyBub3QgeWV0IHN0YXJ0ZWQsIHRoZW4gdGhlIHVzZXIgYWdlbnQgbXVzdFxuICAgICAgLy8gc2VuZCBhIFdlYlNvY2tldCBNZXNzYWdlIGNvbXByaXNlZCBvZiBkYXRhIHVzaW5nIGEgYmluYXJ5IGZyYW1lXG4gICAgICAvLyBvcGNvZGU7IGlmIHRoZSBkYXRhIGNhbm5vdCBiZSBzZW50LCBlLmcuIGJlY2F1c2UgaXQgd291bGQgbmVlZCB0b1xuICAgICAgLy8gYmUgYnVmZmVyZWQgYnV0IHRoZSBidWZmZXIgaXMgZnVsbCwgdGhlIHVzZXIgYWdlbnQgbXVzdCBmbGFnIHRoZVxuICAgICAgLy8gV2ViU29ja2V0IGFzIGZ1bGwgYW5kIHRoZW4gY2xvc2UgdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uLiBUaGVcbiAgICAgIC8vIGRhdGEgdG8gYmUgc2VudCBpcyB0aGUgZGF0YSBzdG9yZWQgaW4gdGhlIHNlY3Rpb24gb2YgdGhlIGJ1ZmZlclxuICAgICAgLy8gZGVzY3JpYmVkIGJ5IHRoZSBBcnJheUJ1ZmZlciBvYmplY3QgdGhhdCBkYXRhIHJlZmVyZW5jZXMuIEFueVxuICAgICAgLy8gaW52b2NhdGlvbiBvZiB0aGlzIG1ldGhvZCB3aXRoIHRoaXMga2luZCBvZiBhcmd1bWVudCB0aGF0IGRvZXNcbiAgICAgIC8vIG5vdCB0aHJvdyBhbiBleGNlcHRpb24gbXVzdCBpbmNyZWFzZSB0aGUgYnVmZmVyZWRBbW91bnQgYXR0cmlidXRlXG4gICAgICAvLyBieSB0aGUgbGVuZ3RoIG9mIGRhdGHigJlzIGJ1ZmZlciBpbiBieXRlcy5cblxuICAgICAgdGhpcy4jYnVmZmVyZWRBbW91bnQgKz0gZGF0YS5ieXRlTGVuZ3RoXG4gICAgICB0aGlzLiNzZW5kUXVldWUuYWRkKGRhdGEsICgpID0+IHtcbiAgICAgICAgdGhpcy4jYnVmZmVyZWRBbW91bnQgLT0gZGF0YS5ieXRlTGVuZ3RoXG4gICAgICB9LCBzZW5kSGludHMudHlwZWRBcnJheSlcbiAgICB9IGVsc2UgaWYgKGlzQmxvYkxpa2UoZGF0YSkpIHtcbiAgICAgIC8vIElmIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvbiBpcyBlc3RhYmxpc2hlZCwgYW5kIHRoZSBXZWJTb2NrZXRcbiAgICAgIC8vIGNsb3NpbmcgaGFuZHNoYWtlIGhhcyBub3QgeWV0IHN0YXJ0ZWQsIHRoZW4gdGhlIHVzZXIgYWdlbnQgbXVzdFxuICAgICAgLy8gc2VuZCBhIFdlYlNvY2tldCBNZXNzYWdlIGNvbXByaXNlZCBvZiBkYXRhIHVzaW5nIGEgYmluYXJ5IGZyYW1lXG4gICAgICAvLyBvcGNvZGU7IGlmIHRoZSBkYXRhIGNhbm5vdCBiZSBzZW50LCBlLmcuIGJlY2F1c2UgaXQgd291bGQgbmVlZCB0b1xuICAgICAgLy8gYmUgYnVmZmVyZWQgYnV0IHRoZSBidWZmZXIgaXMgZnVsbCwgdGhlIHVzZXIgYWdlbnQgbXVzdCBmbGFnIHRoZVxuICAgICAgLy8gV2ViU29ja2V0IGFzIGZ1bGwgYW5kIHRoZW4gY2xvc2UgdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uLiBUaGUgZGF0YVxuICAgICAgLy8gdG8gYmUgc2VudCBpcyB0aGUgcmF3IGRhdGEgcmVwcmVzZW50ZWQgYnkgdGhlIEJsb2Igb2JqZWN0LiBBbnlcbiAgICAgIC8vIGludm9jYXRpb24gb2YgdGhpcyBtZXRob2Qgd2l0aCBhIEJsb2IgYXJndW1lbnQgdGhhdCBkb2VzIG5vdCB0aHJvd1xuICAgICAgLy8gYW4gZXhjZXB0aW9uIG11c3QgaW5jcmVhc2UgdGhlIGJ1ZmZlcmVkQW1vdW50IGF0dHJpYnV0ZSBieSB0aGUgc2l6ZVxuICAgICAgLy8gb2YgdGhlIEJsb2Igb2JqZWN04oCZcyByYXcgZGF0YSwgaW4gYnl0ZXMuXG5cbiAgICAgIHRoaXMuI2J1ZmZlcmVkQW1vdW50ICs9IGRhdGEuc2l6ZVxuICAgICAgdGhpcy4jc2VuZFF1ZXVlLmFkZChkYXRhLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuI2J1ZmZlcmVkQW1vdW50IC09IGRhdGEuc2l6ZVxuICAgICAgfSwgc2VuZEhpbnRzLmJsb2IpXG4gICAgfVxuICB9XG5cbiAgZ2V0IHJlYWR5U3RhdGUgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFdlYlNvY2tldClcblxuICAgIC8vIFRoZSByZWFkeVN0YXRlIGdldHRlciBzdGVwcyBhcmUgdG8gcmV0dXJuIHRoaXMncyByZWFkeSBzdGF0ZS5cbiAgICByZXR1cm4gdGhpc1trUmVhZHlTdGF0ZV1cbiAgfVxuXG4gIGdldCBidWZmZXJlZEFtb3VudCAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgV2ViU29ja2V0KVxuXG4gICAgcmV0dXJuIHRoaXMuI2J1ZmZlcmVkQW1vdW50XG4gIH1cblxuICBnZXQgdXJsICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBXZWJTb2NrZXQpXG5cbiAgICAvLyBUaGUgdXJsIGdldHRlciBzdGVwcyBhcmUgdG8gcmV0dXJuIHRoaXMncyB1cmwsIHNlcmlhbGl6ZWQuXG4gICAgcmV0dXJuIFVSTFNlcmlhbGl6ZXIodGhpc1trV2ViU29ja2V0VVJMXSlcbiAgfVxuXG4gIGdldCBleHRlbnNpb25zICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBXZWJTb2NrZXQpXG5cbiAgICByZXR1cm4gdGhpcy4jZXh0ZW5zaW9uc1xuICB9XG5cbiAgZ2V0IHByb3RvY29sICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBXZWJTb2NrZXQpXG5cbiAgICByZXR1cm4gdGhpcy4jcHJvdG9jb2xcbiAgfVxuXG4gIGdldCBvbm9wZW4gKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFdlYlNvY2tldClcblxuICAgIHJldHVybiB0aGlzLiNldmVudHMub3BlblxuICB9XG5cbiAgc2V0IG9ub3BlbiAoZm4pIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBXZWJTb2NrZXQpXG5cbiAgICBpZiAodGhpcy4jZXZlbnRzLm9wZW4pIHtcbiAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignb3BlbicsIHRoaXMuI2V2ZW50cy5vcGVuKVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXMuI2V2ZW50cy5vcGVuID0gZm5cbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignb3BlbicsIGZuKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLiNldmVudHMub3BlbiA9IG51bGxcbiAgICB9XG4gIH1cblxuICBnZXQgb25lcnJvciAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgV2ViU29ja2V0KVxuXG4gICAgcmV0dXJuIHRoaXMuI2V2ZW50cy5lcnJvclxuICB9XG5cbiAgc2V0IG9uZXJyb3IgKGZuKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgV2ViU29ja2V0KVxuXG4gICAgaWYgKHRoaXMuI2V2ZW50cy5lcnJvcikge1xuICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdlcnJvcicsIHRoaXMuI2V2ZW50cy5lcnJvcilcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLiNldmVudHMuZXJyb3IgPSBmblxuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGZuKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLiNldmVudHMuZXJyb3IgPSBudWxsXG4gICAgfVxuICB9XG5cbiAgZ2V0IG9uY2xvc2UgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFdlYlNvY2tldClcblxuICAgIHJldHVybiB0aGlzLiNldmVudHMuY2xvc2VcbiAgfVxuXG4gIHNldCBvbmNsb3NlIChmbikge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFdlYlNvY2tldClcblxuICAgIGlmICh0aGlzLiNldmVudHMuY2xvc2UpIHtcbiAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xvc2UnLCB0aGlzLiNldmVudHMuY2xvc2UpXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy4jZXZlbnRzLmNsb3NlID0gZm5cbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignY2xvc2UnLCBmbilcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4jZXZlbnRzLmNsb3NlID0gbnVsbFxuICAgIH1cbiAgfVxuXG4gIGdldCBvbm1lc3NhZ2UgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFdlYlNvY2tldClcblxuICAgIHJldHVybiB0aGlzLiNldmVudHMubWVzc2FnZVxuICB9XG5cbiAgc2V0IG9ubWVzc2FnZSAoZm4pIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBXZWJTb2NrZXQpXG5cbiAgICBpZiAodGhpcy4jZXZlbnRzLm1lc3NhZ2UpIHtcbiAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIHRoaXMuI2V2ZW50cy5tZXNzYWdlKVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXMuI2V2ZW50cy5tZXNzYWdlID0gZm5cbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGZuKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLiNldmVudHMubWVzc2FnZSA9IG51bGxcbiAgICB9XG4gIH1cblxuICBnZXQgYmluYXJ5VHlwZSAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgV2ViU29ja2V0KVxuXG4gICAgcmV0dXJuIHRoaXNba0JpbmFyeVR5cGVdXG4gIH1cblxuICBzZXQgYmluYXJ5VHlwZSAodHlwZSkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFdlYlNvY2tldClcblxuICAgIGlmICh0eXBlICE9PSAnYmxvYicgJiYgdHlwZSAhPT0gJ2FycmF5YnVmZmVyJykge1xuICAgICAgdGhpc1trQmluYXJ5VHlwZV0gPSAnYmxvYidcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpc1trQmluYXJ5VHlwZV0gPSB0eXBlXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBzZWUgaHR0cHM6Ly93ZWJzb2NrZXRzLnNwZWMud2hhdHdnLm9yZy8jZmVlZGJhY2stZnJvbS10aGUtcHJvdG9jb2xcbiAgICovXG4gICNvbkNvbm5lY3Rpb25Fc3RhYmxpc2hlZCAocmVzcG9uc2UsIHBhcnNlZEV4dGVuc2lvbnMpIHtcbiAgICAvLyBwcm9jZXNzUmVzcG9uc2UgaXMgY2FsbGVkIHdoZW4gdGhlIFwicmVzcG9uc2XigJlzIGhlYWRlciBsaXN0IGhhcyBiZWVuIHJlY2VpdmVkIGFuZCBpbml0aWFsaXplZC5cIlxuICAgIC8vIG9uY2UgdGhpcyBoYXBwZW5zLCB0aGUgY29ubmVjdGlvbiBpcyBvcGVuXG4gICAgdGhpc1trUmVzcG9uc2VdID0gcmVzcG9uc2VcblxuICAgIGNvbnN0IHBhcnNlciA9IG5ldyBCeXRlUGFyc2VyKHRoaXMsIHBhcnNlZEV4dGVuc2lvbnMpXG4gICAgcGFyc2VyLm9uKCdkcmFpbicsIG9uUGFyc2VyRHJhaW4pXG4gICAgcGFyc2VyLm9uKCdlcnJvcicsIG9uUGFyc2VyRXJyb3IuYmluZCh0aGlzKSlcblxuICAgIHJlc3BvbnNlLnNvY2tldC53cyA9IHRoaXNcbiAgICB0aGlzW2tCeXRlUGFyc2VyXSA9IHBhcnNlclxuXG4gICAgdGhpcy4jc2VuZFF1ZXVlID0gbmV3IFNlbmRRdWV1ZShyZXNwb25zZS5zb2NrZXQpXG5cbiAgICAvLyAxLiBDaGFuZ2UgdGhlIHJlYWR5IHN0YXRlIHRvIE9QRU4gKDEpLlxuICAgIHRoaXNba1JlYWR5U3RhdGVdID0gc3RhdGVzLk9QRU5cblxuICAgIC8vIDIuIENoYW5nZSB0aGUgZXh0ZW5zaW9ucyBhdHRyaWJ1dGXigJlzIHZhbHVlIHRvIHRoZSBleHRlbnNpb25zIGluIHVzZSwgaWZcbiAgICAvLyAgICBpdCBpcyBub3QgdGhlIG51bGwgdmFsdWUuXG4gICAgLy8gaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9yZmM2NDU1I3NlY3Rpb24tOS4xXG4gICAgY29uc3QgZXh0ZW5zaW9ucyA9IHJlc3BvbnNlLmhlYWRlcnNMaXN0LmdldCgnc2VjLXdlYnNvY2tldC1leHRlbnNpb25zJylcblxuICAgIGlmIChleHRlbnNpb25zICE9PSBudWxsKSB7XG4gICAgICB0aGlzLiNleHRlbnNpb25zID0gZXh0ZW5zaW9uc1xuICAgIH1cblxuICAgIC8vIDMuIENoYW5nZSB0aGUgcHJvdG9jb2wgYXR0cmlidXRl4oCZcyB2YWx1ZSB0byB0aGUgc3VicHJvdG9jb2wgaW4gdXNlLCBpZlxuICAgIC8vICAgIGl0IGlzIG5vdCB0aGUgbnVsbCB2YWx1ZS5cbiAgICAvLyBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL3JmYzY0NTUjc2VjdGlvbi0xLjlcbiAgICBjb25zdCBwcm90b2NvbCA9IHJlc3BvbnNlLmhlYWRlcnNMaXN0LmdldCgnc2VjLXdlYnNvY2tldC1wcm90b2NvbCcpXG5cbiAgICBpZiAocHJvdG9jb2wgIT09IG51bGwpIHtcbiAgICAgIHRoaXMuI3Byb3RvY29sID0gcHJvdG9jb2xcbiAgICB9XG5cbiAgICAvLyA0LiBGaXJlIGFuIGV2ZW50IG5hbWVkIG9wZW4gYXQgdGhlIFdlYlNvY2tldCBvYmplY3QuXG4gICAgZmlyZUV2ZW50KCdvcGVuJywgdGhpcylcbiAgfVxufVxuXG4vLyBodHRwczovL3dlYnNvY2tldHMuc3BlYy53aGF0d2cub3JnLyNkb20td2Vic29ja2V0LWNvbm5lY3RpbmdcbldlYlNvY2tldC5DT05ORUNUSU5HID0gV2ViU29ja2V0LnByb3RvdHlwZS5DT05ORUNUSU5HID0gc3RhdGVzLkNPTk5FQ1RJTkdcbi8vIGh0dHBzOi8vd2Vic29ja2V0cy5zcGVjLndoYXR3Zy5vcmcvI2RvbS13ZWJzb2NrZXQtb3BlblxuV2ViU29ja2V0Lk9QRU4gPSBXZWJTb2NrZXQucHJvdG90eXBlLk9QRU4gPSBzdGF0ZXMuT1BFTlxuLy8gaHR0cHM6Ly93ZWJzb2NrZXRzLnNwZWMud2hhdHdnLm9yZy8jZG9tLXdlYnNvY2tldC1jbG9zaW5nXG5XZWJTb2NrZXQuQ0xPU0lORyA9IFdlYlNvY2tldC5wcm90b3R5cGUuQ0xPU0lORyA9IHN0YXRlcy5DTE9TSU5HXG4vLyBodHRwczovL3dlYnNvY2tldHMuc3BlYy53aGF0d2cub3JnLyNkb20td2Vic29ja2V0LWNsb3NlZFxuV2ViU29ja2V0LkNMT1NFRCA9IFdlYlNvY2tldC5wcm90b3R5cGUuQ0xPU0VEID0gc3RhdGVzLkNMT1NFRFxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhXZWJTb2NrZXQucHJvdG90eXBlLCB7XG4gIENPTk5FQ1RJTkc6IHN0YXRpY1Byb3BlcnR5RGVzY3JpcHRvcnMsXG4gIE9QRU46IHN0YXRpY1Byb3BlcnR5RGVzY3JpcHRvcnMsXG4gIENMT1NJTkc6IHN0YXRpY1Byb3BlcnR5RGVzY3JpcHRvcnMsXG4gIENMT1NFRDogc3RhdGljUHJvcGVydHlEZXNjcmlwdG9ycyxcbiAgdXJsOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICByZWFkeVN0YXRlOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBidWZmZXJlZEFtb3VudDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgb25vcGVuOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBvbmVycm9yOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBvbmNsb3NlOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBjbG9zZToga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgb25tZXNzYWdlOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBiaW5hcnlUeXBlOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBzZW5kOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBleHRlbnNpb25zOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBwcm90b2NvbDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgW1N5bWJvbC50b1N0cmluZ1RhZ106IHtcbiAgICB2YWx1ZTogJ1dlYlNvY2tldCcsXG4gICAgd3JpdGFibGU6IGZhbHNlLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9XG59KVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhXZWJTb2NrZXQsIHtcbiAgQ09OTkVDVElORzogc3RhdGljUHJvcGVydHlEZXNjcmlwdG9ycyxcbiAgT1BFTjogc3RhdGljUHJvcGVydHlEZXNjcmlwdG9ycyxcbiAgQ0xPU0lORzogc3RhdGljUHJvcGVydHlEZXNjcmlwdG9ycyxcbiAgQ0xPU0VEOiBzdGF0aWNQcm9wZXJ0eURlc2NyaXB0b3JzXG59KVxuXG53ZWJpZGwuY29udmVydGVyc1snc2VxdWVuY2U8RE9NU3RyaW5nPiddID0gd2ViaWRsLnNlcXVlbmNlQ29udmVydGVyKFxuICB3ZWJpZGwuY29udmVydGVycy5ET01TdHJpbmdcbilcblxud2ViaWRsLmNvbnZlcnRlcnNbJ0RPTVN0cmluZyBvciBzZXF1ZW5jZTxET01TdHJpbmc+J10gPSBmdW5jdGlvbiAoViwgcHJlZml4LCBhcmd1bWVudCkge1xuICBpZiAod2ViaWRsLnV0aWwuVHlwZShWKSA9PT0gJ09iamVjdCcgJiYgU3ltYm9sLml0ZXJhdG9yIGluIFYpIHtcbiAgICByZXR1cm4gd2ViaWRsLmNvbnZlcnRlcnNbJ3NlcXVlbmNlPERPTVN0cmluZz4nXShWKVxuICB9XG5cbiAgcmV0dXJuIHdlYmlkbC5jb252ZXJ0ZXJzLkRPTVN0cmluZyhWLCBwcmVmaXgsIGFyZ3VtZW50KVxufVxuXG4vLyBUaGlzIGltcGxlbWVudHMgdGhlIHByb3Bvc2FsIG1hZGUgaW4gaHR0cHM6Ly9naXRodWIuY29tL3doYXR3Zy93ZWJzb2NrZXRzL2lzc3Vlcy80Mlxud2ViaWRsLmNvbnZlcnRlcnMuV2ViU29ja2V0SW5pdCA9IHdlYmlkbC5kaWN0aW9uYXJ5Q29udmVydGVyKFtcbiAge1xuICAgIGtleTogJ3Byb3RvY29scycsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVyc1snRE9NU3RyaW5nIG9yIHNlcXVlbmNlPERPTVN0cmluZz4nXSxcbiAgICBkZWZhdWx0VmFsdWU6ICgpID0+IG5ldyBBcnJheSgwKVxuICB9LFxuICB7XG4gICAga2V5OiAnZGlzcGF0Y2hlcicsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5hbnksXG4gICAgZGVmYXVsdFZhbHVlOiAoKSA9PiBnZXRHbG9iYWxEaXNwYXRjaGVyKClcbiAgfSxcbiAge1xuICAgIGtleTogJ2hlYWRlcnMnLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLm51bGxhYmxlQ29udmVydGVyKHdlYmlkbC5jb252ZXJ0ZXJzLkhlYWRlcnNJbml0KVxuICB9XG5dKVxuXG53ZWJpZGwuY29udmVydGVyc1snRE9NU3RyaW5nIG9yIHNlcXVlbmNlPERPTVN0cmluZz4gb3IgV2ViU29ja2V0SW5pdCddID0gZnVuY3Rpb24gKFYpIHtcbiAgaWYgKHdlYmlkbC51dGlsLlR5cGUoVikgPT09ICdPYmplY3QnICYmICEoU3ltYm9sLml0ZXJhdG9yIGluIFYpKSB7XG4gICAgcmV0dXJuIHdlYmlkbC5jb252ZXJ0ZXJzLldlYlNvY2tldEluaXQoVilcbiAgfVxuXG4gIHJldHVybiB7IHByb3RvY29sczogd2ViaWRsLmNvbnZlcnRlcnNbJ0RPTVN0cmluZyBvciBzZXF1ZW5jZTxET01TdHJpbmc+J10oVikgfVxufVxuXG53ZWJpZGwuY29udmVydGVycy5XZWJTb2NrZXRTZW5kRGF0YSA9IGZ1bmN0aW9uIChWKSB7XG4gIGlmICh3ZWJpZGwudXRpbC5UeXBlKFYpID09PSAnT2JqZWN0Jykge1xuICAgIGlmIChpc0Jsb2JMaWtlKFYpKSB7XG4gICAgICByZXR1cm4gd2ViaWRsLmNvbnZlcnRlcnMuQmxvYihWLCB7IHN0cmljdDogZmFsc2UgfSlcbiAgICB9XG5cbiAgICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KFYpIHx8IHR5cGVzLmlzQXJyYXlCdWZmZXIoVikpIHtcbiAgICAgIHJldHVybiB3ZWJpZGwuY29udmVydGVycy5CdWZmZXJTb3VyY2UoVilcbiAgICB9XG4gIH1cblxuICByZXR1cm4gd2ViaWRsLmNvbnZlcnRlcnMuVVNWU3RyaW5nKFYpXG59XG5cbmZ1bmN0aW9uIG9uUGFyc2VyRHJhaW4gKCkge1xuICB0aGlzLndzW2tSZXNwb25zZV0uc29ja2V0LnJlc3VtZSgpXG59XG5cbmZ1bmN0aW9uIG9uUGFyc2VyRXJyb3IgKGVycikge1xuICBsZXQgbWVzc2FnZVxuICBsZXQgY29kZVxuXG4gIGlmIChlcnIgaW5zdGFuY2VvZiBDbG9zZUV2ZW50KSB7XG4gICAgbWVzc2FnZSA9IGVyci5yZWFzb25cbiAgICBjb2RlID0gZXJyLmNvZGVcbiAgfSBlbHNlIHtcbiAgICBtZXNzYWdlID0gZXJyLm1lc3NhZ2VcbiAgfVxuXG4gIGZpcmVFdmVudCgnZXJyb3InLCB0aGlzLCAoKSA9PiBuZXcgRXJyb3JFdmVudCgnZXJyb3InLCB7IGVycm9yOiBlcnIsIG1lc3NhZ2UgfSkpXG5cbiAgY2xvc2VXZWJTb2NrZXRDb25uZWN0aW9uKHRoaXMsIGNvZGUpXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXZWJTb2NrZXRcbn1cbiJdLCJuYW1lcyI6WyJ3ZWJpZGwiLCJyZXF1aXJlIiwiVVJMU2VyaWFsaXplciIsImVudmlyb25tZW50U2V0dGluZ3NPYmplY3QiLCJzdGF0aWNQcm9wZXJ0eURlc2NyaXB0b3JzIiwic3RhdGVzIiwic2VudENsb3NlRnJhbWVTdGF0ZSIsInNlbmRIaW50cyIsImtXZWJTb2NrZXRVUkwiLCJrUmVhZHlTdGF0ZSIsImtDb250cm9sbGVyIiwia0JpbmFyeVR5cGUiLCJrUmVzcG9uc2UiLCJrU2VudENsb3NlIiwia0J5dGVQYXJzZXIiLCJpc0Nvbm5lY3RpbmciLCJpc0VzdGFibGlzaGVkIiwiaXNDbG9zaW5nIiwiaXNWYWxpZFN1YnByb3RvY29sIiwiZmlyZUV2ZW50IiwiZXN0YWJsaXNoV2ViU29ja2V0Q29ubmVjdGlvbiIsImNsb3NlV2ViU29ja2V0Q29ubmVjdGlvbiIsIkJ5dGVQYXJzZXIiLCJrRW51bWVyYWJsZVByb3BlcnR5IiwiaXNCbG9iTGlrZSIsImdldEdsb2JhbERpc3BhdGNoZXIiLCJ0eXBlcyIsIkVycm9yRXZlbnQiLCJDbG9zZUV2ZW50IiwiU2VuZFF1ZXVlIiwiV2ViU29ja2V0IiwiRXZlbnRUYXJnZXQiLCJldmVudHMiLCJidWZmZXJlZEFtb3VudCIsInByb3RvY29sIiwiZXh0ZW5zaW9ucyIsInNlbmRRdWV1ZSIsImNvbnN0cnVjdG9yIiwidXJsIiwicHJvdG9jb2xzIiwib3BlbiIsImVycm9yIiwiY2xvc2UiLCJtZXNzYWdlIiwicHJlZml4IiwiYXJndW1lbnRMZW5ndGhDaGVjayIsImFyZ3VtZW50cyIsIm9wdGlvbnMiLCJjb252ZXJ0ZXJzIiwiVVNWU3RyaW5nIiwiYmFzZVVSTCIsInNldHRpbmdzT2JqZWN0IiwiYmFzZVVybCIsInVybFJlY29yZCIsIlVSTCIsImUiLCJET01FeGNlcHRpb24iLCJoYXNoIiwiaHJlZiIsImVuZHNXaXRoIiwibGVuZ3RoIiwiU2V0IiwibWFwIiwicCIsInRvTG93ZXJDYXNlIiwic2l6ZSIsImV2ZXJ5IiwiY2xpZW50IiwicmVzcG9uc2UiLCJvbkNvbm5lY3Rpb25Fc3RhYmxpc2hlZCIsIkNPTk5FQ1RJTkciLCJOT1RfU0VOVCIsImNvZGUiLCJ1bmRlZmluZWQiLCJyZWFzb24iLCJicmFuZENoZWNrIiwiY2xhbXAiLCJyZWFzb25CeXRlTGVuZ3RoIiwiQnVmZmVyIiwiYnl0ZUxlbmd0aCIsInNlbmQiLCJkYXRhIiwiV2ViU29ja2V0U2VuZERhdGEiLCJhZGQiLCJzdHJpbmciLCJpc0FycmF5QnVmZmVyIiwiYXJyYXlCdWZmZXIiLCJBcnJheUJ1ZmZlciIsImlzVmlldyIsInR5cGVkQXJyYXkiLCJibG9iIiwicmVhZHlTdGF0ZSIsIm9ub3BlbiIsImZuIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImFkZEV2ZW50TGlzdGVuZXIiLCJvbmVycm9yIiwib25jbG9zZSIsIm9ubWVzc2FnZSIsImJpbmFyeVR5cGUiLCJ0eXBlIiwiI29uQ29ubmVjdGlvbkVzdGFibGlzaGVkIiwicGFyc2VkRXh0ZW5zaW9ucyIsInBhcnNlciIsIm9uIiwib25QYXJzZXJEcmFpbiIsIm9uUGFyc2VyRXJyb3IiLCJiaW5kIiwic29ja2V0Iiwid3MiLCJPUEVOIiwiaGVhZGVyc0xpc3QiLCJnZXQiLCJwcm90b3R5cGUiLCJDTE9TSU5HIiwiQ0xPU0VEIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydGllcyIsIlN5bWJvbCIsInRvU3RyaW5nVGFnIiwidmFsdWUiLCJ3cml0YWJsZSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJzZXF1ZW5jZUNvbnZlcnRlciIsIkRPTVN0cmluZyIsIlYiLCJhcmd1bWVudCIsInV0aWwiLCJUeXBlIiwiaXRlcmF0b3IiLCJXZWJTb2NrZXRJbml0IiwiZGljdGlvbmFyeUNvbnZlcnRlciIsImtleSIsImNvbnZlcnRlciIsImRlZmF1bHRWYWx1ZSIsIkFycmF5IiwiYW55IiwibnVsbGFibGVDb252ZXJ0ZXIiLCJIZWFkZXJzSW5pdCIsIkJsb2IiLCJzdHJpY3QiLCJCdWZmZXJTb3VyY2UiLCJyZXN1bWUiLCJlcnIiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/websocket/websocket.js\n");

/***/ })

};
;